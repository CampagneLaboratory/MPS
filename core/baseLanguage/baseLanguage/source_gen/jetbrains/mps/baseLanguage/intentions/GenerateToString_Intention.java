package jetbrains.mps.baseLanguage.intentions;

/*Generated by MPS */

import jetbrains.mps.intentions.GenerateIntention;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;

public class GenerateToString_Intention extends GenerateIntention {
  public GenerateToString_Intention() {
  }

  public String getDescription(final SNode node, final EditorContext editorContext) {
    return "toString()";
  }

  public boolean isApplicable(final SNode node, final EditorContext editorContext) {
    if (!(this.isApplicableToNode(node, editorContext))) {
      return false;
    }
    return true;
  }

  public boolean isApplicableToNode(final SNode node, final EditorContext editorContext) {
    final Wrappers._boolean hasToString = new Wrappers._boolean(false);
    ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "method", true)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode method) {
        if (SPropertyOperations.getString(method, "name").equals("toString") && ListSequence.fromList(SLinkOperations.getTargets(method, "parameter", true)).isEmpty()) {
          hasToString.value = true;
        }
      }
    });
    return !(hasToString.value);
  }

  public void execute(final SNode node, final EditorContext editorContext) {
    /*
      SNode classConcept = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassConcept");
      SNode methodDeclaration = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration", null);
      SPropertyOperations.set(methodDeclaration, "name", "toString");
      SLinkOperations.setNewChild(methodDeclaration, "returnType", "jetbrains.mps.baseLanguage.structure.VoidType");
      SLinkOperations.setNewChild(methodDeclaration, "body", "jetbrains.mps.baseLanguage.structure.StatementList");
      SNode returnStatement = SLinkOperations.addNewChild(SLinkOperations.getTarget(methodDeclaration, "body", true), "statement", "jetbrains.mps.baseLanguage.structure.ReturnStatement");
      SNode dotExpression = SLinkOperations.setNewChild(returnStatement, "expression", "jetbrains.mps.baseLanguage.structure.DotExpression");
      SLinkOperations.setNewChild(dotExpression, "operand", "jetbrains.mps.baseLanguage.structure.ThisExpression");
      SNode fieldRef = SLinkOperations.setNewChild(dotExpression, "operation", "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation");
      String result = SPropertyOperations.getString(classConcept, "name") + " ";
      for (SNode field : SLinkOperations.getTargets(classConcept, "field", true)) {
        result += SPropertyOperations.getString(field, "name") + ": " + field;
      }
      SLinkOperations.addChild(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "method", methodDeclaration);

    */
  }

  public String getLocationString() {
    return "jetbrains.mps.baseLanguage.intentions";
  }

  public String getConcept() {
    return "jetbrains.mps.baseLanguage.structure.ClassConcept";
  }
}
