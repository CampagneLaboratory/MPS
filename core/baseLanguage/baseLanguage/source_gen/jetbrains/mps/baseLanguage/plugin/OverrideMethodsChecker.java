package jetbrains.mps.baseLanguage.plugin;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.EditorCheckerAdapter;
import java.util.Set;
import jetbrains.mps.nodeEditor.EditorMessage;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.IOperationContext;
import java.util.List;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.index.ClassifierSuccessorsFinder;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.Map;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Iterator;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.behavior.BaseMethodDeclaration_Behavior;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.event.SModelFileChangedEvent;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.event.SModelPropertyEvent;

public class OverrideMethodsChecker extends EditorCheckerAdapter {
  private static final int MAX_MESSAGE_NUMBER = 5;
  private static final String LF = "\n";
  private static final String TOOLTIP_INDENT = LF + "    ";

  private boolean myIndexWasNotReady;

  public OverrideMethodsChecker() {
  }

  public Set<EditorMessage> createMessages(SNode rootNode, IOperationContext operationConcets, List<SModelEvent> events, boolean wasCheckedOnce) {
    Iterable<SNode> classifiers = ListSequence.fromList(SNodeOperations.getDescendants(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.ClassConcept") || SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.Interface");
      }
    });
    this.myIndexWasNotReady = !(ClassifierSuccessorsFinder.isIndexReady());
    if (Sequence.fromIterable(classifiers).isEmpty() || this.myIndexWasNotReady) {
      return Collections.emptySet();
    }
    Set<EditorMessage> result = SetSequence.fromSet(new HashSet<EditorMessage>());
    for (SNode containedClassifier : Sequence.fromIterable(classifiers)) {
      this.collectOverridenMethods(containedClassifier, result);
      this.collectOverridingMethods(containedClassifier, result);
    }
    return result;
  }

  private void collectOverridingMethods(SNode container, Set<EditorMessage> messages) {
    Iterable<SNode> methods = ListSequence.fromList(SLinkOperations.getTargets(container, "method", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return canOverride(it);
      }
    });
    if (Sequence.fromIterable(methods).isEmpty()) {
      return;
    }
    Map<SNode, List<Tuples._2<SNode, SNode>>> overridingToOverridenMethodsMap = MapSequence.fromMap(new HashMap<SNode, List<Tuples._2<SNode, SNode>>>());
    this.collectOverridingMethodsInClassifierHierarchy(container, methods, overridingToOverridenMethodsMap, SetSequence.fromSet(new HashSet<SNode>()));
    for (SNode overridingMethod : SetSequence.fromSet(MapSequence.fromMap(overridingToOverridenMethodsMap).keySet())) {
      StringBuffer tooltip = new StringBuffer();
      int messageCounter = 0;
      boolean overrides = SPropertyOperations.getBoolean(overridingMethod, "isAbstract") || ListSequence.fromList(MapSequence.fromMap(overridingToOverridenMethodsMap).get(overridingMethod)).where(new IWhereFilter<Tuples._2<SNode, SNode>>() {
        public boolean accept(Tuples._2<SNode, SNode> it) {
          return !(SPropertyOperations.getBoolean(it._0(), "isAbstract"));
        }
      }).isNotEmpty();
      for (Iterator<Tuples._2<SNode, SNode>> it = ListSequence.fromList(MapSequence.fromMap(overridingToOverridenMethodsMap).get(overridingMethod)).iterator(); it.hasNext();) {
        SNode overridenClassifier = it.next()._1();
        tooltip.append((overrides ?
          "Overrides" :
          "Implements"
        ));
        tooltip.append(" method in '");
        tooltip.append(INamedConcept_Behavior.call_getFqName_1213877404258(overridenClassifier));
        tooltip.append("'");
        if (it.hasNext()) {
          tooltip.append(LF);
          if (++messageCounter >= MAX_MESSAGE_NUMBER) {
            tooltip.append("...");
            break;
          }
        }
      }
      SetSequence.fromSet(messages).addElement(new OverridingMethodEditorMessage(overridingMethod, this, tooltip.toString(), overrides));
    }
  }

  private void collectOverridingMethodsInClassifierHierarchy(SNode classifier, final Iterable<SNode> methods, final Map<SNode, List<Tuples._2<SNode, SNode>>> overridingToOverridenMethodsMap, final Set<SNode> visitedClassifiers) {
    if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      SNode clazz = SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept");
      SNode superClassifier = SLinkOperations.getTarget(SLinkOperations.getTarget(clazz, "superclass", true), "classifier", false);
      if (addIfNotContains(visitedClassifiers, superClassifier)) {
        this.collectOverridingMethods(superClassifier, methods, overridingToOverridenMethodsMap, visitedClassifiers);
      }
      ListSequence.fromList(SLinkOperations.getTargets(clazz, "implementedInterface", true)).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return SLinkOperations.getTarget(it, "classifier", false);
        }
      }).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return addIfNotContains(visitedClassifiers, it);
        }
      }).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          OverrideMethodsChecker.this.collectOverridingMethods(it, methods, overridingToOverridenMethodsMap, visitedClassifiers);
        }
      });
    } else if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.Interface")) {
      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.Interface"), "extendedInterface", true)).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return SLinkOperations.getTarget(it, "classifier", false);
        }
      }).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return addIfNotContains(visitedClassifiers, it);
        }
      }).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          OverrideMethodsChecker.this.collectOverridingMethods(it, methods, overridingToOverridenMethodsMap, visitedClassifiers);
        }
      });
    }
  }

  private void collectOverridingMethods(SNode classifier, Iterable<SNode> methods, Map<SNode, List<Tuples._2<SNode, SNode>>> overridingToOverridenMethodsMap, Set<SNode> visitedClassifiers) {
    List<SNode> methodsCopy = ListSequence.fromListWithValues(new ArrayList<SNode>(), methods);
    for (SNode classifierMethod : ListSequence.fromList(SLinkOperations.getTargets(classifier, "method", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return canBeOverriden(it);
      }
    })) {
      for (Iterator<SNode> it = ListSequence.fromList(methodsCopy).iterator(); it.hasNext();) {
        SNode nextMethod = it.next();
        if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(classifierMethod, nextMethod)) {
          List<Tuples._2<SNode, SNode>> overridenMethods = MapSequence.fromMap(overridingToOverridenMethodsMap).get(nextMethod);
          if (overridenMethods == null) {
            overridenMethods = ListSequence.fromList(new ArrayList<Tuples._2<SNode, SNode>>());
            MapSequence.fromMap(overridingToOverridenMethodsMap).put(nextMethod, overridenMethods);
          }
          ListSequence.fromList(overridenMethods).addElement(MultiTuple.<SNode,SNode>from(classifierMethod, classifier));
          it.remove();
          break;
        }
      }
    }
    if (!(ListSequence.fromList(methodsCopy).isEmpty())) {
      this.collectOverridingMethodsInClassifierHierarchy(classifier, methodsCopy, overridingToOverridenMethodsMap, visitedClassifiers);
    }
  }

  private void collectOverridenMethods(SNode container, Set<EditorMessage> messages) {
    /*
      // Use this code with <node> method. <node> is faster, but does not produce full tooltip message 
      List<SNode> methods = SLinkOperations.getTargets(container, "method", true);
      if (ListSequence.fromList(methods).isEmpty()) {
        return;
      }
      // creating a copy of methods collection because of future modifications applied to it in <node> method 
      List<SNode> methodsCopy = new ArrayList<SNode>();
      for (SNode method : ListSequence.fromList(methods)) {
        if (canBeOverriden(method)) {
          ListSequence.fromList(methodsCopy).addElement(method);
        }
      }
      if (ListSequence.fromList(methodsCopy).isEmpty()) {
        return;
      }
    */
    Iterable<SNode> methods = ListSequence.fromList(SLinkOperations.getTargets(container, "method", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return canBeOverriden(it);
      }
    });
    if (Sequence.fromIterable(methods).isEmpty()) {
      return;
    }
    List<SNode> derivedClasses = ClassifierSuccessorsFinder.getDerivedClassifiers(container, GlobalScope.getInstance());
    Iterable<SNode> derivedClassifiers = ListSequence.fromList(derivedClasses).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.as(it, "jetbrains.mps.baseLanguage.structure.Classifier");
      }
    }).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (it != null);
      }
    });
    if (ListSequence.fromList(derivedClasses).isEmpty()) {
      return;
    }
    this.createOverridenMethodsMessagesFull(methods, derivedClassifiers, messages);
  }

  private void createOverridenMethodsMessagesFull(Iterable<SNode> methods, Iterable<SNode> derivedClassifiers, Set<EditorMessage> messages) {
    Map<SNode, List<SNode>> overridenMethodsToOverridingClassifiersMap = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());
    for (SNode derivedClassifier : Sequence.fromIterable(derivedClassifiers)) {
      for (SNode derivedClassifierMethod : ListSequence.fromList(SLinkOperations.getTargets(derivedClassifier, "method", true)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return canOverride(it);
        }
      })) {
        for (SNode method : Sequence.fromIterable(methods)) {
          if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(derivedClassifierMethod, method)) {
            List<SNode> overridingClassifiers = MapSequence.fromMap(overridenMethodsToOverridingClassifiersMap).get(method);
            if (overridingClassifiers == null) {
              overridingClassifiers = new ArrayList<SNode>();
              MapSequence.fromMap(overridenMethodsToOverridingClassifiersMap).put(method, overridingClassifiers);
            }
            ListSequence.fromList(overridingClassifiers).addElement(derivedClassifier);
            break;
          }
        }
      }
    }
    for (SNode overridenMethod : SetSequence.fromSet(MapSequence.fromMap(overridenMethodsToOverridingClassifiersMap).keySet())) {
      boolean overriden = !(SPropertyOperations.getBoolean(overridenMethod, "isAbstract"));
      StringBuffer tooltip = new StringBuffer("Is ");
      tooltip.append((overriden ?
        "overriden" :
        "implemented"
      ));
      tooltip.append(" in");
      int messageCounter = 0;
      for (Iterator<SNode> it = ListSequence.fromList(MapSequence.fromMap(overridenMethodsToOverridingClassifiersMap).get(overridenMethod)).iterator(); it.hasNext();) {
        SNode overridingClassifier = it.next();
        tooltip.append(TOOLTIP_INDENT);
        tooltip.append(INamedConcept_Behavior.call_getFqName_1213877404258(overridingClassifier));
        if (++messageCounter >= MAX_MESSAGE_NUMBER && it.hasNext()) {
          tooltip.append(TOOLTIP_INDENT);
          tooltip.append("...");
          break;
        }
      }
      SetSequence.fromSet(messages).addElement(new OverridenMethodEditorMessage(overridenMethod, this, tooltip.toString(), overriden));
    }
  }

  private void createOverridenMethodsMessages(List<SNode> methods, Iterable<SNode> derivedClasses, Set<EditorMessage> messages) {
    for (Iterator<SNode> derivedClassesIt = Sequence.fromIterable(derivedClasses).iterator(); derivedClassesIt.hasNext() && ListSequence.fromList(methods).isNotEmpty();) {
      SNode nextNode = derivedClassesIt.next();
      if (!(SNodeOperations.isInstanceOf(nextNode, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
        continue;
      }
      for (Iterator<SNode> derivedClassMethodsIt = ListSequence.fromList(SLinkOperations.getTargets(((SNode) nextNode), "method", true)).iterator(); derivedClassMethodsIt.hasNext() && ListSequence.fromList(methods).isNotEmpty();) {
        SNode derivedClassifierMethod = derivedClassMethodsIt.next();
        if (canOverride(derivedClassifierMethod)) {
          for (SNode method : ListSequence.fromList(methods)) {
            if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(derivedClassifierMethod, method)) {
              ListSequence.fromList(methods).removeElement(method);
              SetSequence.fromSet(messages).addElement(new OverridenMethodEditorMessage(method, this, null, true));
              break;
            }
          }
        }
      }
    }
  }

  @Override
  public boolean hasDramaticalEvent(List<SModelEvent> events) {
    if (this.myIndexWasNotReady) {
      return true;
    }
    for (SModelEvent event : ListSequence.fromList(events)) {
      if (event instanceof SModelRootEvent || event instanceof SModelFileChangedEvent) {
        return true;
      }
      if (event instanceof SModelChildEvent) {
        SModelChildEvent childEvent = (SModelChildEvent) event;
        SNode child = childEvent.getChild();
        String childRole = childEvent.getChildRole();
        // Class or Interface was added/removed 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.Interface") || SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.ClassConcept") || SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
          return true;
        }
        // method was added/removed from containing Classifier 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration") && SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Classifier", "method"), "role").equals(childRole)) {
          return true;
        }
        // one of extendedInterface/superclass/implementedInterface child elements was added/removed 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.ClassifierType") && (SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Interface", "extendedInterface"), "role").equals(childRole) || SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept", "superclass"), "role").equals(childRole) || SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept", "implementedInterface"), "role").equals(childRole))) {
          return true;
        }
        // parameter was added/removed 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration") && SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration", "parameter"), "role").equals(childRole)) {
          return true;
        }
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.Type") && this.isParameterType(child)) {
          return true;
        }
      }
      if (event instanceof SModelReferenceEvent) {
        SModelReferenceEvent referenceEvent = (SModelReferenceEvent) event;
        SReference reference = referenceEvent.getReference();
        SNode sourceNode = reference.getSourceNode();
        String referenceRole = reference.getRole();
        if (SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassifierType", "classifier"), "role").equals(referenceRole) && SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.ClassifierType") && (SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), "jetbrains.mps.baseLanguage.structure.Classifier"))) {
          return true;
        }
        if (SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.AnonymousClass", "classifier"), "role").equals(referenceRole) && SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
          return true;
        }
        if (SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.Type") && this.isParameterType(sourceNode)) {
          return true;
        }
      }
      if (event instanceof SModelPropertyEvent) {
        SModelPropertyEvent propertyEvent = (SModelPropertyEvent) event;
        SNode node = propertyEvent.getNode();
        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) {
          return true;
        }
      }
    }
    return false;
  }

  private boolean isParameterType(SNode type) {
    SNode parent = SNodeOperations.getParent(type);
    if (SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration")) {
      return true;
    }
    if (SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.Type")) {
      return this.isParameterType(parent);
    }
    return false;
  }

  private static boolean canBeOverriden(SNode method) {
    return !(SPropertyOperations.getBoolean(method, "isFinal") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, "visibility", true), "jetbrains.mps.baseLanguage.structure.PrivateVisibility"));
  }

  private static boolean canOverride(SNode method) {
    return !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, "visibility", true), "jetbrains.mps.baseLanguage.structure.PrivateVisibility"));
  }

  private static boolean addIfNotContains(Set<SNode> classifierSet, SNode classifier) {
    if (!(SetSequence.fromSet(classifierSet).contains(classifier))) {
      SetSequence.fromSet(classifierSet).addElement(classifier);
      return true;
    }
    return false;
  }
}
