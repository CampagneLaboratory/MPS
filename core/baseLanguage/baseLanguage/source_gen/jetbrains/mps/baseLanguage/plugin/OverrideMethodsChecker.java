package jetbrains.mps.baseLanguage.plugin;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.EditorCheckerAdapter;
import java.util.Set;
import jetbrains.mps.nodeEditor.EditorMessage;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.IOperationContext;
import java.util.List;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.index.ClassifierSuccessorsFinder;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Iterator;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.behavior.BaseMethodDeclaration_Behavior;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.event.SModelFileChangedEvent;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.event.SModelPropertyEvent;

public class OverrideMethodsChecker extends EditorCheckerAdapter {
  private static final int MAX_MESSAGE_NUMBER = 5;
  private static final String LF = "\n";
  private static final String TOOLTIP_INDENT = LF + "    ";

  private boolean myIndexWasNotReady;

  public OverrideMethodsChecker() {
  }

  public Set<EditorMessage> createMessages(SNode rootNode, IOperationContext operationContext, List<SModelEvent> events, boolean wasCheckedOnce) {
    Iterable<SNode> classifiers = ListSequence.fromList(SNodeOperations.getDescendants(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.ClassConcept") || SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.Interface");
      }
    });
    this.myIndexWasNotReady = !(ClassifierSuccessorsFinder.isIndexReady(operationContext.getProject()));
    if (Sequence.fromIterable(classifiers).isEmpty() || this.myIndexWasNotReady) {
      return Collections.emptySet();
    }
    Set<EditorMessage> result = SetSequence.fromSet(new HashSet<EditorMessage>());
    for (SNode containedClassifier : Sequence.fromIterable(classifiers)) {
      collectOverridenMethods(containedClassifier, result);
      collectOverridingMethods(containedClassifier, result);
    }
    return result;
  }

  private void collectOverridingMethods(SNode container, Set<EditorMessage> messages) {
    OverridingMethodsFinder finder = new OverridingMethodsFinder(container);
    for (SNode overridingMethod : SetSequence.fromSet(finder.getOverridingMethods())) {
      StringBuffer tooltip = new StringBuffer();
      int messageCounter = 0;
      Set<Tuples._2<SNode, SNode>> overridenMethods = finder.getOverridenMethods(overridingMethod);
      boolean overrides = SPropertyOperations.getBoolean(overridingMethod, "isAbstract") || SetSequence.fromSet(overridenMethods).where(new IWhereFilter<Tuples._2<SNode, SNode>>() {
        public boolean accept(Tuples._2<SNode, SNode> it) {
          return !(SPropertyOperations.getBoolean(it._0(), "isAbstract"));
        }
      }).isNotEmpty();
      for (Iterator<Tuples._2<SNode, SNode>> it = SetSequence.fromSet(overridenMethods).iterator(); it.hasNext();) {
        SNode overridenClassifier = it.next()._1();
        tooltip.append((overrides ?
          "Overrides" :
          "Implements"
        ));
        tooltip.append(" method in '");
        tooltip.append(INamedConcept_Behavior.call_getFqName_1213877404258(overridenClassifier));
        tooltip.append("'");
        if (it.hasNext()) {
          tooltip.append(LF);
          if (++messageCounter == MAX_MESSAGE_NUMBER) {
            tooltip.append("...");
            break;
          }
        }
      }
      SetSequence.fromSet(messages).addElement(new OverridingMethodEditorMessage(overridingMethod, this, tooltip.toString(), overrides));
    }
  }

  private void collectOverridenMethods(SNode container, Set<EditorMessage> messages) {
    Map<String, Set<SNode>> nameToMethodsMap = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
    for (SNode method : ListSequence.fromList(SLinkOperations.getTargets(container, "method", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return OverridingMethodsFinder.canBeOverriden(it);
      }
    })) {
      SetSequence.fromSet(OverridingMethodsFinder.safeGet(nameToMethodsMap, SPropertyOperations.getString(method, "name"))).addElement(method);
    }
    if (MapSequence.fromMap(nameToMethodsMap).isEmpty()) {
      return;
    }
    List<SNode> rawDerivedClassifiers = ClassifierSuccessorsFinder.getDerivedClassifiers(container, GlobalScope.getInstance());
    Iterable<SNode> derivedClassifiers = ListSequence.fromList(rawDerivedClassifiers).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.as(it, "jetbrains.mps.baseLanguage.structure.Classifier");
      }
    }).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (it != null);
      }
    });
    if (Sequence.fromIterable(derivedClassifiers).isEmpty()) {
      return;
    }
    Map<SNode, Set<Tuples._2<SNode, SNode>>> overridenToOverridingMethodsMap = createOverridenToOverridingMethodsMap(nameToMethodsMap, derivedClassifiers);
    for (SNode overridenMethod : SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).keySet())) {
      boolean overriden = !(SPropertyOperations.getBoolean(overridenMethod, "isAbstract"));
      StringBuffer tooltip = new StringBuffer("Is ");
      tooltip.append((overriden ?
        "overriden" :
        "implemented"
      ));
      tooltip.append(" in");
      int messageCounter = 0;
      for (Iterator<Tuples._2<SNode, SNode>> it = SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).get(overridenMethod)).iterator(); it.hasNext();) {
        SNode overridingClassifier = it.next()._1();
        tooltip.append(TOOLTIP_INDENT);
        tooltip.append(INamedConcept_Behavior.call_getFqName_1213877404258(overridingClassifier));
        if (++messageCounter == MAX_MESSAGE_NUMBER && it.hasNext()) {
          tooltip.append(TOOLTIP_INDENT);
          tooltip.append("...");
          break;
        }
      }
      SetSequence.fromSet(messages).addElement(new OverridenMethodEditorMessage(overridenMethod, this, tooltip.toString(), overriden));
    }
  }

  private Map<SNode, Set<Tuples._2<SNode, SNode>>> createOverridenToOverridingMethodsMap(Map<String, Set<SNode>> nameToMethodsMap, Iterable<SNode> derivedClassifiers) {
    Map<SNode, Set<Tuples._2<SNode, SNode>>> result = MapSequence.fromMap(new HashMap<SNode, Set<Tuples._2<SNode, SNode>>>());
    for (SNode derivedClassifier : Sequence.fromIterable(derivedClassifiers)) {
      for (final SNode derivedClassifierMethod : ListSequence.fromList(SLinkOperations.getTargets(derivedClassifier, "method", true)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return OverridingMethodsFinder.canOverride(it);
        }
      })) {
        Set<SNode> similarMethods = MapSequence.fromMap(nameToMethodsMap).get(SPropertyOperations.getString(derivedClassifierMethod, "name"));
        if (similarMethods == null) {
          continue;
        }
        SNode overridenMethod = SetSequence.fromSet(similarMethods).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(it, derivedClassifierMethod);
          }
        });
        if (overridenMethod != null) {
          Set<Tuples._2<SNode, SNode>> overridingMethods = OverridingMethodsFinder.safeGet(result, overridenMethod);
          SetSequence.fromSet(overridingMethods).addElement(MultiTuple.<SNode,SNode>from(derivedClassifierMethod, derivedClassifier));
          if (SetSequence.fromSet(overridingMethods).count() > MAX_MESSAGE_NUMBER) {
            SetSequence.fromSet(similarMethods).removeElement(overridenMethod);
            if (SetSequence.fromSet(similarMethods).isEmpty()) {
              MapSequence.fromMap(nameToMethodsMap).put(SPropertyOperations.getString(derivedClassifierMethod, "name"), null);
              if (MapSequence.fromMap(nameToMethodsMap).isEmpty()) {
                return result;
              }
            }
          }
        }
      }
    }
    return result;
  }

  @Override
  public boolean hasDramaticalEvent(List<SModelEvent> events) {
    if (this.myIndexWasNotReady) {
      return true;
    }
    for (SModelEvent event : ListSequence.fromList(events)) {
      if (event instanceof SModelRootEvent || event instanceof SModelFileChangedEvent) {
        return true;
      }
      if (event instanceof SModelChildEvent) {
        SModelChildEvent childEvent = (SModelChildEvent) event;
        SNode child = childEvent.getChild();
        String childRole = childEvent.getChildRole();
        // Class or Interface was added/removed 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.Interface") || SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.ClassConcept") || SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
          return true;
        }
        // method was added/removed from containing Classifier 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration") && SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Classifier", "method"), "role").equals(childRole)) {
          return true;
        }
        // one of extendedInterface/superclass/implementedInterface child elements was added/removed 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.ClassifierType") && (SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Interface", "extendedInterface"), "role").equals(childRole) || SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept", "superclass"), "role").equals(childRole) || SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept", "implementedInterface"), "role").equals(childRole))) {
          return true;
        }
        // parameter was added/removed 
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration") && SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration", "parameter"), "role").equals(childRole)) {
          return true;
        }
        if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.Type") && isParameterType(child)) {
          return true;
        }
      }
      if (event instanceof SModelReferenceEvent) {
        SModelReferenceEvent referenceEvent = (SModelReferenceEvent) event;
        SReference reference = referenceEvent.getReference();
        SNode sourceNode = reference.getSourceNode();
        String referenceRole = reference.getRole();
        if (SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassifierType", "classifier"), "role").equals(referenceRole) && SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.ClassifierType") && (SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), "jetbrains.mps.baseLanguage.structure.Classifier"))) {
          return true;
        }
        if (SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.AnonymousClass", "classifier"), "role").equals(referenceRole) && SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
          return true;
        }
        if (SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.Type") && isParameterType(sourceNode)) {
          return true;
        }
      }
      if (event instanceof SModelPropertyEvent) {
        SModelPropertyEvent propertyEvent = (SModelPropertyEvent) event;
        SNode node = propertyEvent.getNode();
        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) {
          return true;
        }
      }
    }
    return false;
  }

  private static boolean isParameterType(SNode type) {
    SNode parent = SNodeOperations.getParent(type);
    if (SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration")) {
      return true;
    }
    if (SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.Type")) {
      return isParameterType(parent);
    }
    return false;
  }
}
