package jetbrains.mps.baseLanguage.helgins;

/*Generated by MPS */

import jetbrains.mps.bootstrap.helgins.dependencies.InferenceMethod;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.helgins.inference.TypeChecker;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.ext.collections.internal.query.SequenceOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import java.util.Map;
import jetbrains.mps.baseLanguage.ext.collections.internal.query.ListOperations;
import jetbrains.mps.core.constraints.BaseConcept_Behavior;
import java.util.Iterator;
import jetbrains.mps.util.Pair;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.cfg.BasicBlock;
import jetbrains.mps.cfg.IControlFlowGraph;
import java.util.HashSet;
import jetbrains.mps.smodel.SModelUtil_new;

public class RulesFunctions_BaseLanguage {
  public static boolean TRACE_METHOD_TYPES = false;

  @InferenceMethod()
  public static void comparisonOp(SNode binOp) {
    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(binOp, "rightExpression", true), "jetbrains.mps.baseLanguage.helgins", "1176897133366", true), SLinkOperations.getTarget(new QuotationClass_25().createNode(), "descriptor", false), SLinkOperations.getTarget(binOp, "rightExpression", true), null, "jetbrains.mps.baseLanguage.helgins", "1176897142200");
    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(binOp, "leftExpression", true), "jetbrains.mps.baseLanguage.helgins", "1176897185028", true), SLinkOperations.getTarget(new QuotationClass_26().createNode(), "descriptor", false), SLinkOperations.getTarget(binOp, "leftExpression", true), null, "jetbrains.mps.baseLanguage.helgins", "1176897185023");
    TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(binOp, "jetbrains.mps.baseLanguage.helgins", "1203512292516", true), new QuotationClass_27().createNode(), binOp, null, "jetbrains.mps.baseLanguage.helgins", "1203512292514");
  }

  @InferenceMethod()
  public static void numericOp(final SNode binOp) {
    final SNode rightExpressionType_typevar_1185962758265 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);
    final SNode leftExpressionType_typevar_1185962769627 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);
    TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getEquationManager().getRepresentator(rightExpressionType_typevar_1185962758265), TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(binOp, "rightExpression", true), "jetbrains.mps.baseLanguage.helgins", "1185962985524", true), SLinkOperations.getTarget(binOp, "rightExpression", true), null, "jetbrains.mps.baseLanguage.helgins", "1185962983223");
    TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getEquationManager().getRepresentator(leftExpressionType_typevar_1185962769627), TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(binOp, "leftExpression", true), "jetbrains.mps.baseLanguage.helgins", "1185963005725", true), SLinkOperations.getTarget(binOp, "leftExpression", true), null, "jetbrains.mps.baseLanguage.helgins", "1185963003424");
    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getEquationManager().getRepresentator(rightExpressionType_typevar_1185962758265), SLinkOperations.getTarget(new QuotationClass_28().createNode(), "descriptor", false), SLinkOperations.getTarget(binOp, "rightExpression", true), null, "jetbrains.mps.baseLanguage.helgins", "1176908856117");
    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getEquationManager().getRepresentator(leftExpressionType_typevar_1185962769627), SLinkOperations.getTarget(new QuotationClass_29().createNode(), "descriptor", false), SLinkOperations.getTarget(binOp, "leftExpression", true), null, "jetbrains.mps.baseLanguage.helgins", "1176908902743");
    TypeChecker.getInstance().getRuntimeSupport().whenConcrete(TypeChecker.getInstance().getEquationManager().getRepresentator(leftExpressionType_typevar_1185962769627), new Runnable() {

      public void run() {
        TypeChecker.getInstance().getRuntimeSupport().whenConcrete(TypeChecker.getInstance().getEquationManager().getRepresentator(rightExpressionType_typevar_1185962758265), new Runnable() {

          public void run() {
            TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(binOp, "jetbrains.mps.baseLanguage.helgins", "1203512296348", true), Queries.getBinaryOperationType(TypeChecker.getInstance().getEquationManager().getRepresentator(leftExpressionType_typevar_1185962769627), TypeChecker.getInstance().getEquationManager().getRepresentator(rightExpressionType_typevar_1185962758265)), binOp, null, "jetbrains.mps.baseLanguage.helgins", "1203512296346");
          }

        }, "jetbrains.mps.baseLanguage.helgins", "1185963100352");
      }

    }, "jetbrains.mps.baseLanguage.helgins", "1185963072800");
  }

  public static Iterable<SNode> collectReturnStatements(SNode node) {
    Iterable<SNode> returnStatements = SequenceOperations.map(SNodeOperations.getChildren(node), new zMapper(null, null));
    return returnStatements;
  }

  public static SNode concreteTypeFromGenericType(SNode type, SNode genericClassifier, SNode instanceType) {
    SNode returnType = SNodeOperations.copyNode(type);
    if(genericClassifier == null) {
      return returnType;
    }
    {
      Pattern_8 pattern_1181217694220 = new Pattern_8(genericClassifier);
      SNode coercedNode_1181217694219 = TypeChecker.getInstance().getRuntimeSupport().coerce(instanceType, pattern_1181217694220);
      if(coercedNode_1181217694219 != null) {
        List<SNode> actualParams = pattern_1181217694220.PatternVar;
        for(SNode child : SNodeOperations.getDescendants(returnType, null, true)) {
          if(SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
            SNode tvr = child;
            SNode tvd = SLinkOperations.getTarget(tvr, "typeVariableDeclaration", false);
            int index = SequenceOperations.indexOf(SLinkOperations.getTargets(genericClassifier, "typeVariableDeclaration", true), tvd);
            SNode actualParam = (index < actualParams.size() && index >= 0 ?
              actualParams.get(index) :
              new QuotationClass_30().createNode()
            );
            if(returnType == tvr) {
              returnType = SNodeOperations.copyNode(actualParam, TypeChecker.getInstance().getRuntimeTypesModel());
            } else
            {
              // in this code the 'tvr' is not necessarily *child* of the 'returnType'.
              // in this case the replaceChild(old,new) fails with assertion.
              // new code is safe but might be not correct
              // returnType . replaceChild ( tvr , actualParam . copy ) ;
              SNodeOperations.replaceWithAnother(tvr, SNodeOperations.copyNode(actualParam));
            }
          }
        }
      }
    }
    return returnType;
  }

  @InferenceMethod()
  public static void inference_matchConcreteTypesWithTypeVariables(SNode genericClassifier, SNode instanceType, Map<SNode, List<SNode>> mmap) {
    if((genericClassifier != null) && mmap != null) {
      {
        Pattern_9 pattern_1203433053192 = new Pattern_9(genericClassifier);
        SNode coercedNode_1203433035924 = TypeChecker.getInstance().getRuntimeSupport().coerce(instanceType, pattern_1203433053192);
        if(coercedNode_1203433035924 != null) {
          List<SNode> actualParams = pattern_1203433053192.PatternVar3;
          int idx = 0;
          for(SNode tvd : SLinkOperations.getTargets(genericClassifier, "typeVariableDeclaration", true)) {
            if(idx < actualParams.size()) {
              List<SNode> nodes = mmap.get(tvd);
              if(nodes != null) {
                SNode tvar = ListOperations.getElement(nodes, 0);
                if(RulesFunctions_BaseLanguage.TRACE_METHOD_TYPES) {
                  System.out.println("-2- " + BaseConcept_Behavior.call_getPresentation_1180102203531(tvar) + " :==: " + BaseConcept_Behavior.call_getPresentation_1180102203531(ListOperations.getElement(nodes, 0)));
                }
                TypeChecker.getInstance().getRuntimeSupport().createEquation(tvar, actualParams.get(idx), null, null, "jetbrains.mps.baseLanguage.helgins", "1203433378489");
              }
            }
            idx = idx + 1;
          }
        }
      }
    }
  }

  @InferenceMethod()
  public static Map<SNode, List<SNode>> inference_equateParametersAndReturnType(SNode mc, SNode returnType) {
    Map<SNode, List<SNode>> mmap = null;
    {
      SNode arg;
      SNode param;
      Iterator<SNode> arg_iterator = SLinkOperations.getTargets(mc, "actualArgument", true).iterator();
      Iterator<SNode> param_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, "baseMethodDeclaration", false), "parameter", true).iterator();
      while(true) {
        if(!(arg_iterator.hasNext())) {
          break;
        }
        if(!(param_iterator.hasNext())) {
          break;
        }
        arg = arg_iterator.next();
        param = param_iterator.next();
        {
          Pair<SNode, Map<SNode, List<SNode>>> pair = RulesFunctions_BaseLanguage.inference_matchTypeWithTypeVariables(SLinkOperations.getTarget(param, "type", true), mmap);
          SNode matchedType = pair.o1;
          mmap = pair.o2;
          if(RulesFunctions_BaseLanguage.TRACE_METHOD_TYPES) {
            System.out.println("-1- TYPEOF(" + BaseConcept_Behavior.call_getPresentation_1180102203531(arg) + ") :<=: " + BaseConcept_Behavior.call_getPresentation_1180102203531(matchedType));
          }
          TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(arg, "jetbrains.mps.baseLanguage.helgins", "1203441371331", true), matchedType, arg, null, "jetbrains.mps.baseLanguage.helgins", "1203441371327");
        }
      }
    }
    if(returnType != null) {
      Pair<SNode, Map<SNode, List<SNode>>> pair = RulesFunctions_BaseLanguage.inference_matchTypeWithTypeVariables(returnType, mmap);
      SNode matchedType = pair.o1;
      mmap = pair.o2;
      if(RulesFunctions_BaseLanguage.TRACE_METHOD_TYPES) {
        System.out.println("-1- TYPEOF(" + BaseConcept_Behavior.call_getPresentation_1180102203531(mc) + ") :==: " + BaseConcept_Behavior.call_getPresentation_1180102203531(matchedType));
      }
      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(mc, "jetbrains.mps.baseLanguage.helgins", "1203441371361", true), matchedType, mc, null, "jetbrains.mps.baseLanguage.helgins", "1203441371359");
    }
    return mmap;
  }

  @InferenceMethod()
  public static void inference_equateMatchingTypeVariables(Map<SNode, List<SNode>> mmap) {
    if(mmap != null) {
      for(Map.Entry<SNode, List<SNode>> e : mmap.entrySet()) {
        List<SNode> nodes = e.getValue();
        SNode prev = null;
        for(SNode tvar : nodes) {
          if(prev != null && prev != tvar) {
            if(RulesFunctions_BaseLanguage.TRACE_METHOD_TYPES) {
              System.out.println("-3- " + BaseConcept_Behavior.call_getPresentation_1180102203531(prev) + " :==: " + BaseConcept_Behavior.call_getPresentation_1180102203531(tvar));
            }
            TypeChecker.getInstance().getRuntimeSupport().createEquation(prev, tvar, null, null, "jetbrains.mps.baseLanguage.helgins", "1203452876024");
          }
          prev = tvar;
        }
        if(RulesFunctions_BaseLanguage.TRACE_METHOD_TYPES) {
          if((prev != null)) {
            final SNode var = prev;
            final SNode prevVar_typevar_1204114618000 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);
            TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getEquationManager().getRepresentator(prevVar_typevar_1204114618000), prev, null, null, "jetbrains.mps.baseLanguage.helgins", "1204114618001");
            TypeChecker.getInstance().getRuntimeSupport().whenConcrete(TypeChecker.getInstance().getEquationManager().getRepresentator(prevVar_typevar_1204114618000), new Runnable() {

              public void run() {
                System.out.println("-4- " + BaseConcept_Behavior.call_getPresentation_1180102203531(var) + " :==: " + BaseConcept_Behavior.call_getPresentation_1180102203531(TypeChecker.getInstance().getEquationManager().getRepresentator(prevVar_typevar_1204114618000)));
              }

            }, "jetbrains.mps.baseLanguage.helgins", "1204114618006");
          }
        }
      }
    }
  }

  @InferenceMethod()
  private static Pair<SNode, Map<SNode, List<SNode>>> inference_matchTypeWithTypeVariables(SNode type, Map<SNode, List<SNode>> mmap) {
    SNode resType = SNodeOperations.copyNode(type);
    if(SNodeOperations.isInstanceOf(resType, "jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
      final SNode tvar_typevar_1203439588896 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);
      SNode tvd = SLinkOperations.getTarget(resType, "typeVariableDeclaration", false);
      RulesFunctions_BaseLanguage.inference_mapTypeVariable(tvd, TypeChecker.getInstance().getEquationManager().getRepresentator(tvar_typevar_1203439588896), (mmap = RulesFunctions_BaseLanguage.getMMap(mmap)));
      resType = TypeChecker.getInstance().getEquationManager().getRepresentator(tvar_typevar_1203439588896);
    } else
    {
      mmap = RulesFunctions_BaseLanguage.inference_mapTypeVariables(resType, mmap);
    }
    return new Pair<SNode, Map<SNode, List<SNode>>>(resType, mmap);
  }

  @InferenceMethod()
  private static Map<SNode, List<SNode>> inference_mapTypeVariables(SNode type, Map<SNode, List<SNode>> mmap) {
    if(SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
      final SNode tvar_typevar_1203431658168 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);
      SNode tvd = SLinkOperations.getTarget(type, "typeVariableDeclaration", false);
      RulesFunctions_BaseLanguage.inference_mapTypeVariable(tvd, TypeChecker.getInstance().getEquationManager().getRepresentator(tvar_typevar_1203431658168), (mmap = RulesFunctions_BaseLanguage.getMMap(mmap)));
      SNodeOperations.replaceWithAnother(type, TypeChecker.getInstance().getEquationManager().getRepresentator(tvar_typevar_1203431658168));
    } else
    {
      List<SNode> children = new ArrayList<SNode>(SNodeOperations.getChildren(type));
      for(SNode chld : children) {
        mmap = RulesFunctions_BaseLanguage.inference_mapTypeVariables(chld, mmap);
      }
    }
    return mmap;
  }

  private static Map<SNode, List<SNode>> getMMap(Map<SNode, List<SNode>> mmap) {
    if(mmap == null) {
      return new HashMap<SNode, List<SNode>>();
    }
    return mmap;
  }

  private static void inference_mapTypeVariable(SNode tvd, SNode tvar, Map<SNode, List<SNode>> mmap) {
    RulesFunctions_BaseLanguage.putTypeVariable(tvd, tvar, mmap);
  }

  private static void putTypeVariable(SNode tvd, SNode tvar, Map<SNode, List<SNode>> mmap) {
    List<SNode> nodes = mmap.get(tvd);
    if(nodes == null) {
      nodes = new ArrayList<SNode>();
      mmap.put(tvd, nodes);
    }
    ListOperations.addElement(nodes, tvar);
  }

  public static Set<BasicBlock> findLastBlocks(IControlFlowGraph controlFlowGraph) {
    BasicBlock exit = controlFlowGraph.getExitBlock();
    Set<BasicBlock> lastBlocks = new HashSet<BasicBlock>();
    Set<BasicBlock> newLastBlocks = new HashSet<BasicBlock>();
    Set<BasicBlock> foundBlocks = new HashSet<BasicBlock>();
    Set<BasicBlock> passed = new HashSet<BasicBlock>();
    lastBlocks.add(exit);
    while(!(lastBlocks.isEmpty())) {
      for(BasicBlock lastBlock : lastBlocks) {
        passed.add(lastBlock);
        if(lastBlock.isFake()) {
          for(BasicBlock entry : lastBlock.getEntryStar()) {
            if(!(passed.contains(entry))) {
              newLastBlocks.add(entry);
            }
          }
        } else
        {
          foundBlocks.add(lastBlock);
        }
      }
      lastBlocks = newLastBlocks;
      newLastBlocks = new HashSet<BasicBlock>();
    }
    return foundBlocks;
  }

  public static boolean isWithinStatic(SNode node) {
    SNode staticAncestor = SNodeOperations.getAncestorWhereConceptInList(node, new String[]{"jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration","jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"}, false, false);
    if(staticAncestor != null) {
      return true;
    }
    SNode statementList = SNodeOperations.getAncestor(node, "jetbrains.mps.baseLanguage.structure.StatementList", false, false);
    SNode prevStatementList = null;
    while((statementList != null)) {
      prevStatementList = statementList;
      statementList = SNodeOperations.getAncestor(statementList, "jetbrains.mps.baseLanguage.structure.StatementList", false, false);
    }
    if((prevStatementList != null)) {
      do {
        SNode matchedNode_1201700829805 = SNodeOperations.getParent(prevStatementList, null, false, false);
        {
          boolean matches_1201700829807 = false;
          matches_1201700829807 = SModelUtil_new.isAssignableConcept(SNodeOperations.getParent(prevStatementList, null, false, false).getConceptFqName(), "jetbrains.mps.baseLanguage.structure.ClassConcept");
          if(matches_1201700829807) {
            return SLinkOperations.getTarget(matchedNode_1201700829805, "staticInitializer", true) == prevStatementList;
          }
        }
      } while(false);
    }
    return false;
  }

}
