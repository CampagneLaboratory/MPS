package jetbrains.mps.baseLanguage.util.plugin.refactorings;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.Map;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.pattern.util.MatchingUtil;
import jetbrains.mps.lang.pattern.util.IMatchModifier;
import jetbrains.mps.internal.collections.runtime.MapSequence;

public class MethodDuplicatesFinder {
  private List<SNode> myNodesToFind;
  private final Map<SNode, SNode> myMapping;

  public MethodDuplicatesFinder(List<SNode> nodesToFind, Map<SNode, SNode> mapping) {
    this.myNodesToFind = nodesToFind;
    this.myMapping = mapping;
  }

  public List<MethodMatch> findDuplicates(SNode root) {
    List<MethodMatch> found = new ArrayList<MethodMatch>();
    if (ListSequence.fromList(this.myNodesToFind).count() == 1) {
      for (SNode node : ListSequence.fromList(SNodeOperations.getDescendants(root, "jetbrains.mps.lang.core.structure.BaseConcept", false, new String[]{}))) {
        MethodDuplicatesFinder.MethodMatchModifier modifier = new MethodDuplicatesFinder.MethodMatchModifier();
        modifier.getMatch().putNode(node);
        if (MatchingUtil.matchNodes(node, ListSequence.fromList(this.myNodesToFind).first(), modifier, true)) {
          MethodMatch resultMatch = modifier.getMatch();
          if (resultMatch.checkMapping()) {
            found.add(resultMatch);
          }
        }
      }
    }
    return found;
  }

  public void matchNodes(SNode candidate, SNode node) {
  }

  public class MethodMatchModifier implements IMatchModifier {
    private MethodMatch myMatch;

    public MethodMatchModifier() {
      this.myMatch = new MethodMatch();
    }

    public boolean accept(SNode candidate, SNode original) {
      if (MapSequence.fromMap(MethodDuplicatesFinder.this.myMapping).containsKey(original)) {
        return true;
      }
      return false;
    }

    public boolean acceptList(List<SNode> list1, List<SNode> list2) {
      return false;
    }

    public void performAction(SNode candidate, SNode original) {
      this.myMatch.putMapping(candidate, MapSequence.fromMap(MethodDuplicatesFinder.this.myMapping).get(original));
    }

    public void performGroupAction(List<SNode> list1, List<SNode> list2) {
    }

    public MethodMatch getMatch() {
      return this.myMatch;
    }
  }
}
