package jetbrains.mps.baseLanguage.util.plugin.refactorings;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import java.util.List;
import javax.swing.JComponent;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.typesystem.runtime.HUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.behavior.IInternalType_Behavior;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.baseLanguage.behavior.Expression_Behavior;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.baseLanguage.behavior.Type_Behavior;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public abstract class IntroduceVariableRefactoring {
  private String myName;
  private SNode myExpression;
  private SNode myExpressionType;
  private List<String> myExpectedNames;

  public String init(SNode node, JComponent editorComponent) {
    SNode expressionType = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(node), HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.Type"), true);
    if (SNodeOperations.isInstanceOf(expressionType, "jetbrains.mps.baseLanguage.structure.IInternalType")) {
      expressionType = IInternalType_Behavior.call_getPublicType_1213877443338(SNodeOperations.cast(expressionType, "jetbrains.mps.baseLanguage.structure.IInternalType"));
    }
    if (!(SNodeOperations.isInstanceOf(expressionType, "jetbrains.mps.baseLanguage.structure.Type"))) {
      return "Couldn't compute type of expression: " + expressionType;
    } else
    if (this.isVoidType(expressionType)) {
      return "Expression has no type";
    } else {
      this.myExpression = node;
      this.myExpressionType = SNodeOperations.cast(expressionType, "jetbrains.mps.baseLanguage.structure.Type");
      Set<String> expectedNames = SetSequence.fromSet(new HashSet<String>());
      String expectedVariableName = Expression_Behavior.call_getVariableExpectedName_1213877519781(node);
      if (expectedVariableName != null) {
        SetSequence.fromSet(expectedNames).addElement(NameUtil.decapitalize(expectedVariableName));
      }
      List<String> variableSuffixes = Type_Behavior.call_getVariableSuffixes_1213877337304(SNodeOperations.cast(expressionType, "jetbrains.mps.baseLanguage.structure.Type"));
      if (variableSuffixes != null) {
        SetSequence.fromSet(expectedNames).addSequence(ListSequence.fromList(variableSuffixes));
      }
      this.myExpectedNames = SetSequence.fromSet(expectedNames).where(new IWhereFilter<String>() {
        public boolean accept(String it) {
          return it.matches("[a-zA-Z0-9_]*");
        }
      }).toListSequence();
      if (ListSequence.fromList(this.myExpectedNames).isEmpty()) {
        ListSequence.fromList(this.myExpectedNames).addElement("");
      }
      return null;
    }
  }

  public void setName(String name) {
    this.myName = name;
  }

  public String getName() {
    return this.myName;
  }

  public SNode getExpression() {
    return this.myExpression;
  }

  public SNode getExpressionType() {
    return this.myExpressionType;
  }

  public List<String> getExpectedNames() {
    return this.myExpectedNames;
  }

  public abstract SNode doRefactoring();

  protected boolean isVoidType(SNode expressionType) {
    return SNodeOperations.isInstanceOf(expressionType, "jetbrains.mps.baseLanguage.structure.VoidType");
  }
}
