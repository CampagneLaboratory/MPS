package jetbrains.mps.baseLanguage.util.plugin.refactorings;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class ExtractMethodWithExitPoints extends ExtractMethodFromStatementsRefactoring {
  public ExtractMethodWithExitPoints(ExtractMethodRefactoringParameters parameters) {
    super(parameters);
  }

  protected SNode getMethodType() {
    return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BooleanType", null);
  }

  protected void addCallExpression(SNode newMethod) {
    SNode methodCall = this.createMethodCall(newMethod);
    SNode ifNode = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IfStatement", null);
    SLinkOperations.setTarget(ifNode, "condition", methodCall, true);
    SLinkOperations.setTarget(ifNode, "ifTrue", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null), true);
    SLinkOperations.addChild(SLinkOperations.getTarget(ifNode, "ifTrue", true), "statement", ListSequence.fromList(this.myAnalyzer.getIntenalExitPoints()).first());
    SNodeOperations.insertPrevSiblingChild(ListSequence.fromList(this.myStatements).first(), ifNode);
    for (SNode statement : ListSequence.fromList(this.myStatements)) {
      SNodeOperations.deleteNode(statement);
    }
  }

  protected void modifyPartToExtract() {
    SNode ret = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ReturnStatement", null);
    SNode constant = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BooleanConstant", null);
    SPropertyOperations.set(constant, "value", "" + false);
    SLinkOperations.setTarget(ret, "expression", constant, true);
    ListSequence.fromList(this.myStatements).addElement(SNodeOperations.copyNode(ret));
    SPropertyOperations.set(constant, "value", "" + true);
    for (SNode exitPoint : ListSequence.fromList(this.myAnalyzer.getIntenalExitPoints())) {
      SNodeOperations.replaceWithAnother(exitPoint, SNodeOperations.copyNode(ret));
    }
  }
}
