package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import jetbrains.mps.smodel.search.IReferenceInfoResolver;
import jetbrains.mps.baseLanguage.structure.ClassConcept;
import java.util.List;
import jetbrains.mps.baseLanguage.structure.Expression;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration;
import java.util.Map;
import jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration;
import jetbrains.mps.baseLanguage.structure.Type;

/*package*/ class StaticMethodReferenceInfoResolver implements IReferenceInfoResolver {
  private ClassConcept myClazz;
  private List<Expression> myActualArguments;
  private ClassifierAndSuperClassifiersScope mySearchScope;

  public StaticMethodReferenceInfoResolver(ClassifierAndSuperClassifiersScope searchScope, ClassConcept clazz, List<Expression> actualArguments) {
    this.myClazz = clazz;
    this.myActualArguments = actualArguments;
    this.mySearchScope = searchScope;
  }

  public SNode resolve(String referenceInfo, SModelReference targetModelReference) {
    if (referenceInfo == null) {
      return null;
    }
    List<BaseMethodDeclaration> methods = this.mySearchScope.getMethodsByName(referenceInfo);
    if (methods.isEmpty()) {
      return null;
    }
    if (methods.size() == 1) {
      return methods.get(0).getNode();
    }
    methods = (List<BaseMethodDeclaration>) MethodResolveUtil.selectByParmCount(methods, this.myActualArguments);
    if (methods.size() == 1) {
      return methods.get(0).getNode();
    }
    Map<TypeVariableDeclaration, Type> typeByTypeVar = ClassifierAndSuperClassifiersCache.getInstance(this.myClazz).getTypeByTypeVariableMap();
    return MethodResolveUtil.chooseByParameterType(methods, this.myActualArguments, typeByTypeVar).getNode();
  }
}
