package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import jetbrains.mps.cache.AbstractCache;
import jetbrains.mps.cache.KeyProducer;
import java.util.Map;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.HashMap;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.INodeAdapter;
import java.util.Set;
import java.util.Collections;
import jetbrains.mps.baseLanguage.structure.Classifier;
import java.util.ArrayList;
import jetbrains.mps.smodel.BaseAdapter;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.cache.CachesManager;

/*package*/ class ClassifiersCache extends AbstractCache {
  private static final KeyProducer keyProducer = new KeyProducer();

  private Map<String, List<SNode>> myClassifiersByName = new HashMap<String, List<SNode>>();
  private Map<SNode, String> myNameByClassifier = new HashMap<SNode, String>();

  protected ClassifiersCache(Object key, SModelDescriptor model) {
    super(key);
    List<INodeAdapter> list = model.getSModel().getRootsAdapters();
    for (INodeAdapter adapter : list) {
      this.processNode(adapter, true);
    }
  }

  @Override
  public Set<SModelDescriptor> getDependsOnModels(Object element) {
    // http://youtrack.jetbrains.net/issue/MPS-8362
    assert element != null : "Model descriptor is null";
    return Collections.singleton((SModelDescriptor) element);
  }

  private void processNode(INodeAdapter adapter, boolean put) {
    if (adapter instanceof Classifier) {
      if (put) {
        this.putClassifier((Classifier) adapter);
      } else {
        this.removeClassifier((Classifier) adapter);
      }
    } else {
      for (INodeAdapter child : adapter.getChildren()) {
        this.processNode(child, put);
      }
    }
  }

  private void putClassifier(Classifier classifier) {
    String name = this.getRefName(classifier);
    if (!(this.myClassifiersByName.containsKey(name))) {
      this.myClassifiersByName.put(name, new ArrayList<SNode>(1));
    }
    this.myClassifiersByName.get(name).add(classifier.getNode());
    this.myNameByClassifier.put(classifier.getNode(), name);
    List<Classifier> list = classifier.getStaticInnerClassifierses();
    for (Classifier innerClassifier : list) {
      this.putClassifier(innerClassifier);
    }
  }

  private void removeClassifier(Classifier classifier) {
    String name = this.getRefName(classifier);
    if (this.myClassifiersByName.containsKey(name)) {
      List<SNode> nodes = this.myClassifiersByName.get(name);
      nodes.remove(classifier.getNode());
      if (nodes.isEmpty()) {
        this.myClassifiersByName.remove(name);
      }
    }
    this.myNameByClassifier.remove(classifier.getNode());
    List<Classifier> list = classifier.getStaticInnerClassifierses();
    for (Classifier innerClassifier : list) {
      this.removeClassifier(innerClassifier);
    }
  }

  private String getRefName(Classifier classifier) {
    String name = classifier.getName();
    if (name == null) {
      name = "";
    }
    INodeAdapter parent = classifier.getParent();
    if (parent instanceof Classifier) {
      return this.getRefName(((Classifier) parent)) + "." + name;
    }
    return name;
  }

  public List<Classifier> getClassifiers() {
    List<SNode> result = new ArrayList<SNode>(this.myNameByClassifier.keySet());
    return BaseAdapter.toAdapters(result);
  }

  public List<Classifier> getClassifiersByRefName(String refName) {
    List<SNode> result = this.myClassifiersByName.get(refName);
    if (result != null) {
      return BaseAdapter.toAdapters(result);
    }
    return new ArrayList<Classifier>();
  }

  public void rootAdded(SModelRootEvent event) {
    INodeAdapter adapter = event.getRoot().getAdapter();
    this.processNode(adapter, true);
  }

  public void rootRemoved(SModelRootEvent event) {
    INodeAdapter adapter = event.getRoot().getAdapter();
    this.processNode(adapter, false);
  }

  public void childAdded(SModelChildEvent event) {
    BaseAdapter adapter = event.getChild().getAdapter();
    if (!((adapter instanceof Classifier))) {
      if (adapter.getParent(Classifier.class, false) != null) {
        return;
      }
    }
    this.processNode(adapter, true);
  }

  public void beforeChildRemoved(SModelChildEvent event) {
    BaseAdapter adapter = event.getChild().getAdapter();
    if (!((adapter instanceof Classifier))) {
      if (adapter.getParent(Classifier.class, false) != null) {
        return;
      }
    }
    this.processNode(adapter, false);
  }

  public void propertyChanged(SModelPropertyEvent event) {
    BaseAdapter adapter = event.getNode().getAdapter();
    if (adapter instanceof Classifier && Classifier.NAME.equals(event.getPropertyName())) {
      List<Classifier> classifiersToUpdate = new ArrayList<Classifier>();
      classifiersToUpdate.add(((Classifier) adapter));
      this.collectInnerClasses((Classifier) adapter, classifiersToUpdate);
      for (Classifier classifier : classifiersToUpdate) {
        String oldRefName = this.myNameByClassifier.get(classifier.getNode());
        List<SNode> nodes = this.myClassifiersByName.get(oldRefName);
        nodes.remove(classifier.getNode());
        if (nodes.isEmpty()) {
          this.myClassifiersByName.remove(oldRefName);
        }
        this.myNameByClassifier.remove(classifier.getNode());
      }
      this.putClassifier(((Classifier) adapter));
    }
  }

  private void collectInnerClasses(Classifier classConcept, List<Classifier> list) {
    List<Classifier> inners = classConcept.getStaticInnerClassifierses();
    list.addAll(inners);
    for (Classifier inner : inners) {
      this.collectInnerClasses(inner, list);
    }
  }

  public static ClassifiersCache getInstance(SModelDescriptor model) {
    String uid = model.getSModelReference().toString();
    Object key = keyProducer.createKey(uid);
    return (ClassifiersCache) CachesManager.getInstance().getCache(key, model, new CachesManager.CacheCreator<SModelDescriptor>() {
      public AbstractCache create(Object key, SModelDescriptor element) {
        return new ClassifiersCache(key, element);
      }
    });
  }
}
