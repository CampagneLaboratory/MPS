package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import jetbrains.mps.smodel.search.AbstractSearchScope;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.baseLanguage.structure.ClassifierType;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import jetbrains.mps.util.Condition;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.structure.ClassifierMember;
import jetbrains.mps.smodel.BaseAdapter;
import jetbrains.mps.smodel.search.IReferenceInfoResolver;
import jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration;
import jetbrains.mps.baseLanguage.structure.Classifier;
import jetbrains.mps.baseLanguage.structure.ClassConcept;
import jetbrains.mps.baseLanguage.structure.IMethodCall;
import jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration;

public class ClassifierVisibleMembersScope extends AbstractSearchScope {
  private final SNode myContextNode;
  private final ClassifierAndSuperClassifiersScope myClassifierScope;
  private ClassifierType myClassifierType;

  public ClassifierVisibleMembersScope(@Nullable ClassifierType classifierType, @Nullable SNode contextNode, int constraint) {
    this.myClassifierType = classifierType;
    this.myContextNode = contextNode;
    this.myClassifierScope = new ClassifierAndSuperClassifiersScope((classifierType != null ?
      classifierType.getClassifier() :
      null
    ), constraint);
  }

  @NotNull
  public List<SNode> getNodes(Condition<SNode> condition) {
    List<SNode> result = new ArrayList<SNode>();
    for (ClassifierMember member : this.getClassifierMembers()) {
      if (condition.met(member.getNode())) {
        result.add(member.getNode());
      }
    }
    return result;
  }

  private List<ClassifierMember> getClassifierMembers() {
    List<ClassifierMember> members = this.myClassifierScope.getAdapters(ClassifierMember.class);
    List<ClassifierMember> result = new ArrayList<ClassifierMember>();
    for (ClassifierMember member : members) {
      if (VisibilityUtil.isVisible(BaseAdapter.fromNode(this.myContextNode), member)) {
        result.add(member);
      }
    }
    return result;
  }

  public IReferenceInfoResolver getReferenceInfoResolver(SNode referenceNode, AbstractConceptDeclaration targetConcept) {
    if (this.myClassifierType != null) {
      if (SModelUtil_new.isAssignableConcept(targetConcept, StaticMethodDeclaration.concept)) {
        Classifier classifier = this.myClassifierType.getClassifier();
        if (classifier instanceof ClassConcept && referenceNode.getAdapter() instanceof IMethodCall) {
          return new StaticMethodReferenceInfoResolver(this.myClassifierScope, (ClassConcept) classifier, ((IMethodCall) referenceNode.getAdapter()).getActualArguments());
        }
      } else
      if (SModelUtil_new.isAssignableConcept(targetConcept, InstanceMethodDeclaration.concept)) {
        if (referenceNode.getAdapter() instanceof IMethodCall) {
          return new InstanceMethodReferenceInfoResolver(this.myClassifierScope, this.myClassifierType, ((IMethodCall) referenceNode.getAdapter()).getActualArguments());
        }
      }
    }
    return this.myClassifierScope.getReferenceInfoResolver(referenceNode, targetConcept);
  }
}
