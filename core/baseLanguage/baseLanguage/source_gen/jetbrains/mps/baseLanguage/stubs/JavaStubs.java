package jetbrains.mps.baseLanguage.stubs;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.structure.*;
import jetbrains.mps.stubs.BaseStubModelRootManager;
import jetbrains.mps.logging.Logger;
import java.util.Set;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.stubs.StubLocation;
import jetbrains.mps.stubs.ModelInfo;
import jetbrains.mps.reloading.IClassPathItem;
import jetbrains.mps.stubs.javastub.ASMModelLoader;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.stubs.javastub.classpath.StubHelper;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.DefaultSModelDescriptor;
import java.util.HashSet;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.LanguageID;
import jetbrains.mps.workbench.actions.goTo.index.SNodeDescriptor;
import jetbrains.mps.reloading.AbstractClassPathItem;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

import jetbrains.mps.stubs.javastub.classpath.ClassifierKind;

public class JavaStubs extends BaseStubModelRootManager {
  private static Logger LOG = Logger.getLogger(JavaStubs.class);

  public JavaStubs() {
  }

  protected Set<Language> getLanguagesToImport() {
    Set<Language> res = new HashSet<Language>();
    res.add(BaseLanguage_Language.get());
    return res;
  }

  protected void updateModel(final StubLocation location, final ModelInfo modelInfo) {
    final JavaStubs localThis = JavaStubs.this;
    IClassPathItem cpItem = JavaStubs.this.createClassPathItem(location);
    if (cpItem == null) {
      return;
    }
    new ASMModelLoader(cpItem, modelInfo.getModelDescriptor(), modelInfo.getModel()) {
      public SModelDescriptor getModelDescriptor(String packageName) {
        SModelReference modelReference = StubHelper.uidForPackageInStubs(packageName);
        SModelDescriptor result = SModelRepository.getInstance().getModelDescriptor(modelReference);
        if (result != null) {
          return result;
        }
        result = new DefaultSModelDescriptor(localThis, null, modelReference);
        SModelRepository.getInstance().registerModelDescriptor(result, modelInfo.getModelDescriptor().getModule());
        return result;
      }
    }.updateModel();
  }

  protected Set<SModelDescriptor> getModelDescriptors(final StubLocation location) {
    String pack = location.getPrefix();
    IClassPathItem cpItem = JavaStubs.this.createClassPathItem(location);
    if (cpItem == null) {
      return new HashSet<SModelDescriptor>();
    }

    Set<String> subpackages = cpItem.getSubpackages(pack);

    if (pack.equals("")) {
    }
    Set<SModelDescriptor> result = new HashSet<SModelDescriptor>();
    for (String subpackage : subpackages) {
      if (!(cpItem.getAvailableClasses(subpackage).isEmpty())) {
        SModelReference modelReference = StubHelper.uidForPackageInStubs(subpackage);
        if (SModelRepository.getInstance().getModelDescriptor(modelReference) != null) {
          final SModelDescriptor descriptor = SModelRepository.getInstance().getModelDescriptor(SModelReference.fromString(subpackage + "@" + SModelStereotype.getStubStereotypeForId(LanguageID.JAVA)));
          assert descriptor != null;
          SModelRepository.getInstance().addOwnerForDescriptor(descriptor, location.getModule());
          result.add(descriptor);
        } else {
          SModelDescriptor modelDescriptor = new DefaultSModelDescriptor(JavaStubs.this, null, modelReference);
          result.add(modelDescriptor);
        }
      }
      result.addAll(JavaStubs.this.getModelDescriptors(new StubLocation(location.getPath(), subpackage, location.getModule())));
    }
    return result;
  }

  public Set<SNodeDescriptor> getRootNodeDescriptors(final StubLocation location) {
    Set<SNodeDescriptor> result = new jetbrains.mps.util.misc.hash.HashSet<SNodeDescriptor>();
    JavaStubs.this.iterateClasspath(JavaStubs.this.createClassPathItem(location), result, "");
    return result;
  }

  private IClassPathItem createClassPathItem(StubLocation location) {
    IClassPathItem result = null;
    try {
      result = AbstractClassPathItem.createFromPath(location.getPath(), location.getModule());
    } catch (IOException e) {
      LOG.error("Error on loading stubs", e);
    }
    return result;
  }

  private void iterateClasspath(IClassPathItem item, Set<SNodeDescriptor> result, final String pack) {
    int numberInStubModel = 0;
    List<String> availableClasses = new ArrayList<String>();
    availableClasses.addAll(item.getAvailableClasses(pack));
    Collections.sort(availableClasses);
    for (String cls : availableClasses) {
      if (cls.contains("$")) {
        continue;
      }
      byte[] content = item.getClass(("".equals(pack) ?
        cls :
        pack + "." + cls
      ));
      String conceptFqName = ClassConcept.concept;
      ClassifierKind kind = ClassifierKind.getClassifierKind(content);
      if (kind == ClassifierKind.CLASS) {
        conceptFqName = ClassConcept.concept;
      } else if (kind == ClassifierKind.INTERFACE) {
        conceptFqName = Interface.concept;
      } else if (kind == ClassifierKind.ANNOTATIONS) {
        conceptFqName = Annotation.concept;
      } else if (kind == ClassifierKind.ENUM) {
        conceptFqName = EnumClass.concept;
      } else if (kind == ClassifierKind.UNKNOWN) {
        continue;
      }
      result.add(new SNodeDescriptor(cls, conceptFqName, 0, 0, numberInStubModel) {
        public SModelReference getModelReference() {
          return StubHelper.uidForPackageInStubs(pack);
        }
      });
      numberInStubModel++;
    }
    for (String subpack : item.getSubpackages(pack)) {
      JavaStubs.this.iterateClasspath(item, result, subpack);
    }
  }
}
