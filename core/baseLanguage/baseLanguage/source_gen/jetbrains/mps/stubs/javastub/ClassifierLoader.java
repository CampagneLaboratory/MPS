package jetbrains.mps.stubs.javastub;

/*Generated by MPS */

import jetbrains.mps.reloading.IClassPathItem;
import jetbrains.mps.smodel.SModel;
import java.util.List;
import jetbrains.mps.baseLanguage.structure.Classifier;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.reloading.AbstractClassPathItem;
import org.objectweb.asm.ClassReader;
import jetbrains.mps.stubs.javastub.asm.ASMClass;
import org.objectweb.asm.tree.InnerClassNode;
import org.objectweb.asm.Opcodes;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.stubs.javastub.classpath.ClassifierKind;
import jetbrains.mps.baseLanguage.structure.ClassConcept;
import jetbrains.mps.baseLanguage.structure.Interface;
import jetbrains.mps.baseLanguage.structure.Annotation;
import jetbrains.mps.baseLanguage.structure.EnumClass;
import jetbrains.mps.util.NameUtil;

public class ClassifierLoader {
  private IClassPathItem myCpItem;
  private SModel myModel;
  private List<Classifier> myClassifiers = ListSequence.fromList(new ArrayList<Classifier>());

  public ClassifierLoader(SModel model, IClassPathItem cpItem) {
    myModel = model;
    myCpItem = cpItem;
  }

  public List<Classifier> getLoadedClassifiers() {
    return myClassifiers;
  }

  public Classifier getRootClassifier(String name) {
    Classifier c = getClassifier(name);
    if (c == null) {
      return null;
    }
    myModel.addRoot(c.getNode());
    return c;
  }

  private Classifier getClassifier(String name) {
    if (AbstractClassPathItem.isAnonymous(name)) {
      return null;
    }

    String pack = myModel.getLongName();
    byte[] code = myCpItem.getClass((pack.length() == 0 ?
      name :
      pack + "." + name
    ));
    if (code == null) {
      return null;
    }
    ClassReader reader = new ClassReader(code);
    Classifier res = createClassifierForClass(name, myModel, reader);
    ListSequence.fromList(myClassifiers).addElement(res);
    updateInnerClassifiers(new ASMClass(reader), res);
    return res;
  }

  public void updateInnerClassifiers(ASMClass ac, Classifier cls) {
    for (InnerClassNode cn : ac.getInnerClasses()) {
      if ((cn.access & Opcodes.ACC_SYNTHETIC) != 0) {
        continue;
      }

      boolean isPrivate = (cn.access & Opcodes.ACC_PRIVATE) != 0;
      if (isPrivate && ASMModelLoader.SKIP_PRIVATE) {
        continue;
      }

      String name = cn.name;
      if (name == null) {
        continue;
      }
      if (!(name.startsWith(ac.getName() + "$"))) {
        continue;
      }

      int index = name.lastIndexOf("/");
      if (index != -1) {
        name = name.substring(index + 1);
      }

      boolean isStatic = (cn.access & Opcodes.ACC_STATIC) != 0;

      Classifier c = getClassifier(name);
      if (c == null) {
        continue;
      }

      SNode n = c.getNode();
      SPropertyOperations.set(SNodeOperations.cast(n, "jetbrains.mps.baseLanguage.structure.Classifier"), "nonStatic", "" + !(isStatic));
      cls.addStaticInnerClassifiers(c);
    }
  }

  private Classifier createClassifierForClass(String fqName, SModel model, ClassReader reader) {
    Classifier result = null;
    ClassifierKind kind = ClassifierKind.getClassifierKind(reader);
    if (kind == null) {
      return null;
    }
    if (kind == ClassifierKind.CLASS) {
      result = ClassConcept.newInstance(model);
    } else if (kind == ClassifierKind.INTERFACE) {
      result = Interface.newInstance(model);
    } else if (kind == ClassifierKind.ANNOTATIONS) {
      result = Annotation.newInstance(model);
    } else if (kind == ClassifierKind.ENUM) {
      result = EnumClass.newInstance(model);
    } else if (kind == ClassifierKind.UNKNOWN) {
      return null;
    }
    result.setName(NameUtil.shortNameFromLongName(fqName.replace('$', '.')));
    result.getNode().setId(ASMNodeId.createId(fqName));
    return result;
  }
}
