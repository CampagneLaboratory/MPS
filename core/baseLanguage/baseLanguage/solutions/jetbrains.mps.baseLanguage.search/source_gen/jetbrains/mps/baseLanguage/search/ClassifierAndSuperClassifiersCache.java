package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import jetbrains.mps.cache.AbstractCache;
import jetbrains.mps.cache.KeyProducer;
import jetbrains.mps.cache.DataSet;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.baseLanguage.structure.Classifier;
import java.util.Set;
import jetbrains.mps.smodel.SModelDescriptor;
import java.util.HashSet;
import java.util.List;
import jetbrains.mps.smodel.BaseAdapter;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.structure.VariableDeclaration;
import jetbrains.mps.baseLanguage.structure.FieldDeclaration;
import jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration;
import java.util.Map;
import jetbrains.mps.cache.CachesManager;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.baseLanguage.structure.GenericDeclaration;
import jetbrains.mps.baseLanguage.structure.ClassConcept;
import jetbrains.mps.baseLanguage.structure.Interface;
import jetbrains.mps.baseLanguage.structure.AnonymousClass;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import java.util.LinkedHashSet;
import jetbrains.mps.generator.JavaModelUtil_new;
import java.util.Iterator;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.behavior.Type_Behavior;
import jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration;
import jetbrains.mps.baseLanguage.structure.BaseVariableDeclaration;

/*package*/ final class ClassifierAndSuperClassifiersCache extends AbstractCache {
  private static final KeyProducer keyProducer = new KeyProducer();
  private static final AbstractCache.DataSetCreator<ClassifierAndSuperClassifiersCache> CLASSIFIERS_CACHE_CREATOR = new AbstractCache.DataSetCreator<ClassifierAndSuperClassifiersCache>() {
    public DataSet create(ClassifierAndSuperClassifiersCache ownerCache) {
      return new ClassifierAndSuperClassifiersCache.ClassifiersDataSet((SNode) ownerCache.myTopClassifier.getNode(), ownerCache);
    }
  };
  private static final AbstractCache.DataSetCreator<ClassifierAndSuperClassifiersCache> METHODS_CACHE_CREATOR = new AbstractCache.DataSetCreator<ClassifierAndSuperClassifiersCache>() {
    public DataSet create(ClassifierAndSuperClassifiersCache ownerCache) {
      return new ClassifierAndSuperClassifiersCache.MethodsDataSet(ownerCache);
    }
  };
  private static final AbstractCache.DataSetCreator<ClassifierAndSuperClassifiersCache> FIELDS_CACHE_CREATOR = new AbstractCache.DataSetCreator<ClassifierAndSuperClassifiersCache>() {
    public DataSet create(ClassifierAndSuperClassifiersCache ownerCache) {
      return new ClassifierAndSuperClassifiersCache.FieldsDataSet(ownerCache);
    }
  };

  private final Classifier myTopClassifier;

  private ClassifierAndSuperClassifiersCache(Object key, Classifier topClassifier) {
    super(key);
    this.myTopClassifier = topClassifier;
  }

  @Override
  public Set<SModelDescriptor> getDependsOnModels(Object element) {
    Set<SModelDescriptor> dependsOnModel = new HashSet<SModelDescriptor>();
    for (Classifier classifier : this.getClassifiers()) {
      SModelDescriptor descriptor = classifier.getModel().getModelDescriptor();
      assert descriptor != null : "Model descriptor is null for classifier: " + classifier;
      dependsOnModel.add(descriptor);
    }
    return dependsOnModel;
  }

  @Deprecated
  /*package*/ List<Classifier> getClassifiers() {
    ClassifierAndSuperClassifiersCache.ClassifiersDataSet dataSet = (ClassifierAndSuperClassifiersCache.ClassifiersDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.ClassifiersDataSet.ID, CLASSIFIERS_CACHE_CREATOR);
    return BaseAdapter.toAdapters(dataSet.getClassifiers());
  }

  /*package*/ List<SNode> getClassifierNodes() {
    ClassifierAndSuperClassifiersCache.ClassifiersDataSet dataSet = (ClassifierAndSuperClassifiersCache.ClassifiersDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.ClassifiersDataSet.ID, CLASSIFIERS_CACHE_CREATOR);
    return dataSet.getClassifiers();
  }

  /*package*/ List<SNode> getMethods() {
    ClassifierAndSuperClassifiersCache.MethodsDataSet dataSet = (ClassifierAndSuperClassifiersCache.MethodsDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.MethodsDataSet.ID, METHODS_CACHE_CREATOR);
    return dataSet.getMethods();
  }

  /*package*/ List<SNode> getOverriddenMethods(SNode method) {
    ClassifierAndSuperClassifiersCache.MethodsDataSet dataSet = (ClassifierAndSuperClassifiersCache.MethodsDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.MethodsDataSet.ID, METHODS_CACHE_CREATOR);
    return dataSet.getOverriddenMethods(method);
  }

  /*package*/ List<SNode> getMethodsByName(String methodName) {
    ClassifierAndSuperClassifiersCache.MethodsDataSet dataSet = (ClassifierAndSuperClassifiersCache.MethodsDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.MethodsDataSet.ID, METHODS_CACHE_CREATOR);
    List<SNode> methods = dataSet.getMethodsByName(methodName);
    if (methods == null) {
      return new ArrayList<SNode>();
    }
    return methods;
  }

  /*package*/ List<VariableDeclaration> getFields() {
    ClassifierAndSuperClassifiersCache.FieldsDataSet dataSet = (ClassifierAndSuperClassifiersCache.FieldsDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.FieldsDataSet.ID, FIELDS_CACHE_CREATOR);
    return dataSet.getFields();
  }

  /*package*/ FieldDeclaration getFieldByName(String name) {
    ClassifierAndSuperClassifiersCache.FieldsDataSet dataSet = (ClassifierAndSuperClassifiersCache.FieldsDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.FieldsDataSet.ID, FIELDS_CACHE_CREATOR);
    return dataSet.getFieldByName(name);
  }

  /*package*/ StaticFieldDeclaration getStaticFieldByName(String name) {
    ClassifierAndSuperClassifiersCache.FieldsDataSet dataSet = (ClassifierAndSuperClassifiersCache.FieldsDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.FieldsDataSet.ID, FIELDS_CACHE_CREATOR);
    return dataSet.getStaticFieldByName(name);
  }

  /*package*/ Map<SNode, SNode> getTypeByTypeVariableMap() {
    ClassifierAndSuperClassifiersCache.ClassifiersDataSet dataSet = (ClassifierAndSuperClassifiersCache.ClassifiersDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.ClassifiersDataSet.ID, CLASSIFIERS_CACHE_CREATOR);
    return dataSet.getTypeByTypeVariableMap();
  }

  /*package*/ static ClassifierAndSuperClassifiersCache getInstance(Classifier topClassifier) {
    SNode node = topClassifier.getNode();
    Object key = keyProducer.createKey(node);
    return (ClassifierAndSuperClassifiersCache) CachesManager.getInstance().getCache(key, topClassifier, new CachesManager.CacheCreator<Classifier>() {
      public AbstractCache create(Object key, Classifier element) {
        return new ClassifierAndSuperClassifiersCache(key, element);
      }
    });
  }

  public static ClassifierAndSuperClassifiersCache getInstance(SNode topClassifierNode) {
    return ClassifierAndSuperClassifiersCache.getInstance((Classifier) BaseAdapter.fromNode(topClassifierNode));
  }

  private static final class ClassifiersDataSet extends DataSet {
    public static final String ID = "CLASSIFIERS_DATASET";

    private SNode myTopClassifier;
    private List<SNode> myClassifiers;
    private Map<SNode, SNode> myTypeByTypeVariable;
    private Set<SNode> myDependsOnNodes;

    public ClassifiersDataSet(SNode topClassifier, AbstractCache ownerCache) {
      super(ID, ownerCache, DataSet.DefaultNodeChangedProcessing.DROP_OWNER_CACHE);
      this.myTopClassifier = topClassifier;
    }

    public List<SNode> getClassifiers() {
      return this.myClassifiers;
    }

    public Set<SNode> getDependsOnNodes() {
      return this.myDependsOnNodes;
    }

    /*package*/ Map<SNode, SNode> getTypeByTypeVariableMap() {
      return this.myTypeByTypeVariable;
    }

    protected void init() {
      this.myTypeByTypeVariable = MapSequence.fromMap(new HashMap<SNode, SNode>());
      this.myClassifiers = ClassifierAndSuperClassifiersCache.ClassifiersDataSet.getImplementedAndExtended(this.myTopClassifier, this.myTypeByTypeVariable);
      this.myDependsOnNodes = SetSequence.fromSet(new HashSet<SNode>());
      for (SNode classifier : this.myClassifiers) {
        SetSequence.fromSet(this.myDependsOnNodes).addElement(classifier);
        if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
          for (SNode type : SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass")), "typeParameter", true)) {
            SetSequence.fromSet(this.myDependsOnNodes).addElement(type);
            SetSequence.fromSet(this.myDependsOnNodes).addSequence(ListSequence.fromList(type.getDescendants()));
          }
        } else {
          for (SNode typeVariableDecl : SLinkOperations.getTargets(classifier, "typeVariableDeclaration", true)) {
            SetSequence.fromSet(this.myDependsOnNodes).addElement(typeVariableDecl);
          }
        }
        if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept") && !(SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass"))) {
          SNode classifierType0 = SLinkOperations.getTarget((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "superclass", true);
          if (classifierType0 != null) {
            SetSequence.fromSet(this.myDependsOnNodes).addElement(classifierType0);
            SetSequence.fromSet(this.myDependsOnNodes).addSequence(ListSequence.fromList(classifierType0.getDescendants()));
          }
          for (SNode classifierType1 : SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "implementedInterface", true)) {
            SetSequence.fromSet(this.myDependsOnNodes).addElement(classifierType1);
            SetSequence.fromSet(this.myDependsOnNodes).addSequence(ListSequence.fromList(classifierType1.getDescendants()));
          }
        } else
        if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.Interface")) {
          for (SNode classifierType : SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.Interface")), "extendedInterface", true)) {
            SetSequence.fromSet(this.myDependsOnNodes).addElement(classifierType);
            SetSequence.fromSet(this.myDependsOnNodes).addSequence(ListSequence.fromList(classifierType.getDescendants()));
          }
        }
      }
    }

    public void childAdded(SModelChildEvent event) {
      if (event.getParent().getAdapter() instanceof Classifier) {
        String role = event.getChildRole();
        if (!((GenericDeclaration.TYPE_VARIABLE_DECLARATION.equals(role) || ClassConcept.SUPERCLASS.equals(role) || ClassConcept.IMPLEMENTED_INTERFACE.equals(role) || Interface.EXTENDED_INTERFACE.equals(role) || AnonymousClass.TYPE_PARAMETER.equals(role)))) {
          return;
        }
      }
      super.childAdded(event);
    }

    public void childRemoved(SModelChildEvent event) {
      if (event.getParent().getAdapter() instanceof Classifier) {
        String role = event.getChildRole();
        if (!((GenericDeclaration.TYPE_VARIABLE_DECLARATION.equals(role) || ClassConcept.SUPERCLASS.equals(role) || ClassConcept.IMPLEMENTED_INTERFACE.equals(role) || Interface.EXTENDED_INTERFACE.equals(role) || AnonymousClass.TYPE_PARAMETER.equals(role)))) {
          return;
        }
      }
      super.childRemoved(event);
    }

    public void propertyChanged(SModelPropertyEvent event) {
    }

    private static List<SNode> getImplementedAndExtended(SNode classifier, Map<SNode, SNode> typeByTypeVar) {
      Set<SNode> set = SetSequence.fromSet(new LinkedHashSet<SNode>());
      ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(classifier, set, null, typeByTypeVar);
      List<SNode> result = new ArrayList<SNode>();
      ListSequence.fromList(result).addSequence(SetSequence.fromSet(set));
      SNode objectClass = (SNode) JavaModelUtil_new.findClassifier("java.lang", "Object", true);
      if (objectClass != null) {
        if (!(SetSequence.fromSet(set).contains(objectClass))) {
          int indexOfFirstInterface = 0;
          for (SNode classifierInResult : set) {
            if (SNodeOperations.isInstanceOf(classifierInResult, "jetbrains.mps.baseLanguage.structure.Interface")) {
              break;
            }
            indexOfFirstInterface++;
          }
          if (indexOfFirstInterface == 0) {
            result.add(objectClass);
          } else {
            result.add(indexOfFirstInterface, objectClass);
          }
        }
      }
      return result;
    }

    private static void collectImplementedAndExtended(SNode classifier, Set<SNode> result, List<SNode> typeParms, Map<SNode, SNode> typeByTypeVar) {
      if ((classifier == null)) {
        return;
      }
      if (SetSequence.fromSet(result).contains(classifier)) {
        return;
      }
      SetSequence.fromSet(result).addElement(classifier);
      if (typeParms != null && ListSequence.fromList(typeParms).count() > 0) {
        Iterator<SNode> typeVars = ListSequence.fromList(SLinkOperations.getTargets(classifier, "typeVariableDeclaration", true)).iterator();
        for (SNode typeParm : typeParms) {
          if (!(typeVars.hasNext())) {
            break;
          }
          SNode typeVar = typeVars.next();
          MapSequence.fromMap(typeByTypeVar).put(typeVar, typeParm);
        }
      }
      if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
        SNode cls = SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass");
        ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(SLinkOperations.getTarget(cls, "classifier", false), result, SLinkOperations.getTargets(cls, "typeParameter", true), typeByTypeVar);
      } else
      if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        SNode classifierType0 = SLinkOperations.getTarget((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "superclass", true);
        if (classifierType0 != null) {
          ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(SLinkOperations.getTarget(classifierType0, "classifier", false), result, SLinkOperations.getTargets(classifierType0, "parameter", true), typeByTypeVar);
        }
        for (SNode classifierType1 : SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "implementedInterface", true)) {
          ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(SLinkOperations.getTarget(classifierType1, "classifier", false), result, SLinkOperations.getTargets(classifierType1, "parameter", true), typeByTypeVar);
        }
        if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
          SNode enumClassNode = JavaModelUtil_new.findClassifier("java.lang", "Enum", true);
          if (enumClassNode != null) {
            SNode enumClassifier = SNodeOperations.cast(enumClassNode, "jetbrains.mps.baseLanguage.structure.Classifier");
            ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(enumClassifier, result, null, typeByTypeVar);
          }
        }
      } else
      if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.Interface")) {
        for (SNode classifierType : SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.Interface")), "extendedInterface", true)) {
          ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(SLinkOperations.getTarget(classifierType, "classifier", false), result, SLinkOperations.getTargets(classifierType, "parameter", true), typeByTypeVar);
        }
      }
    }
  }

  private static final class MethodsDataSet extends DataSet {
    public static final String ID = "METHODS_DATASET";

    private Map<String, List<SNode>> myMethodsByName;
    private Map<SNode, List<SNode>> myOverriddenMethods;
    private Set<SNode> myDependsOnNodes;

    public MethodsDataSet(AbstractCache ownerCache) {
      super(ID, ownerCache, DataSet.DefaultNodeChangedProcessing.DROP_DATA_SET);
    }

    public List<SNode> getMethods() {
      List<SNode> result = new ArrayList<SNode>();
      for (List<SNode> list : this.myMethodsByName.values()) {
        ListSequence.fromList(result).addSequence(ListSequence.fromList(list));
      }
      return result;
    }

    public List<SNode> getOverriddenMethods(SNode method) {
      List<SNode> list = this.myOverriddenMethods.get(method);
      if (list != null) {
        return list;
      }
      return new ArrayList<SNode>();
    }

    @Nullable
    public List<SNode> getMethodsByName(String methodName) {
      if (methodName == null) {
        return this.myMethodsByName.get("");
      }
      return this.myMethodsByName.get(methodName);
    }

    public Set<SNode> getDependsOnNodes() {
      return this.myDependsOnNodes;
    }

    protected void init() {
      List<SNode> allMethods = new ArrayList<SNode>();
      List<SNode> classifiers = ((ClassifierAndSuperClassifiersCache) this.getOwnerCache()).getClassifierNodes();
      for (SNode classifier : classifiers) {
        allMethods.addAll(SLinkOperations.getTargets(classifier, "method", true));
        if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
          allMethods.addAll(SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "staticMethod", true));
        }
      }
      this.myMethodsByName = MapSequence.fromMap(new HashMap<String, List<SNode>>());
      this.myOverriddenMethods = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());
forEachInAllMethods:
      for (SNode currMethod : allMethods) {
        if (SNodeOperations.isInstanceOf(currMethod, "jetbrains.mps.baseLanguage.structure.PlaceholderMethodDeclaration")) {
          continue;
        }
        String name = SPropertyOperations.getString(currMethod, "name");
        if (name == null) {
          name = "";
        }
        if (!(this.myMethodsByName.containsKey(name))) {
          List<SNode> methods = new ArrayList<SNode>();
          methods.add(currMethod);
          MapSequence.fromMap(myMethodsByName).put(name, methods);
          MapSequence.fromMap(myOverriddenMethods).put(currMethod, new ArrayList<SNode>());
        } else {
          int currMethodParmCount = ListSequence.fromList(SLinkOperations.getTargets(currMethod, "parameter", true)).count();
          List<SNode> equalParmCountMethods = new ArrayList<SNode>();
          List<SNode> methods = this.myMethodsByName.get(name);
          for (SNode method : methods) {
            if ((SNodeOperations.getParent(currMethod) != SNodeOperations.getParent(method)) && ListSequence.fromList(SLinkOperations.getTargets(method, "parameter", true)).count() == currMethodParmCount) {
              equalParmCountMethods.add(method);
            }
          }
          if (equalParmCountMethods.size() > 0) {
            if (currMethodParmCount == 0) {
              ListSequence.fromList(MapSequence.fromMap(myOverriddenMethods).get(ListSequence.fromList(equalParmCountMethods).first())).addElement(currMethod);
              continue forEachInAllMethods;
            }
            Map<SNode, SNode> typeByTypeVar = ((ClassifierAndSuperClassifiersCache) this.getOwnerCache()).getTypeByTypeVariableMap();
            String currentParms = this.createMethodParameterTypesString(currMethod, typeByTypeVar);
            for (SNode otherMethod : equalParmCountMethods) {
              String otherParms = this.createMethodParameterTypesString(otherMethod, typeByTypeVar);
              if (otherParms.equals(currentParms)) {
                this.myOverriddenMethods.get(otherMethod).add(currMethod);
                continue forEachInAllMethods;
              }
            }
          }
          ListSequence.fromList(MapSequence.fromMap(myMethodsByName).get(name)).addElement(currMethod);
          MapSequence.fromMap(myOverriddenMethods).put(currMethod, new ArrayList<SNode>());
        }
      }
      this.myDependsOnNodes = SetSequence.fromSet(new HashSet<SNode>());
      for (SNode classifier : classifiers) {
        SetSequence.fromSet(this.myDependsOnNodes).addElement(classifier);
      }
      for (SNode method : allMethods) {
        SetSequence.fromSet(this.myDependsOnNodes).addElement(method);
        for (SNode parm : SLinkOperations.getTargets(method, "parameter", true)) {
          SNode type = SLinkOperations.getTarget(parm, "type", true);
          if (type == null) {
            continue;
          }
          SetSequence.fromSet(myDependsOnNodes).addElement(type);
          SetSequence.fromSet(myDependsOnNodes).addSequence(ListSequence.fromList(type.getDescendants()));
        }
      }
    }

    private String createMethodParameterTypesString(SNode method, Map<SNode, SNode> typeByTypeVar) {
      StringBuilder result = new StringBuilder();
      for (SNode parm : SLinkOperations.getTargets(method, "parameter", true)) {
        SNode type = SLinkOperations.getTarget(parm, "type", true);
        type = GenericTypesUtil.getTypeWithResolvedTypeVars(type, typeByTypeVar);
        if (result.length() > 0) {
          result.append(',');
        }
        if (type != null) {
          result.append(Type_Behavior.call_getErasureSignature_1213877337313(type));
        } else {
          result.append("");
        }
      }
      return result.toString();
    }

    public void childAdded(SModelChildEvent event) {
      if (event.getParent().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.Classifier")) {
        if (!(event.getChild().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"))) {
          return;
        }
      }
      if (event.getParent().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) {
        String role = event.getChildRole();
        if (!(BaseMethodDeclaration.PARAMETER.equals(role))) {
          return;
        }
      }
      super.childAdded(event);
    }

    public void childRemoved(SModelChildEvent event) {
      if (event.getParent().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.Classifier")) {
        if (!(event.getChild().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"))) {
          return;
        }
      }
      if (event.getParent().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) {
        String role = event.getChildRole();
        if (!(BaseMethodDeclaration.PARAMETER.equals(role))) {
          return;
        }
      }
      super.childRemoved(event);
    }

    public void propertyChanged(SModelPropertyEvent event) {
      if (BaseMethodDeclaration.NAME.equals(event.getPropertyName()) && event.getNode().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) {
        super.propertyChanged(event);
      }
    }
  }

  private static class FieldsDataSet extends DataSet {
    public static final String ID = "FIELDS_DATASET";

    private Map<String, FieldDeclaration> myFieldsByName;
    private Map<String, StaticFieldDeclaration> myStaticFieldsByName;
    private Set<SNode> myDependsOnNodes;

    public FieldsDataSet(AbstractCache ownerCache) {
      super(ID, ownerCache, DataSet.DefaultNodeChangedProcessing.DROP_DATA_SET);
    }

    public List<VariableDeclaration> getFields() {
      ArrayList<VariableDeclaration> result = new ArrayList<VariableDeclaration>(this.myFieldsByName.values());
      result.addAll(this.myStaticFieldsByName.values());
      return result;
    }

    public FieldDeclaration getFieldByName(String name) {
      if (name == null) {
        return this.myFieldsByName.get("");
      }
      return this.myFieldsByName.get(name);
    }

    public StaticFieldDeclaration getStaticFieldByName(String name) {
      if (name == null) {
        return this.myStaticFieldsByName.get("");
      }
      return this.myStaticFieldsByName.get(name);
    }

    public Set<SNode> getDependsOnNodes() {
      return this.myDependsOnNodes;
    }

    protected void init() {
      this.myFieldsByName = new HashMap<String, FieldDeclaration>();
      this.myStaticFieldsByName = new HashMap<String, StaticFieldDeclaration>();
      List<VariableDeclaration> allFields = new ArrayList<VariableDeclaration>();
      List<Classifier> classifiers = ((ClassifierAndSuperClassifiersCache) this.getOwnerCache()).getClassifiers();
      for (Classifier classifier : classifiers) {
        List<StaticFieldDeclaration> staticFields = classifier.getStaticFields();
        allFields.addAll(staticFields);
        for (StaticFieldDeclaration staticField : staticFields) {
          String name = staticField.getName();
          if (name == null) {
            name = "";
          }
          if (!(this.myStaticFieldsByName.containsKey(name))) {
            this.myStaticFieldsByName.put(name, staticField);
          }
        }
        if (classifier instanceof ClassConcept) {
          List<FieldDeclaration> fields = ((ClassConcept) classifier).getFields();
          allFields.addAll(fields);
          for (FieldDeclaration field : fields) {
            String name = field.getName();
            if (name == null) {
              name = "";
            }
            if (!(this.myFieldsByName.containsKey(name))) {
              this.myFieldsByName.put(name, field);
            }
          }
        }
      }
      this.myDependsOnNodes = new HashSet<SNode>();
      for (Classifier classifier : classifiers) {
        this.myDependsOnNodes.add(classifier.getNode());
      }
      for (VariableDeclaration field : allFields) {
        this.myDependsOnNodes.add(field.getNode());
      }
    }

    public void childAdded(SModelChildEvent event) {
      if (event.getParent().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.Classifier")) {
        SNode child = event.getChild();
        if (!((SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.FieldDeclaration") || SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")))) {
          return;
        }
      }
      if (event.getParent().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.VariableDeclaration")) {
        return;
      }
      super.childAdded(event);
    }

    public void childRemoved(SModelChildEvent event) {
      if (event.getParent().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.Classifier")) {
        SNode child = event.getChild();
        if (!((SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.FieldDeclaration") || SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")))) {
          return;
        }
      }
      if (event.getParent().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.VariableDeclaration")) {
        return;
      }
      super.childRemoved(event);
    }

    public void propertyChanged(SModelPropertyEvent event) {
      SNode node = event.getNode();
      if (BaseVariableDeclaration.NAME.equals(event.getPropertyName()) && (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.FieldDeclaration") || SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration"))) {
        super.propertyChanged(event);
      }
    }
  }
}
