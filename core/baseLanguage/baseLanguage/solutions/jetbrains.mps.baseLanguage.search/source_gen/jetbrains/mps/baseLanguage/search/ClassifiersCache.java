package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import jetbrains.mps.cache.AbstractCache;
import jetbrains.mps.cache.KeyProducer;
import java.util.Map;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.HashMap;
import jetbrains.mps.smodel.SModelDescriptor;
import java.util.Set;
import java.util.Collections;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.structure.Classifier;
import java.util.ArrayList;
import jetbrains.mps.smodel.INodeAdapter;
import jetbrains.mps.smodel.BaseAdapter;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.cache.CachesManager;

/*package*/ class ClassifiersCache extends AbstractCache {
  private static final KeyProducer keyProducer = new KeyProducer();

  private Map<String, List<SNode>> myClassifiersByName = new HashMap<String, List<SNode>>();
  private Map<SNode, String> myNameByClassifier = new HashMap<SNode, String>();

  protected ClassifiersCache(Object key, SModelDescriptor model) {
    super(key);
    for (SNode node : model.getSModel().roots()) {
      this.processNode(node, true);
    }
  }

  @Override
  public Set<SModelDescriptor> getDependsOnModels(Object element) {
    return Collections.singleton((SModelDescriptor) element);
  }

  private void processNode(SNode adapter, boolean put) {
    if (SNodeOperations.isInstanceOf(adapter, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      Classifier classifier = ((Classifier) SNodeOperations.getAdapter(SNodeOperations.cast(adapter, "jetbrains.mps.baseLanguage.structure.Classifier")));
      if (put) {
        this.putClassifier(classifier);
      } else {
        this.removeClassifier(classifier);
      }
    } else {
      for (SNode child : SNodeOperations.getChildren(adapter)) {
        this.processNode(child, put);
      }
    }
  }

  private void putClassifier(Classifier classifier) {
    String name = this.getRefName(classifier);
    if (!(this.myClassifiersByName.containsKey(name))) {
      this.myClassifiersByName.put(name, new ArrayList<SNode>(1));
    }
    this.myClassifiersByName.get(name).add(classifier.getNode());
    this.myNameByClassifier.put(classifier.getNode(), name);
    List<Classifier> list = classifier.getStaticInnerClassifierses();
    for (Classifier innerClassifier : list) {
      this.putClassifier(innerClassifier);
    }
  }

  private void removeClassifier(Classifier classifier) {
    String name = this.getRefName(classifier);
    if (this.myClassifiersByName.containsKey(name)) {
      List<SNode> nodes = this.myClassifiersByName.get(name);
      nodes.remove(classifier.getNode());
      if (nodes.isEmpty()) {
        this.myClassifiersByName.remove(name);
      }
    }
    this.myNameByClassifier.remove(classifier.getNode());
    List<Classifier> list = classifier.getStaticInnerClassifierses();
    for (Classifier innerClassifier : list) {
      this.removeClassifier(innerClassifier);
    }
  }

  private String getRefName(Classifier classifier) {
    String name = classifier.getName();
    if (name == null) {
      name = "";
    }
    INodeAdapter parent = classifier.getParent();
    if (parent instanceof Classifier) {
      return this.getRefName(((Classifier) parent)) + "." + name;
    }
    return name;
  }

  public List<Classifier> getClassifiers() {
    List<SNode> result = new ArrayList<SNode>(this.myNameByClassifier.keySet());
    return BaseAdapter.toAdapters(result);
  }

  public List<Classifier> getClassifiersByRefName(String refName) {
    List<SNode> result = this.myClassifiersByName.get(refName);
    if (result != null) {
      return BaseAdapter.toAdapters(result);
    }
    return new ArrayList<Classifier>();
  }

  public void rootAdded(SModelRootEvent event) {
    this.processNode(event.getRoot(), true);
  }

  public void rootRemoved(SModelRootEvent event) {
    this.processNode(event.getRoot(), false);
  }

  public void childAdded(SModelChildEvent event) {
    SNode node = event.getChild();
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
      if (SNodeOperations.getAncestor(node, "jetbrains.mps.baseLanguage.structure.Classifier", false, false) != null) {
        return;
      }
    }
    this.processNode(node, true);
  }

  public void beforeChildRemoved(SModelChildEvent event) {
    SNode node = event.getChild();
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
      if (SNodeOperations.getAncestor(node, "jetbrains.mps.baseLanguage.structure.Classifier", false, false) != null) {
        return;
      }
    }
    this.processNode(node, true);
  }

  public void propertyChanged(SModelPropertyEvent event) {
    BaseAdapter adapter = event.getNode().getAdapter();
    if (adapter instanceof Classifier && Classifier.NAME.equals(event.getPropertyName())) {
      List<Classifier> classifiersToUpdate = new ArrayList<Classifier>();
      classifiersToUpdate.add(((Classifier) adapter));
      this.collectInnerClasses((Classifier) adapter, classifiersToUpdate);
      for (Classifier classifier : classifiersToUpdate) {
        String oldRefName = this.myNameByClassifier.get(classifier.getNode());
        List<SNode> nodes = this.myClassifiersByName.get(oldRefName);
        if (nodes != null) {
          nodes.remove(classifier.getNode());
        }
        if (nodes == null || nodes.isEmpty()) {
          this.myClassifiersByName.remove(oldRefName);
        }
        this.myNameByClassifier.remove(classifier.getNode());
      }
      this.putClassifier(((Classifier) adapter));
    }
  }

  private void collectInnerClasses(Classifier classConcept, List<Classifier> list) {
    List<Classifier> inners = classConcept.getStaticInnerClassifierses();
    list.addAll(inners);
    for (Classifier inner : inners) {
      this.collectInnerClasses(inner, list);
    }
  }

  public static ClassifiersCache getInstance(SModelDescriptor model) {
    String uid = model.getSModelReference().toString();
    Object key = keyProducer.createKey(uid);
    return (ClassifiersCache) CachesManager.getInstance().getCache(key, model, new CachesManager.CacheCreator<SModelDescriptor>() {
      public AbstractCache create(Object key, SModelDescriptor element) {
        return new ClassifiersCache(key, element);
      }
    });
  }
}
