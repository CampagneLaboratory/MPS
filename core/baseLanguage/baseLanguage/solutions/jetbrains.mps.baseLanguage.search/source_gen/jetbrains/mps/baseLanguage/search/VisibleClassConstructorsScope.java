package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.IScope;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import jetbrains.mps.baseLanguage.structure.Classifier;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.structure.Interface;
import jetbrains.mps.baseLanguage.structure.ClassConcept;
import jetbrains.mps.smodel.search.IReferenceInfoResolver;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.baseLanguage.structure.ConstructorDeclaration;
import jetbrains.mps.baseLanguage.structure.ClassCreator;
import jetbrains.mps.baseLanguage.structure.Expression;
import jetbrains.mps.baseLanguage.structure.Type;
import jetbrains.mps.smodel.SModelReference;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration;
import java.util.Map;
import java.util.HashMap;

public class VisibleClassConstructorsScope extends VisibleClassifiersScope {
  @Deprecated
  public VisibleClassConstructorsScope(SModel model, IScope scope) {
    super(model, IClassifiersSearchScope.CONSTRUCTOR, scope);
  }

  public VisibleClassConstructorsScope(@NotNull SNode contextNode, IScope scope) {
    super(contextNode, IClassifiersSearchScope.CONSTRUCTOR, scope);
  }

  @NotNull
  public List<Classifier> getClassifiers() {
    List<Classifier> list = super.getClassifiers();
    List<Classifier> result = new ArrayList<Classifier>(list.size());
    for (Classifier classifier : list) {
      if (classifier instanceof Interface) {
        continue;
      }
      if (classifier instanceof ClassConcept && ((ClassConcept) classifier).getAbstractClass()) {
        continue;
      }
      result.add(classifier);
    }
    return result;
  }

  public IReferenceInfoResolver getReferenceInfoResolver(SNode referenceNode, SNode targetConcept) {
    if (SModelUtil.isAssignableConcept(NameUtil.nodeFQName(targetConcept), ConstructorDeclaration.concept)) {
      if (referenceNode.getAdapter() instanceof ClassCreator) {
        ClassCreator classCreator = (ClassCreator) referenceNode.getAdapter();
        return new VisibleClassConstructorsScope.ConstructorDeclarationReferenceInfoResolver(classCreator.getActualArguments(), classCreator.getTypeParameters(), getModel(), getScope());
      }
    }
    return super.getReferenceInfoResolver(referenceNode, targetConcept);
  }

  private static class ConstructorDeclarationReferenceInfoResolver extends ReachableClassifiersScope.ClassifierReferenceInfoResolver {
    private List<Expression> myActualArgs;
    private List<Type> myTypeParms;

    /*package*/ ConstructorDeclarationReferenceInfoResolver(List<Expression> actualArgs, List<Type> typeParms, SModel model, IScope scope) {
      super(model, scope);
      myActualArgs = actualArgs;
      myTypeParms = typeParms;
    }

    public SNode resolve(String referenceInfo, SModelReference targetModelReference) {
      SNode classifier_ = super.resolve(referenceInfo, targetModelReference);
      if (classifier_ == null) {
        return null;
      }
      Classifier classifier = (Classifier) classifier_.getAdapter();
      if (classifier instanceof ClassConcept) {
        List<ConstructorDeclaration> constructors = ((ClassConcept) classifier).getConstructors();
        if (constructors.size() == 1) {
          return constructors.get(0).getNode();
        } else
        if (constructors.size() > 1) {
          constructors = (List<ConstructorDeclaration>) MethodResolveUtil.selectByParmCount(constructors, myActualArgs);
          if (constructors.size() == 1) {
            return constructors.get(0).getNode();
          } else {
            Iterator<Type> typeParms = myTypeParms.iterator();
            Iterator<TypeVariableDeclaration> typeVars = classifier.getTypeVariableDeclarations().iterator();
            Map<TypeVariableDeclaration, Type> typeByTypeVar = new HashMap<TypeVariableDeclaration, Type>();
            while (typeParms.hasNext() && typeVars.hasNext()) {
              typeByTypeVar.put(typeVars.next(), typeParms.next());
            }
            return MethodResolveUtil.chooseByParameterType(constructors, myActualArgs, typeByTypeVar).getNode();
          }
        }
      }
      return null;
    }
  }
}
