package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import jetbrains.mps.smodel.IScope;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.search.ModelAndImportedModelsScope;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.search.IReferenceInfoResolver;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.SModelReference;
import java.util.Collection;
import jetbrains.mps.project.IModule;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class ReachableClassifiersScope extends AbstractClassifiersScope {
  protected static Log log = LogFactory.getLog(ReachableClassifiersScope.class);

  private IScope myScope;
  private SModel myModel;

  public ReachableClassifiersScope(SModel model, int constraint, IScope scope) {
    super(constraint);
    this.myModel = model;
    this.myScope = scope;
  }

  public SModel getModel() {
    return this.myModel;
  }

  public IScope getScope() {
    return this.myScope;
  }

  @NotNull
  public List<SNode> getClassifiers() {
    List<SModelDescriptor> models = new ModelAndImportedModelsScope(this.myModel, false, this.myScope).getModels();
    List<SNode> result = new ArrayList<SNode>();
    for (SModelDescriptor model : models) {
      List<SNode> classifiers = ClassifiersCache.getInstance(model).getClassifiers();
      ListSequence.fromList(result).addSequence(ListSequence.fromList(classifiers));
    }
    return result;
  }

  @Override
  public IReferenceInfoResolver getReferenceInfoResolver(SNode referenceNode, SNode targetConcept) {
    if (SModelUtil.isAssignableConcept(targetConcept, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.Classifier"))) {
      return new ReachableClassifiersScope.ClassifierReferenceInfoResolver(this.myModel, this.myScope);
    }
    return super.getReferenceInfoResolver(referenceNode, targetConcept);
  }

  protected static class ClassifierReferenceInfoResolver implements IReferenceInfoResolver {
    private SModel myModel;
    private IScope myScope;

    public ClassifierReferenceInfoResolver(SModel model, IScope scope) {
      this.myModel = model;
      this.myScope = scope;
    }

    public SNode resolve(String referenceInfo, SModelReference targetModelReference) {
      if (targetModelReference.getSModelId() != null) {
        SModelDescriptor targetModel = this.myScope.getModelDescriptor(targetModelReference);
        if (targetModel == null) {
          return null;
        }
        return ListSequence.fromList(ClassifiersCache.getInstance(targetModel).getClassifiersByRefName(referenceInfo)).first();
      }

      Collection<IModule> visibleModules = IterableUtil.asCollection(myScope.getVisibleModules());

      List<SNode> classifiers = new ArrayList<SNode>();
      for (SModelDescriptor model : ListSequence.fromList(SModelRepository.getInstance().getModelDescriptors())) {
        if (!(visibleModules.contains(model.getModule()))) {
          continue;
        }
        if (!(model.getSModelReference().getSModelFqName().equals(targetModelReference.getSModelFqName()))) {
          continue;
        }

        ListSequence.fromList(classifiers).addSequence(ListSequence.fromList(ClassifiersCache.getInstance(model).getClassifiersByRefName(referenceInfo)));
      }

      if (ListSequence.fromList(classifiers).isEmpty()) {
        return null;
      }
      if (ListSequence.fromList(classifiers).count() > 1) {
        for (SNode cls : ListSequence.fromList(classifiers)) {
          if (SNodeOperations.getModel(cls) == myModel) {
            return cls;
          }
          if (check_x9ho2v_a0b0a0i0a0_0(check_x9ho2v_a0a1a0a8a0a_0(myModel)) == check_x9ho2v_a0b0a0i0a0(check_x9ho2v_a0a1a0a8a0a(SNodeOperations.getModel(cls)))) {
            return cls;
          }
        }

        final StringBuilder warn = new StringBuilder();
        warn.append("reference can't be resolved: ");
        warn.append(referenceInfo);
        warn.append(" in ");
        warn.append(myModel.getLongName());
        warn.append(" can reference nodes from models: ");
        ListSequence.fromList(classifiers).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            warn.append(SNodeOperations.getModel(it).getSModelReference()).append("; ");
          }
        });

        if (log.isWarnEnabled()) {
          log.warn(warn);
        }
        return null;
      }
      return ListSequence.fromList(classifiers).getElement(0);
    }

    private static IModule check_x9ho2v_a0b0a0i0a0(SModelDescriptor checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getModule();
      }
      return null;
    }

    private static SModelDescriptor check_x9ho2v_a0a1a0a8a0a(SModel checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getModelDescriptor();
      }
      return null;
    }

    private static IModule check_x9ho2v_a0b0a0i0a0_0(SModelDescriptor checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getModule();
      }
      return null;
    }

    private static SModelDescriptor check_x9ho2v_a0a1a0a8a0a_0(SModel checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getModelDescriptor();
      }
      return null;
    }
  }
}
