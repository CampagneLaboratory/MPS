package jetbrains.mps.baseLanguage.overloadedOperators.generator.template.util;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.util.NameUtil;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class BinaryOperationUtil {
  public BinaryOperationUtil() {
  }

  public static boolean isOverloading(SNode node, SNode leftType, SNode rightType, SNode operator) {
    if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(leftType, SLinkOperations.getTarget(operator, "leftType", true)) && TypeChecker.getInstance().getSubtypingManager().isSubtype(rightType, SLinkOperations.getTarget(operator, "rightType", true)))) {
      return false;
    }
    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(operator, "operator", true), "jetbrains.mps.baseLanguage.overloadedOperators.structure.BinaryOperationReference")) {
      if (SNodeOperations.isInstanceOf(node, NameUtil.nodeFQName(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(operator, "operator", true), "jetbrains.mps.baseLanguage.overloadedOperators.structure.BinaryOperationReference"), "binaryOperation", false)))) {
        return true;
      }
    } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(operator, "operator", true), "jetbrains.mps.baseLanguage.overloadedOperators.structure.CustomOperator") && SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.overloadedOperators.structure.CustomOperatorUsage")) {
      if (SLinkOperations.getTarget(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.overloadedOperators.structure.CustomOperatorUsage"), "operator", false) == SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(operator, "operator", true), "jetbrains.mps.baseLanguage.overloadedOperators.structure.CustomOperator"), "declaration", false)) {
        return true;
      }
    }
    return false;
  }

  public static List<SNode> getOverloadedOperators(SNode node, SNode leftType, SNode rightType, List<SNode> operators) {
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return null;
    }
    List<SNode> result = new ArrayList<SNode>();
    for (SNode operator : operators) {
      if (isOverloading(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), leftType, rightType, operator)) {
        ListSequence.fromList(result).addElement(operator);
      }
    }
    return result;
  }

  public static boolean hasOverloadedOperators(SNode node, SNode leftType, SNode rightType, List<SNode> operators) {
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return false;
    }
    for (SNode operator : operators) {
      if (isOverloading(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), leftType, rightType, operator)) {
        return true;
      }
    }
    return false;
  }

  public static boolean isSubTypeOperator(SNode subOperator, SNode superOperator) {
    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(SLinkOperations.getTarget(superOperator, "leftType", true), SLinkOperations.getTarget(subOperator, "leftType", true), false)) {
      return false;
    }
    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(SLinkOperations.getTarget(subOperator, "leftType", true), SLinkOperations.getTarget(superOperator, "leftType", true), false)) {
      return true;
    }
    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(SLinkOperations.getTarget(superOperator, "rightType", true), SLinkOperations.getTarget(subOperator, "rightType", true), false)) {
      return false;
    }
    return true;
  }

  public static SNode getNearestOverloaded(SNode node, SNode leftType, SNode rightType, List<SNode> operators) {
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return null;
    }
    operators = getOverloadedOperators(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), leftType, rightType, operators);
    if (ListSequence.fromList(operators).count() == 0) {
      return null;
    }
    SNode result = ListSequence.fromList(operators).first();
    for (SNode operator : operators) {
      if (isSubTypeOperator(operator, result)) {
        result = operator;
      }
    }
    return result;
  }
}
