package jetbrains.mps.baseLanguage.unitTest.plugin;

/*Generated by MPS */

import javax.swing.table.TableModel;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import javax.swing.event.TableModelListener;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.baseLanguage.unitTest.runtime.TestEvent;
import org.jetbrains.annotations.Nullable;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import javax.swing.event.TableModelEvent;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class StatisticsTableModel implements TableModel {
  private static List<String> testColumns = ListSequence.fromListAndArray(new ArrayList<String>(), "Test", "Time elapsed", "Usage Delta", "Usage Before", "Usage After", "Results");

  private List<TableModelListener> listeners = ListSequence.fromList(new ArrayList<TableModelListener>());
  private List<TestStatisticsRow> rows;
  private List<TestStatisticsRow> filteredRows = ListSequence.fromList(new ArrayList<TestStatisticsRow>());
  protected String filterTestCase = null;
  protected String filterTestMethod = null;
  private TestNameMap<TestCaseRow, TestMethodRow> map = new TestNameMap<TestCaseRow, TestMethodRow>();
  private TestRunState myState;

  public StatisticsTableModel(final TestRunState state) {
    this.myState = state;
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        StatisticsTableModel.this.setTests(state.getTestsMap());
      }
    });
    this.myState.addListener(new TestStateListener() {
      public void onTestStart(TestEvent event) {
        TestMethodRow row = this.findRowForEvent(event);
        if (row != null) {
          row.setStartTime(event.getTime());
          row.setUsageBefore(event.getMemoryUsage());
        }
      }

      @Nullable
      private TestMethodRow findRowForEvent(TestEvent event) {
        return StatisticsTableModel.this.getRow(event.getTestCaseName(), event.getTestMethodName());
      }

      public void onTestEnd(TestEvent event) {
        TestMethodRow row = this.findRowForEvent(event);
        if (row != null) {
          row.setFinishTime(event.getTime());
          row.setUsageAfter(event.getMemoryUsage());
        }
      }

      public void onTestError(TestEvent event) {
        TestMethodRow row = this.findRowForEvent(event);
        if (row != null) {
          row.getErrored();
        }
      }

      public void onTestFailure(TestEvent event) {
        TestMethodRow row = this.findRowForEvent(event);
        if (row != null) {
          row.getFailed();
        }
      }

      public void onLooseTest(String className, String methodName) {
        TestMethodRow row = StatisticsTableModel.this.getRow(className, methodName);
        if (row != null) {
          row.getErrored();
        }
      }
    });
  }

  private void setTests(Map<SNode, List<SNode>> tests) {
    this.rows = ListSequence.fromList(new ArrayList<TestStatisticsRow>());
    TotalRow totalRow = new TotalRow();
    ListSequence.fromList(this.rows).addElement(totalRow);
    this.map.clear();
    for (SNode testCase : SetSequence.fromSet(MapSequence.fromMap(tests).keySet())) {
      TestCaseRow testCaseRow = new TestCaseRow(testCase);
      totalRow.addRow(testCaseRow);
      ListSequence.fromList(this.rows).addElement(testCaseRow);
      this.map.put(testCase, testCaseRow);
      for (SNode testMethod : ListSequence.fromList(MapSequence.fromMap(tests).get(testCase))) {
        TestMethodRow testMethodRow = new TestMethodRow(testMethod);
        testCaseRow.addRow(testMethodRow);
        ListSequence.fromList(this.rows).addElement(testMethodRow);
        this.map.put(testCase, testMethod, testMethodRow);
      }
    }
    this.filter();
  }

  public TestMethodRow getRow(String testCase, String testMethod) {
    return this.map.get(testCase, testMethod);
  }

  public void updateRow(TestMethodRow row) {
    int index = ListSequence.fromList(this.filteredRows).indexOf(row);
    if (index >= 0) {
      for (TableModelListener listener : ListSequence.fromList(this.listeners)) {
        listener.tableChanged(new TableModelEvent(this));
      }
    }
  }

  public int getRowCount() {
    return ListSequence.fromList(this.filteredRows).count();
  }

  public Object getValueAt(int rowIndex, int columnIndex) {
    return ListSequence.fromList(this.filteredRows).getElement(rowIndex);
  }

  public void setFilter(String testCase, String testMethod) {
    this.filterTestCase = testCase;
    this.filterTestMethod = testMethod;
    this.filter();
  }

  private void filter() {
    this.filteredRows = ListSequence.fromList(this.rows).where(new IWhereFilter<TestStatisticsRow>() {
      public boolean accept(TestStatisticsRow it) {
        return it.matches(StatisticsTableModel.this.filterTestCase, StatisticsTableModel.this.filterTestMethod);
      }
    }).toListSequence();
    for (TableModelListener listener : ListSequence.fromList(this.listeners)) {
      listener.tableChanged(new TableModelEvent(this));
    }
  }

  public int getColumnCount() {
    return ListSequence.fromList(testColumns).count();
  }

  public String getColumnName(int columnIndex) {
    return ListSequence.fromList(testColumns).getElement(columnIndex);
  }

  public Class<?> getColumnClass(int columnIndex) {
    return TestStatisticsRow.class;
  }

  public boolean isCellEditable(int rowIndex, int columnIndex) {
    return false;
  }

  public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
  }

  public void addTableModelListener(TableModelListener listener) {
    ListSequence.fromList(this.listeners).addElement(listener);
  }

  public void removeTableModelListener(TableModelListener listener) {
    ListSequence.fromList(this.listeners).removeElement(listener);
  }
}
