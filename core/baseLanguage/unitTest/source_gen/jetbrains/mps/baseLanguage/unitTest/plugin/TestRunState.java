package jetbrains.mps.baseLanguage.unitTest.plugin;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.util.Key;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestCase_Behavior;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestMethod_Behavior;
import jetbrains.mps.baseLanguage.unitTest.runtime.TestEvent;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class TestRunState {
  private static final Object lock = new Object();

  private List<String> testMethods = ListSequence.fromList(new ArrayList<String>());
  private Map<SNode, List<SNode>> map = MapSequence.fromMap(new LinkedHashMap<SNode, List<SNode>>(16, (float) 0.75, false));
  private String curClass;
  private String curMethod;
  private String curToken;
  private String loseTest;
  private String loseMethod;
  private int totalTests = 0;
  private int completedTests = 0;
  private int defectTests = 0;
  private Set<TestView> viewList = SetSequence.fromSet(new HashSet<TestView>());
  private boolean isTerminated;
  private String availableText = null;
  private Key key = null;
  private final List<TestStateListener> listeners = ListSequence.fromList(new ArrayList<TestStateListener>());

  public TestRunState(List<SNode> testCases, List<SNode> testMethods, StatisticsTableModel statisticsModel) {
    this.initTestState(testCases, testMethods);
  }

  public TestRunState(List<SNode> tests) {
    this.initTestState(ListSequence.fromList(tests).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.unitTest.structure.ITestCase");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.unitTest.structure.ITestCase");
      }
    }).toListSequence(), ListSequence.fromList(tests).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.unitTest.structure.ITestMethod");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.unitTest.structure.ITestMethod");
      }
    }).toListSequence());
  }

  private void initTestState(final List<SNode> testCases, final List<SNode> testMethods) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        TestRunState.this.addTestCases(testCases);
        TestRunState.this.addTestMethods(testMethods);
        for (SNode testCase : MapSequence.fromMap(TestRunState.this.map).keySet()) {
          for (SNode testMethod : MapSequence.fromMap(TestRunState.this.map).get(testCase)) {
            ListSequence.fromList(TestRunState.this.testMethods).addElement(ITestCase_Behavior.call_getClassName_1216136193905(testCase) + '.' + ITestMethod_Behavior.call_getTestName_1216136419751(testMethod));
          }
        }
      }
    });
    this.totalTests = ListSequence.fromList(this.testMethods).count();

    this.initView();
  }

  private void addTestCases(List<SNode> testCases) {
    for (SNode testCase : ListSequence.fromList(testCases)) {
      List<SNode> testMethods = new ArrayList<SNode>();
      MapSequence.fromMap(this.map).put(testCase, testMethods);
      ListSequence.fromList(testMethods).addSequence(ListSequence.fromList(ITestCase_Behavior.call_getTestSet_1216130724401(testCase)));
    }
  }

  private void addTestMethods(List<SNode> testMethods) {
    for (SNode testMethod : ListSequence.fromList(testMethods)) {
      SNode testCase = ITestMethod_Behavior.call_getTestCase_1216134500045(testMethod);
      List<SNode> curTestMethods = MapSequence.fromMap(this.map).get(testCase);
      if (curTestMethods == null) {
        curTestMethods = new ArrayList<SNode>();
        MapSequence.fromMap(this.map).put(testCase, curTestMethods);
      }
      if (!(ListSequence.fromList(curTestMethods).contains(testMethod))) {
        ListSequence.fromList(curTestMethods).addElement(testMethod);
      }
    }
  }

  private void updateView() {
    for (TestView view : this.viewList) {
      view.update();
    }
  }

  private void initView() {
    for (TestView view : this.viewList) {
      view.init();
    }
  }

  public void addView(TestView testView) {
    SetSequence.fromSet(this.viewList).addElement(testView);
  }

  public void startTest(final TestEvent event) {
    ListSequence.fromList(this.listeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestStart(event);
      }
    });
    this.startTest(event.getTestCaseName(), event.getTestMethodName());
  }

  public void endTest(final TestEvent event) {
    ListSequence.fromList(this.listeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestEnd(event);
      }
    });
    this.endTest();
  }

  public void testError(final TestEvent event) {
    ListSequence.fromList(this.listeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestError(event);
      }
    });
    this.defectTest();
  }

  public void testFailure(final TestEvent event) {
    ListSequence.fromList(this.listeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestFailure(event);
      }
    });
    this.defectTest();
  }

  public void looseTest(final String className, final String testName) {
    ListSequence.fromList(this.listeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onLooseTest(className, testName);
      }
    });
    this.looseTestInternal(className, testName);
  }

  private void startTest(String className, String methodName) {
    if (className.equals(this.curClass) && methodName.equals(this.curMethod)) {
      return;
    }
    synchronized (lock) {
      this.curClass = className;
      this.curMethod = methodName;
      this.updateView();
    }
  }

  private void endTest() {
    synchronized (lock) {
      this.completedTests++;
      this.updateView();
      this.curClass = null;
      this.curMethod = null;
    }
  }

  private void defectTest() {
    synchronized (lock) {
      this.defectTests++;
      this.updateView();
    }
  }

  private void looseTestInternal(String test, String method) {
    synchronized (lock) {
      this.loseTest = test;
      this.loseMethod = method;
      this.defectTests++;
      this.completedTests++;
      this.updateView();
      this.loseTest = null;
      this.loseMethod = null;
    }
  }

  public void terminate() {
    synchronized (lock) {
      this.isTerminated = true;
      this.updateView();
    }
  }

  public void outputText(String text, Key key) {
    synchronized (lock) {
      this.availableText = text;
      this.key = key;
      this.updateView();
      this.availableText = null;
      this.key = null;
    }
  }

  public void completeTestEvent(TestEvent event) {
    String token = event.getToken();
    if (token.equals(TestEvent.END_TEST_PREFIX) || token.equals(TestEvent.ERROR_TEST_SUFFIX) || token.equals(TestEvent.FAILURE_TEST_SUFFIX)) {
      String testClassName = event.getTestCaseName();
      String testMethodName = event.getTestMethodName();
      String key = testClassName + '.' + testMethodName;
      synchronized (this.testMethods) {
        if (ListSequence.fromList(this.testMethods).contains(key)) {
          ListSequence.fromList(this.testMethods).removeElement(key);
        }
      }
    }
  }

  public List<String> getUnusedMethods() {
    return this.testMethods;
  }

  public int getTotalTests() {
    return this.totalTests;
  }

  public int getDefectTests() {
    return this.defectTests;
  }

  public int getCompletedTests() {
    return this.completedTests;
  }

  public String getCurrentClass() {
    return this.curClass;
  }

  public String getCurrentMethod() {
    return this.curMethod;
  }

  public void setToken(String token) {
    this.curToken = token;
  }

  public String getToken() {
    return this.curToken;
  }

  public String getLoseMethod() {
    return this.loseMethod;
  }

  public String getLoseClass() {
    return this.loseTest;
  }

  public boolean isTerminated() {
    return this.isTerminated;
  }

  public String getAvailableText() {
    return this.availableText;
  }

  public Key getKey() {
    return this.key;
  }

  public void addListener(TestStateListener listener) {
    ListSequence.fromList(this.listeners).addElement(listener);
  }

  public void removeListener(TestStateListener listener) {
    ListSequence.fromList(this.listeners).removeElement(listener);
  }

  public Map<SNode, List<SNode>> getTestsMap() {
    return this.map;
  }
}
