package jetbrains.mps.baseLanguage.unitTest.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.ui.MPSTree;
import jetbrains.mps.smodel.IOperationContext;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.MPSProjectHolder;
import jetbrains.mps.baseLanguage.unitTest.runtime.TestEvent;
import javax.swing.SwingUtilities;
import jetbrains.mps.ide.ui.MPSTreeNode;
import jetbrains.mps.ide.ui.TextTreeNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestCase_Behavior;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestMethod_Behavior;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import java.util.ArrayList;
import jetbrains.mps.workbench.MPSDataKeys;
import com.intellij.ide.DataManager;

public class TestTree extends MPSTree implements TestView {
  private IOperationContext operationContext;
  private Map<SNode, List<SNode>> tests;
  private TestNameMap<TestCaseTreeNode, TestMethodTreeNode> map;
  private boolean isAllTree = true;
  private boolean isRebuilded = true;
  private TestRunState state;

  public TestTree(TestRunState state, MPSProject project) {
    this.state = state;
    this.tests = MapSequence.fromMap(new LinkedHashMap<SNode, List<SNode>>(16, (float)0.75, false));
    this.map = new TestNameMap<TestCaseTreeNode, TestMethodTreeNode>();
    this.isAllTree = !(project.getComponent(MPSProjectHolder.class).getMPSProject().getPluginManager().getPrefsComponent(JUnitTestActionOptions_PreferencesComponent.class).getStateObject().isHidePassed);
    this.rebuildLater();
  }

  public void update() {
    String loseTest = this.state.getLoseClass();
    String loseMethod = this.state.getLoseMethod();
    String test = this.state.getCurrentClass();
    String method = this.state.getCurrentMethod();
    if (loseTest != null && loseMethod != null) {
      TestMethodTreeNode node = this.get(loseTest, loseMethod);
      if (node != null) {
        node.setState(TestState.ERROR);
      }
    } else {
      TestMethodTreeNode node = this.get(test, method);
      if (node != null) {
        if (TestEvent.START_TEST_PREFIX.equals(this.state.getToken())) {
          node.setState(TestState.IN_PROGRESS);
          if (this.getPreferences().getStateObject().isTrackRunning) {
            this.setCurrentNode(node);
          }
        } else if (TestEvent.END_TEST_PREFIX.equals(this.state.getToken())) {
          TestState state = node.getState();
          if (state == TestState.IN_PROGRESS) {
            node.setState(TestState.PASSED);
            TestMethodRow row = this.state.getTestMethodRow(test, method);
            if (row != null) {
              row.setSucceed();
            }
          }
        } else if (TestEvent.FAILURE_TEST_PREFIX.equals(this.state.getToken())) {
          node.setState(TestState.FAILED);
        } else if (TestEvent.ERROR_TEST_PREFIX.equals(this.state.getToken())) {
          node.setState(TestState.ERROR);
        }
      }
      if (node != null && this.getPreferences().getStateObject().isSelectFirstFailed && node.getNextLeaf() == null) {
        SwingUtilities.invokeLater(new Runnable() {
          public void run() {
            TestTree.this.selectFirstDefectNode();
          }
        });
      }
    }
  }

  public MPSTreeNode rebuild() {
    MPSTreeNode root = new TextTreeNode("Tests");
    TestNameMap<TestCaseTreeNode, TestMethodTreeNode> temp = new TestNameMap<TestCaseTreeNode, TestMethodTreeNode>();
    for (SNode testCase : SetSequence.fromSet(MapSequence.fromMap(this.tests).keySet())) {
      if ((testCase == null)) {
        continue;
      }
      TestCaseTreeNode testCaseTreeNode = new TestCaseTreeNode(this.operationContext, testCase);
      boolean hasFailedTest = false;
      for (SNode method : ListSequence.fromList(MapSequence.fromMap(this.tests).get(testCase))) {
        TestMethodTreeNode oldMethodTreeNode = this.map.get(ITestCase_Behavior.call_getClassName_1216136193905(testCase), ITestMethod_Behavior.call_getTestName_1216136419751(method));
        TestMethodTreeNode newMethodTreeNode = new TestMethodTreeNode(this.operationContext, method);
        TestMethodTreeNode methodTreeNode = (this.isRebuilded ?
          newMethodTreeNode :
          oldMethodTreeNode
        );
        if (oldMethodTreeNode == null && !(this.isAllTree)) {
          continue;
        }
        boolean isFailedMethod = !(isPassed(oldMethodTreeNode));
        hasFailedTest = hasFailedTest || isFailedMethod;
        if (this.isAllTree || isFailedMethod) {
          if (methodTreeNode == null) {
            continue;
          }
          testCaseTreeNode.add(methodTreeNode);
          temp.put(testCase, method, methodTreeNode);
        } else if (!(this.isRebuilded)) {
          temp.put(testCase, method, oldMethodTreeNode);
        }
      }
      if (this.isAllTree || hasFailedTest) {
        root.add(testCaseTreeNode);
        temp.put(testCase, testCaseTreeNode);
      } else if (!(this.isRebuilded)) {
        temp.put(testCase, testCaseTreeNode);
      }
    }
    this.map = temp;
    this.isRebuilded = true;
    return root;
  }

  public boolean hasFailedTests() {
    for (final SNode testCase : SetSequence.fromSet(MapSequence.fromMap(this.tests).keySet())) {
      if ((testCase == null)) {
        continue;
      }
      for (final SNode method : ListSequence.fromList(MapSequence.fromMap(this.tests).get(testCase))) {
        final Wrappers._T<String> className = new Wrappers._T<String>();
        final Wrappers._T<String> methodName = new Wrappers._T<String>();
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            className.value = ITestCase_Behavior.call_getClassName_1216136193905(testCase);
            methodName.value = ITestMethod_Behavior.call_getTestName_1216136419751(method);
          }
        });
        TestMethodTreeNode treeNode = this.map.get(className.value, methodName.value);
        if ((method == null)) {
          continue;
        }
        if (!(isPassed(treeNode))) {
          return true;
        }
      }
    }
    return false;
  }

  public IOperationContext getContext() {
    return this.operationContext;
  }

  public void hidePassed(boolean hide) {
    this.isAllTree = !(hide);
    this.isRebuilded = false;
    this.rebuildNow();
    this.expandAll();
  }

  public void buildFailedTestTree() {
    this.isAllTree = false;
    this.isRebuilded = true;
    this.rebuildNow();
  }

  public void setTests(IOperationContext operationContext, Map<SNode, List<SNode>> tests) {
    this.operationContext = operationContext;
    this.tests = tests;
    this.isRebuilded = true;
    this.rebuildNow();
  }

  public List<String> getMethodName() {
    List<String> result = ListSequence.fromList(new ArrayList<String>());
    for (List<SNode> values : MapSequence.fromMap(this.tests).values()) {
      for (SNode value : values) {
        ListSequence.fromList(result).addElement(ITestMethod_Behavior.call_getTestName_1216136419751(value));
      }
    }
    return result;
  }

  public TestCaseTreeNode get(String className) {
    return this.map.get(className);
  }

  public TestMethodTreeNode get(String className, String methodName) {
    return this.map.get(className, methodName);
  }

  public void selectFirstDefectNode() {
    for (final SNode testCase : SetSequence.fromSet(MapSequence.fromMap(this.tests).keySet())) {
      for (final SNode method : ListSequence.fromList(MapSequence.fromMap(this.tests).get(testCase))) {
        final Wrappers._T<String> className = new Wrappers._T<String>();
        final Wrappers._T<String> methodName = new Wrappers._T<String>();
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            className.value = ITestCase_Behavior.call_getClassName_1216136193905(testCase);
            methodName.value = ITestMethod_Behavior.call_getTestName_1216136419751(method);
          }
        });
        TestMethodTreeNode testMethodTreeNode = this.map.get(className.value, methodName.value);
        if (isFailed(testMethodTreeNode)) {
          this.setCurrentNode(testMethodTreeNode);
          return;
        }
      }
    }
  }

  public JUnitTestActionOptions_PreferencesComponent getPreferences() {
    return MPSDataKeys.MPS_PROJECT.getData(DataManager.getInstance().getDataContext()).getComponent(MPSProjectHolder.class).getMPSProject().getPluginManager().getPrefsComponent(JUnitTestActionOptions_PreferencesComponent.class);
  }

  public static boolean isFailed(MPSTreeNode node) {
    if (!(node.isLeaf())) {
      return false;
    }
    TestMethodTreeNode leaf = (TestMethodTreeNode)node;
    TestState state = leaf.getState();
    return state.equals(TestState.ERROR) || state.equals(TestState.FAILED);
  }

  public static boolean isPassed(TestMethodTreeNode method) {
    if (method == null) {
      return false;
    }
    return method.getState() != null && method.getState().equals(TestState.PASSED);
  }
}
