package jetbrains.mps.closures.constraints;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.helgins.inference.TypeChecker;
import jetbrains.mps.bootstrap.helgins.runtime.HUtil;
import java.util.List;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;

public class ClassifierTypeUtil {

  public static SNode getTypeCoercedToClassifierType(SNode type) {
    SNode ct = TypeChecker.getInstance().getRuntimeSupport().coerce(type, HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.ClassifierType"), true);
    if((ct != null)) {
      List<SNode> params = SLinkOperations.getTargets(ct, "parameter", true);
      if(params != null && params.size() > 0) {
        SNode res = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierType", null);
        SLinkOperations.setTarget(res, "classifier", SLinkOperations.getTarget(ct, "classifier", false), false);
        for(SNode p : params) {
          SLinkOperations.addChild(res, "parameter", SNodeOperations.copyNode(ClassifierTypeUtil.getTypeCoercedToClassifierType(p)));
        }
        return res;
      }
      return ct;
    }
    return type;
  }

}
