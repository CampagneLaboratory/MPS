package jetbrains.mps.closures.test;

/*Generated by MPS */

import junit.framework.TestCase;
import jetbrains.mps.closures.runtime.FunctionTypes._R;
import jetbrains.mps.closures.runtime.FunctionTypes;
import jetbrains.mps.closures.runtime.FunctionTypes._R_from_T;
import jetbrains.mps.closures.runtime.FunctionTypes._R_from_S_and_T;
import junit.framework.Assert;

public class AdvancedFunctionTypes_Test extends TestCase {

  public void test_returnsFunction() throws Exception {
    _R<? extends _R<? extends Integer>> fun1 = new FunctionTypes._R <_R<? extends Integer>>() {

      public _R<? extends Integer> invoke() {
        return new FunctionTypes._R <Integer>() {

          public Integer invoke() {
            return 1;
          }

        };
      }

    };
    _R<? extends _R<? extends _R<? extends Integer>>> fun2 = new FunctionTypes._R <_R<? extends _R<? extends Integer>>>() {

      public _R<? extends _R<? extends Integer>> invoke() {
        return new FunctionTypes._R <_R<? extends Integer>>() {

          public _R<? extends Integer> invoke() {
            return new FunctionTypes._R <Integer>() {

              public Integer invoke() {
                return 1;
              }

            };
          }

        };
      }

    };
    _R<? extends _R<? extends Integer>> fun3;
    _R<? extends _R<? extends Number>> fun4;
    fun1 = fun2.invoke();
    fun3 = fun1;
    // TODO: support for adapters for function that accepts/returns function
    // fun4 = fun3
    // fun4 = fun2.invoke()
    fun4 = fun3;
    fun4 = fun2.invoke();
  }

  public void test_acceptsFunction() throws Exception {
    _R_from_T<? extends Integer, ? super _R<? extends Integer>> fun = new FunctionTypes._R_from_T <Integer, _R<? extends Integer>>() {

      public Integer invoke(_R<? extends Integer> f) {
        return f.invoke();
      }

    };
    _R_from_S_and_T<? extends Integer, ? super Integer, ? super Integer> add = new FunctionTypes._R_from_S_and_T <Integer, Integer, Integer>() {

      public Integer invoke(Integer x, Integer y) {
        return x + y;
      }

    };
    _R_from_T<? extends Integer, ? super Integer> plusThree = new FunctionTypes._R_from_T <Integer, Integer>() {

      public Integer invoke(Integer x) {
        return x + 3;
      }

    };
    _R_from_T<? extends Integer, ? super Integer> curriedPlusThree = this.curry(add, 3);
    Assert.assertEquals(plusThree.invoke(1), curriedPlusThree.invoke(1));
  }

  public _R_from_T<? extends Integer, ? super Integer> curry(final _R_from_S_and_T<? extends Integer, ? super Integer, ? super Integer> fun, final int y) {
    return new FunctionTypes._R_from_T <Integer, Integer>() {

      public Integer invoke(Integer x) {
        return fun.invoke(x, y);
      }

    };
  }

}
