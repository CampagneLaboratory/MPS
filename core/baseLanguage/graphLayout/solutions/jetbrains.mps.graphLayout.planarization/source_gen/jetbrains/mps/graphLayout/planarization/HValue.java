package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;

public class HValue {
  private PQNode myNode;
  private int myValue;
  private PQNode myHChild;
  private boolean myCanBeMade;

  public HValue(PQNode node) {
    myNode = node;
  }

  public void compute() {
    if (myNode.getState() == PQNode.State.FULL || myNode.getState() == PQNode.State.EMPTY) {
      myValue = 0;
      myHChild = null;
      myCanBeMade = true;
    } else {
      if (myNode instanceof PNode) {
        computeForPNode();
      }
      if (myNode instanceof QNode) {
        computeForQNode();
      }
    }
  }

  private void computeForPNode() {
    myHChild = null;
    myValue = 0;
    int numPartialFullLeaves = 0;
    for (PQNode child : ListSequence.fromList(myNode.getChildren())) {
      if (child.getState() == PQNode.State.PARTIAL) {
        numPartialFullLeaves += child.getNumFullLeaves();
        HValue childValue = new HValue(myNode);
        if (myValue < child.getNumFullLeaves() - childValue.getValue()) {
          myValue = child.getNumFullLeaves() - childValue.getValue();
          myHChild = child;
        }
      }
    }
    myValue = numPartialFullLeaves - myValue;
    myCanBeMade = true;
  }

  private void computeForQNode() {
    Iterator<PQNode> childItr = ListSequence.fromList(myNode.getChildren()).iterator();
    findHByIterator(childItr);
    int leftValue = myValue;
    PQNode leftHChild = myHChild;
    boolean leftCanBeMade = myCanBeMade;
    childItr = ListSequence.fromList(myNode.getChildren()).reversedList().iterator();
    findHByIterator(childItr);
    int rightValue = myValue;
    PQNode rightHChild = myHChild;
    boolean rightCanBeMade = myCanBeMade;
    if (!(leftCanBeMade || rightCanBeMade)) {
      myCanBeMade = false;
    } else {
      myCanBeMade = true;
      if (!(leftCanBeMade)) {
        myHChild = rightHChild;
        myValue = rightValue;
        return;
      }
      if (!(rightCanBeMade)) {
        myHChild = leftHChild;
        myValue = leftValue;
        return;
      }
      if (leftValue < rightValue) {
        myHChild = leftHChild;
        myValue = leftValue;
        return;
      } else {
        myHChild = rightHChild;
        myValue = rightValue;
        return;
      }
    }
  }

  private void findHByIterator(Iterator<PQNode> childItr) {
    PQNode firstPartial = null;
    boolean foundPartial = false;
    int w = 0;
    while (childItr.hasNext()) {
      PQNode cur = childItr.next();
      if (!(foundPartial)) {
        if (cur.getState() == PQNode.State.EMPTY) {
          foundPartial = true;
        }
        if (cur.getState() == PQNode.State.PARTIAL) {
          firstPartial = cur;
          foundPartial = true;
        }
      } else {
        w += cur.getNumFullLeaves();
      }
    }
    HValue hValue = new HValue(myNode);
    if (firstPartial == null || !(hValue.canBeMade())) {
      myCanBeMade = false;
    } else {
      myHChild = firstPartial;
      myValue = w + hValue.getValue();
    }
  }

  public int getValue() {
    return myValue;
  }

  public boolean canBeMade() {
    return myCanBeMade;
  }
}
