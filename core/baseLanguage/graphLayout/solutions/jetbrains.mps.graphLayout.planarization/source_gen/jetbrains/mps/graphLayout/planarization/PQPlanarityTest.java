package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import java.util.List;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.util.NodeMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.util.Arrays;
import jetbrains.mps.graphLayout.planarGraph.Face;
import java.util.Iterator;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class PQPlanarityTest {
  private static int SHOW_LOG = 0;

  private Map<Node, List<Edge>> myInEdgeOrder;

  public PQPlanarityTest() {
  }

  public EmbeddedGraph testPlanarity(Graph graph, Map<Node, Integer> stNumbering) {
    if (SHOW_LOG > 0) {
      System.out.println("GRAPH!!! " + graph);
      System.out.println(stNumbering);
    }
    myInEdgeOrder = new NodeMap<List<Edge>>(graph);
    Node[] nodeOrder = new Node[graph.getNumNodes()];
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      nodeOrder[MapSequence.fromMap(stNumbering).get(node)] = node;
    }
    PQTree graphTree = new PQTree();
    PQNode curPQNode = new PNode(nodeOrder[0], null);
    graphTree.setRoot(curPQNode);
    for (int i = 0; i < nodeOrder.length - 1; i++) {
      Node curGraphNode = nodeOrder[i];
      // add leaves for edges starting from current graph node 
      for (Edge edge : ListSequence.fromList(curGraphNode.getOutEdges())) {
        PNode node = new PNode(edge.getTarget(), edge);
        curPQNode.addLastChild(node);
      }
      Node nextGraphNode = nodeOrder[i + 1];
      if (SHOW_LOG > 0) {
        System.out.println(graphTree);
        System.out.println("next node is: " + nextGraphNode);
      }
      if (i < nodeOrder.length - 1) {
        curPQNode = graphTree.modifyTree(nextGraphNode);
      } else {
        MapSequence.fromMap(myInEdgeOrder).put(nextGraphNode, ListSequence.fromList(new LinkedList<Edge>()));
        getLastEdgeOrder(graphTree.getRoot(), MapSequence.fromMap(myInEdgeOrder).get(nextGraphNode));
      }
    }
    EdgesOrder order = ((QNode) ListSequence.fromList(graphTree.getRoot().getChildren()).first()).getEdgesOrder();
    if (PQPlanarityTest.SHOW_LOG > 0) {
      System.out.println(graphTree);
      for (int i = nodeOrder.length - 1; i >= 0; i--) {
        Node node = nodeOrder[i];
        System.out.print("node " + node + ":");
        System.out.print(" in edges: " + order.getInEdgesOrder(node));
        System.out.println(" out edges: " + order.getOutEdgesOrder(node));
      }
    }
    EmbeddedGraph embeddedGraph = createEmbeddedGraph(graph, order, Arrays.asList(nodeOrder));
    if (PQPlanarityTest.SHOW_LOG > 0) {
      System.out.println(embeddedGraph);
      System.out.println("bad edges:");
      for (Edge edge : ListSequence.fromList(graph.getEdges())) {
        if (!(MapSequence.fromMap(embeddedGraph.getAdjacentFacesMap()).containsKey(edge))) {
          System.out.println(edge);
        }
      }
    }
    return embeddedGraph;
  }

  public void getLastEdgeOrder(PQNode node, List<Edge> edgeList) {
    if (ListSequence.fromList(node.getChildren()).count() == 0) {
      ListSequence.fromList(edgeList).addElement(((PNode) node).getEdge());
    } else {
      for (PQNode child : ListSequence.fromList(node.getChildren())) {
        getLastEdgeOrder(child, edgeList);
      }
    }
  }

  public EmbeddedGraph createEmbeddedGraph(Graph graph, EdgesOrder order, List<Node> nodeOrder) {
    EmbeddedGraph embeddedGraph = new EmbeddedGraph(graph);
    Node last = ListSequence.fromList(nodeOrder).last();
    Face outerFace = order.findFace(graph, last, ListSequence.fromList(order.getInEdgesOrder(last)).first(), false);
    embeddedGraph.addFace(outerFace);
    embeddedGraph.setOuterFace(outerFace);
    for (Node node : ListSequence.fromList(nodeOrder).reversedList()) {
      Iterator<Edge> edgeItr = ListSequence.fromList(order.getInEdgesOrder(node)).iterator();
      // last edge should not be processed 
      while (edgeItr.hasNext()) {
        Edge edge = edgeItr.next();
        embeddedGraph.addFace(order.findFace(graph, node, edge, true));
      }
    }
    return embeddedGraph;
  }

  public void findAddedComponent(Node node, Set<Node> res, Set<Node> added, Map<Node, List<Edge>> edgeOrder) {
    if (SetSequence.fromSet(added).contains(node)) {
      SetSequence.fromSet(res).addElement(node);
    } else {
      for (Edge edge : ListSequence.fromList(MapSequence.fromMap(edgeOrder).get(node))) {
        findAddedComponent(edge.getSource(), res, added, edgeOrder);
      }
    }
  }
}
