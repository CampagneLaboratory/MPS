package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import java.util.List;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.ListIterator;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;

public class PQTree {
  private PQNode myRoot;
  private List<Leaf> myLeaves;
  private Map<PQNode, Integer> myNumFullLeaves;

  public PQTree() {
    myLeaves = ListSequence.fromList(new ArrayList<Leaf>());
    myRoot = null;
  }

  public PQNode getRoot() {
    return this.myRoot;
  }

  public void setRoot(PQNode root) {
    this.myRoot = root;
  }

  public void addLeaf(Leaf leaf) {
    ListSequence.fromList(myLeaves).addElement(leaf);
  }

  public PQNode modifyTree(Set<Leaf> successiveLeaves) {
    Node graphNode = SetSequence.fromSet(SetSequence.fromSet(successiveLeaves).first().getGraphNodes()).first().getNode();
    for (Leaf leaf : ListSequence.fromList(myLeaves)) {
      leaf.setState(PQNode.State.EMPTY);
    }
    for (Leaf leaf : SetSequence.fromSet(successiveLeaves)) {
      leaf.setState(PQNode.State.FULL);
    }
    String treeRepresentation = this.toString();
    int oldNum = SetSequence.fromSet(successiveLeaves).count();
    makeReducible();
    Iterator<Leaf> leavesItr = SetSequence.fromSet(successiveLeaves).iterator();
    while (leavesItr.hasNext()) {
      Leaf leaf = leavesItr.next();
      if (leaf.getState() == PQNode.State.EMPTY) {
        ListSequence.fromList(myLeaves).removeElement(leaf);
        PQNode cur = leaf;
        while (ListSequence.fromList(cur.getParent().getChildren()).count() == 1) {
          cur = cur.getParent();
        }
        ListSequence.fromList(cur.getParent().getChildren()).removeElement(cur);
        leavesItr.remove();
      }
    }
    if (oldNum > SetSequence.fromSet(successiveLeaves).count()) {
      System.out.println("Graph has been made reductible!");
      System.out.println("before:");
      System.out.println(treeRepresentation);
      System.out.println("after:");
      System.out.println(this);
    }
    myNumFullLeaves = MapSequence.fromMap(new HashMap<PQNode, Integer>());
    PQNode pertinentRoot = findPertinentRoot(myRoot, SetSequence.fromSet(successiveLeaves).count());
    if (SetSequence.fromSet(successiveLeaves).count() == 1) {
      pertinentRoot = pertinentRoot.getParent();
      List<PQNode> children = pertinentRoot.getChildren();
      ListIterator<PQNode> childItr = children.listIterator();
      PQNode newNode = new PNode();
      newNode.setParent(pertinentRoot);
      while (childItr.hasNext()) {
        PQNode child = childItr.next();
        if (child.getState() == PQNode.State.FULL) {
          childItr.set(newNode);
          Edge edge = ((Edge) ((Leaf) child).getData());
          NodeWithInEdgeOrder childGraphNode = child.getGraphNode();
          childGraphNode.setInEdgesOrder(ListSequence.fromListAndArray(new LinkedList<Edge>(), edge));
          newNode.addGraphNode(childGraphNode);
        }
      }
      return newNode;
    } else {
      List<PQNode> modifiedChildren = ListSequence.fromList(new ArrayList<PQNode>());
      if (pertinentRoot instanceof QNode) {
        PQNode prePertinentRoot = pertinentRoot.getParent();
        for (PQNode child : ListSequence.fromList(prePertinentRoot.getChildren())) {
          if (child == pertinentRoot) {
            ListSequence.fromList(modifiedChildren).addElement(arrange(child, true));
          } else {
            ListSequence.fromList(modifiedChildren).addElement(arrange(child, false));
          }
        }
        for (PQNode child : ListSequence.fromList(modifiedChildren)) {
          child.setParent(prePertinentRoot);
        }
        return prePertinentRoot.processAsPertinentRoot(modifiedChildren, graphNode);
      } else {
        for (PQNode child : ListSequence.fromList(pertinentRoot.getChildren())) {
          ListSequence.fromList(modifiedChildren).addElement(arrange(child, false));
        }
        for (PQNode child : ListSequence.fromList(modifiedChildren)) {
          child.setParent(pertinentRoot);
        }
        return pertinentRoot.processAsPertinentRoot(modifiedChildren, graphNode);
      }
    }
  }

  public PQNode findPertinentRoot() {
    int numAllFullLeaves = 0;
    for (Leaf leaf : ListSequence.fromList(myLeaves)) {
      if (leaf.getState() == PQNode.State.FULL) {
        numAllFullLeaves++;
      }
    }
    myNumFullLeaves = MapSequence.fromMap(new HashMap<PQNode, Integer>());
    return findPertinentRoot(myRoot, numAllFullLeaves);
  }

  public PQNode findPertinentRoot(PQNode node, int numAllFullLeaves) {
    if (node instanceof Leaf) {
      if (node.getState() == PQNode.State.FULL) {
        MapSequence.fromMap(myNumFullLeaves).put(node, 1);
      } else {
        MapSequence.fromMap(myNumFullLeaves).put(node, 0);
      }
    } else {
      int numFullLeaves = 0;
      boolean hasPartial = false;
      int numEmptyChildren = 0;
      for (PQNode child : ListSequence.fromList(node.getChildren())) {
        PQNode pertinentRoot = findPertinentRoot(child, numAllFullLeaves);
        if (pertinentRoot != null) {
          return pertinentRoot;
        }
        numFullLeaves += MapSequence.fromMap(myNumFullLeaves).get(child);
        if (child.getState() == PQNode.State.PARTIAL) {
          hasPartial = true;
        }
        if (child.getState() == PQNode.State.EMPTY) {
          numEmptyChildren++;
        }
      }
      if (hasPartial) {
        node.setState(PQNode.State.PARTIAL);
      } else {
        if (numEmptyChildren == 0) {
          node.setState(PQNode.State.FULL);
        } else if (numEmptyChildren == ListSequence.fromList(node.getChildren()).count()) {
          node.setState(PQNode.State.EMPTY);
        } else {
          node.setState(PQNode.State.PARTIAL);
        }
      }
      MapSequence.fromMap(myNumFullLeaves).put(node, numFullLeaves);
    }
    node.setNumFullLeaves(MapSequence.fromMap(myNumFullLeaves).get(node));
    if (MapSequence.fromMap(myNumFullLeaves).get(node) == numAllFullLeaves) {
      return node;
    } else {
      return null;
    }
  }

  private PQNode arrange(PQNode node, boolean isRealPertinentRoot) {
    // this boolean value is for Q3 case only 
    if (!(MapSequence.fromMap(myNumFullLeaves).containsKey(node)) || MapSequence.fromMap(myNumFullLeaves).get(node) == 0) {
      node.setState(PQNode.State.EMPTY);
      return node;
    }
    List<PQNode> children = node.getChildren();
    ListIterator<PQNode> childItr = children.listIterator();
    while (childItr.hasNext()) {
      PQNode child = childItr.next();
      PQNode newChild = arrange(child, false);
      if (newChild == null) {
        return null;
      }
      childItr.set(newChild);
    }
    return node.makeReduction(isRealPertinentRoot);
  }

  @Override
  public String toString() {
    return getRoot().toString(0);
  }

  public List<Leaf> getLeaves() {
    return this.myLeaves;
  }

  public void makeReducible() {
    myNumFullLeaves = MapSequence.fromMap(new HashMap<PQNode, Integer>());
    int numFullLeavesInTree = 0;
    for (Leaf leaf : ListSequence.fromList(myLeaves)) {
      if (leaf.getState() == PQNode.State.FULL) {
        numFullLeavesInTree++;
      }
    }
    PQNode pertinentRoot = findPertinentRoot(myRoot, numFullLeavesInTree);
    if (pertinentRoot.getState() == PQNode.State.PARTIAL) {
      pertinentRoot.computeHValue();
      pertinentRoot.computeAValue();
      if (pertinentRoot.getHValue() < pertinentRoot.getAValue()) {
        pertinentRoot.makeHDeletion();
      } else {
        pertinentRoot.makeADeletion();
      }
    }
  }
}
