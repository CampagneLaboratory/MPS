package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import java.util.List;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.graph.Edge;

public abstract class PQNode {
  public static final int INF = 1000000;

  protected List<PQNode> myChildren;
  private PQNode myParent;
  private PQNode.State myState;
  protected Set<NodeWithInEdgeOrder> myGraphNodes;
  private int myNumFullLeaves;

  public PQNode() {
    myChildren = ListSequence.fromList(new ArrayList<PQNode>());
    myState = null;
    myParent = null;
    myGraphNodes = SetSequence.fromSet(new HashSet<NodeWithInEdgeOrder>());
  }

  /**
   * A spesial procedure for pertinent root. It merges all full leaves to one p-node and makes new biconnected
   * component created by reduction correct.
   * 
   * @param children new children of ppertinent root generated by reduction step
   */
  public abstract PQNode processAsPertinentRoot(List<PQNode> children, Node nextGraphNode);

  public abstract PQNode makeReduction(boolean isRealPertinentRoot);

  public abstract int getAValue();

  public void computeAValue() {
    for (PQNode child : ListSequence.fromList(getChildren())) {
      child.computeAValue();
    }
  }

  public abstract void makeADeletion();

  public abstract int getHValue();

  public void computeHValue() {
    for (PQNode child : ListSequence.fromList(getChildren())) {
      child.computeHValue();
    }
  }

  public abstract void makeHDeletion();

  public void setState(PQNode.State state) {
    myState = state;
  }

  public PQNode.State getState() {
    return myState;
  }

  public List<PQNode> getChildren() {
    return myChildren;
  }

  public void addLastChild(PQNode child) {
    ListSequence.fromList(myChildren).addElement(child);
    child.setParent(this);
  }

  public void addFirstChild(PQNode child) {
    ListSequence.fromList(myChildren).insertElement(0, child);
    child.setParent(this);
  }

  public PQNode getParent() {
    return this.myParent;
  }

  public void setParent(PQNode parent) {
    this.myParent = parent;
  }

  public Set<NodeWithInEdgeOrder> getGraphNodesInSubtree(List<Edge> listOrder) {
    Set<NodeWithInEdgeOrder> graphNodes = this.getGraphNodes();
    if (this instanceof Leaf) {
      Leaf leaf = ((Leaf) this);
      ListSequence.fromList(listOrder).addElement((Edge) leaf.getData());
    }
    for (PQNode child : ListSequence.fromList(this.getChildren())) {
      SetSequence.fromSet(graphNodes).addSequence(SetSequence.fromSet(child.getGraphNodesInSubtree(listOrder)));
    }
    return graphNodes;
  }

  public String toString(int offset) {
    StringBuilder builder = new StringBuilder();
    String spaces = "";
    for (int i = 0; i < offset; i++) {
      spaces += " ";
    }
    builder.append(spaces + "node " + getType() + " nodes: " + myGraphNodes + " state = " + getState() + "\n");
    if (ListSequence.fromList(getChildren()).count() > 0) {
      builder.append(spaces + "children: \n");
      for (PQNode child : ListSequence.fromList(getChildren())) {
        builder.append(child.toString(offset + 2));
      }
    }
    return builder.toString();
  }

  public Set<NodeWithInEdgeOrder> getGraphNodes() {
    return myGraphNodes;
  }

  public NodeWithInEdgeOrder getGraphNode() {
    return SetSequence.fromSet(getGraphNodes()).first();
  }

  public void addGraphNode(NodeWithInEdgeOrder node) {
    SetSequence.fromSet(myGraphNodes).addElement(node);
  }

  public Set<NodeWithInEdgeOrder> collectGraphNodes() {
    Set<NodeWithInEdgeOrder> graphNodes = SetSequence.fromSet(new HashSet<NodeWithInEdgeOrder>());
    SetSequence.fromSet(graphNodes).addSequence(SetSequence.fromSet(getGraphNodes()));
    for (PQNode child : ListSequence.fromList(getChildren())) {
      SetSequence.fromSet(graphNodes).addSequence(SetSequence.fromSet(child.collectGraphNodes()));
    }
    return graphNodes;
  }

  public PQNode adjust() {
    if (ListSequence.fromList(getChildren()).count() == 1) {
      return ListSequence.fromList(getChildren()).getElement(0);
    }
    return this;
  }

  public abstract String getType();

  public int getNumFullLeaves() {
    return this.myNumFullLeaves;
  }

  public void setNumFullLeaves(int numFullLeaves) {
    this.myNumFullLeaves = numFullLeaves;
  }

  protected void makeEmpty() {
    if (getState() == PQNode.State.EMPTY) {
      return;
    }
    for (PQNode child : ListSequence.fromList(getChildren())) {
      child.makeEmpty();
    }
    setState(PQNode.State.EMPTY);
  }

  public static   enum State {
    FULL(),
    PARTIAL(),
    EMPTY();

    State() {
    }
  }
}
