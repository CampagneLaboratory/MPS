package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import java.util.Map;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Iterator;

public class PQPlanarization {
  private static final int INF = Integer.MAX_VALUE;

  /**
   * this map stores minimum number of leaves needs to be removed from pq-tree to make node emply
   */
  private Map<PQNode, Integer> myW;
  /**
   * his map stores minimum number of leaves needs to be removed from pq-tree to make node full
   */
  private Map<PQNode, Integer> myB;
  /**
   * this map stores minimum number of leaves needs to be removed from pq-tree so that full leaves of node 
   * can be arranges in such a way that they appear consequently at either left or right end of the frontier
   */
  private Map<PQNode, Integer> myH;
  private Map<PQNode, PQNode> myHChild1;
  private Map<PQNode, PQNode> myHChild2;
  /**
   * this map stores minimum number of leaves needs to be removed from pq-tree so that full leaves of node 
   * can be arranges in such a way that they appear consequently in the middle of the frontier
   */
  private Map<PQNode, Integer> myA;
  private Map<PQNode, PQNode> myAChild;
  private Set<PQNode> myPerformedA;
  private Map<PQNode, Integer> myNumFullLeaves;

  public PQPlanarization() {
  }

  private void computeMaps(PQNode node) {
    for (PQNode child : ListSequence.fromList(node.getChildren())) {
      computeMaps(node);
    }
    if (node.getState() == PQNode.State.FULL) {
      MapSequence.fromMap(myW).put(node, MapSequence.fromMap(myNumFullLeaves).get(node));
      MapSequence.fromMap(myH).put(node, 0);
      MapSequence.fromMap(myA).put(node, 0);
    } else if (node.getState() == PQNode.State.EMPTY) {
      MapSequence.fromMap(myW).put(node, 0);
    } else {
    }

  }

  public void computeMapForPartialNode(PQNode node) {
    int w = 0;
    for (PQNode child : ListSequence.fromList(node.getChildren())) {
      w += MapSequence.fromMap(myW).get(child);
    }
    MapSequence.fromMap(myW).put(node, w);
    if (node instanceof PNode) {
      Iterable<PQNode> partialChildren = ListSequence.fromList(node.getChildren()).where(new IWhereFilter<PQNode>() {
        public boolean accept(PQNode it) {
          return it.getState() == PQNode.State.PARTIAL;
        }
      });
      int partialW = 0;
      for (PQNode child : Sequence.fromIterable(partialChildren)) {
        partialW += MapSequence.fromMap(myW).get(child);
      }
      // finding myH 
      int h1 = 0;
      PQNode h1Child = null;
      for (PQNode child : Sequence.fromIterable(partialChildren)) {
        if (h1 <= MapSequence.fromMap(myW).get(child) - MapSequence.fromMap(myH).get(child)) {
          h1 = MapSequence.fromMap(myW).get(child) - MapSequence.fromMap(myH).get(child);
          h1Child = child;
        }
      }
      h1 = partialW - h1;
      MapSequence.fromMap(myH).put(node, h1);
      MapSequence.fromMap(myHChild1).put(node, h1Child);
      // finding myA 
      int a1 = 0;
      PQNode aChild = null;
      for (PQNode child : Sequence.fromIterable(partialChildren)) {
        if (a1 < MapSequence.fromMap(myW).get(child) - MapSequence.fromMap(myA).get(child)) {
          a1 = MapSequence.fromMap(myW).get(child) - MapSequence.fromMap(myA).get(child);
          aChild = child;
        }
      }
      MapSequence.fromMap(myAChild).put(node, aChild);
      a1 = MapSequence.fromMap(myW).get(node) - a1;
      int h2 = 0;
      PQNode h2Child = null;
      for (PQNode child : Sequence.fromIterable(partialChildren)) {
        if (child == h1Child) {
          continue;
        }
        if (h2 <= MapSequence.fromMap(myW).get(child) - MapSequence.fromMap(myH).get(child)) {
          h2 = MapSequence.fromMap(myW).get(child) - MapSequence.fromMap(myH).get(child);
          h2Child = child;
        }
      }
      MapSequence.fromMap(myHChild2).put(node, h2Child);
      int a2 = partialW - h1 - h2;
      MapSequence.fromMap(myA).put(node, Math.min(a1, a2));
      if (a1 < a2) {
        SetSequence.fromSet(myPerformedA).addElement(node);
      }
    }
    if (node instanceof QNode) {
      // findind myH 
      Iterator<PQNode> childItr = ListSequence.fromList(node.getChildren()).iterator();
      PQNode hLeftNode = null;
      int hLeft = this.findHforPartialQRoot(childItr);
      childItr = ListSequence.fromList(node.getChildren()).reversedList().iterator();
      PQNode hRightNode = null;
      int hRight = this.findHforPartialQRoot(childItr);

    }
  }

  private int findHforPartialQRoot(Iterator<PQNode> childItr) {
    PQNode firstPartial = null;
    boolean foundPartial = false;
    int w = 0;
    while (childItr.hasNext()) {
      PQNode cur = childItr.next();
      if (!(foundPartial)) {
        if (cur.getState() == PQNode.State.EMPTY) {
          w += MapSequence.fromMap(myW).get(cur);
          foundPartial = true;
        }
        if (cur.getState() == PQNode.State.PARTIAL) {
          firstPartial = cur;
          foundPartial = true;
        }
      } else {
        w += MapSequence.fromMap(myW).get(cur);
      }
    }
    if (firstPartial == null) {
      return INF;
    } else {
      return w + MapSequence.fromMap(myH).get(firstPartial);
    }
  }
}
