package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;
import java.util.List;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class QNode extends PQNode {
  private int myHValue;
  private PQNode myHChild;
  private boolean myMakeHLeft;
  private int myAValue;
  private PQNode myFirstAChild;
  private PQNode mySecondAChild;
  private boolean myMakeAFromH;

  public QNode() {
  }

  public PQNode processPartialCandidate(PQNode.State initialState, boolean isPertinentRoot) {
    Set<QNode> nodesToRevert = SetSequence.fromSet(new HashSet<QNode>());
    QNode candidate = createCandidate(initialState, nodesToRevert);
    if (checkCandidate(candidate, isPertinentRoot)) {
      candidate.setParent(this.getParent());
      SetSequence.fromSet(candidate.getGraphNodes()).addSequence(SetSequence.fromSet(this.getGraphNodes()));
      for (QNode node : SetSequence.fromSet(nodesToRevert)) {
        node.reverse();
      }
      // in q-node first should go empty children, and then full children 
      if (ListSequence.fromList(candidate.getChildren()).first().getState() == PQNode.State.FULL) {
        candidate.reverse();
      }
      candidate.setState(PQNode.State.PARTIAL);
      return candidate;
    } else {
      return null;
    }
  }

  private QNode createCandidate(PQNode.State initialState, Set<QNode> nodesToRevert) {
    PQNode.State curState = initialState;
    QNode candidate = new QNode();
    for (PQNode child : ListSequence.fromList(getChildren())) {
      if (child.getState() != PQNode.State.PARTIAL) {
        candidate.addLastChild(child);
        curState = child.getState();
      } else {
        Iterator<PQNode> partialChildIrt;
        if (curState == PQNode.State.EMPTY) {
          partialChildIrt = ListSequence.fromList(child.getChildren()).iterator();
        } else {
          SetSequence.fromSet(nodesToRevert).addElement(((QNode) child));
          partialChildIrt = ListSequence.fromList(child.getChildren()).reversedList().iterator();
        }
        while (partialChildIrt.hasNext()) {
          candidate.addLastChild(partialChildIrt.next());
        }
        curState = ListSequence.fromList(candidate.getChildren()).last().getState();
      }
    }
    return candidate;
  }

  private boolean checkCandidate(QNode candidate, boolean isPertinentRoot) {
    boolean startFullSegment = false;
    boolean endFullSegment = false;
    for (PQNode child : ListSequence.fromList(candidate.getChildren())) {
      if (child.getState() == PQNode.State.FULL) {
        if (!(startFullSegment)) {
          startFullSegment = true;
        }
        if (endFullSegment) {
          return false;
        }
      } else {
        if (startFullSegment) {
          endFullSegment = true;
        }
      }
    }
    if (isPertinentRoot) {
      return true;
    } else {
      return ListSequence.fromList(candidate.getChildren()).first().getState() == PQNode.State.FULL || ListSequence.fromList(candidate.getChildren()).last().getState() == PQNode.State.FULL;
    }
  }

  public PQNode makeReduction(boolean isRealPertinentRoot) {
    if (getState() != PQNode.State.PARTIAL) {
      return this;
    }
    PQNode candidate = processPartialCandidate(PQNode.State.EMPTY, isRealPertinentRoot);
    if (candidate != null) {
      return candidate;
    }
    candidate = processPartialCandidate(PQNode.State.FULL, isRealPertinentRoot);
    if (candidate != null) {
      return candidate;
    }
    return null;
    /*
      int numFull = 0;
      int numEmpty = 0;
      int numPartial = 0;
      for (PQNode child : ListSequence.fromList(getChildren())) {
        if (child.getState() == PQNode.State.FULL) {
          numFull++;
        }
        if (child.getState() == PQNode.State.PARTIAL) {
          numPartial++;
        }
        if (child.getState() == PQNode.State.EMPTY) {
          numEmpty++;
        }
      }
      if (numPartial == 0) {
        if (numEmpty == 0) {
          return doQ1Pattern(PQNode.State.FULL);
        } else {
          PQNode.State prevChildState = ListSequence.fromList(getChildren()).getElement(0).getState();
          int numDiff = 0;
          for (PQNode child : ListSequence.fromList(getChildren())) {
            if (child.getState() != prevChildState) {
              numDiff++;
              prevChildState = child.getState();
            }
          }
          boolean isGoodPertinent = numDiff == 2 && isRealPertinentRoot && ListSequence.fromList(getChildren()).getElement(0).getState() == PQNode.State.EMPTY;
          if (numDiff > 1 && !(isGoodPertinent)) {
            return null;
          }
          return doQ1Pattern(PQNode.State.PARTIAL);
        }
      } else if (numPartial == 1) {
        Iterator<PQNode> childItr = ListSequence.fromList(getChildren()).iterator();
        PQNode cur = childItr.next();
        PQNode.State firstChildState = null;
        while (cur.getState() != PQNode.State.PARTIAL) {
          if (firstChildState == null) {
            firstChildState = cur.getState();
          }
          if (cur.getState() != firstChildState) {
            return null;
          }
          cur = childItr.next();
        }
        while (childItr.hasNext()) {
          cur = childItr.next();
          if (cur.getState() == firstChildState) {
            return null;
          }
        }
        return doQ2Pattern();
      } else if (numPartial == 2) {
        if (!(isRealPertinentRoot)) {
          return null;
        }
        Iterator<PQNode> childItr = ListSequence.fromList(getChildren()).iterator();
        PQNode cur = childItr.next();
        while (cur.getState() != PQNode.State.PARTIAL) {
          if (cur.getState() != PQNode.State.EMPTY) {
            return null;
          }
          cur = childItr.next();
        }
        cur = childItr.next();
        while (cur.getState() != PQNode.State.PARTIAL) {
          if (cur.getState() != PQNode.State.FULL) {
            return null;
          }
          cur = childItr.next();
        }
        while (childItr.hasNext()) {
          cur = childItr.next();
          if (cur.getState() != PQNode.State.EMPTY) {
            return null;
          }
        }
        return doQ3Pattern();
      }
      return null;
    */
  }

  public PQNode processAsPertinentRoot(List<PQNode> children, Node nextGraphNode) {
    return null;
  }

  /**
   * Implements Q1 pattern for PQ-Tree reduction. This happens when Q-Node
   * has no parial children
   */
  public PQNode doQ1Pattern(PQNode.State state) {
    setState(state);
    if (ListSequence.fromList(getChildren()).first().getState() == PQNode.State.FULL) {
      reverse();
    }
    return this;
  }

  /**
   * Implements Q2 pattern for PQ-Tree reduction. This happens when Q-Node
   * has exactly one partial child
   */
  public PQNode doQ2Pattern() {
    PQNode newQNode = new QNode();
    newQNode.setState(PQNode.State.PARTIAL);
    if (ListSequence.fromList(getChildren()).first().getState() == PQNode.State.FULL || (ListSequence.fromList(getChildren()).first().getState() == PQNode.State.PARTIAL && ListSequence.fromList(getChildren()).last().getState() == PQNode.State.EMPTY)) {
      reverse();
    }
    for (PQNode child : ListSequence.fromList(getChildren())) {
      if (child.getState() == PQNode.State.PARTIAL) {
        for (PQNode partialChild : ListSequence.fromList(child.getChildren())) {
          newQNode.addLastChild(partialChild);
        }
      } else {
        newQNode.addLastChild(child);
      }
    }
    return newQNode;
  }

  /**
   * Implements Q3 pattern for PQ-Tree reduction. This happens when Q-Node
   * has exactly two partial children
   */
  public PQNode doQ3Pattern() {
    PQNode newQNode = new QNode();
    newQNode.setState(PQNode.State.PARTIAL);
    boolean firstPartial = true;
    for (PQNode child : ListSequence.fromList(getChildren())) {
      if (child.getState() == PQNode.State.PARTIAL) {
        List<PQNode> partialChildren = child.getChildren();
        if (!(firstPartial)) {
          ((QNode) child).reverse();
          partialChildren = ListSequence.fromList(partialChildren).reversedList();
        }
        for (PQNode partialChild : ListSequence.fromList(partialChildren)) {
          newQNode.addLastChild(partialChild);
        }
        firstPartial = false;
      } else {
        newQNode.addLastChild(child);
      }
    }
    return newQNode;
  }

  @Override
  public void addLastChild(PQNode child) {
    super.addLastChild(child);
    SetSequence.fromSet(myGraphNodes).addSequence(SetSequence.fromSet(child.getGraphNodes()));
  }

  @Override
  public void addFirstChild(PQNode child) {
    super.addFirstChild(child);
    SetSequence.fromSet(myGraphNodes).addSequence(SetSequence.fromSet(child.getGraphNodes()));
  }

  public String getType() {
    return "Q";
  }

  public void reverse() {
    myChildren = ListSequence.fromList(myChildren).reversedList();
    Set<Node> parentNodes = SetSequence.fromSet(new HashSet<Node>());
    SetSequence.fromSet(parentNodes).addSequence(SetSequence.fromSet(getParent().getGraphNodes()).select(new ISelector<NodeWithInEdgeOrder, Node>() {
      public Node select(NodeWithInEdgeOrder it) {
        return it.getNode();
      }
    }));
    for (NodeWithInEdgeOrder graphNode : SetSequence.fromSet(getGraphNodes())) {
      if (!(SetSequence.fromSet(parentNodes).contains(graphNode.getNode()))) {
        graphNode.reverse();
      }
    }
  }

  public int getAValue() {
    return myAValue;
  }

  public void computeAValue() {
    super.computeAValue();
    if (getState() != PQNode.State.PARTIAL) {
      myAValue = 0;
      return;
    }
    int valueFromA = 0;
    PQNode aChild = null;
    for (PQNode child : ListSequence.fromList(getChildren())) {
      int curValue = child.getNumFullLeaves() - child.getAValue();
      if (valueFromA < curValue) {
        valueFromA = curValue;
        aChild = child;
      }
    }
    valueFromA = getNumFullLeaves() - valueFromA;
    int valueFromH = INF;
    PQNode firstChild = null;
    PQNode lastChild = null;
    PQNode curFirst = null;
    boolean insideHSegment = false;
    int numFullLeavesInSegment = 0;
    for (PQNode child : ListSequence.fromList(getChildren())) {
      if (insideHSegment) {
        if (child.getState() == PQNode.State.FULL) {
          numFullLeavesInSegment += child.getNumFullLeaves();
        } else {
          int aValue = getNumFullLeaves() - numFullLeavesInSegment - (curFirst.getNumFullLeaves() - curFirst.getHValue()) - (child.getNumFullLeaves() - child.getHValue());
          if (aValue < valueFromH) {
            firstChild = curFirst;
            lastChild = child;
            valueFromH = aValue;
          }
          numFullLeavesInSegment = 0;
          if (child.getState() == PQNode.State.PARTIAL) {
            curFirst = child;
          } else {
            insideHSegment = false;
          }
        }
      } else {
        if (child.getState() != PQNode.State.EMPTY) {
          curFirst = child;
          insideHSegment = true;
        }
      }
    }
    // last segment wasn't checked by previous cycle 
    PQNode last = ListSequence.fromList(getChildren()).last();
    if (insideHSegment && curFirst != last) {
      int aValue = getNumFullLeaves() - numFullLeavesInSegment - curFirst.getAValue() - last.getAValue();
      if (aValue < valueFromH) {
        firstChild = curFirst;
        lastChild = last;
        valueFromH = aValue;
      }
    }
    if (valueFromA < valueFromH) {
      myMakeAFromH = false;
      myAValue = valueFromA;
      myFirstAChild = aChild;
      mySecondAChild = null;
    } else {
      myMakeAFromH = true;
      myAValue = valueFromH;
      myFirstAChild = firstChild;
      mySecondAChild = lastChild;
    }
    if (myAValue > INF) {
      myAValue = INF;
    }
  }

  public void makeADeletion() {
    if (getState() != PQNode.State.PARTIAL) {
      return;
    }
    if (myMakeAFromH) {
      boolean insideHSegment = false;
      for (PQNode child : ListSequence.fromList(getChildren())) {
        if (child == myFirstAChild || child == mySecondAChild) {
          insideHSegment = !(insideHSegment);
          child.makeHDeletion();
        } else {
          if (!(insideHSegment)) {
            child.makeEmpty();
          }
        }
      }
    } else {
      for (PQNode child : ListSequence.fromList(getChildren())) {
        if (child == myFirstAChild) {
          child.makeADeletion();
        } else {
          child.makeEmpty();
        }
      }
    }
  }

  public int getHValue() {
    return myHValue;
  }

  public void computeHValue() {
    super.computeHValue();
    if (getState() != PQNode.State.PARTIAL) {
      myHValue = 0;
      return;
    }
    Iterator<PQNode> childItr = ListSequence.fromList(getChildren()).iterator();
    findHByIterator(childItr);
    int leftValue = myHValue;
    PQNode leftHChild = myHChild;
    childItr = ListSequence.fromList(getChildren()).reversedList().iterator();
    findHByIterator(childItr);
    int rightValue = myHValue;
    PQNode rightHChild = myHChild;
    if (leftValue < rightValue) {
      myHValue = leftValue;
      myHChild = leftHChild;
      myMakeHLeft = true;
    } else {
      myHValue = rightValue;
      myHChild = rightHChild;
      myMakeHLeft = false;
    }
    if (myHValue > INF) {
      myHValue = INF;
    }
  }

  public void makeHDeletion() {
    if (getState() != PQNode.State.PARTIAL) {
      return;
    }
    boolean isToDelete;
    if (myMakeHLeft) {
      isToDelete = false;
    } else {
      isToDelete = true;
    }
    for (PQNode child : ListSequence.fromList(getChildren())) {
      if (child == myHChild) {
        child.makeHDeletion();
        isToDelete = !(isToDelete);
      } else {
        if (isToDelete) {
          child.makeEmpty();
        }
      }
    }
  }

  private void findHByIterator(Iterator<PQNode> childItr) {
    PQNode firstPartial = null;
    boolean foundPartial = false;
    int w = 0;
    while (childItr.hasNext()) {
      PQNode cur = childItr.next();
      if (!(foundPartial)) {
        if (cur.getState() == PQNode.State.EMPTY) {
          foundPartial = true;
        }
        if (cur.getState() == PQNode.State.PARTIAL) {
          firstPartial = cur;
          foundPartial = true;
        }
        if (cur.getState() == PQNode.State.FULL) {
          firstPartial = cur;
        }
      } else {
        w += cur.getNumFullLeaves();
      }
    }
    if (firstPartial == null) {
      myHValue = INF;
      myHChild = null;
    } else {
      myHValue = w + firstPartial.getHValue();
      myHChild = firstPartial;
    }
  }
}
