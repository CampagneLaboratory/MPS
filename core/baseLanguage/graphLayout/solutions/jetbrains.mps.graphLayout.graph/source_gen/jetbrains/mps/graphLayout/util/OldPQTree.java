package jetbrains.mps.graphLayout.util;

/*Generated by MPS */

import java.util.List;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.ListIterator;

public class OldPQTree {
  private OldPQTreeNode myRoot;
  private List<OldLeaf> myLeaves;
  private Map<OldPQTreeNode, Integer> myNumFullLeaves;

  public OldPQTree() {
    myLeaves = ListSequence.fromList(new ArrayList<OldLeaf>());
    myRoot = null;
  }

  public OldPQTreeNode getRoot() {
    return this.myRoot;
  }

  public void setRoot(OldPQTreeNode root) {
    this.myRoot = root;
  }

  public void addLeaf(OldLeaf leaf) {
    ListSequence.fromList(myLeaves).addElement(leaf);
  }

  public OldPQTreeNode arrange(Set<OldLeaf> successiveLeaves) {
    for (OldLeaf leaf : ListSequence.fromList(myLeaves)) {
      leaf.setState(OldPQTreeNode.State.EMPTY);
    }
    for (OldLeaf leaf : SetSequence.fromSet(successiveLeaves)) {
      leaf.setState(OldPQTreeNode.State.FULL);
    }
    myNumFullLeaves = MapSequence.fromMap(new HashMap<OldPQTreeNode, Integer>());
    OldPQTreeNode pertinentRoot = findPertinentRoot(myRoot, SetSequence.fromSet(successiveLeaves).count());
    return arrange(pertinentRoot, true);
  }

  public OldPQTreeNode findPertinentRoot(OldPQTreeNode node, int numAllFullLeaves) {
    if (node instanceof OldLeaf) {
      if (node.getState() == OldPQTreeNode.State.FULL) {
        MapSequence.fromMap(myNumFullLeaves).put(node, 1);
      } else {
        MapSequence.fromMap(myNumFullLeaves).put(node, 0);
      }
    } else {
      int num = 0;
      for (OldPQTreeNode child : ListSequence.fromList(node.getChildren())) {
        OldPQTreeNode pertinentRoot = findPertinentRoot(child, numAllFullLeaves);
        if (pertinentRoot != null) {
          return pertinentRoot;
        }
        num += MapSequence.fromMap(myNumFullLeaves).get(child);
      }
      MapSequence.fromMap(myNumFullLeaves).put(node, num);
    }
    if (MapSequence.fromMap(myNumFullLeaves).get(node) == numAllFullLeaves) {
      return node;
    } else {
      return null;
    }
  }

  public OldPQTreeNode arrange(OldPQTreeNode node, boolean isPertinentRoot) {
    if (MapSequence.fromMap(myNumFullLeaves).get(node) == 0) {
      node.setState(OldPQTreeNode.State.EMPTY);
      return node;
    }
    List<OldPQTreeNode> children = node.getChildren();
    ListIterator<OldPQTreeNode> childItr = children.listIterator();
    while (childItr.hasNext()) {
      OldPQTreeNode child = childItr.next();
      OldPQTreeNode newChild = arrange(child, false);
      if (newChild == null) {
        return null;
      }
      childItr.set(newChild);
    }
    return node.makeReduction(isPertinentRoot);
  }

  @Override
  public String toString() {
    return getRoot().toString(0);
  }

  public List<OldLeaf> getLeaves() {
    return this.myLeaves;
  }
}
