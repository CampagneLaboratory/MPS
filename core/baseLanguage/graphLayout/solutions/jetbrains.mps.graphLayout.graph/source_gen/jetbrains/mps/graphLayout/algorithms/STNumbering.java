package jetbrains.mps.graphLayout.algorithms;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.graphLayout.util.NodeMap;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.List;
import java.util.ArrayList;

public class STNumbering {
  public static Map<Node, Integer> number(Graph graph, Node source, Node target) {
    Edge stEdge = null;
    boolean deleteAfter = false;
    for (Edge edge : ListSequence.fromList(source.getEdges())) {
      if (edge.getOpposite(source) == target) {
        stEdge = edge;
      }
    }
    if (stEdge == null) {
      stEdge = source.addEdgeTo(target);
      deleteAfter = true;
    }
    STNumbering.FirstDfs firstDfs = new STNumbering.FirstDfs();
    firstDfs.doDfs(graph, source, stEdge);
    Map<Node, Node> low = firstDfs.getLow();
    STNumbering.SecondDfs secondDfs = new STNumbering.SecondDfs();
    secondDfs.doDfs(graph, source, stEdge, low);
    Map<Node, Integer> res = new NodeMap<Integer>(graph);
    int curNum = 0;
    for (Node node : ListSequence.fromList(secondDfs.getList())) {
      MapSequence.fromMap(res).put(node, curNum++);
    }
    if (deleteAfter) {
      stEdge.removeFromGraph();
    }
    return res;
  }

  public static class FirstDfs extends Dfs {
    private Map<Node, Node> myLow;
    private Map<Node, Integer> myNum;
    private int myCurNum;

    public FirstDfs() {
    }

    public void doDfs(Graph graph, Node source, Edge stEdge) {
      myLow = new NodeMap<Node>(graph);
      myNum = new NodeMap<Integer>(graph);
      init(graph, Edge.Direction.BOTH);
      MapSequence.fromMap(getDfsState()).put(source, DURING);
      MapSequence.fromMap(myLow).put(source, source);
      MapSequence.fromMap(myNum).put(source, 0);
      myCurNum = 1;
      dfs(stEdge.getOpposite(source), stEdge);
    }

    @Override
    protected void preprocess(Node node, Edge from) {
      MapSequence.fromMap(myNum).put(node, myCurNum++);
      MapSequence.fromMap(myLow).put(node, node);
    }

    @Override
    protected void processEdge(Edge edge, Node source) {
      Node next = edge.getOpposite(source);
      if (MapSequence.fromMap(getDfsState()).get(next) == DURING) {
        changeLow(source, next);
      }
    }

    @Override
    protected void postprocess(Node node, Edge from) {
      Node prev = from.getOpposite(node);
      changeLow(prev, MapSequence.fromMap(myLow).get(node));
    }

    private void changeLow(Node node, Node newLow) {
      Node oldLow = MapSequence.fromMap(myLow).get(node);
      if (MapSequence.fromMap(myNum).get(oldLow) > MapSequence.fromMap(myNum).get(newLow)) {
        MapSequence.fromMap(myLow).put(node, newLow);
      }
    }

    public Map<Node, Node> getLow() {
      return this.myLow;
    }

    public Map<Node, Integer> getNum() {
      return this.myNum;
    }
  }

  public static class SecondDfs extends Dfs {
    private Map<Node, Integer> mySign;
    private Map<Node, Node> myLow;
    private List<Node> myList;
    private Node myTarget;

    public SecondDfs() {
    }

    public void doDfs(Graph graph, Node source, Edge stEdge, Map<Node, Node> low) {
      init(graph, Edge.Direction.BOTH);
      myLow = low;
      mySign = new NodeMap<Integer>(graph);
      MapSequence.fromMap(getDfsState()).put(source, DURING);
      Node target = stEdge.getOpposite(source);
      myTarget = target;
      MapSequence.fromMap(mySign).put(source, -1);
      myList = ListSequence.fromListAndArray(new ArrayList<Node>(), source, target);
      dfs(target, stEdge);
    }

    @Override
    protected void preprocess(Node node, Edge from) {
      if (node != myTarget) {
        Node prev = from.getOpposite(node);
        int prevIndex = ListSequence.fromList(myList).indexOf(prev);
        int nodeIndex = prevIndex;
        if (MapSequence.fromMap(mySign).get(MapSequence.fromMap(myLow).get(node)) > 0) {
          nodeIndex = prevIndex + 1;
        }
        ListSequence.fromList(myList).insertElement(nodeIndex, node);
        MapSequence.fromMap(mySign).put(prev, -MapSequence.fromMap(mySign).get(MapSequence.fromMap(myLow).get(node)));
      }
    }

    public List<Node> getList() {
      return myList;
    }
  }
}
