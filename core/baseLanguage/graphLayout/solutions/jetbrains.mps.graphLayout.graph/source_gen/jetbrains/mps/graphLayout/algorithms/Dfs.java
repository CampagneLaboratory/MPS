package jetbrains.mps.graphLayout.algorithms;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Graph;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.graphLayout.graph.Edge;

public abstract class Dfs {
  public static int BEFORE = 0;
  public static int DURING = 1;
  public static int AFTER = 2;

  private Graph myGraph;
  private Map<Node, Integer> myDfsState;

  public Dfs() {
  }

  public void doDfs(Graph graph) {
    myGraph = graph;
    myDfsState = MapSequence.fromMap(new HashMap<Node, Integer>());
    for (Node node : ListSequence.fromList(myGraph.getNodes())) {
      MapSequence.fromMap(myDfsState).put(node, BEFORE);
    }
    for (Node node : ListSequence.fromList(myGraph.getNodes())) {
      if (MapSequence.fromMap(myDfsState).get(node) == BEFORE) {
        processRoot();
        dfs(node);
      }
    }
  }

  private void dfs(Node node) {
    MapSequence.fromMap(myDfsState).put(node, DURING);
    preprocess(node);
    for (Edge edge : ListSequence.fromList(node.getOutEdges())) {
      processEdge(edge);
      Node target = edge.getTarget();
      if (MapSequence.fromMap(myDfsState).get(target) == BEFORE) {
        dfs(target);
      }
    }
    postprocess(node);
    MapSequence.fromMap(myDfsState).put(node, AFTER);
  }

  protected void processRoot() {
  }

  protected void preprocess(Node node) {
  }

  protected void processEdge(Edge edge) {
  }

  protected void postprocess(Node node) {
  }

  protected Map<Node, Integer> getDfsState() {
    return this.myDfsState;
  }
}
