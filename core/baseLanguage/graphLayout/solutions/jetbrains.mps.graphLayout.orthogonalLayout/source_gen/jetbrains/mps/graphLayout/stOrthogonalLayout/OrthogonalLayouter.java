package jetbrains.mps.graphLayout.stOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Graph;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.algorithms.ConnectivityComponents;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.graphLayout.util.NodeMap;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.graph.Edge;
import java.util.Set;
import jetbrains.mps.graphLayout.algorithms.BiconnectAugmentation;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.planarization.TreeEmbeddingFinder;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.graphLayout.algorithms.STNumbering;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class OrthogonalLayouter {
  public OrthogonalLayouter() {
  }

  public void doLayout(Graph graph) {
    Map<Node, Integer> components = ConnectivityComponents.getComponents(graph);
    int maxComponent = 0;
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      maxComponent = Math.max(maxComponent, MapSequence.fromMap(components).get(node));
    }
    Map<Node, Node> newNodes = new NodeMap<Node>(graph);
    List<Graph> subgraphs = ListSequence.fromList(new ArrayList<Graph>());
    for (int i = 0; i <= maxComponent; i++) {
      ListSequence.fromList(subgraphs).addElement(new Graph());
    }
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      Graph subgraph = ListSequence.fromList(subgraphs).getElement(MapSequence.fromMap(components).get(node));
      MapSequence.fromMap(newNodes).put(node, subgraph.addNode());
    }
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      MapSequence.fromMap(newNodes).get(edge.getSource()).addEdgeTo(MapSequence.fromMap(newNodes).get(edge.getTarget()));
    }
    for (Graph subgraph : ListSequence.fromList(subgraphs)) {
      findSTLayout(graph);
    }
  }

  public void findSTLayout(Graph graph) {
    Set<Edge> addedEdges = BiconnectAugmentation.makeBiconnected(graph);
    // here is hack, during makeBiconnected only one node is added to the graph 
    Set<Node> addedNodes = SetSequence.fromSetAndArray(new HashSet<Node>(), ListSequence.fromList(graph.getNodes()).last());
    Map<Node, Node> graphToCopy = new NodeMap<Node>(graph);
    Map<Node, Node> copyToGraph = new NodeMap<Node>(graph);
    Graph copy = new Graph();
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      Node newNode = copy.addNode();
      MapSequence.fromMap(graphToCopy).put(node, newNode);
      MapSequence.fromMap(copyToGraph).put(newNode, node);
    }
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      MapSequence.fromMap(graphToCopy).get(edge.getSource()).addEdgeTo(MapSequence.fromMap(graphToCopy).get(edge.getTarget()));
    }
    EmbeddedGraph embeddedGraph = new TreeEmbeddingFinder().find(copy);
    List<Node> outerNodes = ListSequence.fromList(new ArrayList<Node>());
    for (Dart dart : ListSequence.fromList(embeddedGraph.getOuterFace().getDarts())) {
      ListSequence.fromList(outerNodes).addElement(dart.getTarget());
    }
    outerNodes = ListSequence.fromList(outerNodes).where(new IWhereFilter<Node>() {
      public boolean accept(Node it) {
        return !(it.isDummy());
      }
    }).toListSequence();
    Node s = ListSequence.fromList(outerNodes).getElement(0);
    Node t = ListSequence.fromList(outerNodes).getElement((ListSequence.fromList(outerNodes).count()) / 2);
    Map<Node, Integer> num = STNumbering.number(graph, MapSequence.fromMap(copyToGraph).get(s), MapSequence.fromMap(copyToGraph).get(t));
    for (Edge edgeCopy : ListSequence.fromList(copy.getEdges())) {
      if (edgeCopy.getSource().isDummy() || edgeCopy.getTarget().isDummy()) {
        continue;
      }
      Node source = MapSequence.fromMap(copyToGraph).get(edgeCopy.getSource());
      Node target = MapSequence.fromMap(copyToGraph).get(edgeCopy.getTarget());
      if (MapSequence.fromMap(num).get(source) > MapSequence.fromMap(num).get(target)) {
        edgeCopy.revert();
      }
    }
    for (final Node dummyCopy : ListSequence.fromList(copy.getNodes()).where(new IWhereFilter<Node>() {
      public boolean accept(Node it) {
        return it.isDummy();
      }
    })) {
      Set<Node> adj = SetSequence.fromSet(new HashSet<Node>());
      SetSequence.fromSet(adj).addSequence(ListSequence.fromList(dummyCopy.getEdges()).select(new ISelector<Edge, Node>() {
        public Node select(Edge it) {
          return it.getOpposite(dummyCopy);
        }
      }));

    }
  }
}
