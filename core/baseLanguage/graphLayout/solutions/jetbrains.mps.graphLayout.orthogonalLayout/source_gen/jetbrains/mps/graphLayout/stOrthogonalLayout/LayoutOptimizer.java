package jetbrains.mps.graphLayout.stOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graphLayout.GraphLayout;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.List;
import java.awt.Point;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.awt.Rectangle;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class LayoutOptimizer {
  private GraphLayout myLayout;

  private LayoutOptimizer(GraphLayout layout) {
    myLayout = layout;
  }

  private void optimize() {
    boolean foundOptimize = true;
    while (foundOptimize) {
      for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(myLayout.getEdgeLayout()).keySet())) {
        List<Point> path = myLayout.getLayoutFor(edge);
        int size = ListSequence.fromList(path).count();
        for (int i = 0; i < size - 4; i++) {
          List<Point> chain = ListSequence.fromList(new ArrayList<Point>());
          ListSequence.fromList(chain).addElement(ListSequence.fromList(path).getElement(i));
          ListSequence.fromList(chain).addElement(ListSequence.fromList(path).getElement(i + 1));
          ListSequence.fromList(chain).addElement(ListSequence.fromList(path).getElement(i + 2));
          ListSequence.fromList(chain).addElement(ListSequence.fromList(path).getElement(i + 3));
          tryChain(chain);
        }
      }
    }
  }

  private List<Point> tryChain(List<Point> chain) {
    int minX = Integer.MAX_VALUE;
    int minY = Integer.MAX_VALUE;
    int maxX = Integer.MIN_VALUE;
    int maxY = Integer.MIN_VALUE;
    for (Point p : ListSequence.fromList(chain)) {
      minX = Math.min(minX, p.x);
      minY = Math.min(minX, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }
    List<Point> in = ListSequence.fromList(new ArrayList<Point>());
    for (Point p : ListSequence.fromList(chain)) {
      if (p.x != minX && p.x != maxX) {
        ListSequence.fromList(in).addElement(p);
      } else if (p.y != minY && p.y != maxY) {
        ListSequence.fromList(in).addElement(p);
      }
    }
    if (ListSequence.fromList(in).count() == 2) {
      boolean ver = ListSequence.fromList(in).getElement(0).x == ListSequence.fromList(in).getElement(1).x;
      int pX = Math.max(ListSequence.fromList(in).getElement(0).x, ListSequence.fromList(in).getElement(1).x);
      int pY = Math.max(ListSequence.fromList(in).getElement(0).y, ListSequence.fromList(in).getElement(1).y);
      if (testRect(new Rectangle(minX, minY, pX - minX, pY - minY))) {
        return getChain(minX, minY, maxX, maxY, !(ver));
      }
      pX = Math.min(ListSequence.fromList(in).getElement(0).x, ListSequence.fromList(in).getElement(1).x);
      pY = Math.min(ListSequence.fromList(in).getElement(0).y, ListSequence.fromList(in).getElement(1).y);
      if (testRect(new Rectangle(pX, pY, maxX - pX, maxY - pY))) {
        if (testRect(new Rectangle(minX, minY, pX - minX, pY - minY))) {
          return getChain(minX, minY, maxX, maxY, ver);
        }
      }
    }
    return null;
  }

  private List<Point> getChain(int minX, int minY, int maxX, int maxY, boolean firstVer) {
    List<Point> newChain = ListSequence.fromList(new ArrayList<Point>());
    ListSequence.fromList(newChain).addElement(new Point(minX, minY));
    if (firstVer) {
      ListSequence.fromList(newChain).addElement(new Point(minX, maxY));
    } else {
      ListSequence.fromList(newChain).addElement(new Point(maxX, minY));
    }
    ListSequence.fromList(newChain).addElement(new Point(maxX, maxY));
    return newChain;
  }

  private boolean testRect(Rectangle rect) {
    for (Rectangle nodeRect : Sequence.fromIterable(MapSequence.fromMap(myLayout.getNodeLayout()).values())) {
      if (isStrictlyInside(nodeRect.x, nodeRect.y, rect)) {
        return false;
      }
      if (isStrictlyInside(nodeRect.x, nodeRect.y + nodeRect.height, rect)) {
        return false;
      }
      if (isStrictlyInside(nodeRect.x + nodeRect.width, nodeRect.y, rect)) {
        return false;
      }
      if (isStrictlyInside(nodeRect.x + nodeRect.width, nodeRect.y + nodeRect.height, rect)) {
        return false;
      }
    }
    for (List<Point> path : Sequence.fromIterable(MapSequence.fromMap(myLayout.getEdgeLayout()).values())) {
      for (Point p : ListSequence.fromList(path)) {
        if (isStrictlyInside(p.x, p.y, rect)) {
          return false;
        }
      }
    }
    return true;
  }

  private boolean isStrictlyInside(int x, int y, Rectangle rect) {
    return x < rect.x + rect.width && y < rect.y + rect.height && x > rect.x && y > rect.y;
  }

  public static void optimizeEdges(GraphLayout layout) {
    new LayoutOptimizer(layout).optimize();
  }
}
