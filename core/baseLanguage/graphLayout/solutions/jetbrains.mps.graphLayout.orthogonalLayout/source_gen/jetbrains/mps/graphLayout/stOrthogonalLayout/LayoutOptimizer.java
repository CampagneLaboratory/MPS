package jetbrains.mps.graphLayout.stOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graphLayout.GraphLayout;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.List;
import java.awt.Point;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.util.GeomUtil;
import java.awt.Rectangle;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class LayoutOptimizer {
  private GraphLayout myLayout;

  private LayoutOptimizer(GraphLayout layout) {
    myLayout = layout;
  }

  private void optimize() {
    boolean foundOptimize = true;
    while (foundOptimize) {
      foundOptimize = false;
      myLayout.refineEdgeLayout();
      for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(myLayout.getEdgeLayout()).keySet())) {
        List<Point> path = myLayout.getLayoutFor(edge);
        for (int i = 0; i < ListSequence.fromList(path).count() - 3; i++) {
          List<Point> chain = ListSequence.fromList(new ArrayList<Point>());
          ListSequence.fromList(chain).addElement(ListSequence.fromList(path).getElement(i));
          ListSequence.fromList(chain).addElement(ListSequence.fromList(path).getElement(i + 1));
          ListSequence.fromList(chain).addElement(ListSequence.fromList(path).getElement(i + 2));
          ListSequence.fromList(chain).addElement(ListSequence.fromList(path).getElement(i + 3));
          List<Point> newChain = tryChain(chain, edge);
          if (newChain != null) {
            foundOptimize = true;
            List<Point> temp = ListSequence.fromList(new ArrayList<Point>());
            ListSequence.fromList(temp).addSequence(ListSequence.fromList(path).subListSequence(0, i));
            ListSequence.fromList(temp).addSequence(ListSequence.fromList(newChain));
            ListSequence.fromList(temp).addSequence(ListSequence.fromList(path).subListSequence(i + 4, ListSequence.fromList(path).count()));
            myLayout.setLayoutFor(edge, temp);
            break;
          }
        }
      }
    }
  }

  private List<Point> tryChain(List<Point> chain, Edge edge) {
    boolean verMid = ListSequence.fromList(chain).getElement(1).x == ListSequence.fromList(chain).getElement(2).x;
    boolean zLike;
    if (verMid) {
      zLike = GeomUtil.insideOpenSegment(ListSequence.fromList(chain).getElement(0).x, ListSequence.fromList(chain).getElement(3).x, ListSequence.fromList(chain).getElement(1).x);
    } else {
      zLike = GeomUtil.insideOpenSegment(ListSequence.fromList(chain).getElement(0).y, ListSequence.fromList(chain).getElement(3).y, ListSequence.fromList(chain).getElement(1).y);
    }
    if (zLike) {
      if (testRect(GeomUtil.getRectangle(ListSequence.fromList(chain).getElement(0), ListSequence.fromList(chain).getElement(2)), edge)) {
        return getChain(ListSequence.fromList(chain).getElement(0), ListSequence.fromList(chain).getElement(2), ListSequence.fromList(chain).getElement(3));
      }
      if (testRect(GeomUtil.getRectangle(ListSequence.fromList(chain).getElement(1), ListSequence.fromList(chain).getElement(3)), edge)) {
        return ListSequence.fromList(getChain(ListSequence.fromList(chain).getElement(3), ListSequence.fromList(chain).getElement(1), ListSequence.fromList(chain).getElement(0))).reversedList();
      }
    } else {
      Rectangle first = GeomUtil.getRectangle(ListSequence.fromList(chain).getElement(0), ListSequence.fromList(chain).getElement(2));
      Rectangle second = GeomUtil.getRectangle(ListSequence.fromList(chain).getElement(1), ListSequence.fromList(chain).getElement(3));
      boolean firstSmaller = first.height <= second.height && first.width <= second.width;
      if (firstSmaller) {
        if (testRect(first, edge)) {
          return getChain(ListSequence.fromList(chain).getElement(0), ListSequence.fromList(chain).getElement(2), ListSequence.fromList(chain).getElement(3));
        }
      } else {
        if (testRect(second, edge)) {
          return ListSequence.fromList(getChain(ListSequence.fromList(chain).getElement(3), ListSequence.fromList(chain).getElement(1), ListSequence.fromList(chain).getElement(0))).reversedList();
        }
      }
    }
    return null;
  }

  public List<Point> getChain(Point begin, Point mid, Point end) {
    List<Point> chain = ListSequence.fromList(new ArrayList<Point>());
    ListSequence.fromList(chain).addElement(begin);
    if (mid.x == end.x) {
      ListSequence.fromList(chain).addElement(new Point(mid.x, begin.y));
    } else {
      ListSequence.fromList(chain).addElement(new Point(begin.x, mid.y));
    }
    ListSequence.fromList(chain).addElement(end);
    return chain;
  }

  private boolean testRect(Rectangle rect, Edge edge) {
    for (Node node : SetSequence.fromSet(MapSequence.fromMap(myLayout.getNodeLayout()).keySet())) {
      if (ListSequence.fromList(edge.getAdjacentNodes()).contains(node)) {
        continue;
      }
      Rectangle nodeRect = myLayout.getLayoutFor(node);
      if (isInsideAndNotACorner(nodeRect.x, nodeRect.y, rect)) {
        return false;
      }
      if (isInsideAndNotACorner(nodeRect.x, nodeRect.y + nodeRect.height, rect)) {
        return false;
      }
      if (isInsideAndNotACorner(nodeRect.x + nodeRect.width, nodeRect.y, rect)) {
        return false;
      }
      if (isInsideAndNotACorner(nodeRect.x + nodeRect.width, nodeRect.y + nodeRect.height, rect)) {
        return false;
      }
    }
    for (List<Point> path : Sequence.fromIterable(MapSequence.fromMap(myLayout.getEdgeLayout()).values())) {
      for (Point p : ListSequence.fromList(path)) {
        if (isInsideAndNotACorner(p.x, p.y, rect)) {
          return false;
        }
      }
    }
    return true;
  }

  private boolean isInsideAndNotACorner(int x, int y, Rectangle rect) {
    boolean insideX = GeomUtil.insideClosedSegment(rect.x, rect.x + rect.width, x);
    boolean insideY = GeomUtil.insideClosedSegment(rect.y, rect.y + rect.height, y);
    if (insideX && insideY) {
      boolean notX = x != rect.x && x != rect.x + rect.width;
      boolean notY = y != rect.y && y != rect.y + rect.height;
      return notX || notY;
    }
    return false;
  }

  public static void optimizeEdges(GraphLayout layout) {
    new LayoutOptimizer(layout).optimize();
  }
}
