package jetbrains.mps.graphLayout.flowOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graphLayout.ILayouter;
import jetbrains.mps.graphLayout.graphLayout.GraphLayoutPoint;
import jetbrains.mps.graphLayout.graph.Graph;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.graphLayout.algorithms.BiconnectAugmentation;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.planarization.ShortestPathEmbeddingFinder;
import jetbrains.mps.graphLayout.planarization.PQPlanarizationFinder;
import java.util.List;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.awt.Point;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.graphLayout.util.Direction2D;
import jetbrains.mps.graphLayout.planarGraph.Face;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Iterator;
import jetbrains.mps.graphLayout.algorithms.Dfs;

public class OrthogonalPointLayouter implements ILayouter {
  private static int UNIT_LENGHT = 1;
  private static int SHOW_INFO = 0;

  public OrthogonalPointLayouter() {
  }

  public GraphLayoutPoint doLayout(Graph graph) {
    Graph copy = new Graph();
    Map<Node, Node> nodeMap = MapSequence.fromMap(new HashMap<Node, Node>());
    Map<Edge, Edge> edgeMap = MapSequence.fromMap(new HashMap<Edge, Edge>());
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      MapSequence.fromMap(nodeMap).put(node, copy.addNode());
    }
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      MapSequence.fromMap(edgeMap).put(edge, MapSequence.fromMap(nodeMap).get(edge.getSource()).addEdgeTo(MapSequence.fromMap(nodeMap).get(edge.getTarget())));
    }
    BiconnectAugmentation.smartMakeBiconnected(copy);
    EmbeddedGraph embeddedGraph = new ShortestPathEmbeddingFinder(new PQPlanarizationFinder()).find(copy);
    Map<Edge, List<Edge>> history = MapSequence.fromMap(new HashMap<Edge, List<Edge>>());
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      MapSequence.fromMap(history).put(edge, embeddedGraph.findFullHistory(MapSequence.fromMap(edgeMap).get(edge)));
      if (!(ListSequence.fromList(ListSequence.fromList(MapSequence.fromMap(history).get(edge)).first().getAdjacentNodes()).contains(edge.getSource()))) {
        MapSequence.fromMap(history).put(edge, ListSequence.fromList(MapSequence.fromMap(history).get(edge)).reversedList());
      }
    }
    Map<Node, List<Node>> newNodes = MapSequence.fromMap(new HashMap<Node, List<Node>>());
    Map<Edge, Edge> replacedEdges = MapSequence.fromMap(new HashMap<Edge, Edge>());
    Set<Edge> newEdges = reduceNodesDegree(embeddedGraph, newNodes, replacedEdges);
    for (Edge edge : SetSequence.fromSet(MapSequence.fromMap(replacedEdges).keySet())) {
      Edge replacement = MapSequence.fromMap(replacedEdges).get(edge);
      if (MapSequence.fromMap(replacedEdges).containsKey(replacement)) {
        MapSequence.fromMap(replacedEdges).put(edge, MapSequence.fromMap(replacedEdges).get(replacement));
      }
    }
    for (List<Edge> list : Sequence.fromIterable(MapSequence.fromMap(history).values())) {
      Edge first = ListSequence.fromList(list).first();
      if (MapSequence.fromMap(replacedEdges).containsKey(first)) {
        ListSequence.fromList(list).setElement(0, MapSequence.fromMap(replacedEdges).get(first));
      }
      if (ListSequence.fromList(list).count() > 1) {
        Edge last = ListSequence.fromList(list).last();
        if (MapSequence.fromMap(replacedEdges).containsKey(last)) {
          ListSequence.fromList(list).setElement(ListSequence.fromList(list).count() - 1, MapSequence.fromMap(replacedEdges).get(last));
        }
      }
    }
    GraphLayoutPoint copyLayout = getFlowLayout(embeddedGraph, newEdges);
    GraphLayoutPoint graphLayout = new GraphLayoutPoint(graph);
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      Node copyNode = MapSequence.fromMap(nodeMap).get(node);
      if (MapSequence.fromMap(newNodes).containsKey(copyNode)) {
        int minX = Integer.MAX_VALUE;
        int minY = Integer.MAX_VALUE;
        int maxX = Integer.MIN_VALUE;
        int maxY = Integer.MIN_VALUE;
        for (Node newNode : ListSequence.fromList(MapSequence.fromMap(newNodes).get(copyNode))) {
          Point point = copyLayout.getLayoutFor(newNode);
          minX = Math.min(point.x, minX);
          minY = Math.min(point.y, minY);
          maxX = Math.max(point.x, maxX);
          maxY = Math.max(point.y, maxY);
        }
        graphLayout.setLayoutFor(node, new Point((minX + maxX) / 2, (minY + maxY) / 2));
      } else {
        graphLayout.setLayoutFor(node, copyLayout.getLayoutFor(MapSequence.fromMap(nodeMap).get(node)));
      }
    }
    for (Edge graphEdge : ListSequence.fromList(graph.getEdges())) {
      List<Point> edgeLayout = ListSequence.fromList(new ArrayList<Point>());
      List<Edge> edgeHistory = MapSequence.fromMap(history).get(graphEdge);
      Node copySource = MapSequence.fromMap(nodeMap).get(graphEdge.getSource());
      Node cur;
      Node firstSource = ListSequence.fromList(edgeHistory).first().getSource();
      if (copySource == firstSource || ListSequence.fromList(MapSequence.fromMap(newNodes).get(copySource)).contains(firstSource)) {
        cur = firstSource;
      } else {
        cur = ListSequence.fromList(edgeHistory).first().getTarget();
      }
      for (Edge edge : ListSequence.fromList(edgeHistory)) {
        if (cur == edge.getSource()) {
          ListSequence.fromList(edgeLayout).addSequence(ListSequence.fromList(copyLayout.getLayoutFor(edge)));
        } else {
          ListSequence.fromList(edgeLayout).addSequence(ListSequence.fromList(copyLayout.getLayoutFor(edge)).reversedList());
        }
        cur = edge.getOpposite(cur);
      }
      ListSequence.fromList(edgeLayout).insertElement(0, graphLayout.getLayoutFor(graphEdge.getSource()));
      ListSequence.fromList(edgeLayout).addElement(graphLayout.getLayoutFor(graphEdge.getTarget()));
      graphLayout.setLayoutFor(graphEdge, edgeLayout);
    }
    return graphLayout;
  }

  public GraphLayoutPoint getFlowLayout(EmbeddedGraph embeddedGraph, Set<Edge> edgesToBeStraight) {
    Graph graph = embeddedGraph.getGraph();
    List<Edge> oldEdges = ListSequence.fromList(new ArrayList<Edge>());
    ListSequence.fromList(oldEdges).addSequence(ListSequence.fromList(graph.getEdges()));
    List<Node> oldNodes = ListSequence.fromList(new ArrayList<Node>());
    ListSequence.fromList(oldNodes).addSequence(ListSequence.fromList(graph.getNodes()));
    Map<Dart, Integer> bends = MapSequence.fromMap(new HashMap<Dart, Integer>());
    Map<Dart, Integer> angles = MapSequence.fromMap(new HashMap<Dart, Integer>());
    OrthogonalRepresentation.getRepresentation(embeddedGraph, edgesToBeStraight, bends, angles);
    if (SHOW_INFO > 0) {
      System.out.println("bends:");
      System.out.println(bends);
    }
    OrthogonalRepresentation.replaceBendsByNodes(embeddedGraph, bends, angles);
    Map<Dart, Direction2D> directions = OrthogonalRepresentation.getDirections(embeddedGraph, angles);
    if (SHOW_INFO > 0) {
      this.printEmbeddedGraphWithDirections(embeddedGraph, directions);
    }
    makeRectangularFaces(embeddedGraph, directions);
    if (SHOW_INFO > 0) {
      System.out.println("after making faces rectangular: ");
      printEmbeddedGraphWithDirections(embeddedGraph, directions);
    }
    Map<Edge, Integer> lengths = new EdgeLengthComputer().compute(embeddedGraph, directions);
    OrthogonalPointLayouter.CoordinatePlacerDfs dfs = new OrthogonalPointLayouter.CoordinatePlacerDfs(embeddedGraph, lengths, directions);
    dfs.doDfs(graph, Edge.Direction.BOTH);

    Map<Node, Point> coordinates = dfs.getCoordinates();
    GraphLayoutPoint graphLayout = new GraphLayoutPoint(graph);
    for (Node node : ListSequence.fromList(oldNodes)) {
      graphLayout.setLayoutFor(node, MapSequence.fromMap(coordinates).get(node));
    }
    for (Edge edge : ListSequence.fromList(oldEdges)) {
      List<Edge> history = embeddedGraph.findFullHistory(edge);
      List<Point> edgeLayout = ListSequence.fromList(new ArrayList<Point>());
      Node cur = edge.getSource();
      ListSequence.fromList(edgeLayout).addElement(MapSequence.fromMap(coordinates).get(cur));
      for (Edge historyEdge : ListSequence.fromList(history)) {
        Node next = historyEdge.getOpposite(cur);
        ListSequence.fromList(edgeLayout).addElement(MapSequence.fromMap(coordinates).get(next));
        cur = next;
      }
      graphLayout.setLayoutFor(edge, edgeLayout);
    }
    GraphLayoutPoint copyLayout = new GraphLayoutPoint(graph);
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      copyLayout.setLayoutFor(node, MapSequence.fromMap(coordinates).get(node));
    }
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      List<Point> edgeLayout = ListSequence.fromList(new ArrayList<Point>());
      ListSequence.fromList(edgeLayout).addElement(new Point(MapSequence.fromMap(coordinates).get(edge.getSource())));
      ListSequence.fromList(edgeLayout).addElement(new Point(MapSequence.fromMap(coordinates).get(edge.getTarget())));
      copyLayout.setLayoutFor(edge, edgeLayout);
    }
    return graphLayout;
  }

  private void printEmbeddedGraphWithDirections(EmbeddedGraph embeddedGraph, Map<Dart, Direction2D> directions) {
    System.out.println("after replacing bends by nodes: ");
    for (Face face : ListSequence.fromList(embeddedGraph.getFaces())) {
      System.out.println("face: ");
      if (embeddedGraph.isOuterFace(face)) {
        System.out.println("outer!");
      }
      for (Dart dart : ListSequence.fromList(face.getDarts())) {
        System.out.print(dart + " dir = " + MapSequence.fromMap(directions).get(dart) + "; ");
      }
      System.out.println();
    }
  }

  public Set<Edge> reduceNodesDegree(EmbeddedGraph embeddedGraph, Map<Node, List<Node>> nodeMap, Map<Edge, Edge> edgeMap) {
    Graph graph = embeddedGraph.getGraph();
    Set<Edge> addedEdges = SetSequence.fromSet(new HashSet<Edge>());
    List<Node> realNodes = ListSequence.fromList(new ArrayList<Node>());
    ListSequence.fromList(realNodes).addSequence(ListSequence.fromList(graph.getNodes()));
    for (final Node node : ListSequence.fromList(realNodes)) {
      List<Edge> edges = node.getEdges();
      if (ListSequence.fromList(edges).count() <= 4) {
        continue;
      }
      List<Node> newNodes = ListSequence.fromList(new ArrayList<Node>());
      MapSequence.fromMap(nodeMap).put(node, newNodes);
      Edge firstEdge = ListSequence.fromList(edges).first();
      Dart firstDart = ListSequence.fromList(embeddedGraph.getDarts(firstEdge)).findFirst(new IWhereFilter<Dart>() {
        public boolean accept(Dart dart) {
          return dart.getSource() == node;
        }
      });
      Dart curDart = firstDart;
      Node firstNewNode = graph.addDummyNode();
      Node curNewNode = firstNewNode;
      Edge firstNewEdge = firstNewNode.addEdgeTo(firstEdge.getOpposite(node));
      if (firstEdge.getSource() == node) {
        firstEdge.revert();
      }
      ListSequence.fromList(newNodes).addElement(firstNewNode);
      MapSequence.fromMap(edgeMap).put(firstEdge, firstNewEdge);
      Edge curNewEdge = firstNewEdge;
      Face newFace = new Face(graph);
      do {
        Face curFace = embeddedGraph.getFace(curDart);
        List<Dart> darts = curFace.getDarts();
        int curPos = ListSequence.fromList(darts).indexOf(curDart);
        int nextPos = curPos - 1;
        if (nextPos == -1) {
          nextPos = ListSequence.fromList(darts).count() - 1;
        }
        Dart nextDart = embeddedGraph.getOpposite(ListSequence.fromList(darts).getElement(nextPos));
        if (nextDart == null) {
          nextDart = firstDart;
        }
        Node oppositeNode = nextDart.getEdge().getOpposite(node);
        Node nextNewNode;
        if (nextDart == firstDart) {
          nextNewNode = firstNewNode;
        } else {
          nextNewNode = graph.addDummyNode();
          ListSequence.fromList(newNodes).addElement(nextNewNode);
        }
        Edge nextNewEdge;
        if (nextDart == firstDart) {
          nextNewEdge = firstNewEdge;
        } else {
          nextNewEdge = nextNewNode.addEdgeTo(oppositeNode);
          if (firstEdge.getSource() == node) {
            firstEdge.revert();
          }
          MapSequence.fromMap(edgeMap).put(nextDart.getEdge(), nextNewEdge);
        }
        Edge edgeBetweenNewNodes = curNewNode.addEdgeTo(nextNewNode);
        SetSequence.fromSet(addedEdges).addElement(edgeBetweenNewNodes);
        newFace.addLast(new Dart(edgeBetweenNewNodes, curNewNode));
        embeddedGraph.setDart(curFace, nextPos, new Dart(nextNewEdge, oppositeNode));
        embeddedGraph.setDart(curFace, curPos, new Dart(curNewEdge, curNewNode));
        embeddedGraph.insertDart(curFace, nextPos + 1, new Dart(edgeBetweenNewNodes, nextNewNode));
        curDart = nextDart;
        curNewNode = nextNewNode;
        curNewEdge = nextNewEdge;
      } while (curDart != firstDart);
      embeddedGraph.addFace(newFace);
      graph.remove(node);
    }
    return addedEdges;
  }

  public void makeRectangularFaces(EmbeddedGraph embeddedGraph, Map<Dart, Direction2D> direction) {
    List<Face> faces = ListSequence.fromList(new ArrayList<Face>());
    ListSequence.fromList(faces).addSequence(ListSequence.fromList(embeddedGraph.getFaces()));
    for (Face face : ListSequence.fromList(faces)) {
      if (embeddedGraph.isOuterFace(face)) {
        continue;
      }
      makeFaceRectangle(embeddedGraph, face, direction);
    }
  }

  public void makeFaceRectangle(EmbeddedGraph embeddedGraph, Face face, Map<Dart, Direction2D> direction) {
    Dart badDart = null;
    List<Dart> darts = face.getDarts();
    Iterator<Dart> dartItr = ListSequence.fromList(darts).iterator();
    Dart prev = ListSequence.fromList(darts).last();
    int sum = 0;
    while (dartItr.hasNext() && badDart == null) {
      Dart cur = dartItr.next();
      int turn = MapSequence.fromMap(direction).get(prev).getTurn(MapSequence.fromMap(direction).get(cur));
      if (turn < 0) {
        badDart = prev;
        sum = turn;
      }
      prev = cur;
    }
    while (sum != 1) {
      if (!(dartItr.hasNext())) {
        dartItr = ListSequence.fromList(darts).iterator();
      }
      Dart cur = dartItr.next();
      sum += MapSequence.fromMap(direction).get(prev).getTurn(MapSequence.fromMap(direction).get(cur));
      prev = cur;
    }
    if (badDart != null) {
      List<Edge> newEdges = ListSequence.fromList(new ArrayList<Edge>());
      Dart prevOpposite = embeddedGraph.getOpposite(prev);
      Node newNode = embeddedGraph.splitEdge(prev.getEdge(), newEdges);
      for (Edge newEdge : ListSequence.fromList(newEdges)) {
        for (Dart newDart : ListSequence.fromList(embeddedGraph.getDarts(newEdge))) {
          if (embeddedGraph.getFace(newDart) == face) {
            MapSequence.fromMap(direction).put(newDart, MapSequence.fromMap(direction).get(prev));
          } else {
            MapSequence.fromMap(direction).put(newDart, MapSequence.fromMap(direction).get(prev).opposite());
          }
        }
      }
      MapSequence.fromMap(direction).removeKey(prev);
      MapSequence.fromMap(direction).removeKey(prevOpposite);
      Node badCorner = badDart.getTarget();
      Edge splitEdge = badCorner.addEdgeTo(newNode);
      List<Face> newFaces = embeddedGraph.splitFace(face, ListSequence.fromListAndArray(new ArrayList<Edge>(), splitEdge), badCorner, newNode);
      for (Dart dart : ListSequence.fromList(embeddedGraph.getDarts(splitEdge))) {
        if (dart.getSource() == badCorner) {
          MapSequence.fromMap(direction).put(dart, MapSequence.fromMap(direction).get(badDart));
        } else {
          MapSequence.fromMap(direction).put(dart, MapSequence.fromMap(direction).get(badDart).opposite());
        }
      }
      for (Face newFace : ListSequence.fromList(newFaces)) {
        makeFaceRectangle(embeddedGraph, newFace, direction);
      }
    }
  }

  public class CoordinatePlacerDfs extends Dfs {
    private Map<Node, Point> myCoordinates;
    private Map<Edge, Integer> myLenghts;
    private Map<Dart, Direction2D> myDirections;
    private EmbeddedGraph myEmbeddedGraph;

    public CoordinatePlacerDfs(EmbeddedGraph embeddedGraph, Map<Edge, Integer> lengths, Map<Dart, Direction2D> directions) {
      myCoordinates = MapSequence.fromMap(new HashMap<Node, Point>());
      myLenghts = lengths;
      myDirections = directions;
      myEmbeddedGraph = embeddedGraph;
    }

    @Override
    protected void preprocessRoot(Node root) {
      MapSequence.fromMap(myCoordinates).put(root, new Point(10, 10));
    }

    @Override
    protected void preprocess(Node node, Edge from) {
      if (from == null) {
        return;
      }
      final Node source = from.getOpposite(node);
      int x = MapSequence.fromMap(myCoordinates).get(source).x;
      int y = MapSequence.fromMap(myCoordinates).get(source).y;
      Dart dart = ListSequence.fromList(myEmbeddedGraph.getDarts(from)).findFirst(new IWhereFilter<Dart>() {
        public boolean accept(Dart dart) {
          return dart.getSource() == source;
        }
      });
      if (MapSequence.fromMap(myDirections).get(dart) == Direction2D.RIGHT) {
        x += OrthogonalPointLayouter.UNIT_LENGHT * MapSequence.fromMap(myLenghts).get(from);
      }
      if (MapSequence.fromMap(myDirections).get(dart) == Direction2D.LEFT) {
        x -= OrthogonalPointLayouter.UNIT_LENGHT * MapSequence.fromMap(myLenghts).get(from);
      }
      if (MapSequence.fromMap(myDirections).get(dart) == Direction2D.UP) {
        y += OrthogonalPointLayouter.UNIT_LENGHT * MapSequence.fromMap(myLenghts).get(from);
      }
      if (MapSequence.fromMap(myDirections).get(dart) == Direction2D.DOWN) {
        y -= OrthogonalPointLayouter.UNIT_LENGHT * MapSequence.fromMap(myLenghts).get(from);
      }
      MapSequence.fromMap(myCoordinates).put(node, new Point(x, y));
    }

    public Map<Node, Point> getCoordinates() {
      return myCoordinates;
    }
  }
}
