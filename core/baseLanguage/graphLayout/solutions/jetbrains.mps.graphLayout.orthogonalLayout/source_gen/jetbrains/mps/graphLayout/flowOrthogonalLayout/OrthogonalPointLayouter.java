package jetbrains.mps.graphLayout.flowOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graphLayout.ILayouter;
import jetbrains.mps.graphLayout.graphLayout.GraphLayoutPoint;
import jetbrains.mps.graphLayout.graph.Graph;
import java.util.Set;
import jetbrains.mps.graphLayout.graph.Edge;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.graphLayout.algorithms.BiconnectAugmentation;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.planarization.ShortestPathEmbeddingFinder;
import jetbrains.mps.graphLayout.planarization.PQPlanarizationFinder;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.awt.Point;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.algorithms.Dfs;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class OrthogonalPointLayouter implements ILayouter {
  private static int UNIT_LENGHT = 1;

  public OrthogonalPointLayouter() {
  }

  public GraphLayoutPoint doLayout(Graph graph) {
    Set<Edge> newEdges = reduceNodesDegree(graph);
    Graph copy = new Graph();
    Map<Node, Node> nodeMap = MapSequence.fromMap(new HashMap<Node, Node>());
    final Map<Edge, Edge> edgeMap = MapSequence.fromMap(new HashMap<Edge, Edge>());
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      MapSequence.fromMap(nodeMap).put(node, copy.addNode());
    }
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      MapSequence.fromMap(edgeMap).put(edge, MapSequence.fromMap(nodeMap).get(edge.getSource()).addEdgeTo(MapSequence.fromMap(nodeMap).get(edge.getTarget())));
    }
    BiconnectAugmentation.smartMakeBiconnected(copy);
    int num = copy.getNumNodes();
    EmbeddedGraph embeddedGraph = new ShortestPathEmbeddingFinder(new PQPlanarizationFinder()).find(copy);
    System.out.println("*--------------------------------------------------------------*");
    System.out.println("INFO: added " + (copy.getNumNodes() - num) + " edge crossings!!!");
    System.out.println("*--------------------------------------------------------------*");
    Map<Dart, Integer> bends = MapSequence.fromMap(new HashMap<Dart, Integer>());
    Map<Dart, Integer> angles = MapSequence.fromMap(new HashMap<Dart, Integer>());
    Set<Edge> copyEdges = SetSequence.fromSet(new HashSet<Edge>());
    SetSequence.fromSet(copyEdges).addSequence(SetSequence.fromSet(newEdges).select(new ISelector<Edge, Edge>() {
      public Edge select(Edge edge) {
        return MapSequence.fromMap(edgeMap).get(edge);
      }
    }));
    OrthogonalRepresentation.getRepresentation(embeddedGraph, copyEdges, bends, angles);
    OrthogonalRepresentation.replaceBendsByNodes(embeddedGraph, bends, angles);
    Map<Dart, Integer> directions = OrthogonalRepresentation.getDirections(embeddedGraph, angles);
    Map<Edge, Integer> lengths = new EdgeLengthComputer().compute(embeddedGraph, directions);
    OrthogonalPointLayouter.CoordinatePlacerDfs dfs = new OrthogonalPointLayouter.CoordinatePlacerDfs(embeddedGraph, lengths, directions);
    dfs.doDfs(copy, Edge.Direction.BOTH);
    Map<Node, Point> coordinates = dfs.getCoordinates();
    GraphLayoutPoint layout = new GraphLayoutPoint(graph);
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      layout.setLayoutFor(node, MapSequence.fromMap(coordinates).get(MapSequence.fromMap(nodeMap).get(node)));
    }
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      List<Point> edgeLayout = ListSequence.fromList(new ArrayList<Point>());
      Edge copyEdge = MapSequence.fromMap(edgeMap).get(edge);
      List<Edge> history = embeddedGraph.findFullHistory(copyEdge);
      ListSequence.fromList(edgeLayout).addElement(new Point(MapSequence.fromMap(coordinates).get(ListSequence.fromList(history).first().getSource())));
      for (Edge historyEdge : ListSequence.fromList(history)) {
        ListSequence.fromList(edgeLayout).addElement(new Point(MapSequence.fromMap(coordinates).get(historyEdge.getTarget())));
      }
      layout.setLayoutFor(edge, edgeLayout);
    }
    return layout;
  }

  public Set<Edge> reduceNodesDegree(Graph graph) {
    Set<Edge> newEdges = SetSequence.fromSet(new HashSet<Edge>());
    List<Node> realNodes = ListSequence.fromList(new ArrayList<Node>());
    ListSequence.fromList(realNodes).addSequence(ListSequence.fromList(graph.getNodes()));
    for (Node node : ListSequence.fromList(realNodes)) {
      List<Edge> edges = node.getEdges();
      if (ListSequence.fromList(edges).count() > 4) {
        ListSequence.fromList(edges).removeLastElement();
        List<Node> newNodes = ListSequence.fromList(new ArrayList<Node>());
        ListSequence.fromList(newNodes).addElement(node);
        for (Edge edge : ListSequence.fromList(edges)) {
          Node newNode = graph.addDummyNode();
          ListSequence.fromList(newNodes).addElement(newNode);
          newNode.addEdgeTo(edge.getOpposite(node));
          edge.removeFromGraph();
        }
        Node prev = null;
        for (Node cur : ListSequence.fromList(newNodes)) {
          if (prev == null) {
            SetSequence.fromSet(newEdges).addElement(cur.addEdgeTo(ListSequence.fromList(newNodes).last()));
          } else {
            SetSequence.fromSet(newEdges).addElement(cur.addEdgeTo(prev));
          }
          prev = cur;
        }
      }
    }
    return newEdges;
  }

  public class CoordinatePlacerDfs extends Dfs {
    private Map<Node, Point> myCoordinates;
    private Map<Edge, Integer> myLenghts;
    private Map<Dart, Integer> myDirections;
    private EmbeddedGraph myEmbeddedGraph;

    public CoordinatePlacerDfs(EmbeddedGraph embeddedGraph, Map<Edge, Integer> lengths, Map<Dart, Integer> directions) {
      myCoordinates = MapSequence.fromMap(new HashMap<Node, Point>());
      myLenghts = lengths;
      myDirections = directions;
      myEmbeddedGraph = embeddedGraph;
    }

    @Override
    protected void preprocessRoot(Node root) {
      MapSequence.fromMap(myCoordinates).put(root, new Point(5, 5));
    }

    @Override
    protected void preprocess(Node node, Edge from) {
      if (from == null) {
        return;
      }
      final Node source = from.getOpposite(node);
      int x = MapSequence.fromMap(myCoordinates).get(source).x;
      int y = MapSequence.fromMap(myCoordinates).get(source).y;
      Dart dart = ListSequence.fromList(myEmbeddedGraph.getDarts(from)).findFirst(new IWhereFilter<Dart>() {
        public boolean accept(Dart dart) {
          return dart.getSource() == source;
        }
      });
      if (MapSequence.fromMap(myDirections).get(dart) == OrthogonalRepresentation.RIGHT) {
        x += OrthogonalPointLayouter.UNIT_LENGHT * MapSequence.fromMap(myLenghts).get(from);
      }
      if (MapSequence.fromMap(myDirections).get(dart) == OrthogonalRepresentation.LEFT) {
        x -= OrthogonalPointLayouter.UNIT_LENGHT * MapSequence.fromMap(myLenghts).get(from);
      }
      if (MapSequence.fromMap(myDirections).get(dart) == OrthogonalRepresentation.UP) {
        y += OrthogonalPointLayouter.UNIT_LENGHT * MapSequence.fromMap(myLenghts).get(from);
      }
      if (MapSequence.fromMap(myDirections).get(dart) == OrthogonalRepresentation.DOWN) {
        y -= OrthogonalPointLayouter.UNIT_LENGHT * MapSequence.fromMap(myLenghts).get(from);
      }
      MapSequence.fromMap(myCoordinates).put(node, new Point(x, y));
    }

    public Map<Node, Point> getCoordinates() {
      return myCoordinates;
    }
  }
}
