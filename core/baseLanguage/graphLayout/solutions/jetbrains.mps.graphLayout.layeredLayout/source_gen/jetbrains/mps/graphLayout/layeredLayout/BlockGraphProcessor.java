package jetbrains.mps.graphLayout.layeredLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.graphLayout.algorithms.Dfs;
import jetbrains.mps.graphLayout.graph.Edge;

public class BlockGraphProcessor {
  private int[] myClasses;
  private int[] myNumInEdges;
  private int[] myShift;
  private int[] myPosition;
  private int myMaxClass;

  public BlockGraphProcessor() {
  }

  public void process(Graph blockGraph) {
    BlockGraphProcessor.ClassesFinder finder = new BlockGraphProcessor.ClassesFinder();
    finder.doDfs(blockGraph);
    int curClass = 1;
    myShift = new int[myMaxClass + 1];
    myPosition = new int[blockGraph.getNumNodes()];
    for (Node node : ListSequence.fromList(blockGraph.getNodes())) {
      if (myClasses[node.getIndex()] == curClass) {
      }
      curClass++;
    }
    debugInfo();
  }

  private void debugInfo() {
    System.out.println("block graph processing:");
    System.out.println("num of classes: " + myMaxClass);
    System.out.println("classes:");
    for (int i = 0; i < myClasses.length; i++) {
      System.out.print(i + ": " + myClasses[i] + ", ");
    }
    System.out.println();
    System.out.println("num of in class edges:");
    for (int i = 0; i < myNumInEdges.length; i++) {
      System.out.print(i + ": " + myNumInEdges[i] + ", ");
    }
    System.out.println();
  }

  private void processClass(int index) {
    if (myNumInEdges[index] > 0) {
      throw new RuntimeException("block graph has incorrect order of block nodes");
    }
    List<Integer> queue = ListSequence.fromList(new LinkedList<Integer>());
    ListSequence.fromList(queue).addElement(index);
    while (ListSequence.fromList(queue).count() > 0) {
    }
  }

  private class ClassesFinder extends Dfs {
    public ClassesFinder() {
    }

    @Override
    protected void preprocess(Node node) {
      myClasses[node.getIndex()] = myMaxClass;
    }

    @Override
    protected void processEdge(Edge edge) {
      int sourceIndex = edge.getSource().getIndex();
      int targetIndex = edge.getTarget().getIndex();
      if (myClasses[targetIndex] == 0 || myClasses[sourceIndex] == myClasses[targetIndex]) {
        myNumInEdges[targetIndex]++;
      }
    }

    @Override
    protected void processRoot() {
      myMaxClass++;
    }

    @Override
    public void doDfs(Graph graph) {
      myMaxClass = 0;
      myClasses = new int[graph.getNumNodes()];
      myNumInEdges = new int[graph.getNumNodes()];
      super.doDfs(graph);
    }
  }
}
