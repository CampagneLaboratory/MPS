package jetbrains.mps.graphLayout.layeredLayout;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.graphLayout.graph.Edge;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import java.awt.Point;
import jetbrains.mps.graphLayout.graph.Graph;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Comparator;

public class BKCoordinatePlacer implements ICoordinatePlacer {
  private int[] myPosInLayer;
  private Set<Edge> badEdges;

  public BKCoordinatePlacer() {
  }

  public Map<Node, Point> placeCoordinates(Graph graph, NodeLayeredOrder order) {
    myPosInLayer = new int[graph.getNumNodes()];
    for (int layer = 0; layer < order.getNumLayers(); layer++) {
      List<Integer> layerOrder = order.getIntOrder(layer);
      for (int pos = 0; pos < ListSequence.fromList(layerOrder).count(); pos++) {
        myPosInLayer[ListSequence.fromList(layerOrder).getElement(pos)] = pos;
      }
    }
    badEdges = SetSequence.fromSet(new HashSet<Edge>());
    for (int layer = 0; layer < order.getNumLayers() - 1; layer++) {
      SetSequence.fromSet(badEdges).addSequence(SetSequence.fromSet(findBadEdgesInLayer(order.getOrder(layer))));
    }
    int[] roots = computeBlocks(order);
    return null;
  }

  public int[] getRoots(NodeLayeredOrder order) {
    Graph graph = order.getGraph();
    myPosInLayer = new int[graph.getNumNodes()];
    for (int layer = 0; layer < order.getNumLayers(); layer++) {
      List<Integer> layerOrder = order.getIntOrder(layer);
      for (int pos = 0; pos < ListSequence.fromList(layerOrder).count(); pos++) {
        myPosInLayer[ListSequence.fromList(layerOrder).getElement(pos)] = pos;
      }
    }
    badEdges = SetSequence.fromSet(new HashSet<Edge>());
    for (int layer = 0; layer < order.getNumLayers() - 1; layer++) {
      SetSequence.fromSet(badEdges).addSequence(SetSequence.fromSet(findBadEdgesInLayer(order.getOrder(layer))));
    }
    return computeBlocks(order);
  }

  private Set<Edge> findBadEdgesInLayer(List<Node> layerOrder) {
    Set<Edge> badEdges = SetSequence.fromSet(new HashSet<Edge>());
    int p1 = -1;
    int p2 = -1;
    for (Node node : ListSequence.fromList(layerOrder)) {
      if (node.isDummy()) {
        p2 = getOppositePos(node);
        break;
      }
    }
    if (p2 > -1) {
      for (Node node : ListSequence.fromList(layerOrder)) {
        if (node.isDummy()) {
          p1 = p2;
          p2 = getOppositePos(node);
        } else {
          for (Edge edge : ListSequence.fromList(node.getOutEdges())) {
            int targetPos = myPosInLayer[edge.getTarget().getIndex()];
            if (targetPos < p1 || targetPos > p2) {
              SetSequence.fromSet(badEdges).addElement(edge);
            }
          }
        }
      }
    }
    return badEdges;

  }

  private int getOppositePos(Node dummyNode) {
    return myPosInLayer[ListSequence.fromList(dummyNode.getOutEdges()).getElement(0).getTarget().getIndex()];
  }

  private int[] computeBlocks(NodeLayeredOrder order) {
    Graph graph = order.getGraph();
    int[] roots = new int[graph.getNumNodes()];
    for (int i = 0; i < roots.length; i++) {
      roots[i] = i;
    }
    for (int layer = 1; layer < order.getNumLayers(); layer++) {
      int curConnectedPos = -1;
      for (int index : ListSequence.fromList(order.getIntOrder(layer))) {
        Node node = graph.getNode(index);
        List<Edge> sortedByPos = ListSequence.fromList(node.getInEdges()).sort(new Comparator<Edge>() {
          public int compare(Edge a, Edge b) {
            int aSourceIndex = a.getSource().getIndex();
            int bSourceIndex = b.getSource().getIndex();
            return myPosInLayer[aSourceIndex] - myPosInLayer[bSourceIndex];
          }
        }, true).toListSequence();
        Edge medianEdge = ListSequence.fromList(sortedByPos).getElement(ListSequence.fromList(sortedByPos).count() / 2);
        if (roots[index] == index) {
          curConnectedPos = this.tryToAddRoot(index, roots, medianEdge, curConnectedPos);
        }
        medianEdge = ListSequence.fromList(sortedByPos).getElement((ListSequence.fromList(sortedByPos).count() + 1) / 2);
        if (roots[index] == index) {
          curConnectedPos = this.tryToAddRoot(index, roots, medianEdge, curConnectedPos);
        }
      }
    }
    return roots;
  }

  private int tryToAddRoot(int index, int[] roots, Edge edge, int curConnectedPos) {
    int medianIndex = edge.getSource().getIndex();
    if (!(SetSequence.fromSet(badEdges).contains(edge)) && myPosInLayer[medianIndex] > curConnectedPos) {
      roots[index] = roots[medianIndex];
      curConnectedPos = myPosInLayer[medianIndex];
    }
    return curConnectedPos;
  }
}
