package jetbrains.mps.graphLayout.layeredLayout;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import java.util.Set;
import jetbrains.mps.graphLayout.graph.Edge;
import java.awt.Point;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Comparator;

public class BKCoordinatePlacer implements ICoordinatePlacer {
  private int[] myPosInLayer;
  private int[] myNumLayer;
  private Map<Integer, Node> myRoots;
  private Set<Edge> badEdges;

  public BKCoordinatePlacer() {
  }

  public Map<Node, Point> placeCoordinates(Graph graph, NodeLayeredOrder order) {
    this.init(graph, order);
    int[] roots = computeBlocks(order);
    Graph blockGraph = this.createBlockGraph(order, roots);
    NodeLayers layers = new BlockGraphProcessor().process(blockGraph);
    Map<Node, Point> coord = MapSequence.fromMap(new HashMap<Node, Point>());
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      int index = node.getIndex();
      MapSequence.fromMap(coord).put(node, new Point(layers.get(MapSequence.fromMap(myRoots).get(roots[index])), myNumLayer[index]));
    }
    return coord;
  }

  public Graph createBlockGraph(NodeLayeredOrder order, int[] roots) {
    Graph blockGraph = new Graph();
    myRoots = MapSequence.fromMap(new HashMap<Integer, Node>());
    for (int layer = 0; layer < order.getNumLayers(); layer++) {
      Node prevBlock = null;
      for (int index : ListSequence.fromList(order.getIntOrder(layer))) {
        if (roots[index] == index) {
          MapSequence.fromMap(myRoots).put(index, blockGraph.addNode());
        }
        Node currentBlock = MapSequence.fromMap(myRoots).get(roots[index]);
        if (prevBlock != null) {
          prevBlock.addEdgeTo(currentBlock);
        }
        prevBlock = currentBlock;
      }
    }
    return blockGraph;
  }

  public void init(Graph graph, NodeLayeredOrder order) {
    myPosInLayer = new int[graph.getNumNodes()];
    myNumLayer = new int[graph.getNumNodes()];
    for (int layer = 0; layer < order.getNumLayers(); layer++) {
      List<Integer> layerOrder = order.getIntOrder(layer);
      for (int pos = 0; pos < ListSequence.fromList(layerOrder).count(); pos++) {
        myPosInLayer[ListSequence.fromList(layerOrder).getElement(pos)] = pos;
        myNumLayer[ListSequence.fromList(layerOrder).getElement(pos)] = layer;
      }
    }
    badEdges = SetSequence.fromSet(new HashSet<Edge>());
    for (int layer = 0; layer < order.getNumLayers() - 1; layer++) {
      SetSequence.fromSet(badEdges).addSequence(SetSequence.fromSet(findBadEdgesInLayer(order.getOrder(layer))));
    }
  }

  private Set<Edge> findBadEdgesInLayer(List<Node> layerOrder) {
    Set<Edge> badEdges = SetSequence.fromSet(new HashSet<Edge>());
    int closestInnerEdgePos = -1;
    for (int i = 0; i < ListSequence.fromList(layerOrder).count(); i++) {
      Node node = ListSequence.fromList(layerOrder).getElement(i);
      if (isInnerDummy(node)) {
        closestInnerEdgePos = getOppositePos(node);
      } else {
        for (Edge edge : ListSequence.fromList(node.getOutEdges())) {
          int targetPos = myPosInLayer[edge.getTarget().getIndex()];
          if (targetPos < closestInnerEdgePos) {
            SetSequence.fromSet(badEdges).addElement(edge);
          }
        }
      }
    }
    closestInnerEdgePos = ListSequence.fromList(layerOrder).count() + 1;
    for (int i = ListSequence.fromList(layerOrder).count() - 1; i >= 0; i--) {
      Node node = ListSequence.fromList(layerOrder).getElement(i);
      if (isInnerDummy(node)) {
        closestInnerEdgePos = getOppositePos(node);
      } else {
        for (Edge edge : ListSequence.fromList(node.getOutEdges())) {
          int targetPos = myPosInLayer[edge.getTarget().getIndex()];
          if (targetPos > closestInnerEdgePos) {
            SetSequence.fromSet(badEdges).addElement(edge);
          }
        }
      }
    }
    return badEdges;
  }

  private boolean isInnerDummy(Node node) {
    if (ListSequence.fromList(node.getOutEdges()).count() != 1) {
      return false;
    }
    Edge edge = ListSequence.fromList(node.getOutEdges()).getElement(0);
    return edge.getSource().isDummy() && edge.getTarget().isDummy();
  }

  private int getOppositePos(Node dummyNode) {
    return myPosInLayer[ListSequence.fromList(dummyNode.getOutEdges()).getElement(0).getTarget().getIndex()];
  }

  public int[] computeBlocks(NodeLayeredOrder order) {
    Graph graph = order.getGraph();
    int[] roots = new int[graph.getNumNodes()];
    for (int i = 0; i < roots.length; i++) {
      roots[i] = i;
    }
    for (int layer = 1; layer < order.getNumLayers(); layer++) {
      int curConnectedPos = -1;
      for (int index : ListSequence.fromList(order.getIntOrder(layer))) {
        Node node = graph.getNode(index);
        List<Edge> sortedByPos = ListSequence.fromList(node.getInEdges()).sort(new Comparator<Edge>() {
          public int compare(Edge a, Edge b) {
            int aSourceIndex = a.getSource().getIndex();
            int bSourceIndex = b.getSource().getIndex();
            return myPosInLayer[aSourceIndex] - myPosInLayer[bSourceIndex];
          }
        }, true).toListSequence();
        Edge medianEdge = ListSequence.fromList(sortedByPos).getElement((ListSequence.fromList(sortedByPos).count() - 1) / 2);
        if (roots[index] == index) {
          curConnectedPos = this.tryToAddRoot(index, roots, medianEdge, curConnectedPos);
        }
        medianEdge = ListSequence.fromList(sortedByPos).getElement((ListSequence.fromList(sortedByPos).count()) / 2);
        if (roots[index] == index) {
          curConnectedPos = this.tryToAddRoot(index, roots, medianEdge, curConnectedPos);
        }
      }
    }
    return roots;
  }

  private int tryToAddRoot(int index, int[] roots, Edge edge, int curConnectedPos) {
    int medianIndex = edge.getSource().getIndex();
    if (!(SetSequence.fromSet(badEdges).contains(edge)) && myPosInLayer[medianIndex] > curConnectedPos) {
      roots[index] = roots[medianIndex];
      curConnectedPos = myPosInLayer[medianIndex];
    }
    return curConnectedPos;
  }
}
