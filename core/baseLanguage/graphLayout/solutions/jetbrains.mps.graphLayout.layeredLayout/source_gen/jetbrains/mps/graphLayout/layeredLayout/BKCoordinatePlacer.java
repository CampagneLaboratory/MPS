package jetbrains.mps.graphLayout.layeredLayout;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import java.util.Set;
import jetbrains.mps.graphLayout.graph.Edge;
import java.awt.Point;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.graphLayout.util.NodeMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Comparator;

public class BKCoordinatePlacer implements ICoordinatePlacer {
  private Map<Node, Integer> myPosInLayer;
  private Map<Node, Integer> myNumLayer;
  private Map<Node, Node> myBlocks;
  private Set<Edge> badEdges;

  public BKCoordinatePlacer() {
  }

  public Map<Node, Point> placeCoordinates(Graph graph, NodeLayeredOrder order) {
    this.init(graph, order);
    Map<Node, Node> roots = computeBlocks(order);
    Graph blockGraph = this.createBlockGraph(order, roots);
    Map<Node, Integer> layers = new BlockGraphProcessor().process(blockGraph);
    Map<Node, Point> coord = MapSequence.fromMap(new HashMap<Node, Point>());
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      MapSequence.fromMap(coord).put(node, new Point(layers.get(MapSequence.fromMap(myBlocks).get(MapSequence.fromMap(roots).get(node))), MapSequence.fromMap(myNumLayer).get(node)));
    }
    return coord;
  }

  public Graph createBlockGraph(NodeLayeredOrder order, Map<Node, Node> roots) {
    Graph blockGraph = new Graph();
    myBlocks = MapSequence.fromMap(new HashMap<Node, Node>());
    for (int layer = 0; layer < order.getNumLayers(); layer++) {
      Node prevBlock = null;
      for (Node node : ListSequence.fromList(order.getOrder(layer))) {
        if (MapSequence.fromMap(roots).get(node) == node) {
          MapSequence.fromMap(myBlocks).put(node, blockGraph.addNode());
        }
        Node currentBlock = MapSequence.fromMap(myBlocks).get(MapSequence.fromMap(roots).get(node));
        if (prevBlock != null) {
          prevBlock.addEdgeTo(currentBlock);
        }
        prevBlock = currentBlock;
      }
    }
    return blockGraph;
  }

  public void init(Graph graph, NodeLayeredOrder order) {
    myPosInLayer = new NodeMap<Integer>(graph);
    myNumLayer = new NodeMap<Integer>(graph);
    for (int layer = 0; layer < order.getNumLayers(); layer++) {
      List<Node> layerOrder = order.getOrder(layer);
      for (int pos = 0; pos < ListSequence.fromList(layerOrder).count(); pos++) {
        MapSequence.fromMap(myPosInLayer).put(ListSequence.fromList(layerOrder).getElement(pos), pos);
        MapSequence.fromMap(myNumLayer).put(ListSequence.fromList(layerOrder).getElement(pos), layer);
      }
    }
    badEdges = SetSequence.fromSet(new HashSet<Edge>());
    for (int layer = 0; layer < order.getNumLayers() - 1; layer++) {
      SetSequence.fromSet(badEdges).addSequence(SetSequence.fromSet(findBadEdgesInLayer(order.getOrder(layer))));
    }
  }

  private Set<Edge> findBadEdgesInLayer(List<Node> layerOrder) {
    Set<Edge> badEdges = SetSequence.fromSet(new HashSet<Edge>());
    int closestInnerEdgePos = -1;
    for (int i = 0; i < ListSequence.fromList(layerOrder).count(); i++) {
      Node node = ListSequence.fromList(layerOrder).getElement(i);
      if (isInnerDummy(node)) {
        closestInnerEdgePos = getOppositePos(node);
      } else {
        for (Edge edge : ListSequence.fromList(node.getOutEdges())) {
          int targetPos = MapSequence.fromMap(myPosInLayer).get(edge.getTarget());
          if (targetPos < closestInnerEdgePos) {
            SetSequence.fromSet(badEdges).addElement(edge);
          }
        }
      }
    }
    closestInnerEdgePos = ListSequence.fromList(layerOrder).count() + 1;
    for (int i = ListSequence.fromList(layerOrder).count() - 1; i >= 0; i--) {
      Node node = ListSequence.fromList(layerOrder).getElement(i);
      if (isInnerDummy(node)) {
        closestInnerEdgePos = getOppositePos(node);
      } else {
        for (Edge edge : ListSequence.fromList(node.getOutEdges())) {
          int targetPos = MapSequence.fromMap(myPosInLayer).get(edge.getTarget());
          if (targetPos > closestInnerEdgePos) {
            SetSequence.fromSet(badEdges).addElement(edge);
          }
        }
      }
    }
    return badEdges;
  }

  private boolean isInnerDummy(Node node) {
    if (ListSequence.fromList(node.getOutEdges()).count() != 1) {
      return false;
    }
    Edge edge = ListSequence.fromList(node.getOutEdges()).getElement(0);
    return edge.getSource().isDummy() && edge.getTarget().isDummy();
  }

  private int getOppositePos(Node dummyNode) {
    return MapSequence.fromMap(myPosInLayer).get(ListSequence.fromList(dummyNode.getOutEdges()).getElement(0).getTarget());
  }

  public Map<Node, Node> computeBlocks(NodeLayeredOrder order) {
    Graph graph = order.getGraph();
    Map<Node, Node> roots = new NodeMap<Node>(graph);
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      MapSequence.fromMap(roots).put(node, node);
    }
    for (int layer = 1; layer < order.getNumLayers(); layer++) {
      int curConnectedPos = -1;
      for (Node node : ListSequence.fromList(order.getOrder(layer))) {
        List<Edge> sortedByPos = ListSequence.fromList(node.getInEdges()).sort(new Comparator<Edge>() {
          public int compare(Edge a, Edge b) {
            Node aSource = a.getSource();
            Node bSource = b.getSource();
            return MapSequence.fromMap(myPosInLayer).get(aSource) - MapSequence.fromMap(myPosInLayer).get(bSource);
          }
        }, true).toListSequence();
        Edge medianEdge = ListSequence.fromList(sortedByPos).getElement((ListSequence.fromList(sortedByPos).count() - 1) / 2);
        if (MapSequence.fromMap(roots).get(node) == node) {
          curConnectedPos = this.tryToAddRoot(node, roots, medianEdge, curConnectedPos);
        }
        medianEdge = ListSequence.fromList(sortedByPos).getElement((ListSequence.fromList(sortedByPos).count()) / 2);
        if (MapSequence.fromMap(roots).get(node) == node) {
          curConnectedPos = this.tryToAddRoot(node, roots, medianEdge, curConnectedPos);
        }
      }
    }
    return roots;
  }

  private int tryToAddRoot(Node node, Map<Node, Node> roots, Edge edge, int curConnectedPos) {
    Node medianNode = edge.getSource();
    if (!(SetSequence.fromSet(badEdges).contains(edge)) && MapSequence.fromMap(myPosInLayer).get(medianNode) > curConnectedPos) {
      MapSequence.fromMap(roots).put(node, MapSequence.fromMap(roots).get(medianNode));
      curConnectedPos = MapSequence.fromMap(myPosInLayer).get(medianNode);
    }
    return curConnectedPos;
  }
}
