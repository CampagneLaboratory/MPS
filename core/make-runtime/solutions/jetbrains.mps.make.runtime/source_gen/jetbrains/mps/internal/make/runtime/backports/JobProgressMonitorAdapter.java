package jetbrains.mps.internal.make.runtime.backports;

/*Generated by MPS */

import jetbrains.mps.progress.ProgressMonitorBase;
import jetbrains.mps.make.script.IJobMonitor;

public class JobProgressMonitorAdapter extends ProgressMonitorBase {
  private static final int WORK_AMOUNT = 10000;

  private IJobMonitor myJobMonitor;
  private String myName;
  private String myStep;

  public JobProgressMonitorAdapter(IJobMonitor monitor) {
    myJobMonitor = monitor;
  }

  protected void update(double frac) {
    if (myName != null) {
      double currFrac = 1. - (double) myJobMonitor.currentProgress().workLeft() / WORK_AMOUNT;
      myJobMonitor.currentProgress().advanceWork(myName, (int) (WORK_AMOUNT * (Math.max(0., frac - currFrac))), myStep);
    }
  }

  protected void setStepInternal(String step) {
    myStep = step;
  }

  protected void setTitleInternal(String text) {
    if ("".equals(text)) {
      return;
    }

    if (myName != null && neq_ud0snj_a0a2a2(myName, text)) {
      myJobMonitor.currentProgress().finishWork(myName);
      myName = null;
    }
    myName = text;
    myJobMonitor.currentProgress().beginWork(text, WORK_AMOUNT, 0);
  }

  @Override
  public void done() {
    super.done();
    if (myName != null) {
      myJobMonitor.currentProgress().finishWork(myName);
      myName = null;
    }
  }

  public boolean isCanceled() {
    return myJobMonitor.stopRequested();
  }

  public void cancel() {
  }

  private static boolean neq_ud0snj_a0a2a2(Object a, Object b) {
    return !((a != null ?
      a.equals(b) :
      a == b
    ));
  }
}
