package jetbrains.mps.internal.make.runtime.backports;

/*Generated by MPS */

import jetbrains.mps.internal.make.runtime.script.AbstractProgressStrategy;
import jetbrains.mps.progress.ProgressMonitor;
import jetbrains.mps.progress.EmptyProgressMonitor;

public class ProgressMonitorProgressStrategy extends AbstractProgressStrategy {
  private static final String TOTAL = "__TOTAL__";
  private static final int MAXWORK = 10000;

  private ProgressMonitor monitor;
  private boolean isInitialized;
  private int done;

  public ProgressMonitorProgressStrategy() {
    super(TOTAL);
    reset(new EmptyProgressMonitor());
  }

  public void reset(ProgressMonitor monitor) {
    this.monitor = (monitor != null ?
      monitor :
      new EmptyProgressMonitor()
    );
    this.done = 0;
    this.isInitialized = false;
  }

  public void initializeIfNeeded() {
    if (!(isInitialized)) {
      monitor.start("", MAXWORK);
      isInitialized = true;
    }
  }

  public ProgressMonitor getProgressMonitor() {
    initializeIfNeeded();
    return monitor;
  }

  protected void begunWork(AbstractProgressStrategy.Work wrk) {
    initializeIfNeeded();
    monitor.subTask(0).start(wrk.name(), 1);
  }

  protected void advancedWork(AbstractProgressStrategy.Work wrk) {
    if (wrk == lastProgress()) {
      initializeIfNeeded();
      int newDone = (int) (wrk.matchingOrTotal(TOTAL).doneRatio() * MAXWORK);
      if (newDone > MAXWORK) {
        newDone = MAXWORK;
      }
      if (newDone > done) {
        monitor.advance(newDone - done);
        done = newDone;
      }
      String newText = (wrk.comment() != null ?
        wrk.name() + " " + wrk.comment() :
        wrk.name()
      );
      monitor.subTask(0).start(newText, 1);
    }
  }

  protected void finishedWork(AbstractProgressStrategy.Work wrk) {
    initializeIfNeeded();
    monitor.advance(0);
  }
}
