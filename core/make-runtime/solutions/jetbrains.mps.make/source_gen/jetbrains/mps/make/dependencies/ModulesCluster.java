package jetbrains.mps.make.dependencies;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.List;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.project.DevKit;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.internal.make.runtime.util.GraphAnalyzer;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class ModulesCluster {
  private Map<SModuleReference, SModule> modulesView = MapSequence.fromMap(new HashMap<SModuleReference, SModule>());
  private Map<SModuleReference, ModulesCluster.ModuleDeps> allDeps = MapSequence.fromMap(new HashMap<SModuleReference, ModulesCluster.ModuleDeps>());

  public ModulesCluster(Iterable<SModule> mods) {
    addAll(mods);
  }

  public void add(SModule mod) {
    this.primAdd(mod);
  }

  public void addAll(Iterable<SModule> mods) {
    for (SModule mod : mods) {
      primAdd(mod);
    }
  }

  public void collectRequired(Iterable<SModule> pool) {
    Set<SModuleReference> allRequired = SetSequence.fromSetWithValues(new HashSet<SModuleReference>(), Sequence.fromIterable(MapSequence.fromMap(allDeps).values()).translate(new ITranslator2<ModulesCluster.ModuleDeps, SModuleReference>() {
      public Iterable<SModuleReference> translate(ModulesCluster.ModuleDeps dep) {
        return dep.required;
      }
    }));
    List<SModule> available = Sequence.fromIterable(pool).toListSequence();
    int atSize;
    do {
      atSize = MapSequence.fromMap(allDeps).count();
      for (Iterator<SModule> it = ListSequence.fromList(available).iterator(); it.hasNext();) {
        SModule mod = it.next();
        SModuleReference mr = mod.getModuleReference();
        if (SetSequence.fromSet(allRequired).contains(mr)) {
          primAdd(mod);
          SetSequence.fromSet(allRequired).addSequence(ListSequence.fromList(MapSequence.fromMap(allDeps).get(mr).required));
          it.remove();
        }
      }
    } while (atSize < MapSequence.fromMap(allDeps).count());
  }

  public void collectAllRequired() {
  }

  public boolean hasCycles() {
    return ListSequence.fromList(new ModulesCluster.ModulesGraph().findCycles()).isNotEmpty();
  }

  public Iterable<? extends Iterable<SModule>> buildOrder() {
    List<List<SModuleReference>> order = new ModulesCluster.ModulesGraph().totalOrder();
    Iterable<? extends Iterable<SModuleReference>> compacted = Sequence.fromIterable(this.compact(order)).toListSequence();
    return Sequence.fromIterable(compacted).select(new ISelector<Iterable<SModuleReference>, IListSequence<SModule>>() {
      public IListSequence<SModule> select(Iterable<SModuleReference> cycle) {
        return Sequence.fromIterable(cycle).select(new ISelector<SModuleReference, SModule>() {
          public SModule select(SModuleReference mr) {
            return MapSequence.fromMap(modulesView).get(mr);
          }
        }).toListSequence();
      }
    }).toListSequence();
  }

  private Iterable<? extends Iterable<SModuleReference>> compact(List<List<SModuleReference>> order) {
    final Wrappers._T<Iterable<SModuleReference>> prev = new Wrappers._T<Iterable<SModuleReference>>(null);
    return ListSequence.fromList(order).concat(Sequence.fromIterable(Sequence.<List<SModuleReference>>singleton(null))).translate(new ITranslator2<List<SModuleReference>, Iterable<SModuleReference>>() {
      public Iterable<Iterable<SModuleReference>> translate(final List<SModuleReference> cycle) {
        return new Iterable<Iterable<SModuleReference>>() {
          public Iterator<Iterable<SModuleReference>> iterator() {
            return new YieldingIterator<Iterable<SModuleReference>>() {
              private int __CP__ = 0;

              protected boolean moveToNext() {
__loop__:
                do {
__switch__:
                  switch (this.__CP__) {
                    case -1:
                      assert false : "Internal error";
                      return false;
                    case 2:
                      if (cycle == null) {
                        this.__CP__ = 3;
                        break;
                      } else if (prev.value == null) {
                        this.__CP__ = 6;
                        break;
                      }
                      this.__CP__ = 8;
                      break;
                    case 9:
                      if (ListSequence.fromList(cycle).translate(new ITranslator2<SModuleReference, SModuleReference>() {
                        public Iterable<SModuleReference> translate(SModuleReference mr) {
                          return MapSequence.fromMap(allDeps).get(mr).required;
                        }
                      }).intersect(Sequence.fromIterable(prev.value).translate(new ITranslator2<SModuleReference, SModuleReference>() {
                        public Iterable<SModuleReference> translate(SModuleReference mr) {
                          return MapSequence.fromMap(allDeps).get(mr).dependent;
                        }
                      })).isEmpty()) {
                        this.__CP__ = 10;
                        break;
                      }
                      this.__CP__ = 12;
                      break;
                    case 4:
                      this.__CP__ = 5;
                      this.yield(prev.value);
                      return true;
                    case 13:
                      this.__CP__ = 14;
                      this.yield(prev.value);
                      return true;
                    case 0:
                      this.__CP__ = 2;
                      break;
                    case 3:
                      this.__CP__ = 4;
                      break;
                    case 5:
                      prev.value = null;
                      this.__CP__ = 1;
                      break;
                    case 6:
                      prev.value = ListSequence.fromList(cycle).toListSequence();
                      this.__CP__ = 1;
                      break;
                    case 8:
                      this.__CP__ = 9;
                      break;
                    case 10:
                      prev.value = Sequence.fromIterable(prev.value).concat(ListSequence.fromList(cycle).toListSequence());
                      this.__CP__ = 1;
                      break;
                    case 12:
                      this.__CP__ = 13;
                      break;
                    case 14:
                      prev.value = ListSequence.fromList(cycle).toListSequence();
                      this.__CP__ = 1;
                      break;
                    default:
                      break __loop__;
                  }
                } while (true);
                return false;
              }
            };
          }
        };
      }
    });
  }

  private boolean isDirty(SModule mod) {
    return false;
  }

  private void primAdd(SModule mod) {
    SModuleReference mr = mod.getModuleReference();
    if (!(MapSequence.fromMap(modulesView).containsKey(mr))) {
      MapSequence.fromMap(modulesView).put(mr, mod);
      updateDeps(mod);
    }
  }

  public void updateDeps(SModule mod) {
    SModuleReference mr = mod.getModuleReference();
    ModulesCluster.ModuleDeps deps = MapSequence.fromMap(allDeps).get(mr);
    if (deps == null) {
      deps = new ModulesCluster.ModuleDeps(mr);
      MapSequence.fromMap(allDeps).put(mr, deps);
    }
    ListSequence.fromList(deps.required).addSequence(Sequence.fromIterable(required(mod)));
    for (SModuleReference req : deps.required) {
      if (MapSequence.fromMap(allDeps).containsKey(req)) {
        ListSequence.fromList(MapSequence.fromMap(allDeps).get(req).dependent).addElement(mr);
      }
    }
    for (IMapping<SModuleReference, ModulesCluster.ModuleDeps> m : MapSequence.fromMap(allDeps).mappingsSet()) {
      if (ListSequence.fromList(m.value().required).contains(mr) && !(ListSequence.fromList(deps.dependent).contains(m.key()))) {
        ListSequence.fromList(deps.dependent).addElement(m.key());
      }
    }
  }

  private Iterable<SModuleReference> required(SModule mod) {
    GlobalModuleDependenciesManager depman = new GlobalModuleDependenciesManager(mod);
    Set<SModule> reqmods = SetSequence.fromSetWithValues(new HashSet<SModule>(), Sequence.fromIterable(((Iterable<Language>) depman.getUsedLanguages())).translate(new ITranslator2<Language, Generator>() {
      public Iterable<Generator> translate(Language lang) {
        return lang.getGenerators();
      }
    }));
    SetSequence.fromSet(reqmods).addSequence(CollectionSequence.fromCollection(depman.getModules(GlobalModuleDependenciesManager.Deptype.COMPILE)));
    SetSequence.fromSet(reqmods).addSequence(CollectionSequence.fromCollection(depman.getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE)));
    Iterable<SModuleReference> reqs = SetSequence.fromSet(reqmods).select(new ISelector<SModule, SModuleReference>() {
      public SModuleReference select(SModule m) {
        return m.getModuleReference();
      }
    });
    if (mod instanceof Generator) {
      reqs = Sequence.fromIterable(reqs).concat(Sequence.fromIterable(Sequence.<SModuleReference>singleton(((Generator) mod).getSourceLanguage().getModuleReference())));
    } else if (mod instanceof Language) {
    } else if (mod instanceof DevKit) {
    } else {
    }
    return Sequence.fromIterable(reqs).distinct().toListSequence();
  }

  public static class ModuleDeps {
    private List<SModuleReference> dependent = ListSequence.fromList(new LinkedList<SModuleReference>());
    private List<SModuleReference> required = ListSequence.fromList(new LinkedList<SModuleReference>());

    public ModuleDeps(SModuleReference mod) {
      ListSequence.fromList(dependent).addElement(mod);
      ListSequence.fromList(required).addElement(mod);
    }
  }

  public class ModulesGraph extends GraphAnalyzer<SModuleReference> {
    public ModulesGraph() {
    }

    @Override
    public Iterable<SModuleReference> forwardEdges(SModuleReference v) {
      return ListSequence.fromList(MapSequence.fromMap(allDeps).get(v).dependent).where(new IWhereFilter<SModuleReference>() {
        public boolean accept(SModuleReference mod) {
          return MapSequence.fromMap(allDeps).containsKey(mod);
        }
      });
    }

    @Override
    public Iterable<SModuleReference> backwardEdges(SModuleReference v) {
      return ListSequence.fromList(MapSequence.fromMap(allDeps).get(v).required).where(new IWhereFilter<SModuleReference>() {
        public boolean accept(SModuleReference mod) {
          return MapSequence.fromMap(allDeps).containsKey(mod);
        }
      });
    }

    @Override
    public Iterable<SModuleReference> vertices() {
      return MapSequence.fromMap(allDeps).keySet();
    }
  }
}
