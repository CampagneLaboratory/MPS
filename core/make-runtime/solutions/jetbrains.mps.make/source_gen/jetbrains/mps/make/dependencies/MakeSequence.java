package jetbrains.mps.make.dependencies;

/*Generated by MPS */

import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.make.script.ScriptBuilder;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;

public class MakeSequence {
  private Iterable<Cluster> myClusters;

  public MakeSequence() {
  }

  public void prepareClusters(final Iterable<? extends IResource> inputRes) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ModulesClusterizer mcr = new ModulesClusterizer();
        myClusters = mcr.clusterize(inputRes);
      }
    });
  }

  public void prepareScipts(@Nullable final IScript defaultScript, @Nullable final MakeSession makeSession) {
    Sequence.fromIterable(myClusters).visitAll(new IVisitor<Cluster>() {
      public void visit(Cluster cluster) {
        if (defaultScript != null) {
          cluster.setScript(defaultScript);
        } else {
          ScriptBuilder scb = cluster.createScriptBuilder();
          cluster.setScript((makeSession == null ? scb.toScript() : makeSession.toScript(scb)));
        }
      }
    });
  }



  @Deprecated
  public Iterable<Cluster> getClusters() {
    // this method is for transition period only, and will be removed afterwards 
    return myClusters;
  }

  public int steps() {
    return Sequence.fromIterable(myClusters).count();
  }

  public void iterate(_FunctionTypes._return_P2_E0<? extends Boolean, ? super IScript, ? super Iterable<IResource>> iterator) {
    // iterator accepts script and resources to be processed by the script, and returns false to stop 
    for (Cluster c : myClusters) {
      if (!(iterator.invoke(c.getScript(), c.getResources()))) {
        break;
      }
    }
  }
}
