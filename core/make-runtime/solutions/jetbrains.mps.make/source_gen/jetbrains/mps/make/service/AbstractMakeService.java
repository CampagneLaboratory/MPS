package jetbrains.mps.make.service;

/*Generated by MPS */

import jetbrains.mps.make.IMakeService;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.script.IScriptController;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.progress.ProgressMonitor;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.make.dependencies.ModulesClusterizer;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.make.script.ScriptBuilder;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.make.facet.IFacet;
import jetbrains.mps.make.facet.FacetRegistry;
import jetbrains.mps.make.facet.ITarget;

public abstract class AbstractMakeService implements IMakeService {
  public AbstractMakeService() {
  }

  @Override
  public Future<IResult> make(MakeSession session, Iterable<? extends IResource> resources, IScript script, IScriptController controller, @NotNull ProgressMonitor monitor) {
    // compatibility: calls method without monitor 
    return make(session, resources, script, controller);
  }

  protected abstract class AbstractInputProcessor {
    protected AbstractInputProcessor() {
    }

    @Deprecated
    protected final Future<IResult> processRawInput(Iterable<? extends IResource> inputRes, IScript defaultScript, IScriptController controller) {
      // use the one with progress monitor 
      // TODO remove (deprecated in 3.0) 
      return processRawInput(inputRes, defaultScript, controller, new EmptyProgressMonitor());
    }

    protected final Future<IResult> processRawInput(final Iterable<? extends IResource> inputRes, final IScript defaultScript, IScriptController controller, @NotNull ProgressMonitor monitor) {
      final Wrappers._T<Iterable<? extends Iterable<? extends IResource>>> clInput = new Wrappers._T<Iterable<? extends Iterable<? extends IResource>>>();
      final Wrappers._T<Iterable<Iterable<String>>> usedLangs = new Wrappers._T<Iterable<Iterable<String>>>();
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          final ModulesClusterizer mcr = new ModulesClusterizer();
          clInput.value = mcr.clusterize(Sequence.fromIterable(inputRes).select(new ISelector<IResource, IResource>() {
            public IResource select(IResource r) {
              return r;
            }
          }));
          usedLangs.value = Sequence.fromIterable(clInput.value).select(new ISelector<Iterable<? extends IResource>, Iterable<String>>() {
            public Iterable<String> select(Iterable<? extends IResource> it) {
              return mcr.allUsedLangNamespaces(it);
            }
          }).toListSequence();
        }
      });

      Iterable<ScriptBuilder> scriptBuilders = Sequence.fromIterable(usedLangs.value).select(new ISelector<Iterable<String>, ScriptBuilder>() {
        public ScriptBuilder select(Iterable<String> langs) {
          final ScriptBuilder scb = new ScriptBuilder();
          Sequence.fromIterable(langs).visitAll(new IVisitor<String>() {
            public void visit(String ns) {
              LanguageRuntime lr = LanguageRegistry.getInstance().getLanguage(ns);
              Iterable<IFacet> fcts = lr.getFacetProvider().getDescriptor(null).getManifest().facets();
              scb.withFacetNames(Sequence.fromIterable(fcts).select(new ISelector<IFacet, IFacet.Name>() {
                public IFacet.Name select(IFacet fct) {
                  return fct.getName();
                }
              }));
              scb.withFacetNames(Sequence.fromIterable(FacetRegistry.getInstance().getFacetsForLanguage(ns)).select(new ISelector<IFacet, IFacet.Name>() {
                public IFacet.Name select(IFacet fct) {
                  return fct.getName();
                }
              }));
            }
          });
          return scb.withFinalTarget(new ITarget.Name("Make.make"));
        }
      }).toListSequence();

      Iterable<IScript> scripts = ((defaultScript != null ?
        Sequence.fromIterable(scriptBuilders).select(new ISelector<ScriptBuilder, IScript>() {
          public IScript select(ScriptBuilder it) {
            return defaultScript;
          }
        }) :
        Sequence.fromIterable(scriptBuilders).select(new ISelector<ScriptBuilder, IScript>() {
          public IScript select(ScriptBuilder scb) {
            return toScript(scb);
          }
        })
      ));

      return processClusteredInput((Iterable<? extends Iterable<IResource>>) clInput.value, scripts, controller, monitor);
    }

    protected IScript toScript(ScriptBuilder scriptBuilder) {
      return scriptBuilder.toScript();
    }

    @Deprecated
    protected Future<IResult> processClusteredInput(Iterable<? extends Iterable<IResource>> clustRes, Iterable<IScript> scripts, IScriptController controller) {
      // TODO remove (deprecated in 3.0) 
      // override the one with progress monitor 
      return null;
    }

    protected Future<IResult> processClusteredInput(Iterable<? extends Iterable<IResource>> clustRes, Iterable<IScript> scripts, IScriptController controller, @NotNull ProgressMonitor monitor) {
      // compatibility 
      return this.processClusteredInput(clustRes, scripts, controller);
    }
  }
}
