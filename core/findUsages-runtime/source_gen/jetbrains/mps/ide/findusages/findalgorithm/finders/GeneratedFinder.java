package jetbrains.mps.ide.findusages.findalgorithm.finders;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.ide.findusages.FindersManager;
import jetbrains.mps.smodel.IScope;
import java.util.List;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchQuery;
import jetbrains.mps.ide.findusages.model.holders.IHolder;
import jetbrains.mps.ide.findusages.model.holders.NodeHolder;
import java.util.ArrayList;
import java.util.Collections;
import jetbrains.mps.ide.findusages.model.SearchResult;
import java.util.Comparator;
import jetbrains.mps.util.Pair;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public abstract class GeneratedFinder implements IInterfacedFinder {
  private static final Logger LOG = Logger.getLogger(GeneratedFinder.class);

  public GeneratedFinder() {
  }

  public boolean isApplicable(SNode node) {
    return true;
  }

  public boolean isVisible(SNode node) {
    return true;
  }

  public String getLongDescription() {
    return "";
  }

  public SNode getNodeToNavigate() {
    final SNode[] finderNode = new SNode[]{null};
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        finderNode[0] = FindersManager.getInstance().getNodeByFinder(GeneratedFinder.this);
      }
    });
    return finderNode[0];
  }

  public boolean canNavigate() {
    return true;
  }

  protected abstract void doFind(SNode node, IScope scope, List<SNode> _results, ProgressIndicator indicator);

  public void getSearchedNodes(SNode node, IScope scope, List<SNode> _results) {
    _results.add(node);
  }

  public String getNodeCategory(SNode node) {
    return "Uncategorized";
  }

  public SearchResults<SNode> find(SearchQuery query, ProgressIndicator indicator) {
    SearchResults<SNode> results = new SearchResults<SNode>();
    IHolder holder = query.getObjectHolder();
    assert holder instanceof NodeHolder;
    SNode node = ((NodeHolder) holder).getObject();
    if (node.isInstanceOfConcept(getConcept()) && isApplicable(node)) {
      List<SNode> resSN = new ArrayList<SNode>();
      getSearchedNodes(node, query.getScope(), resSN);
      for (SNode resnode : resSN) {
        results.getSearchedNodes().add(resnode);
      }
      List<SNode> res = new ArrayList<SNode>();
      doFind(node, query.getScope(), res, indicator);
      Collections.sort(res, getComparator());
      for (SNode resnode : res) {
        results.getSearchResults().add(new SearchResult<SNode>(resnode, getNodeCategory(resnode)));
      }
    } else {
      LOG.debug("Trying to use finder that is not applicable to the concept. Returning empty results.[finder: \"" + getDescription() + "\"; " + "concept: " + node.getConceptFqName());
    }
    return results;
  }

  private Comparator<SNode> getComparator() {
    return new Comparator<SNode>() {
      private Pair<Integer, Boolean> indexInEditor(SNode editorNode, String role, Pair<Integer, Boolean> index) {
        index.o1++;
        if (editorNode.toString().startsWith("%" + role + "%")) {
          return new Pair(index.o1, true);
        }
        for (SNode childEditorNode : editorNode.getChildren()) {
          Pair<Integer, Boolean> result = indexInEditor(childEditorNode, role, index);
          if (result.o2) {
            return result;
          }
        }
        return new Pair(-1, false);
      }

      private int searchInEditors(SNode ancestor, SNode searchedNode) {
        final SNode conceptDeclaration = ancestor.getConceptDeclarationNode();
        SModel structureModel = conceptDeclaration.getModel();
        Language language = (Language) structureModel.getModelDescriptor().getModule();
        SModel editorModel = language.getEditorModelDescriptor().getSModel();
        SNode editorNode = ListSequence.fromList(SModelOperations.getRoots(editorModel, "jetbrains.mps.lang.editor.structure.ConceptEditorDeclaration")).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SLinkOperations.getTarget(it, "conceptDeclaration", false) == conceptDeclaration;
          }
        });
        if ((editorNode == null)) {
          return -1;
        }
        int index = indexInEditor(editorNode, searchedNode.getRole_(), new Pair(-1, false)).o1;
        if (index != -1 || ancestor.getParent() == null) {
          return index;
        }
        return searchInEditors(ancestor.getParent(), searchedNode);
      }

      private int compareWithEditor(SNode ancestor, SNode node1, SNode node2) {
        Integer index1 = searchInEditors(ancestor, node1);
        Integer index2 = searchInEditors(ancestor, node2);
        return index1.compareTo(index2);
      }

      private int compareBrothers(SNode n1, SNode n2) {
        if (SNodeOperations.getContainingLinkRole(n1) == null) {
          return n1.toString().compareTo(n2.toString());
        }
        if (SNodeOperations.getContainingLinkRole(n1).equals(SNodeOperations.getContainingLinkRole(n2))) {
          return SNodeOperations.getIndexInParent(n1) - SNodeOperations.getIndexInParent(n2);
        }
        return compareWithEditor(SNodeOperations.getParent(n1), n1, n2);
        // <node> 
      }

      public int compare(SNode n1, SNode n2) {
        List<SNode> path1 = ListSequence.fromList(SNodeOperations.getAncestors(n1, null, true)).reversedList();
        List<SNode> path2 = ListSequence.fromList(SNodeOperations.getAncestors(n2, null, true)).reversedList();
        for (int i = 0; i < ListSequence.fromList(path1).count() && i < ListSequence.fromList(path2).count(); ++i) {
          if (ListSequence.fromList(path1).getElement(i) != ListSequence.fromList(path2).getElement(i)) {
            return compareBrothers(ListSequence.fromList(path1).getElement(i), ListSequence.fromList(path2).getElement(i));
          }
        }
        return ListSequence.fromList(path1).count() - ListSequence.fromList(path2).count();
      }
    };
  }
}
