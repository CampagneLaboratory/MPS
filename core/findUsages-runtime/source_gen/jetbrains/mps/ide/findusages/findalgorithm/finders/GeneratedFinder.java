package jetbrains.mps.ide.findusages.findalgorithm.finders;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.ide.findusages.FindersManager;
import jetbrains.mps.smodel.IScope;
import java.util.List;
import jetbrains.mps.progress.ProgressMonitor;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchQuery;
import jetbrains.mps.ide.findusages.model.holders.IHolder;
import jetbrains.mps.ide.findusages.model.holders.NodeHolder;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Comparator;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public abstract class GeneratedFinder implements IInterfacedFinder {
  private static final Logger LOG = Logger.getLogger(GeneratedFinder.class);

  public GeneratedFinder() {
  }

  public boolean isApplicable(SNode node) {
    return true;
  }

  public boolean isVisible(SNode node) {
    return true;
  }

  public String getLongDescription() {
    return "";
  }

  public SNode getNodeToNavigate() {
    final SNode[] finderNode = new SNode[]{null};
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        finderNode[0] = FindersManager.getInstance().getNodeByFinder(GeneratedFinder.this);
      }
    });
    return finderNode[0];
  }

  public boolean canNavigate() {
    return true;
  }

  protected abstract void doFind(SNode node, IScope scope, List<SNode> _results, ProgressMonitor monitor);

  public void getSearchedNodes(SNode node, IScope scope, List<SNode> _results) {
    _results.add(node);
  }

  public String getNodeCategory(SNode node) {
    return "Uncategorized";
  }

  public SearchResults<SNode> find(SearchQuery query, ProgressMonitor monitor) {
    SearchResults<SNode> results = new SearchResults<SNode>();
    IHolder holder = query.getObjectHolder();
    assert holder instanceof NodeHolder;
    SNode node = ((NodeHolder) holder).getObject();
    if (SNodeOperations.isInstanceOf(node, NameUtil.nodeFQName((SNode) SModelUtil.findConceptDeclaration(getConcept(), GlobalScope.getInstance()))) && isApplicable(node)) {
      List<SNode> resSN = ListSequence.fromList(new ArrayList<SNode>());
      getSearchedNodes(node, query.getScope(), resSN);
      for (SNode resnode : resSN) {
        results.getSearchedNodes().add(resnode);
      }
      List<SNode> res = new ArrayList<SNode>();
      doFind(node, query.getScope(), res, monitor);
      for (SNode resnode : ListSequence.fromList(res).sort(new Comparator<SNode>() {
        public int compare(SNode a, SNode b) {
          return compareNodes(a, b);
        }
      }, true)) {
        results.getSearchResults().add(new SearchResult<SNode>(resnode, getNodeCategory(resnode)));
      }
    } else {
      LOG.debug("Trying to use finder that is not applicable to the concept. Returning empty results.[finder: \"" + getDescription() + "\"; " + "concept: " + node.getConcept().getId());
    }
    return results;
  }

  private int compareNodes(SNode n1, SNode n2) {
    List<SNode> path1 = ListSequence.fromList(SNodeOperations.getAncestors(n1, null, true)).reversedList();
    List<SNode> path2 = ListSequence.fromList(SNodeOperations.getAncestors(n2, null, true)).reversedList();
    for (int i = 0; i < ListSequence.fromList(path1).count() && i < ListSequence.fromList(path2).count(); ++i) {
      if (ListSequence.fromList(path1).getElement(i) != ListSequence.fromList(path2).getElement(i)) {
        return compareBrothers(ListSequence.fromList(path1).getElement(i), ListSequence.fromList(path2).getElement(i));
      }
    }
    return ListSequence.fromList(path1).count() - ListSequence.fromList(path2).count();
  }

  private int compareBrothers(SNode n1, SNode n2) {
    if (SNodeOperations.getContainingLinkRole(n1) == null) {
      return n1.getPresentation().compareTo(n2.getPresentation());
    }
    if (SNodeOperations.getContainingLinkRole(n1).equals(SNodeOperations.getContainingLinkRole(n2))) {
      return SNodeOperations.getIndexInParent(n1) - SNodeOperations.getIndexInParent(n2);
    }
    // try to compare positions in editor of ancestor 
    SNode l1 = SNodeOperations.getContainingLinkDeclaration(n1);
    SNode l2 = SNodeOperations.getContainingLinkDeclaration(n2);
    for (SNode p = SNodeOperations.getParent(n1); (p != null); p = SNodeOperations.getParent(p)) {
      SNode editor = ((SNode) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.getConceptDeclaration(p), "call_findConceptAspect_8360039740498068384", new Class[]{SNode.class, LanguageAspect.class}, LanguageAspect.EDITOR));
      for (SNode cell : ListSequence.fromList(SNodeOperations.getDescendants(editor, "jetbrains.mps.lang.editor.structure.CellModel_WithRole", false, new String[]{}))) {
        if (SLinkOperations.getTarget(cell, "relationDeclaration", false) == l1) {
          return -1;
        }
        if (SLinkOperations.getTarget(cell, "relationDeclaration", false) == l2) {
          return 1;
        }
      }
    }
    // just compare roles if was not compared in editor 
    return SNodeOperations.getContainingLinkRole(n1).compareTo(SNodeOperations.getContainingLinkRole(n2));
  }
}
