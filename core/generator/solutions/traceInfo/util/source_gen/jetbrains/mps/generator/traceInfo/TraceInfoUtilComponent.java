package jetbrains.mps.generator.traceInfo;

/*Generated by MPS */

import jetbrains.mps.components.CoreComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelFqName;
import java.util.Collections;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.traceInfo.DebugInfo;
import jetbrains.mps.traceInfo.PositionInfo;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.Set;
import jetbrains.mps.traceInfo.DebugInfoRoot;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.Computable;

public class TraceInfoUtilComponent implements CoreComponent {
  private static TraceInfoUtilComponent INSTANCE;
  public static String DEFAULT_MAPPER = "jetbrains.mps.generator.traceInfo";
  protected static Log log = LogFactory.getLog(TraceInfoUtilComponent.class);

  private final _FunctionTypes._return_P1_E0<? extends String, ? super String> myDefaultUnitNameToModelNameMapper = new _FunctionTypes._return_P1_E0<String, String>() {
    public String invoke(String unitName) {
      int lastDot = unitName.lastIndexOf(".");
      return ((lastDot == -1 ?
        "" :
        unitName.substring(0, lastDot)
      ));
    }
  };
  private final Map<String, _FunctionTypes._return_P1_E0<? extends String, ? super String>> myUnitNameToModelNameMapper = MapSequence.fromMap(new HashMap<String, _FunctionTypes._return_P1_E0<? extends String, ? super String>>());

  public TraceInfoUtilComponent() {
  }

  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("Double initialization!");
    }
    INSTANCE = this;
  }

  public void dispose() {
    INSTANCE = null;
  }

  public _FunctionTypes._return_P1_E0<? extends String, ? super String> putMapper(String key, _FunctionTypes._return_P1_E0<? extends String, ? super String> mapper) {
    _FunctionTypes._return_P1_E0<? extends String, ? super String> oldMapper = MapSequence.fromMap(myUnitNameToModelNameMapper).get(key);

    MapSequence.fromMap(myUnitNameToModelNameMapper).put(key, mapper);

    return oldMapper;
  }

  public _FunctionTypes._return_P1_E0<? extends String, ? super String> removeMapper(String key) {
    return MapSequence.fromMap(myUnitNameToModelNameMapper).removeKey(key);
  }

  public Iterable<SModelDescriptor> getCandidateModels(String unitName) {
    return getCandidateModels(unitName, Sequence.fromIterable(Sequence.<_FunctionTypes._return_P1_E0<? extends String, ? super String>>singleton(myDefaultUnitNameToModelNameMapper)).union(Sequence.fromIterable(MapSequence.fromMap(myUnitNameToModelNameMapper).values())));
  }

  public Iterable<SModelDescriptor> getCandidateModels(final String unitName, Iterable<_FunctionTypes._return_P1_E0<? extends String, ? super String>> mappers) {
    return Sequence.fromIterable(mappers).select(new ISelector<_FunctionTypes._return_P1_E0<? extends String, ? super String>, String>() {
      public String select(_FunctionTypes._return_P1_E0<? extends String, ? super String> it) {
        return it.invoke(unitName);
      }
    }).distinct().translate(new ITranslator2<String, SModelDescriptor>() {
      public Iterable<SModelDescriptor> translate(final String modelFqName) {
        return Sequence.fromIterable(Sequence.fromArray(SModelStereotype.values)).where(new IWhereFilter<String>() {
          public boolean accept(String it) {
            return !(SModelStereotype.isStubModelStereotype(it));
          }
        }).select(new ISelector<String, SModelDescriptor>() {
          public SModelDescriptor select(String stereotype) {
            return SModelRepository.getInstance().getModelDescriptor(new SModelFqName(modelFqName, stereotype));
          }
        });
      }
    }).where(new IWhereFilter<SModelDescriptor>() {
      public boolean accept(SModelDescriptor it) {
        return it != null;
      }
    });
  }

  public Iterable<SModelDescriptor> getCandidateModels(String unitName, String mapperId) {
    if (mapperId.equals(DEFAULT_MAPPER)) {
      return getCandidateModels(unitName, Sequence.<_FunctionTypes._return_P1_E0<? extends String, ? super String>>singleton(myDefaultUnitNameToModelNameMapper));
    }
    _FunctionTypes._return_P1_E0<? extends String, ? super String> mapper = MapSequence.fromMap(myUnitNameToModelNameMapper).get(mapperId);
    if (mapper == null) {
      if (log.isWarnEnabled()) {
        log.warn("Cant find mapper by id " + mapperId);
      }
      return Sequence.fromIterable(Collections.<SModelDescriptor>emptyList());
    }
    return getCandidateModels(unitName, Sequence.<_FunctionTypes._return_P1_E0<? extends String, ? super String>>singleton(mapper));
  }

  @Nullable
  public <T> T findInTraceInfo(@NonNls String unitName, _FunctionTypes._return_P2_E0<? extends T, ? super DebugInfo, ? super SModelDescriptor> getter, String mapperKey) {
    for (SModelDescriptor descriptor : Sequence.fromIterable(TraceInfoUtilComponent.getInstance().getCandidateModels(unitName, mapperKey))) {
      final DebugInfo info = TraceInfoCache.getInstance().get(descriptor);
      if (info == null) {
        continue;
      }
      T result = getter.invoke(info, descriptor);
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  public <T> T findInTraceInfo(@NonNls String unitName, _FunctionTypes._return_P2_E0<? extends T, ? super DebugInfo, ? super SModelDescriptor> getter) {
    return findInTraceInfo(unitName, getter, DEFAULT_MAPPER);
  }

  public <T extends PositionInfo> List<SNode> getAllNodes(@NonNls String unitName, final String file, final int lineNumber, final _FunctionTypes._return_P1_E0<? extends Set<T>, ? super DebugInfoRoot> positionsGetter, String mapper) {
    return findInTraceInfo(unitName, new _FunctionTypes._return_P2_E0<List<SNode>, DebugInfo, SModelDescriptor>() {
      public List<SNode> invoke(DebugInfo debugInfo, SModelDescriptor descriptor) {
        List<T> infoForPosition = debugInfo.getInfoForPosition(file, lineNumber, new _FunctionTypes._return_P1_E0<Set<T>, DebugInfoRoot>() {
          public Set<T> invoke(DebugInfoRoot root) {
            return positionsGetter.invoke(root);
          }
        });
        List<SNode> nodes = ListSequence.fromList(new ArrayList<SNode>());
        if (infoForPosition.isEmpty()) {
          return null;
        }
        for (T info : infoForPosition) {
          nodes.add(descriptor.getSModel().getNodeById(info.getNodeId()));
        }
        return nodes;
      }
    }, mapper);
  }

  public <T extends PositionInfo> List<SNode> getAllNodes(@NonNls String unitName, String file, int lineNumber, _FunctionTypes._return_P1_E0<? extends Set<T>, ? super DebugInfoRoot> positionsGetter) {
    return getAllNodes(unitName, file, lineNumber, positionsGetter, DEFAULT_MAPPER);
  }

  @Nullable
  public SNode getNode(@NonNls String unitName, final String fileName, final int lineNumber) {
    return findInTraceInfo(unitName, new _FunctionTypes._return_P2_E0<SNode, DebugInfo, SModelDescriptor>() {
      public SNode invoke(DebugInfo info, SModelDescriptor descriptor) {
        return info.getNodeForLine(fileName, lineNumber, descriptor.getSModel());
      }
    });
  }

  @Nullable
  public SNodePointer getNodePointer(@NonNls final String unitName, final String fileName, final int lineNumber) {
    return ModelAccess.instance().runReadAction(new Computable<SNodePointer>() {
      public SNodePointer compute() {
        SNode node = getNode(unitName, fileName, lineNumber);
        if (node != null) {
          return new SNodePointer(node);
        }
        return null;
      }
    });
  }

  public static TraceInfoUtilComponent getInstance() {
    return INSTANCE;
  }
}
