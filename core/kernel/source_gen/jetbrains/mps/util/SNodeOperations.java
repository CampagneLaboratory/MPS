package jetbrains.mps.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.apiadapter.SConceptNodeAdapter;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.project.GlobalScope;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.SNodeBase;

public class SNodeOperations {
  public SNodeOperations() {
  }

  /**
   * todo rewrite via ISNode methods
   */
  public static boolean isAncestor(SNode ancestor, SNode node) {
    return ((jetbrains.mps.smodel.SNode) ancestor).isAncestorOf(((jetbrains.mps.smodel.SNode) node));
  }

  /**
   * todo rewrite via ISNode methods
   */
  public static List<SNode> getChildren(SNode node, boolean includeAttributes) {
    return ((List) ((jetbrains.mps.smodel.SNode) node).getChildren(includeAttributes));
  }

  /**
   * todo rewrite via ISNode methods
   */
  public static Iterable<SNode> getDescendants(SNode node, Condition<SNode> cond, boolean includeFirst) {
    return ((Iterable) ((jetbrains.mps.smodel.SNode) node).getDescendantsIterable(((Condition) cond), includeFirst));
  }

  /**
   * todo rewrite via ISNode methods
   * todo in our code, rewrite using ancestors.where(condition) or add a custom condition to smodel language ancestor query
   */
  public static SNode findParent(SNode node, Condition<jetbrains.mps.smodel.SNode> condition) {
    return ((jetbrains.mps.smodel.SNode) node).findParent(condition);
  }

  /**
   * todo rewrite via ISNode methods (concept+getProperty)
   */
  public static Map<String, String> getProperties(SNode node) {
    return ((jetbrains.mps.smodel.SNode) node).getProperties();
  }

  /**
   * todo rewrite via ISNode methods
   * todo in our code, rewrite using ancestors.where(condition) or add a custom condition to smodel language ancestor query
   */
  public static SNode getDescendants(SNode node, Condition<jetbrains.mps.smodel.SNode> condition) {
    return ((jetbrains.mps.smodel.SNode) node).findParent(condition);
  }

  /**
   * todo rewrite the code using this
   */
  public static SConcept getConcept(String name) {
    return new SConceptNodeAdapter(((jetbrains.mps.smodel.SNode) SModelUtil.findConceptDeclaration(name, GlobalScope.getInstance())));
  }

  /**
   * todo rewrite the code using this
   */
  public static Set<String> getChildRoles(SNode n) {
    final Set<String> res = SetSequence.fromSet(new HashSet<String>());
    n.visitChildren(new SNode.ChildVisitor() {
      public boolean visitChild(String role, SNode child) {
        SetSequence.fromSet(res).addElement(role);
        return false;
      }
    });
    return res;
  }

  /**
   * todo rewrite the code using this
   */
  public static Set<SReference> getReferences(SNode n) {
    final Set<SReference> res = SetSequence.fromSet(new HashSet<SReference>());
    n.visitReferences(new SNode.ReferenceVisitor() {
      public boolean visitReference(String role, org.jetbrains.mps.openapi.model.SReference reference) {
        SetSequence.fromSet(res).addElement(((SReference) reference));
        return false;
      }
    });
    return res;
  }

  /**
   * todo rewrite the code using this
   */
  public static List<SNode> getChildren(SNode n) {
    final List<SNode> res = ListSequence.fromList(new ArrayList<SNode>());
    n.visitChildren(new SNode.ChildVisitor() {
      public boolean visitChild(String role, SNode child) {
        ListSequence.fromList(res).addElement(child);
        return false;
      }
    });
    return res;
  }

  /**
   * todo rewrite the code using this
   */
  public static Set<String> getReferenceRoles(SNode n) {
    final Set<String> res = SetSequence.fromSet(new HashSet<String>());
    n.visitReferences(new SNode.ReferenceVisitor() {
      public boolean visitReference(String role, org.jetbrains.mps.openapi.model.SReference ref) {
        SetSequence.fromSet(res).addElement(role);
        return false;
      }
    });
    return res;
  }

  /**
   * todo rewrite the code via snode methods
   */
  public static void insertChild(SNode parent, String role, SNode child, SNode anchor, boolean before) {
    ((jetbrains.mps.smodel.SNode) parent).insertChild(((SNodeBase) anchor), role, ((jetbrains.mps.smodel.SNode) child), before);
  }

  /**
   * todo KILL IT! should be node.getModel!=null
   * todo after killing it, correct migration script to return model!=null instead
   */
  @Deprecated
  public static boolean isRegistered(SNode node) {
    return ((jetbrains.mps.smodel.SNode) node).isRegistered();
  }

  /**
   * todo KILL IT! should not be used since nodes are not passed between read actions
   * todo after killing it, correct migration script to return false instead
   */
  @Deprecated
  public static boolean isDisposed(SNode node) {
    return ((jetbrains.mps.smodel.SNode) node).isDisposed();
  }

  /**
   * todo KILL IT! should be node.getTopMostAncestor
   * todo after killing it, correct migration script getTopMostAncestor
   */
  @Deprecated
  public static jetbrains.mps.smodel.SNode getContainingRoot(SNode node) {
    return ((jetbrains.mps.smodel.SNode) node).getContainingRoot();
  }

  /**
   * this is an utility method common to all nodes but needed only for our debug purposes, so we don't put it into SNode
   */
  public static String getDebugText(SNode node) {
    return ((jetbrains.mps.smodel.SNode) node).getDebugText();
  }
}
