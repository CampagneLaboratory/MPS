package jetbrains.mps.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.ModelAccess;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.apiadapter.SConceptNodeAdapter;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.smodel.SReference;
import java.util.LinkedList;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import java.util.Iterator;
import java.util.Queue;
import org.jetbrains.annotations.Nullable;

public class SNodeOperations {
  public SNodeOperations() {
  }

  public static boolean isAncestor(SNode ancestor, SNode node) {
    ModelAccess.assertLegalRead();
    if (ancestor == node) {
      return true;
    }
    SNode parentOfChild = node.getParent();
    if (parentOfChild == null) {
      return false;
    }
    return isAncestor(ancestor, parentOfChild);
  }

  public static String getRoleInParent(jetbrains.mps.smodel.SNode n) {
    return (n.getParent() == null ?
      null :
      n.getParent().getRoleOf(n)
    );
  }

  public static List<jetbrains.mps.smodel.SNode> getChildren(SNode node, boolean includeAttributes) {
    List<jetbrains.mps.smodel.SNode> res = new ArrayList<jetbrains.mps.smodel.SNode>();
    for (SNode child : node.getChildren()) {
      if (child != null && AttributeOperations.isAttribute(child)) {
        res.add(((jetbrains.mps.smodel.SNode) child));
      }
    }
    return res;
  }

  public static Iterable<jetbrains.mps.smodel.SNode> getDescendants(SNode node, Condition<jetbrains.mps.smodel.SNode> cond, boolean includeFirst) {
    return new SNodeOperations.DescendantsIterable(node, cond, includeFirst);
  }

  public static SNode findParent(SNode node, Condition<jetbrains.mps.smodel.SNode> condition) {
    jetbrains.mps.smodel.SNode parent = ((jetbrains.mps.smodel.SNode) node.getParent());
    while (parent != null) {
      if (condition.met(parent)) {
        return ((jetbrains.mps.smodel.SNode) parent);
      }
      parent = ((jetbrains.mps.smodel.SNode) parent.getParent());
    }
    return null;
  }

  public static Map<String, String> getProperties(SNode node) {
    final Map<String, String> result = new HashMap<String, String>();
    node.visitProperties(new SNode.PropertyVisitor() {
      public boolean visitProperty(String name, String value) {
        result.put(name, value);
        return true;
      }
    });
    return result;
  }

  public static List<jetbrains.mps.smodel.SNode> getDescendants(SNode node, Condition<jetbrains.mps.smodel.SNode> condition) {
    List<jetbrains.mps.smodel.SNode> res = ListSequence.fromList(new ArrayList<jetbrains.mps.smodel.SNode>());
    collectDescendants(node, res, condition);
    return res;
  }

  private static void collectDescendants(SNode node, final List<jetbrains.mps.smodel.SNode> list, final Condition<jetbrains.mps.smodel.SNode> condition) {
    node.visitChildren(new SNode.ChildVisitor() {
      public boolean visitChild(String role, SNode child) {
        if (condition == null || condition == Condition.TRUE_CONDITION || (child instanceof jetbrains.mps.smodel.SNode && condition.met(((jetbrains.mps.smodel.SNode) child)))) {
          ListSequence.fromList(list).addElement(((jetbrains.mps.smodel.SNode) child));
        }
        collectDescendants(child, list, condition);
        return true;
      }
    });
  }

  /**
   * todo rewrite the code using this
   */
  public static SConcept getConcept(String name) {
    return new SConceptNodeAdapter(name);
  }

  /**
   * todo rewrite the code using this
   */
  public static Set<String> getChildRoles(SNode n) {
    final Set<String> res = SetSequence.fromSet(new HashSet<String>());
    n.visitChildren(new SNode.ChildVisitor() {
      public boolean visitChild(String role, SNode child) {
        SetSequence.fromSet(res).addElement(role);
        return true;
      }
    });
    return res;
  }

  /**
   * todo rewrite the code using this
   */
  public static List<SReference> getReferences(SNode n) {
    final List<SReference> res = new LinkedList<SReference>();
    n.visitReferences(new SNode.ReferenceVisitor() {
      public boolean visitReference(String role, org.jetbrains.mps.openapi.model.SReference reference) {
        res.add(((SReference) reference));
        return true;
      }
    });
    return res;
  }

  /**
   * todo rewrite the code using this
   */
  public static List<jetbrains.mps.smodel.SNode> getChildren(SNode n) {
    final List<jetbrains.mps.smodel.SNode> res = ListSequence.fromList(new ArrayList<jetbrains.mps.smodel.SNode>());
    n.visitChildren(new SNode.ChildVisitor() {
      public boolean visitChild(String role, SNode child) {
        ListSequence.fromList(res).addElement(((jetbrains.mps.smodel.SNode) child));
        return true;
      }
    });
    return res;
  }

  /**
   * todo rewrite the code using this
   */
  public static Set<String> getReferenceRoles(SNode n) {
    final Set<String> res = SetSequence.fromSet(new HashSet<String>());
    n.visitReferences(new SNode.ReferenceVisitor() {
      public boolean visitReference(String role, org.jetbrains.mps.openapi.model.SReference ref) {
        SetSequence.fromSet(res).addElement(role);
        return true;
      }
    });
    return res;
  }

  /**
   * todo rewrite the code via snode methods
   */
  public static void insertChild(SNode parent, String role, SNode child, SNode anchor, boolean before) {
    if (before) {
      parent.insertChild(role, child, parent.getPrevChild(anchor));
    } else {
      parent.insertChild(role, child, anchor);
    }
  }

  /**
   * todo KILL IT! should be node.getModel!=null
   * todo after killing it, correct migration script to return model!=null instead
   */
  @Deprecated
  public static boolean isRegistered(SNode node) {
    return ((jetbrains.mps.smodel.SNode) node).isRegistered();
  }

  /**
   * todo KILL IT! should not be used since nodes are not passed between read actions
   * todo after killing it, correct migration script to return false instead
   */
  @Deprecated
  public static boolean isDisposed(SNode node) {
    return ((jetbrains.mps.smodel.SNode) node).isDisposed();
  }

  /**
   * todo KILL IT! should be node.getTopMostAncestor
   * todo after killing it, correct migration script getTopMostAncestor
   */
  @Deprecated
  public static SNode getContainingRoot(SNode node) {
    return ((jetbrains.mps.smodel.SNode) node).getContainingRoot();
  }

  /**
   * this is an utility method common to all nodes but needed only for our debug purposes, so we don't put it into SNode
   */
  public static String getDebugText(SNode node) {
    return ((jetbrains.mps.smodel.SNode) node).getDebugText();
  }

  /**
   * This will be replaced by getting resolve info from a reference in a context containing it
   */
  public static String getResolveInfo(SNode n) {
    return ((jetbrains.mps.smodel.SNode) n).getResolveInfo();
  }

  public static void copyProperties(SNode from, final SNode to) {
    from.visitProperties(new SNode.PropertyVisitor() {
      public boolean visitProperty(String p0, String p1) {
        to.setProperty(p0, p1);
        return true;
      }
    });
  }

  public static Language getLanguage(SNode node) {
    return ModuleRepositoryFacade.getInstance().getModule(node.getConcept().getLanguage().getPresentation(), Language.class);
  }

  public static void copyUserObjects(SNode from, final SNode to) {
    from.visitUserObjects(new SNode.UserObjectVisitor() {
      public boolean visitObject(Object object, Object object1) {
        to.putUserObject(object, object1);
        return true;
      }
    });
  }

  private static class DescendantsIterable implements Iterator<jetbrains.mps.smodel.SNode>, Iterable<jetbrains.mps.smodel.SNode> {
    private Condition<jetbrains.mps.smodel.SNode> condition;
    private Queue<SNode> queue = new LinkedList<SNode>();

    /*package*/ DescendantsIterable(SNode original, @Nullable Condition<jetbrains.mps.smodel.SNode> condition, boolean includeFirst) {
      this.condition = condition;
      queue.offer(original);
      if (!(includeFirst)) {
        nextInternal();
      }
    }

    public boolean hasNext() {
      return queue.peek() != null;
    }

    public jetbrains.mps.smodel.SNode next() {
      SNode next;
      do {
        next = nextInternal();
      } while (next != null && condition != null && !(next instanceof jetbrains.mps.smodel.SNode && condition.met(((jetbrains.mps.smodel.SNode) next))));
      return ((jetbrains.mps.smodel.SNode) next);
    }

    public void remove() {
      throw new UnsupportedOperationException();
    }

    private SNode nextInternal() {
      SNode curr = queue.poll();
      if (curr == null) {
        return null;
      }
      for (SNode child : curr.getChildren()) {
        queue.offer(child);
      }
      return curr;
    }

    public Iterator<jetbrains.mps.smodel.SNode> iterator() {
      return this;
    }
  }
}
