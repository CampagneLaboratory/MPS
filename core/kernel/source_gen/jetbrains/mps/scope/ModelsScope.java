package jetbrains.mps.scope;

/*Generated by MPS */

import java.util.Set;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConceptRepository;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.smodel.SModelOperations;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class ModelsScope extends Scope {
  private final boolean myRootsOnly;
  private final String myTargetConcept;
  private final Set<SModel> myModels;
  public ModelsScope(Iterable<SModel> models, boolean rootsOnly, String targetConcept) {
    myModels = SetSequence.fromSetWithValues(new HashSet<SModel>(), models);
    myRootsOnly = rootsOnly;
    myTargetConcept = targetConcept;
  }
  @Override
  public boolean contains(SNode node) {
    SAbstractConcept concept = SConceptRepository.getInstance().getConcept(myTargetConcept);
    if (concept == null) {
      return false;
    }
    return SNodeUtil.isInstanceOf(node, concept) && (!(myRootsOnly) || SNodeOperations.isRoot(node)) && SetSequence.fromSet(myModels).contains(node.getModel());
  }
  @Override
  public SNode resolve(SNode contextNode, String refText) {
    SNode result = null;
    for (SModel model : myModels) {
      if (model == null) {
        continue;
      }
      Iterable<SNode> nodes;
      String conceptToCheck;

      if (myRootsOnly) {
        nodes = model.getRootNodes();
        conceptToCheck = myTargetConcept;
      } else if (myTargetConcept != null) {
        nodes = SModelOperations.getNodes(model, myTargetConcept);
        conceptToCheck = null;
      } else {
        nodes = SNodeUtil.getDescendants(model);
        conceptToCheck = null;
      }

      for (SNode node : nodes) {
        if (conceptToCheck != null && !(SNodeUtil.isInstanceOf(node, SConceptRepository.getInstance().getConcept(conceptToCheck)))) {
          continue;
        }
        String nodeRefText = getReferenceText(null, node);
        if (nodeRefText == null || !(nodeRefText.equals(refText))) {
          continue;
        }

        if (result == null) {
          result = node;
        } else {
          // ambiguity 
          return null;
        }
      }
    }
    return result;
  }
  @Override
  public Iterable<SNode> getAvailableElements(@Nullable String prefix) {
    List<SNode> result = new ArrayList<SNode>();
    for (SModel model : myModels) {
      if (model == null) {
        continue;
      }
      Iterable<SNode> nodes;
      String conceptToCheck;

      if (myRootsOnly) {
        nodes = model.getRootNodes();
        conceptToCheck = myTargetConcept;
      } else if (myTargetConcept != null) {
        nodes = SModelOperations.getNodes(model, myTargetConcept);
        conceptToCheck = null;
      } else {
        nodes = SNodeUtil.getDescendants(model);
        conceptToCheck = null;
      }

      for (SNode node : nodes) {
        if (conceptToCheck != null && !(SNodeUtil.isInstanceOf(node, SConceptRepository.getInstance().getConcept(conceptToCheck)))) {
          continue;
        }
        if ((prefix != null && prefix.length() > 0)) {
          String refText = getReferenceText(null, node);
          if (refText == null || !(refText.startsWith(prefix))) {
            continue;
          }
        }
        ListSequence.fromList(result).addElement(node);
      }
    }
    return result;
  }
  @Override
  public String getReferenceText(SNode contextNode, SNode node) {
    String resolveInfo = SNodeOperations.getResolveInfo(node);
    if ((resolveInfo != null && resolveInfo.length() > 0)) {
      return resolveInfo;
    }
    return node.getPresentation();
  }
  public Iterable<SModel> getModels() {
    return myModels;
  }
}
