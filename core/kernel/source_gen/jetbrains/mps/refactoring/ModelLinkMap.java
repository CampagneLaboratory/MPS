package jetbrains.mps.refactoring;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.util.List;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.smodel.runtime.ConceptKind;
import jetbrains.mps.smodel.runtime.StaticScope;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.persistence.LightModelEnvironmentInfo;
import jetbrains.mps.persistence.PersistenceRegistry;
import jetbrains.mps.smodel.ModelAccess;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class ModelLinkMap {
  private SModel myModel;
  private Map<SNodeReference, List<StaticReference>> myTargetMap = MapSequence.fromMap(new HashMap<SNodeReference, List<StaticReference>>());
  private Map<SNodeReference, List<SNode>> myNodeTypeMap = MapSequence.fromMap(new HashMap<SNodeReference, List<SNode>>());
  private Map<SNodeReference, List<SNode>> myNodeRoleMap = MapSequence.fromMap(new HashMap<SNodeReference, List<SNode>>());
  private Map<SNodeReference, List<SReference>> myRefRoleMap = MapSequence.fromMap(new HashMap<SNodeReference, List<SReference>>());
  private Map<SNodeReference, List<Pair<SNode, String>>> myPropNameMap = MapSequence.fromMap(new HashMap<SNodeReference, List<Pair<SNode, String>>>());
  private Map<SModelReference, List<DynamicReference>> myDynRefMap = MapSequence.fromMap(new HashMap<SModelReference, List<DynamicReference>>());
  private Map<SNode, Tuples._2<ConceptKind, StaticScope>> myMetainfo = MapSequence.fromMap(new HashMap<SNode, Tuples._2<ConceptKind, StaticScope>>());
  private Map<SNode, Boolean> myRoleMetainfo = MapSequence.fromMap(new HashMap<SNode, Boolean>());

  public ModelLinkMap(SModel model) {
    myModel = model;
  }

  public void addTargetLocation(SNodeReference ptr, StaticReference ref) {
    addValue(myTargetMap, ptr, ref);
  }

  public void addTypeLocation(SNodeReference ptr, SNode node) {
    addValue(myNodeTypeMap, ptr, node);
  }

  public void addNodeMetainfo(ConceptKind kind, StaticScope scope, boolean isUnordered, SNode node) {
    MapSequence.fromMap(myMetainfo).put(node, MultiTuple.<ConceptKind,StaticScope>from(kind, scope));
    MapSequence.fromMap(myRoleMetainfo).put(node, isUnordered);
  }

  public void addRoleLocation(SNodeReference ptr, SNode node) {
    addValue(myNodeRoleMap, ptr, node);
  }

  public void addRoleLocation(SNodeReference ptr, SReference ref) {
    addValue(myRefRoleMap, ptr, ref);
  }

  public void addNameLocation(SNodeReference ptr, SNode node, String name) {
    addValue(myPropNameMap, ptr, new Pair<SNode, String>(node, name));
  }

  public void addDynamicReference(SModelReference model, DynamicReference ref) {
    addValue(myDynRefMap, model, ref);
  }

  public boolean moveNode(SNodeReference oldPtr, final SNodeReference newPtr) {
    boolean res = false;
    res |= move(myTargetMap, oldPtr, newPtr, new _FunctionTypes._void_P1_E0<StaticReference>() {
      public void invoke(StaticReference ref) {
        ref.setTargetSModelReference(newPtr.getModelReference());
        ref.setTargetNodeId(((SNodePointer) newPtr).getNodeId());
      }
    });
    res |= move(myNodeTypeMap, oldPtr, newPtr, new _FunctionTypes._void_P1_E0<SNode>() {
      public void invoke(SNode node) {
        String modelName = SModelStereotype.withoutStereotype(newPtr.getModelReference().getModelName());
        String name = NameUtil.shortNameFromLongName(node.getConcept().getQualifiedName());
        ((jetbrains.mps.smodel.SNode) node).setConceptFqName(NameUtil.longNameFromNamespaceAndShortName(modelName, name));
      }
    });
    move(myNodeRoleMap, oldPtr, newPtr, new _FunctionTypes._void_P1_E0<SNode>() {
      public void invoke(SNode n) {
        // do nothing 
      }
    });
    move(myRefRoleMap, oldPtr, newPtr, new _FunctionTypes._void_P1_E0<SReference>() {
      public void invoke(SReference r) {
        // do nothing 
      }
    });
    move(myPropNameMap, oldPtr, newPtr, new _FunctionTypes._void_P1_E0<Pair<SNode, String>>() {
      public void invoke(Pair<SNode, String> p) {
        // do nothing 
      }
    });
    return res;
  }

  public boolean deleteNode(SNodeReference ptr) {
    boolean res = false;
    res |= delete(myNodeTypeMap, ptr, new _FunctionTypes._void_P1_E0<SNode>() {
      public void invoke(SNode node) {
        SNodeOperations.deleteNode(node);
      }
    });
    res |= delete(myNodeRoleMap, ptr, new _FunctionTypes._void_P1_E0<SNode>() {
      public void invoke(SNode node) {
        SNodeOperations.deleteNode(node);
      }
    });
    res |= delete(myRefRoleMap, ptr, new _FunctionTypes._void_P1_E0<SReference>() {
      public void invoke(SReference ref) {
        ref.getSourceNode().setReference(ref.getRole(), null);
      }
    });
    res |= delete(myPropNameMap, ptr, new _FunctionTypes._void_P1_E0<Pair<SNode, String>>() {
      public void invoke(Pair<SNode, String> prop) {
        prop.o1.setProperty(prop.o2, null);
      }
    });
    return res;
  }

  public boolean setName(SNodeReference ptr, final String name) {
    boolean res = false;
    res |= setProp(myNodeTypeMap, ptr, new _FunctionTypes._void_P1_E0<SNode>() {
      public void invoke(SNode node) {
        String modelName = NameUtil.namespaceFromConceptFQName(node.getConcept().getQualifiedName());
        ((jetbrains.mps.smodel.SNode) node).setConceptFqName(NameUtil.conceptFQNameFromNamespaceAndShortName(modelName, name));
      }
    });
    res |= setProp(myPropNameMap, ptr, new _FunctionTypes._void_P1_E0<Pair<SNode, String>>() {
      public void invoke(Pair<SNode, String> prop) {
        // todo: rename correspondent property attribute role 
        String value = prop.o1.getProperty(prop.o2);
        prop.o1.setProperty(prop.o2, null);
        prop.o2 = name;
        prop.o1.setProperty(name, value);
      }
    });
    return res;
  }

  public boolean setRole(SNodeReference ptr, final String role) {
    // todo: rename correspondent link attribute roles 
    boolean res = false;
    res |= setProp(myNodeRoleMap, ptr, new _FunctionTypes._void_P1_E0<SNode>() {
      public void invoke(SNode node) {
        ((jetbrains.mps.smodel.SNode) node).setRoleInParent(role);
      }
    });
    res |= setProp(myRefRoleMap, ptr, new _FunctionTypes._void_P1_E0<SReference>() {
      public void invoke(SReference ref) {
        ((jetbrains.mps.smodel.SReference) ref).setRole(role);
      }
    });
    return res;
  }

  public boolean updateModelReference(SModelReference model, final SModelReference newModel) {
    boolean res = false;
    // update imports 
    for (jetbrains.mps.smodel.SModel.ImportElement element : ListSequence.fromList(((SModelInternal) myModel).importedModels())) {
      if (model.equals(element.getModelReference())) {
        res = true;
        element.setModelReference(newModel);
      }
    }
    for (jetbrains.mps.smodel.SModel.ImportElement element : ListSequence.fromList(((SModelInternal) myModel).getAdditionalModelVersions())) {
      if (model.equals(element.getModelReference())) {
        element.setModelReference(newModel);
      }
    }
    // update references 
    List<DynamicReference> list = myDynRefMap.remove(model);
    if (list != null) {
      res = true;
      ListSequence.fromList(list).visitAll(new IVisitor<DynamicReference>() {
        public void visit(DynamicReference it) {
          it.setTargetSModelReference(newModel);
        }
      });
      MapSequence.fromMap(myDynRefMap).put(newModel, list);
    }
    for (SNodeReference ptr : SetSequence.fromSet(MapSequence.fromMap(myTargetMap).keySet())) {
      if (model.equals(ptr.getModelReference())) {
        res = true;
        ListSequence.fromList(MapSequence.fromMap(myTargetMap).get(ptr)).visitAll(new IVisitor<StaticReference>() {
          public void visit(StaticReference it) {
            it.setTargetSModelReference(newModel);
          }
        });
      }
    }
    // update conceptFqNames (if it was structure model) 
    for (SNodeReference ptr : SetSequence.fromSet(MapSequence.fromMap(myNodeTypeMap).keySet())) {
      if (model.equals(ptr.getModelReference())) {
        res = true;
        ListSequence.fromList(MapSequence.fromMap(myNodeTypeMap).get(ptr)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode node) {
            String name = NameUtil.shortNameFromLongName(node.getConcept().getQualifiedName());
            ((jetbrains.mps.smodel.SNode) node).setConceptFqName(NameUtil.longNameFromNamespaceAndShortName(newModel.getModelName(), name));
          }
        });
      }
    }
    // update maps themselves 
    updatePtrMap(myNodeRoleMap, model, newModel);
    updatePtrMap(myNodeTypeMap, model, newModel);
    updatePtrMap(myPropNameMap, model, newModel);
    updatePtrMap(myRefRoleMap, model, newModel);
    updatePtrMap(myTargetMap, model, newModel);
    return res;
  }

  public void fillModelEnvironmentInfo() {
    final LightModelEnvironmentInfo info = as_1o71zw_a0a0a22(PersistenceRegistry.getInstance().getModelEnvironmentInfo(), LightModelEnvironmentInfo.class);
    if (info == null) {
      return;
    }

    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        for (jetbrains.mps.smodel.SModel.ImportElement i : ListSequence.fromList(((SModelInternal) myModel).getAdditionalModelVersions())) {
          info.modelVersionRead(i);
        }
        for (final SNodeReference ptr : SetSequence.fromSet(MapSequence.fromMap(myNodeRoleMap).keySet())) {
          ListSequence.fromList(MapSequence.fromMap(myNodeRoleMap).get(ptr)).visitAll(new IVisitor<SNode>() {
            public void visit(SNode n) {
              boolean unordered = (MapSequence.fromMap(myRoleMetainfo).containsKey(n) ?
                MapSequence.fromMap(myRoleMetainfo).get(n) :
                false
              );
              info.nodeRoleRead(n, ptr, unordered);
            }
          });
        }
        for (final SNodeReference ptr : SetSequence.fromSet(MapSequence.fromMap(myNodeTypeMap).keySet())) {
          ListSequence.fromList(MapSequence.fromMap(myNodeTypeMap).get(ptr)).visitAll(new IVisitor<SNode>() {
            public void visit(SNode n) {
              Tuples._2<ConceptKind, StaticScope> pair = MapSequence.fromMap(myMetainfo).get(n);
              info.conceptRead(n, ptr, (pair == null ?
                StaticScope.GLOBAL :
                pair._1()
              ), (pair == null ?
                ConceptKind.NORMAL :
                pair._0()
              ));
            }
          });
        }
        for (final SNodeReference ptr : SetSequence.fromSet(MapSequence.fromMap(myRefRoleMap).keySet())) {
          ListSequence.fromList(MapSequence.fromMap(myRefRoleMap).get(ptr)).visitAll(new IVisitor<SReference>() {
            public void visit(SReference r) {
              info.referenceRoleRead(r, ptr);
            }
          });
        }
        for (final SNodeReference ptr : SetSequence.fromSet(MapSequence.fromMap(myPropNameMap).keySet())) {
          ListSequence.fromList(MapSequence.fromMap(myPropNameMap).get(ptr)).visitAll(new IVisitor<Pair<SNode, String>>() {
            public void visit(Pair<SNode, String> nP) {
              info.propertyNameRead(nP.o1, nP.o2, ptr);
            }
          });
        }
      }
    });
  }

  private static <K, T> void addValue(Map<K, List<T>> map, K key, T value) {
    if (key == null || value == null) {
      return;
    }
    List<T> list = MapSequence.fromMap(map).get(key);
    if (list == null) {
      MapSequence.fromMap(map).put(key, list = ListSequence.fromList(new ArrayList<T>()));
    }
    ListSequence.fromList(list).addElement(value);
  }

  private static <T> boolean move(Map<SNodeReference, List<T>> map, SNodeReference ptr, SNodeReference newPtr, final _FunctionTypes._void_P1_E0<? super T> f) {
    List<T> list = map.remove(ptr);
    if (list == null) {
      return false;
    }
    ListSequence.fromList(list).visitAll(new IVisitor<T>() {
      public void visit(T it) {
        f.invoke(it);
      }
    });
    MapSequence.fromMap(map).put(newPtr, list);
    return true;
  }

  private static <T> boolean delete(Map<SNodeReference, List<T>> map, SNodeReference ptr, final _FunctionTypes._void_P1_E0<? super T> f) {
    List<T> list = map.remove(ptr);
    if (list == null) {
      return false;
    }
    ListSequence.fromList(list).visitAll(new IVisitor<T>() {
      public void visit(T it) {
        f.invoke(it);
      }
    });
    return true;
  }

  private static <T> boolean setProp(Map<SNodeReference, List<T>> map, SNodeReference ptr, final _FunctionTypes._void_P1_E0<? super T> f) {
    List<T> list = MapSequence.fromMap(map).get(ptr);
    if (list == null) {
      return false;
    }
    ListSequence.fromList(list).visitAll(new IVisitor<T>() {
      public void visit(T it) {
        f.invoke(it);
      }
    });
    return true;
  }

  private static <T> void updatePtrMap(Map<SNodeReference, List<T>> map, final SModelReference oldModel, SModelReference newModel) {
    List<SNodeReference> ptrList = SetSequence.fromSet(MapSequence.fromMap(map).keySet()).where(new IWhereFilter<SNodeReference>() {
      public boolean accept(SNodeReference it) {
        return oldModel.equals(it.getModelReference());
      }
    }).toListSequence();
    for (SNodeReference ptr : ListSequence.fromList(ptrList)) {
      List<T> list = MapSequence.fromMap(map).removeKey(ptr);
      MapSequence.fromMap(map).put(new SNodePointer(newModel, ((SNodePointer) ptr).getNodeId()), list);
    }
  }

  private static SNodeReference ptr(SNode node) {
    return ((node == null) ?
      null :
      new SNodePointer(node)
    );
  }

  private static <T> T as_1o71zw_a0a0a22(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }
}
