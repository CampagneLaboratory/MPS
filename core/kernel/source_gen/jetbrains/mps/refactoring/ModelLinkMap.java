package jetbrains.mps.refactoring;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import java.util.Map;
import jetbrains.mps.smodel.SNodePointer;
import java.util.List;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.HackSNodeUtil;
import jetbrains.mps.util.NameUtil;

public class ModelLinkMap {
  private SModel myModel;
  private Map<SNodePointer, List<ModelLinkMap.LinkLocator>> myPtrMap;
  private Map<SModelReference, List<DynamicReference>> myDynRefMap;

  public ModelLinkMap(SModel model) {
    myModel = model;
    myPtrMap = MapSequence.fromMap(new HashMap<SNodePointer, List<ModelLinkMap.LinkLocator>>());
    myDynRefMap = MapSequence.fromMap(new HashMap<SModelReference, List<DynamicReference>>());
  }

  private void addLinkLocator(SNodePointer ptr, ModelLinkMap.LinkLocator locator) {
    if (ptr == null) {
      return;
    }
    List<ModelLinkMap.LinkLocator> list = MapSequence.fromMap(myPtrMap).get(ptr);
    if (list == null) {
      MapSequence.fromMap(myPtrMap).put(ptr, list = ListSequence.fromList(new ArrayList<ModelLinkMap.LinkLocator>()));
    }
    ListSequence.fromList(list).addElement(locator);
  }

  public void addTypeLocation(SNodePointer ptr, SNode node) {
    addLinkLocator(ptr, new ModelLinkMap.NodeType(node));
  }

  public void addTargetLocation(SNodePointer ptr, StaticReference ref) {
    addLinkLocator(ptr, new ModelLinkMap.ReferenceTarget(ref));
  }

  public void addRoleLocation(SNodePointer ptr, SReference ref) {
    addLinkLocator(ptr, new ModelLinkMap.ReferenceRole(ref));
  }

  public void addRoleLocation(SNodePointer ptr, SNode node) {
    addLinkLocator(ptr, new ModelLinkMap.NodeRole(node));
  }

  public void addNameLocation(SNodePointer ptr, SNode node, String name) {
    addLinkLocator(ptr, new ModelLinkMap.PropertyName(node, name));
  }

  public void addDynamicReference(SModelReference model, DynamicReference ref) {
    List<DynamicReference> list = MapSequence.fromMap(myDynRefMap).get(model);
    if (list == null) {
      MapSequence.fromMap(myDynRefMap).put(model, list = ListSequence.fromList(new ArrayList<DynamicReference>()));
    }
    ListSequence.fromList(list).addElement(ref);
  }

  public boolean updateNode(SNodePointer ptr, final SNodePointer newPtr, final String info) {
    List<ModelLinkMap.LinkLocator> list = MapSequence.fromMap(myPtrMap).removeKey(ptr);
    if (list == null) {
      return false;
    }
    ListSequence.fromList(list).visitAll(new IVisitor<ModelLinkMap.LinkLocator>() {
      public void visit(ModelLinkMap.LinkLocator it) {
        it.update(newPtr, info);
      }
    });
    MapSequence.fromMap(myPtrMap).put(newPtr, list);
    return true;
  }

  public boolean deleteNode(SNodePointer ptr) {
    List<ModelLinkMap.LinkLocator> list = MapSequence.fromMap(myPtrMap).removeKey(ptr);
    if (list == null) {
      return false;
    }
    ListSequence.fromList(list).visitAll(new IVisitor<ModelLinkMap.LinkLocator>() {
      public void visit(ModelLinkMap.LinkLocator it) {
        it.update(null, null);
      }
    });
    return true;
  }

  public boolean updateModelReference(SModelReference model, SModelReference newModel) {
    for (SModel.ImportElement element : ListSequence.fromList(myModel.importedModels())) {
    }
    return false;
  }

  private static interface LinkLocator {
    public void update(SNodePointer newRef, String info);
  }

  private static class ReferenceTarget implements ModelLinkMap.LinkLocator {
    private StaticReference myReference;

    public ReferenceTarget(StaticReference reference) {
      myReference = reference;
    }

    public void update(SNodePointer newRef, String info) {
      myReference.setTargetSModelReference(newRef.getModelReference());
      myReference.setTargetNodeId(newRef.getNodeId());
      // resolve info? 
    }

    public void updateModel(SModelReference newModel) {
      myReference.setTargetSModelReference(newModel);
    }
  }

  private static class NodeType implements ModelLinkMap.LinkLocator {
    private SNode myNode;

    public NodeType(SNode node) {
      myNode = node;
    }

    public void update(SNodePointer newRef, String type) {
      HackSNodeUtil.setConceptFqName(myNode, type);
    }

    public void updateModel(SModelReference newModel) {
      HackSNodeUtil.setConceptFqName(myNode, NameUtil.conceptFQNameFromNamespaceAndShortName(newModel.getLongName(), NameUtil.shortNameFromLongName(myNode.getConceptFqName())));
    }
  }

  private static class ReferenceRole implements ModelLinkMap.LinkLocator {
    private SReference myReference;

    public ReferenceRole(SReference reference) {
      myReference = reference;
    }

    public void update(SNodePointer newRef, String role) {
      // todo: rename correspondent link attribute roles if exist 
      myReference.setRole(role);
    }
  }

  private static class NodeRole implements ModelLinkMap.LinkLocator {
    private SNode myNode;

    public NodeRole(SNode node) {
      myNode = node;
    }

    public void update(SNodePointer newRef, String role) {
      // todo: rename correspondent link attribute roles 
      myNode.setRoleInParent(role);
    }
  }

  private static class PropertyName implements ModelLinkMap.LinkLocator {
    private SNode myNode;
    private String myName;

    public PropertyName(SNode node, String name) {
      myNode = node;
      myName = name;
    }

    public void update(SNodePointer newRef, String name) {
      // todo: rename correspondent property attribute roles 
      String value = myNode.getPersistentProperty(myName);
      myNode.setProperty(myName, null, false);
      myName = name;
      myNode.setProperty(myName, value, false);
    }
  }
}
