package jetbrains.mps.refactoring;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.descriptor.RefactorableSModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class StructureModification {
  private Map<SModelReference, Integer> myDependencies = MapSequence.fromMap(new HashMap<SModelReference, Integer>());
  private List<StructureModification.Entry> myModificationList = ListSequence.fromList(new ArrayList<StructureModification.Entry>());

  public StructureModification() {
  }

  public void addDependencyModel(SModelReference modelRef, int version) {
    MapSequence.fromMap(myDependencies).put(modelRef, version);
  }

  public void addDependencyModel(SModelReference modelRef) {
    if (!(MapSequence.fromMap(myDependencies).containsKey(modelRef))) {
      RefactorableSModelDescriptor model = as_hr78sn_a0a0a0a4(SModelRepository.getInstance().getModelDescriptor(modelRef), RefactorableSModelDescriptor.class);
      MapSequence.fromMap(myDependencies).put(modelRef, (model == null ?
        -1 :
        model.getVersion()
      ));
    }
  }

  public void setDependencies(Map<SModelReference, Integer> dependencies) {
    myDependencies = dependencies;
  }

  public Map<SModelReference, Integer> getDependencies() {
    return myDependencies;
  }

  public List<StructureModification.Entry> getData() {
    return myModificationList;
  }

  public boolean apply(final ModelLinkMap linkMap) {
    final Wrappers._boolean updated = new Wrappers._boolean(false);
    ListSequence.fromList(myModificationList).visitAll(new IVisitor<StructureModification.Entry>() {
      public void visit(StructureModification.Entry it) {
        updated.value |= it.apply(linkMap);
      }
    });
    return updated.value;
  }

  public static StructureModification.Relation compare(StructureModification a, StructureModification b) {
    Map<SModelReference, Integer> aa = a.getDependencies();
    Map<SModelReference, Integer> bb = b.getDependencies();

    boolean eq = (int) MapSequence.fromMap(aa).count() == (int) MapSequence.fromMap(bb).count();
    for (SModelReference k : SetSequence.fromSet(MapSequence.fromMap(aa).keySet())) {
      if (!(MapSequence.fromMap(bb).containsKey(k))) {
        eq = false;
        continue;
      }
      if ((int) MapSequence.fromMap(aa).get(k) == (int) MapSequence.fromMap(bb).get(k)) {
        continue;
      }
      return (MapSequence.fromMap(aa).get(k) < MapSequence.fromMap(bb).get(k) ?
        StructureModification.Relation.BEFORE :
        StructureModification.Relation.AFTER
      );
    }
    return (eq ?
      StructureModification.Relation.EQUAL :
      StructureModification.Relation.NONE
    );
  }

  public static interface Entry {
    public boolean apply(ModelLinkMap linkMap);
    public Iterable<SModelReference> getDependentModels();
  }

  public static class MoveNode implements StructureModification.Entry {
    public SNodeReference oldID;
    public SNodeReference newID;
    public String resolveInfo;

    public MoveNode(SNodeReference id, SNodeReference to) {
      oldID = id;
      newID = to;
    }

    public boolean apply(ModelLinkMap linkMap) {
      return linkMap.moveNode(oldID, newID);
    }

    public Iterable<SModelReference> getDependentModels() {
      return Sequence.fromArray(new SModelReference[]{oldID.getModelReference(), newID.getModelReference()});
    }
  }

  public static class RenameNode implements StructureModification.Entry {
    public SNodeReference oldID;
    public StructureModification.RenameNode.RenameType type;
    public String oldValue;
    public String newValue;

    public RenameNode(SNodeReference id, StructureModification.RenameNode.RenameType type, String newValue, String oldValue) {
      oldID = id;
      this.type = type;
      this.oldValue = oldValue;
      this.newValue = newValue;
    }

    public boolean apply(ModelLinkMap linkMap) {
      switch (type) {
        case CONCEPT:
        case PROPERTY:
          return linkMap.setName(oldID, newValue);
        case CHILD:
        case REFERENCE:
          return linkMap.setRole(oldID, newValue);
        default:
          return false;
      }
    }

    public Iterable<SModelReference> getDependentModels() {
      return Sequence.fromArray(new SModelReference[]{oldID.getModelReference()});
    }

    public static     enum RenameType {
      CONCEPT(),
      PROPERTY(),
      CHILD(),
      REFERENCE();

      RenameType() {
      }
    }
  }

  public static class RenameModel implements StructureModification.Entry {
    public SModelReference oldModel;
    public SModelReference newModel;

    public RenameModel(SModelReference from, SModelReference to) {
      oldModel = from;
      newModel = to;
    }

    public boolean apply(ModelLinkMap linkMap) {
      return linkMap.updateModelReference(oldModel, newModel);
    }

    public Iterable<SModelReference> getDependentModels() {
      return Sequence.fromArray(new SModelReference[]{oldModel, newModel});
    }
  }

  public static   enum Relation {
    EQUAL(),
    BEFORE(),
    AFTER(),
    NONE(),
    ERROR();

    Relation() {
    }

    public StructureModification.Relation swap() {
      if (this == StructureModification.Relation.BEFORE) {
        return StructureModification.Relation.AFTER;
      }
      if (this == StructureModification.Relation.AFTER) {
        return StructureModification.Relation.BEFORE;
      }
      return this;
    }
  }

  private static <T> T as_hr78sn_a0a0a0a4(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }
}
