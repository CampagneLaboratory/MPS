package jetbrains.mps.refactoring;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.SModelReference;

public class StructureModification {
  private List<StructureModification.MoveNode> myModificationList;

  public StructureModification() {
  }

  public boolean apply(final ModelLinkMap linkMap) {
    final Wrappers._boolean updated = new Wrappers._boolean(false);
    ListSequence.fromList(myModificationList).visitAll(new IVisitor<StructureModification.MoveNode>() {
      public void visit(StructureModification.MoveNode it) {
        updated.value |= it.apply(linkMap);
      }
    });
    return updated.value;
  }

  public static class MoveNode {
    private SNodePointer myOldID;
    private SNodePointer myNewID;
    private String myResolveInfo;
    private String myInfo;

    public MoveNode() {
      // info - name for PropertyDeclartation & AbstractConceptDeclaration or role for LinkDeclaration 
    }

    public boolean apply(ModelLinkMap linkMap) {
      return linkMap.updateNode(myOldID, myNewID, myInfo);
    }
  }

  public static class RenameModel {
    private SModelReference myOldModel;
    private SModelReference myNewModel;

    public RenameModel() {
    }

    public boolean apply(ModelLinkMap linkMap) {
      return false;
    }
  }
}
