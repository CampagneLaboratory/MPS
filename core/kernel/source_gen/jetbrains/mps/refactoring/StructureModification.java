package jetbrains.mps.refactoring;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.DefaultSModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class StructureModification {
  private Map<SModelReference, Integer> myDependencies = MapSequence.fromMap(new HashMap<SModelReference, Integer>());
  private List<StructureModification.Entry> myModificationList = ListSequence.fromList(new ArrayList<StructureModification.Entry>());

  public StructureModification() {
  }

  public void addDependencyModel(SModelReference modelRef, int version) {
    MapSequence.fromMap(myDependencies).put(modelRef, version);
  }

  public void addDependencyModel(SModelReference modelRef) {
    if (!(MapSequence.fromMap(myDependencies).containsKey(modelRef))) {
      DefaultSModelDescriptor model = as_hr78sn_a0a0a0a1(SModelRepository.getInstance().getModelDescriptor(modelRef), DefaultSModelDescriptor.class);
      MapSequence.fromMap(myDependencies).put(modelRef, (model == null ?
        -1 :
        model.getVersion()
      ));
    }
  }

  public void setDependencies(Map<SModelReference, Integer> dependencies) {
    myDependencies = dependencies;
  }

  public Map<SModelReference, Integer> getDependencies() {
    return myDependencies;
  }

  public List<StructureModification.Entry> getData() {
    return myModificationList;
  }

  public boolean apply(final ModelLinkMap linkMap) {
    final Wrappers._boolean updated = new Wrappers._boolean(false);
    ListSequence.fromList(myModificationList).visitAll(new IVisitor<StructureModification.Entry>() {
      public void visit(StructureModification.Entry it) {
        updated.value |= it.apply(linkMap);
      }
    });
    return updated.value;
  }

  public static StructureModification.Relation compare(StructureModification a, StructureModification b) {
    Map<SModelReference, Integer> aa = a.getDependencies();
    Map<SModelReference, Integer> bb = b.getDependencies();

    boolean eq = (int) MapSequence.fromMap(aa).count() == (int) MapSequence.fromMap(bb).count();
    for (SModelReference k : SetSequence.fromSet(MapSequence.fromMap(aa).keySet())) {
      if (!(MapSequence.fromMap(bb).containsKey(k))) {
        eq = false;
        continue;
      }
      if ((int) MapSequence.fromMap(aa).get(k) == (int) MapSequence.fromMap(bb).get(k)) {
        continue;
      }
      return (MapSequence.fromMap(aa).get(k) < MapSequence.fromMap(bb).get(k) ?
        StructureModification.Relation.BEFORE :
        StructureModification.Relation.AFTER
      );
    }
    return (eq ?
      StructureModification.Relation.EQUAL :
      StructureModification.Relation.NONE
    );
  }

  public static Iterable<StructureModification> sort(final List<StructureModification> list) {
    StructureModification.Relation[][] rel = new StructureModification.Relation[ListSequence.fromList(list).count()][ListSequence.fromList(list).count()];
    for (int i = 0; i < ListSequence.fromList(list).count(); ++i) {
      for (int j = 0; j < i; ++j) {
        rel[i][j] = compare(ListSequence.fromList(list).getElement(i), ListSequence.fromList(list).getElement(j));
        rel[j][i] = rel[i][j].swap();
      }
      rel[i][i] = StructureModification.Relation.EQUAL;
    }
    // create graph 
    Map<Integer, Set<Integer>> graph = MapSequence.fromMap(new HashMap<Integer, Set<Integer>>());
label:
    for (int i = 0; i < ListSequence.fromList(list).count(); i++) {
      Set<Integer> cur = SetSequence.fromSet(new HashSet<Integer>());
      for (int j = 0; j < i; j++) {
        if (rel[j][i] == StructureModification.Relation.EQUAL) {
          continue label;
        }
        if (rel[j][i] == StructureModification.Relation.BEFORE) {
          SetSequence.fromSet(cur).addElement(j);
        }
        if (rel[j][i] == StructureModification.Relation.AFTER) {
          SetSequence.fromSet(MapSequence.fromMap(graph).get(j)).addElement(i);
        }
      }
      MapSequence.fromMap(graph).put(i, cur);
    }
    // sort 
    List<Integer> ordered = ListSequence.fromList(new ArrayList<Integer>());
    Set<Integer> visited = SetSequence.fromSet(new HashSet<Integer>());
    for (int node : SetSequence.fromSet(MapSequence.fromMap(graph).keySet())) {
      visit(node, graph, visited, ordered);
    }
    return ListSequence.fromList(ordered).select(new ISelector<Integer, StructureModification>() {
      public StructureModification select(Integer it) {
        return ListSequence.fromList(list).getElement(it);
      }
    });
  }

  private static void visit(int node, Map<Integer, Set<Integer>> graph, Set<Integer> visited, List<Integer> result) {
    // topoligical sorting 
    if (SetSequence.fromSet(visited).contains(node)) {
      return;
    }
    SetSequence.fromSet(visited).addElement(node);
    for (int n : SetSequence.fromSet(MapSequence.fromMap(graph).get(node))) {
      visit(n, graph, visited, result);
    }
    ListSequence.fromList(result).addElement(node);
  }

  private static <T> T as_hr78sn_a0a0a0a1(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }

  public static interface Entry {
    public boolean apply(ModelLinkMap linkMap);
    public Iterable<SModelReference> getDependentModels();
  }

  public static class MoveNode implements StructureModification.Entry {
    public SNodePointer oldID;
    public SNodePointer newID;
    public String resolveInfo;

    public MoveNode(SNodePointer id, SNodePointer to) {
      oldID = id;
      newID = to;
    }

    public boolean apply(ModelLinkMap linkMap) {
      return linkMap.moveNode(oldID, newID);
    }

    public Iterable<SModelReference> getDependentModels() {
      return Sequence.fromArray(new SModelReference[]{oldID.getModelReference(), newID.getModelReference()});
    }
  }

  public static class RenameNode implements StructureModification.Entry {
    public SNodePointer oldID;
    public StructureModification.RenameNode.RenameType type;
    public String oldValue;
    public String newValue;

    public RenameNode(SNodePointer id, StructureModification.RenameNode.RenameType type, String newValue, String oldValue) {
      oldID = id;
      this.type = type;
      this.oldValue = oldValue;
      this.newValue = newValue;
    }

    public boolean apply(ModelLinkMap linkMap) {
      switch (type) {
        case CONCEPT:
        case PROPERTY:
          return linkMap.setName(oldID, newValue);
        case CHILD:
        case REFERENCE:
          return linkMap.setRole(oldID, newValue);
        default:
          return false;
      }
    }

    public Iterable<SModelReference> getDependentModels() {
      return Sequence.fromArray(new SModelReference[]{oldID.getModelReference()});
    }

    public static     enum RenameType {
      CONCEPT(),
      PROPERTY(),
      CHILD(),
      REFERENCE();

      RenameType() {
      }
    }
  }

  public static class RenameModel implements StructureModification.Entry {
    public SModelReference oldModel;
    public SModelReference newModel;

    public RenameModel(SModelReference from, SModelReference to) {
      oldModel = from;
      newModel = to;
    }

    public boolean apply(ModelLinkMap linkMap) {
      return linkMap.updateModelReference(oldModel, newModel);
    }

    public Iterable<SModelReference> getDependentModels() {
      return Sequence.fromArray(new SModelReference[]{oldModel, newModel});
    }
  }

  public static   enum Relation {
    EQUAL(),
    BEFORE(),
    AFTER(),
    NONE(),
    ERROR();

    Relation() {
    }

    public StructureModification.Relation swap() {
      if (this == StructureModification.Relation.BEFORE) {
        return StructureModification.Relation.AFTER;
      }
      if (this == StructureModification.Relation.AFTER) {
        return StructureModification.Relation.BEFORE;
      }
      return this;
    }
  }
}
