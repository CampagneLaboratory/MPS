package jetbrains.mps.refactoring;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISequenceClosure;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;

public class StructureModification {
  private Map<SModelReference, Integer> myDependencies = MapSequence.fromMap(new HashMap<SModelReference, Integer>());
  private List<StructureModification.Entry> myModificationList = ListSequence.fromList(new ArrayList<StructureModification.Entry>());

  public StructureModification() {
  }

  public void addDependencyModel(SModelReference modelRef, int version) {
    MapSequence.fromMap(myDependencies).put(modelRef, version);
  }

  public void addDependencyModel(SModelReference modelRef) {
    if (!(MapSequence.fromMap(myDependencies).containsKey(modelRef))) {
      EditableSModelDescriptor model = as_hr78sn_a0a0a0a1(SModelRepository.getInstance().getModelDescriptor(modelRef), EditableSModelDescriptor.class);
      MapSequence.fromMap(myDependencies).put(modelRef, (model == null ?
        -1 :
        model.getVersion()
      ));
    }
  }

  public void setDependencies(Map<SModelReference, Integer> dependencies) {
    myDependencies = dependencies;
  }

  public Map<SModelReference, Integer> getDependencies() {
    return myDependencies;
  }

  public List<StructureModification.Entry> getData() {
    return myModificationList;
  }

  public boolean apply(final ModelLinkMap linkMap) {
    final Wrappers._boolean updated = new Wrappers._boolean(false);
    ListSequence.fromList(myModificationList).visitAll(new IVisitor<StructureModification.Entry>() {
      public void visit(StructureModification.Entry it) {
        updated.value |= it.apply(linkMap);
      }
    });
    return updated.value;
  }

  private static <T> T as_hr78sn_a0a0a0a1(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }

  public static interface Entry {
    public boolean apply(ModelLinkMap linkMap);
    public Iterable<SModelReference> getDependentModels();
  }

  public static class MoveNode implements StructureModification.Entry {
    public SNodePointer oldID;
    public SNodePointer newID;
    public String resolveInfo;

    public MoveNode(SNodePointer id, SNodePointer to) {
      oldID = id;
      newID = to;
    }

    public boolean apply(ModelLinkMap linkMap) {
      return linkMap.moveNode(oldID, newID);
    }

    public Iterable<SModelReference> getDependentModels() {
      return Sequence.fromClosure(new ISequenceClosure<SModelReference>() {
        public Iterable<SModelReference> iterable() {
          return new Iterable<SModelReference>() {
            public Iterator<SModelReference> iterator() {
              return new YieldingIterator<SModelReference>() {
                private int __CP__ = 0;

                protected boolean moveToNext() {
__loop__:
                  do {
__switch__:
                    switch (this.__CP__) {
                      case -1:
                        assert false : "Internal error";
                        return false;
                      case 2:
                        this.__CP__ = 3;
                        this.yield(oldID.getModelReference());
                        return true;
                      case 3:
                        this.__CP__ = 1;
                        this.yield(newID.getModelReference());
                        return true;
                      case 0:
                        this.__CP__ = 2;
                        break;
                      default:
                        break __loop__;
                    }
                  } while (true);
                  return false;
                }
              };
            }
          };
        }
      });
    }
  }

  public static class RenameNode implements StructureModification.Entry {
    public SNodePointer oldID;
    public StructureModification.RenameNode.RenameType type;
    public String oldValue;
    public String newValue;

    public RenameNode(SNodePointer id, StructureModification.RenameNode.RenameType type, String newValue, String oldValue) {
      oldID = id;
      this.type = type;
      this.oldValue = oldValue;
      this.newValue = newValue;
    }

    public boolean apply(ModelLinkMap linkMap) {
      switch (type) {
        case CONCEPT:
        case PROPERTY:
          return linkMap.setName(oldID, newValue);
        case CHILD:
        case REFERENCE:
          return linkMap.setRole(oldID, newValue);
        default:
          return false;
      }
    }

    public Iterable<SModelReference> getDependentModels() {
      return Sequence.fromClosure(new ISequenceClosure<SModelReference>() {
        public Iterable<SModelReference> iterable() {
          return new Iterable<SModelReference>() {
            public Iterator<SModelReference> iterator() {
              return new YieldingIterator<SModelReference>() {
                private int __CP__ = 0;

                protected boolean moveToNext() {
__loop__:
                  do {
__switch__:
                    switch (this.__CP__) {
                      case -1:
                        assert false : "Internal error";
                        return false;
                      case 2:
                        this.__CP__ = 1;
                        this.yield(oldID.getModelReference());
                        return true;
                      case 0:
                        this.__CP__ = 2;
                        break;
                      default:
                        break __loop__;
                    }
                  } while (true);
                  return false;
                }
              };
            }
          };
        }
      });
    }

    public static     enum RenameType {
      CONCEPT(),
      PROPERTY(),
      CHILD(),
      REFERENCE();

      RenameType() {
      }
    }
  }

  public static class RenameModel implements StructureModification.Entry {
    public SModelReference oldModel;
    public SModelReference newModel;

    public RenameModel() {
    }

    public boolean apply(ModelLinkMap linkMap) {
      return linkMap.updateModelReference(oldModel, newModel);
    }

    public Iterable<SModelReference> getDependentModels() {
      return Sequence.fromClosure(new ISequenceClosure<SModelReference>() {
        public Iterable<SModelReference> iterable() {
          return new Iterable<SModelReference>() {
            public Iterator<SModelReference> iterator() {
              return new YieldingIterator<SModelReference>() {
                private int __CP__ = 0;

                protected boolean moveToNext() {
__loop__:
                  do {
__switch__:
                    switch (this.__CP__) {
                      case -1:
                        assert false : "Internal error";
                        return false;
                      case 2:
                        this.__CP__ = 3;
                        this.yield(oldModel);
                        return true;
                      case 3:
                        this.__CP__ = 1;
                        this.yield(newModel);
                        return true;
                      case 0:
                        this.__CP__ = 2;
                        break;
                      default:
                        break __loop__;
                    }
                  } while (true);
                  return false;
                }
              };
            }
          };
        }
      });
    }
  }
}
