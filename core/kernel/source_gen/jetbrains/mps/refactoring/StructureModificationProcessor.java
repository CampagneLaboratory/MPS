package jetbrains.mps.refactoring;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IMapping;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.smodel.descriptor.RefactorableSModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import java.util.Map;
import java.util.Set;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.apache.log4j.Level;
import jetbrains.mps.RuntimeFlags;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class StructureModificationProcessor {
  private ModelLinkMap myModelMap;
  private SModel myModel;
  public StructureModificationProcessor(ModelLinkMap modelMap, SModel model) {
    myModelMap = modelMap;
    myModel = model;
  }
  private boolean playRefactoring(@NotNull StructureModification data) {
    boolean result = data.apply(myModelMap);
    for (IMapping<SModelReference, Integer> entry : MapSequence.fromMap(data.getDependencies())) {
      // also adds implicit import if necessary 
      myModel.updateImportedModelUsedVersion(entry.key(), entry.value() + 1);
    }
    return result;
  }
  public boolean updateModelOnLoad() {
    // should be called in loading state 
    if (!((refactoringsPlaybackEnabled() && SModelStereotype.isUserModel(myModel.getReference().getModelName())))) {
      return false;
    }
    boolean played = false;
    for (StructureModification data : ListSequence.fromList(sortModifications(getApplicableModifications()))) {
      played |= playRefactoring(data);
    }
    return played;
  }
  public List<StructureModification> getApplicableModifications() {
    List<StructureModification> result = ListSequence.fromList(new ArrayList<StructureModification>());
    for (SModel.ImportElement importElement : ListSequence.fromList(SModelOperations.getAllImportElements(myModel))) {
      RefactorableSModelDescriptor usedModel = as_etzqsh_a0a0a1a5(SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference()), RefactorableSModelDescriptor.class);
      if (usedModel == null) {
        continue;
      }
      for (StructureModification data : ListSequence.fromList(usedModel.getStructureModificationLog().getHistory())) {
        if (importElement.getUsedVersion() <= MapSequence.fromMap(data.getDependencies()).get(usedModel.getReference())) {
          ListSequence.fromList(result).addElement(data);
        }
      }
    }
    return result;
  }
  private List<StructureModification> sortModifications(List<StructureModification> list) {
    // create graph 
    final Map<Integer, Set<Integer>> graph = MapSequence.fromMap(new HashMap<Integer, Set<Integer>>());
lCompare:
    for (final Wrappers._int i = new Wrappers._int(0); i.value < ListSequence.fromList(list).count(); i.value++) {
      Set<Integer> before = SetSequence.fromSet(new HashSet<Integer>());
      List<Integer> after = ListSequence.fromList(new ArrayList<Integer>());
      for (int j : MapSequence.fromMap(graph).keySet()) {
        StructureModification.Relation rel = StructureModification.compare(ListSequence.fromList(list).getElement(j), ListSequence.fromList(list).getElement(i.value));
        if (rel == StructureModification.Relation.EQUAL) {
          continue lCompare;
        }
        if (rel == StructureModification.Relation.BEFORE) {
          SetSequence.fromSet(before).addElement(j);
        }
        if (rel == StructureModification.Relation.AFTER) {
          ListSequence.fromList(after).addElement(j);
        }
      }
      MapSequence.fromMap(graph).put(i.value, before);
      ListSequence.fromList(after).visitAll(new IVisitor<Integer>() {
        public void visit(Integer j) {
          SetSequence.fromSet(MapSequence.fromMap(graph).get(j)).addElement(i.value);
        }
      });
    }
    // sort 
    List<StructureModification> result = ListSequence.fromList(new ArrayList<StructureModification>());
lfind:
    while (MapSequence.fromMap(graph).isNotEmpty()) {
      for (final int k : MapSequence.fromMap(graph).keySet()) {
        if (SetSequence.fromSet(MapSequence.fromMap(graph).get(k)).isEmpty()) {
          ListSequence.fromList(result).addElement(ListSequence.fromList(list).getElement(k));
          MapSequence.fromMap(graph).removeKey(k);
          Sequence.fromIterable(MapSequence.fromMap(graph).values()).visitAll(new IVisitor<Set<Integer>>() {
            public void visit(Set<Integer> it) {
              SetSequence.fromSet(it).removeElement(k);
            }
          });
          continue lfind;
        }
      }
      // we have not found next data: loop detected! 
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Loop found in applicable refactorings for " + myModel + "");
      }
      break;
    }
    return result;
  }
  public static void addToLog(@NotNull final StructureModification data) {
    // add all missed dependencies with current version 
    for (StructureModification.Entry entry : ListSequence.fromList(data.getData())) {
      Sequence.fromIterable(entry.getDependentModels()).visitAll(new IVisitor<SModelReference>() {
        public void visit(SModelReference it) {
          data.addDependencyModel(it);
        }
      });
    }
    // add modification to all dependent models 
    for (IMapping<SModelReference, Integer> dependency : MapSequence.fromMap(data.getDependencies())) {
      RefactorableSModelDescriptor model = (RefactorableSModelDescriptor) SModelRepository.getInstance().getModelDescriptor(dependency.key());
      StructureModificationLog modificationLog = model.getStructureModificationLog();
      modificationLog.addStructureModification(data);
      model.setVersion(dependency.value() + 1);
      model.saveStructureModificationLog(modificationLog);
      model.setChanged(true);
    }
  }
  public static boolean hasRefactoringsToPlay(@NotNull SModel model) {
    if (refactoringsPlaybackEnabled() && SModelStereotype.isUserModel(model.getReference().getModelName())) {
      for (SModel.ImportElement importElement : ListSequence.fromList(SModelOperations.getAllImportElements(model))) {
        RefactorableSModelDescriptor usedModel = as_etzqsh_a0a0a0a0a8(SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference()), RefactorableSModelDescriptor.class);
        if (usedModel != null && importElement.getUsedVersion() < usedModel.getVersion()) {
          return true;
        }
      }
    }
    return false;
  }
  public static boolean refactoringsPlaybackEnabled() {
    return RuntimeFlags.isPlayRefactoringsMode();
  }
  protected static Logger LOG = LogManager.getLogger(StructureModificationProcessor.class);
  private static <T> T as_etzqsh_a0a0a1a5(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_etzqsh_a0a0a0a0a8(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
