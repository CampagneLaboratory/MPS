package jetbrains.mps.refactoring;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.smodel.DefaultSModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class StructureModificationProcessor {
  protected static Log log = LogFactory.getLog(StructureModificationProcessor.class);

  private ModelLinkMap myModelMap;
  private SModel myModel;

  public StructureModificationProcessor(ModelLinkMap modelMap, SModel model) {
    myModelMap = modelMap;
    myModel = model;
  }

  private boolean playRefactoring(@NotNull StructureModification data) {
    boolean result = data.apply(myModelMap);
    for (IMapping<SModelReference, Integer> entry : MapSequence.fromMap(data.getDependencies())) {
      // also adds implicit import if necessary 
      myModel.updateImportedModelUsedVersion(entry.key(), entry.value() + 1);
    }
    return result;
  }

  public boolean updateModelOnLoad() {
    // should be called in loading state 
    if (!(refactoringsPlaybackEnabled() && SModelStereotype.isUserModel(myModel))) {
      return false;
    }
    boolean played = false;
    // <node> 
    for (StructureModification data : Sequence.fromIterable(StructureModification.sort(getApplicableModifications()))) {
      played |= playRefactoring(data);
    }
    return played;
  }

  public List<StructureModification> getApplicableModifications() {
    List<StructureModification> result = ListSequence.fromList(new ArrayList<StructureModification>());
    for (SModel.ImportElement importElement : ListSequence.fromList(SModelOperations.getAllImportElements(myModel))) {
      DefaultSModelDescriptor usedModel = as_etzqsh_a0a0a1a2(SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference()), DefaultSModelDescriptor.class);
      if (usedModel == null) {
        continue;
      }
      for (StructureModification data : ListSequence.fromList(usedModel.getStructureModificationLog().getHistory())) {
        if (importElement.getUsedVersion() <= MapSequence.fromMap(data.getDependencies()).get(usedModel.getSModelReference())) {
          ListSequence.fromList(result).addElement(data);
        }
      }
    }
    return result;
  }

  private List<StructureModification> getSortedModifications() {
    List<StructureModification> allData = ListSequence.fromList(new ArrayList<StructureModification>());
    List<StructureModification.Relation[]> res = ListSequence.fromList(new ArrayList<StructureModification.Relation[]>());
    for (SModel.ImportElement importElement : ListSequence.fromList(SModelOperations.getAllImportElements(myModel))) {
      DefaultSModelDescriptor usedModel = as_etzqsh_a0a0a2a3(SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference()), DefaultSModelDescriptor.class);
      if (usedModel == null) {
        continue;
      }
lCompare:
      for (StructureModification data : ListSequence.fromList(usedModel.getStructureModificationLog().getHistory())) {
        if (MapSequence.fromMap(data.getDependencies()).get(usedModel.getSModelReference()) < importElement.getUsedVersion()) {
          continue;
        }
        StructureModification.Relation[] comp = new StructureModification.Relation[ListSequence.fromList(allData).count() + 1];
        for (int i = 0; i < ListSequence.fromList(allData).count(); ++i) {
          comp[i] = StructureModification.compare(data, ListSequence.fromList(allData).getElement(i));
          if (comp[i] == StructureModification.Relation.EQUAL) {
            continue lCompare;
          }
        }
        ListSequence.fromList(allData).addElement(data);
        ListSequence.fromList(res).addElement(comp);
      }
    }
    // sort 
    List<StructureModification> result = ListSequence.fromList(new ArrayList<StructureModification>());
label:
    while (ListSequence.fromList(allData).isNotEmpty()) {
      // look for node 
lFind:
      for (int i = 0; i < ListSequence.fromList(allData).count(); ++i) {
        for (int j = 0; j < ListSequence.fromList(allData).count(); ++j) {
          if (i < j && ListSequence.fromList(res).getElement(j)[i] == StructureModification.Relation.BEFORE || i > j && ListSequence.fromList(res).getElement(i)[j] == StructureModification.Relation.AFTER) {
            continue lFind;
          }
        }
        ListSequence.fromList(result).addElement(ListSequence.fromList(allData).removeElementAt(i));
        ListSequence.fromList(res).removeElementAt(i);
        continue label;
      }
      // we have not found next data: loop detected! 
      if (log.isErrorEnabled()) {
        log.error("Loop found in applicable refactorings for " + myModel + "");
      }
      break;
    }
    return result;
  }

  public static void addToLog(@NotNull final StructureModification data) {
    // add all missed dependencies with current version 
    for (StructureModification.Entry entry : ListSequence.fromList(data.getData())) {
      Sequence.fromIterable(entry.getDependentModels()).visitAll(new IVisitor<SModelReference>() {
        public void visit(SModelReference it) {
          data.addDependencyModel(it);
        }
      });
    }
    // add modification to all dependent models 
    for (IMapping<SModelReference, Integer> dependency : MapSequence.fromMap(data.getDependencies())) {
      DefaultSModelDescriptor model = (DefaultSModelDescriptor) SModelRepository.getInstance().getModelDescriptor(dependency.key());
      StructureModificationLog modificationLog = model.getStructureModificationLog();
      modificationLog.addStructureModification(data);
      model.setVersion(dependency.value() + 1);
      model.saveStructureModificationLog(modificationLog);
      model.setChanged(true);
    }
  }

  public static boolean hasRefactoringsToPlay(@NotNull SModel model) {
    if (refactoringsPlaybackEnabled() && SModelStereotype.isUserModel(model)) {
      for (SModel.ImportElement importElement : ListSequence.fromList(SModelOperations.getAllImportElements(model))) {
        DefaultSModelDescriptor usedModel = as_etzqsh_a0a0a0a0a1(SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference()), DefaultSModelDescriptor.class);
        if (usedModel != null && importElement.getUsedVersion() < usedModel.getVersion()) {
          return true;
        }
      }
    }
    return false;
  }

  public static boolean refactoringsPlaybackEnabled() {
    return !("false".equals(System.getProperty("mps.playRefactorings")));
  }

  private static <T> T as_etzqsh_a0a0a0a0a1(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }

  private static <T> T as_etzqsh_a0a0a1a2(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }

  private static <T> T as_etzqsh_a0a0a2a3(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }
}
