package jetbrains.mps.refactoring;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.SModelDescriptor;

public class StructureModificationProcessor {
  protected static final Logger LOG = Logger.getLogger(StructureModificationProcessor.class);

  private ModelLinkMap myModelMap;
  private SModel myModel;

  public StructureModificationProcessor(ModelLinkMap modelMap, SModel model) {
    myModelMap = modelMap;
    myModel = model;
  }

  private boolean playRefactoring(@NotNull StructureModification data) {
    for (IMapping<SModelReference, Integer> entry : MapSequence.fromMap(data.getDependencies())) {
      // also adds implicit import if necessary 
      myModel.updateImportedModelUsedVersion(entry.key(), entry.value() + 1);
    }
    return data.apply(myModelMap);
  }

  private boolean playUsedModelDescriptorsRefactorings(EditableSModelDescriptor usedModelDescriptor) {
    int currentVersion = usedModelDescriptor.getVersion();
    int usedVersion = SModelOperations.getUsedVersion(myModel, usedModelDescriptor.getSModelReference());
    if (currentVersion > usedVersion) {
      boolean played = false;
      StructureModificationLog history = usedModelDescriptor.getStructureModificationLog();
      if (history == null) {
        return false;
      }
      for (StructureModification data : history.getHistory()) {
        if (MapSequence.fromMap(data.getDependencies()).get(usedModelDescriptor.getSModelReference()) < usedVersion) {
          continue;
        }
        played |= playRefactoring(data);
      }
      return played;
    } else if (currentVersion < usedVersion) {
      LOG.error("Model version mismatch for import " + usedModelDescriptor.getSModelReference().getSModelFqName() + " in model " + myModel.getSModelFqName());
      LOG.error("Used version = " + usedVersion + ", current version = " + currentVersion);
      // <node> 
      // <node> 
      return true;
    } else {
      return false;
    }
  }

  public boolean updateModelOnLoad() {
    // should be called in loading state 
    if (!(PlayRefactoringsFlag.refactoringsPlaybackEnabled())) {
      return false;
    }
    if (!(SModelStereotype.isUserModel(myModel))) {
      return false;
    }
    boolean result = false;
    // todo: calculate the order of refactorings to play and use it 
    boolean played;
    do {
      played = false;
      for (SModel.ImportElement importElement : SModelOperations.getAllImportElements(myModel)) {
        EditableSModelDescriptor usedModelDescriptor = as_etzqsh_a0a0a1a6a2(SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference()), EditableSModelDescriptor.class);
        if (usedModelDescriptor == null || usedModelDescriptor.getVersion() <= importElement.getUsedVersion()) {
          continue;
        }
        played |= playUsedModelDescriptorsRefactorings(usedModelDescriptor);
      }
      result |= played;
    } while (played);
    return result;
  }

  public static void addToHistory(@NotNull final StructureModification data) {
    // add all dependencies with current version 
    for (StructureModification.Entry d : ListSequence.fromList(data.getData())) {
      Sequence.fromIterable(d.getDependentModels()).visitAll(new IVisitor<SModelReference>() {
        public void visit(SModelReference it) {
          data.addDependencyModel(it);
        }
      });
    }
    // add data to all dependent models 
    for (IMapping<SModelReference, Integer> d : MapSequence.fromMap(data.getDependencies())) {
      EditableSModelDescriptor model = (EditableSModelDescriptor) SModelRepository.getInstance().getModelDescriptor(d.key());
      StructureModificationLog history = model.getStructureModificationLog();
      history.addStructureModification(data);
      model.setVersion(d.value() + 1);
      model.saveStructureModificationLog(history);
      SModelRepository.getInstance().markChanged(model, true);
    }
  }

  public static boolean hasRefactoringsToPlay(@NotNull SModel model) {
    if (!(PlayRefactoringsFlag.refactoringsPlaybackEnabled())) {
      return false;
    }
    if (!(SModelStereotype.isUserModel(model))) {
      return false;
    }
    for (SModel.ImportElement importElement : SModelOperations.getAllImportElements(model)) {
      SModelDescriptor usedModelDescriptor = SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference());
      if (!((usedModelDescriptor instanceof EditableSModelDescriptor))) {
        continue;
      }
      if (importElement.getUsedVersion() < ((EditableSModelDescriptor) usedModelDescriptor).getVersion()) {
        return true;
      }
    }
    return false;
  }

  private static <T> T as_etzqsh_a0a0a1a6a2(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }
}
