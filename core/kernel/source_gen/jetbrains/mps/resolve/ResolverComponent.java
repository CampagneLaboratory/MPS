package jetbrains.mps.resolve;

/*Generated by MPS */

import jetbrains.mps.components.CoreComponent;
import java.util.Comparator;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Iterator;
import org.jetbrains.annotations.NotNull;

public class ResolverComponent implements CoreComponent {
  private static ResolverComponent INSTANCE;
  private static Comparator<SReference> REFERENCE_COMPARATOR = new Comparator<SReference>() {
    public int compare(SReference first, SReference second) {
      SNode firstNode = first.getSourceNode();
      SNode secondNode = second.getSourceNode();
      if (firstNode.isAncestorOf(secondNode)) {
        return 1;
      }
      if (secondNode.isAncestorOf(firstNode)) {
        return -1;
      }
      return 0;
    }
  };

  private List<IResolver> myResolvers;
  private ScopeResolver myScopeResolver;

  public ResolverComponent() {
    myResolvers = ListSequence.fromList(new LinkedList<IResolver>());
    myScopeResolver = new ScopeResolver();
  }

  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }

    INSTANCE = this;
    INSTANCE.addResolver(myScopeResolver);
  }

  public void dispose() {
    INSTANCE.removeResolver(myScopeResolver);
    INSTANCE = null;
  }

  public void addResolver(IResolver resolver) {
    ListSequence.fromList(myResolvers).addElement(resolver);
  }

  public void removeResolver(IResolver resolver) {
    ListSequence.fromList(myResolvers).removeElement(resolver);
  }

  /*package*/ List<IResolver> getResolvers() {
    return myResolvers;
  }

  public boolean resolve(SReference reference, IOperationContext operationContext) {
    AbstractResolveResult resolveResult = doResolve(reference, operationContext);
    if (resolveResult != null) {
      resolveResult.setTarget();
      return true;
    }
    return false;
  }

  public void resolveScopesOnly(Iterable<SReference> references, IOperationContext operationContext) {
    List<SReference> unresolvedReferences = Sequence.fromIterable(references).sort(REFERENCE_COMPARATOR, true).toListSequence();
    boolean performResolve = true;
    while (performResolve) {
      performResolve = false;
      for (Iterator<SReference> iterator = ListSequence.fromList(unresolvedReferences).iterator(); iterator.hasNext();) {
        SReference reference = iterator.next();
        SNode sourceNode = reference.getSourceNode();
        if (sourceNode == null) {
          continue;
        }
        ResolveResult resolveResult = myScopeResolver.resolve(reference, sourceNode, operationContext);
        if (resolveResult != null) {
          resolveResult.setTarget();
          iterator.remove();
          performResolve = true;
        }
      }
    }

  }

  private AbstractResolveResult doResolve(@NotNull SReference reference, @NotNull IOperationContext operationContext) {
    SNode sourceNode = reference.getSourceNode();
    if (sourceNode == null) {
      return null;
    }
    for (IResolver nextResolver : ListSequence.fromList(myResolvers)) {
      AbstractResolveResult resolveResult = nextResolver.resolve(reference, sourceNode, operationContext);
      if (resolveResult != null) {
        return resolveResult;
      }
    }
    return null;
  }

  public static ResolverComponent getInstance() {
    return INSTANCE;
  }
}
