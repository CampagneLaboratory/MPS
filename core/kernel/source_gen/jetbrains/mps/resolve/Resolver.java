package jetbrains.mps.resolve;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.List;
import jetbrains.mps.smodel.SReference;
import java.util.Set;
import jetbrains.mps.smodel.IOperationContext;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.search.SModelSearchUtil;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.util.Computable;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.smodel.constraints.ModelConstraintsUtil;
import jetbrains.mps.scope.ErrorScope;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class Resolver {
  private static final Logger LOG = Logger.getLogger(Resolver.class);

  public Resolver() {
  }

  public static List<SReference> resolveReferences(Set<SReference> references, IOperationContext operationContext) {
    return Resolver.resolveReferences(references, operationContext, new ArrayList<ResolveResult>(), true);
  }

  public static List<SReference> resolveReferences(Set<SReference> references, IOperationContext operationContext, List<ResolveResult> results, boolean forceResolve) {
    List<SReference> referencesToSort = new ArrayList<SReference>(references);
    Collections.sort(referencesToSort, new Comparator<SReference>() {
      public int compare(SReference o1, SReference o2) {
        SNode node1 = o1.getSourceNode();
        SNode node2 = o2.getSourceNode();
        if (node1.isAncestorOf(node2)) {
          return 1;
        }
        if (node2.isAncestorOf(node1)) {
          return -1;
        }
        return 0;
      }
    });
    while (true) {
      int size = referencesToSort.size();
      for (SReference reference : new ArrayList<SReference>(referencesToSort)) {
        boolean resolved = Resolver.resolve1(reference, operationContext, results, forceResolve);
        if (resolved) {
          referencesToSort.remove(reference);
        }
      }
      if (size <= referencesToSort.size()) {
        break;
      }
    }
    return referencesToSort;
  }

  public static boolean resolve1(SReference reference, IOperationContext operationContext) {
    return Resolver.resolve1(reference, operationContext, new ArrayList<ResolveResult>(), true);
  }

  public static boolean resolve1(final SReference reference, final IOperationContext operationContext, final List<ResolveResult> results, final boolean forceResolve) {
    final SNode referenceNode = reference.getSourceNode();
    if (referenceNode == null) {
      return false;
    }
    final SNode linkDeclaration = SModelSearchUtil.findLinkDeclaration(referenceNode.getConceptDeclarationNode(), reference.getRole());
    if (linkDeclaration == null) {
      return false;
    }
    final SNode referentConcept = SModelUtil.getLinkDeclarationTarget(linkDeclaration);
    Boolean result = TypeContextManager.getInstance().runResolveAction(new Computable<Boolean>() {
      @Override
      public Boolean compute() {
        Scope refScope = ModelConstraintsUtil.getScope(reference, operationContext);
        if (refScope instanceof ErrorScope) {
          Resolver.LOG.error("Couldn't create referent search scope : " + ((ErrorScope) refScope).getMessage());
          return false;
        }
        SNode result = null;
        String resolveInfo = reference.getResolveInfo();
        for (SNode node : refScope.getAvailableElements(null)) {
          if (!(node.isInstanceOfConcept(referentConcept))) {
            continue;
          }
          if (resolveInfo != null && (resolveInfo.equals(node.getName()) || SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Classifier") && resolveInfo.equals(SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier"), "nestedName")))) {
            if (result == null) {
              result = node;
            } else {
              // ambiguity 
              return false;
            }
          }
        }
        if (result != null) {
          ResolveResult resolveResult = new ResolveResult(referenceNode, result, reference.getRole(), null);
          results.add(resolveResult);
          if (forceResolve) {
            resolveResult.setTarget();
          }
          return true;
        }
        return false;
      }
    });
    return result;
  }
}
