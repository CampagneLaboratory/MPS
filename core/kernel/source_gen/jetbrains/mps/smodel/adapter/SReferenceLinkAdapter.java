package jetbrains.mps.smodel.adapter;

/*Generated by MPS */

import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.SAbstractLinkId;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SScope;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.scope.Scope;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.smodel.search.ConceptAndSuperConceptsScope;
import org.jetbrains.annotations.NotNull;

public class SReferenceLinkAdapter  implements SReferenceLink {
  protected SReferenceLinkId myRoleId;

  public SReferenceLinkAdapter(String conceptName, String role) {
    super(conceptName, role);
  }

  public SReferenceLinkAdapter(SReferenceLinkId roleId) {
    super(null, null);
    myRoleId = roleId;
  }

  @Override
  public String getRole() {
    fillBothIds();
    // todo here we should obtain name from a concept node, but since we now having code which doesn't work by id and therefore obtains the name
    // todo frequently, we get a huge slowdown if obtaining name from a node here
    // todo in 3.2, it is supposed that we either remove most accesses to this method or we'll return role here and clear it in all concepts when renaming role in IDE
    return role;
  }

  @Override
  public boolean isOptional() {
    // TODO reimplement using ConceptDescriptor
    SNode link = getLinkNode();
    if (link == null) {
      return true;
    }
    return SPropertyOperations.hasValue(link, "sourceCardinality", "0..1", "0..1") || SPropertyOperations.hasValue(link, "sourceCardinality", "0..n", "0..1");
  }

  @Override
  public SAbstractConcept getTargetConcept() {
    // TODO reimplement using ConceptDescriptor
    SNode link = getLinkNode();
    if (link == null) {
      return null;
    }
    SNode t = SLinkOperations.getTarget(link, "target", false);
    SConceptId id = MetaIdByDeclaration.getConceptId((jetbrains.mps.smodel.SNode) t);
    boolean isConcept = t.getConcept().getQualifiedName().equals("jetbrains.mps.lang.structure.structure.ConceptDeclaration");
    return (isConcept ? new SConceptAdapter(id) : new SInterfaceConceptAdapter(id));
  }

  public SAbstractLinkId getRoleId() {
    fillBothIds();
    return myRoleId;
  }

  @Override
  public SAbstractConcept getContainingConcept() {
    return new SConceptAdapter(myRoleId.getConceptId());
  }

  @Override
  public boolean isReference() {
    return true;
  }

  @Override
  public boolean isMultiple() {
    return false;
  }

  public SScope getScope(SNode referenceNode) {
    // TODO scope = ModelConstraints.getReferenceDescriptor(conceptName, role).getScope()
    Scope scope = null;
    if (scope != null) {
      return new SReferenceLinkAdapter.SScopeAdapter(scope, referenceNode);
    }
    return null;
  }
  public SScope getScope(SNode contextNode, @Nullable SContainmentLink link, int index) {
    // TODO scope = ModelConstraints.getReferenceDescriptor(conceptName, role, contextNode, link.role(), index).getScope()
    Scope scope = null;
    if (scope != null) {
      return new SReferenceLinkAdapter.SScopeAdapter(scope, contextNode);
    }
    return null;
  }

  public SNode getLinkNode() {
    if (!(fillBothIds())) {
      return null;
    }
    SConceptAdapter adapter = new SConceptAdapter(getRoleId().getConceptId());
    SModel model = adapter.getConceptDeclarationNode().getModel();
    return ((SNode) model.getNode(new SNodeId.Regular(myRoleId.getReferenceLinkId())));
  }

  public boolean fillBothIds() {
    if (myRoleId != null && role != null) {
      return true;
    }
    if (myRoleId == null) {
      SNode concept = SModelUtil.findConceptDeclaration(conceptName);
      SConceptId cid = MetaIdByDeclaration.getConceptId((jetbrains.mps.smodel.SNode) concept);
      final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(concept);
      SNode linkNode = scope.getLinkDeclarationByRole(role);
      myRoleId = new SReferenceLinkId(cid, MetaIdByDeclaration.getNodeId((jetbrains.mps.smodel.SNode) linkNode));
    } else {
      SAbstractConceptAdapter adapter = new SAbstractConceptAdapter(myRoleId.getConceptId());
      conceptName = adapter.getQualifiedName();
      SNode node = adapter.getConceptDeclarationNode();
      if (node == null) {
        return false;
      }
      role = node.getModel().getNode(new SNodeId.Regular(myRoleId.getReferenceLinkId())).getProperty("role");
    }
    return true;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SReferenceLinkAdapter that = (SReferenceLinkAdapter) o;
    if (myRoleId != null) {
      return myRoleId.equals(that.myRoleId);
    } else {
      String my = "" + conceptName + "#" + role;
      String theirs = "" + that.conceptName + "#" + that.role;
      return my.equals(theirs);
    }
  }

  @Override
  public int hashCode() {
    if (myRoleId != null) {
      return myRoleId.hashCode();
    } else {
      return ("" + conceptName + "#" + role).hashCode();
    }
  }

  private static class SScopeAdapter implements SScope {
    private final SNode myContextNode;
    private final Scope myScope;

    private SScopeAdapter(@NotNull Scope scope, @NotNull SNode contextNode) {
      myScope = scope;
      myContextNode = contextNode;
    }

    public Iterable<SNode> getAvailableElements(@Nullable String prefix) {
      return myScope.getAvailableElements(prefix);
    }
    public boolean contains(SNode node) {
      return myScope.contains(node);
    }
    @Nullable
    public SNode resolve(@NotNull String string) {
      return myScope.resolve(myContextNode, string);
    }
    @Nullable
    public String getReferenceText(@NotNull SNode node) {
      return myScope.getReferenceText(myContextNode, node);
    }
  }
}
