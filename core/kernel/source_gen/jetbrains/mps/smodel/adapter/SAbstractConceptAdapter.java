package jetbrains.mps.smodel.adapter;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.util.containers.BidirectionalMap;
import org.jetbrains.mps.openapi.language.SConceptId;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import jetbrains.mps.util.NameUtil;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.language.ConceptRegistry;
import jetbrains.mps.smodel.runtime.illegal.IllegalConceptDescriptor;
import java.util.Collections;
import jetbrains.mps.smodel.search.ConceptAndSuperConceptsScope;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SAbstractLink;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SPropertyId;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.HashSet;
import org.apache.log4j.Level;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.Language;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.SNodeId;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class SAbstractConceptAdapter implements SAbstractConcept {
  private static BidirectionalMap<SConceptId, String> ourNames = new BidirectionalMap<SConceptId, String>();

  protected SConceptId myConceptId;
  protected String myConceptName;

  @Deprecated
  public SAbstractConceptAdapter(@NotNull String conceptName) {
    myConceptName = conceptName;
    List<SConceptId> ids = ourNames.getKeysByValue(myConceptName);
    if (ids != null && !(ids.isEmpty())) {
      myConceptId = ids.get(0);
    }
  }



  public SAbstractConceptAdapter(@NotNull SConceptId conceptId) {
    myConceptId = conceptId;
    myConceptName = ourNames.get(myConceptId);
  }



  @Override
  public SConceptId getId() {
    if (myConceptId != null) {
      return myConceptId;
    }
    fillBothIds();
    return myConceptId;
  }



  @Override
  public String getQualifiedName() {
    if (myConceptName != null) {
      return myConceptName;
    }
    fillBothIds();
    // todo here we should obtain name from a concept node, but since we now having code which doesn't work by id and therefore obtains the name 
    // todo frequently, we get a huge slowdown if obtaining name from a node here 
    // todo in 3.2, it is supposed that we either remove most accesses to this method or we'll return conceptName here and clear it in all concepts when renaming concept in IDE 
    return myConceptName;
  }



  @Override
  public String getName() {
    return NameUtil.shortNameFromLongName(getQualifiedName());
  }



  @Override
  public Iterable<SReferenceLink> getReferences() {
    ConceptDescriptor d = ConceptRegistry.getInstance().getConceptDescriptor(getQualifiedName());
    if (d instanceof IllegalConceptDescriptor) {
      illegalConceptDescriptorWarning();
      return Collections.emptyList();
    }

    final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(getConceptDeclarationNode());
    return SetSequence.fromSet(((Set<String>) d.getReferenceNames())).select(new ISelector<String, SReferenceLink>() {
      public SReferenceLink select(String it) {
        SNode linkNode = scope.getLinkDeclarationByRole(it);
        if (linkNode == null) {
          return null;
        }
        return ((SReferenceLink) new SReferenceLinkAdapter(IdHelper.getRefRoleId((jetbrains.mps.smodel.SNode) linkNode)));
      }
    });
  }



  @Override
  public Iterable<SContainmentLink> getChildren() {
    ConceptDescriptor d = ConceptRegistry.getInstance().getConceptDescriptor(getQualifiedName());
    if (d instanceof IllegalConceptDescriptor) {
      illegalConceptDescriptorWarning();
      return Collections.emptyList();
    }
    final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(getConceptDeclarationNode());
    return SetSequence.fromSet(((Set<String>) d.getChildrenNames())).select(new ISelector<String, SContainmentLink>() {
      public SContainmentLink select(String it) {
        SNode linkNode = scope.getLinkDeclarationByRole(it);
        if (linkNode == null) {
          return null;
        }
        return ((SContainmentLink) new SContainmentLinkAdapter(IdHelper.getNodeRoleId((jetbrains.mps.smodel.SNode) linkNode)));
      }
    });
  }



  @Override
  @Deprecated
  public SAbstractLink getLink(String role) {
    ConceptDescriptor d = ConceptRegistry.getInstance().getConceptDescriptor(getQualifiedName());
    if (d instanceof IllegalConceptDescriptor) {
      illegalConceptDescriptorWarning();
      return null;
    }
    SNode linkNode = new ConceptAndSuperConceptsScope(getConceptDeclarationNode()).getLinkDeclarationByRole(role);
    if (linkNode == null) {
      return null;
    }
    if (d.hasChild(role)) {
      return new SContainmentLinkAdapter(IdHelper.getNodeRoleId((jetbrains.mps.smodel.SNode) linkNode));
    } else
    if (d.hasReference(role)) {
      return new SReferenceLinkAdapter(IdHelper.getRefRoleId((jetbrains.mps.smodel.SNode) linkNode));
    }
    return null;
  }



  @Override
  public Iterable<SAbstractLink> getLinks() {
    ConceptDescriptor d = ConceptRegistry.getInstance().getConceptDescriptor(myConceptName);
    if (d instanceof IllegalConceptDescriptor) {
      illegalConceptDescriptorWarning();
      return Collections.<SAbstractLink>emptyList();
    }
    final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(getConceptDeclarationNode());

    Iterable<SAbstractLink> seq = SetSequence.fromSet(((Set<String>) d.getChildrenNames())).select(new ISelector<String, SAbstractLink>() {
      public SAbstractLink select(String it) {
        SNode linkNode = scope.getLinkDeclarationByRole(it);
        if (linkNode == null) {
          return null;
        }
        return (SAbstractLink) new SContainmentLinkAdapter(IdHelper.getNodeRoleId((jetbrains.mps.smodel.SNode) linkNode));
      }
    });
    Sequence.fromIterable(seq).concat(SetSequence.fromSet(((Set<String>) d.getReferenceNames())).select(new ISelector<String, SAbstractLink>() {
      public SAbstractLink select(String it) {
        SNode linkNode = scope.getLinkDeclarationByRole(it);
        if (linkNode == null) {
          return null;
        }
        return ((SAbstractLink) new SReferenceLinkAdapter(IdHelper.getRefRoleId((jetbrains.mps.smodel.SNode) linkNode)));
      }
    }));
    return seq;
  }



  @Override
  @Deprecated
  public SProperty getProperty(String name) {
    ConceptDescriptor d = ConceptRegistry.getInstance().getConceptDescriptor(getQualifiedName());
    if (d instanceof IllegalConceptDescriptor) {
      illegalConceptDescriptorWarning();
      return null;
    }
    final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(getConceptDeclarationNode());
    SNode propNode = scope.getPropertyDeclarationByName(name);
    if (!(d.hasProperty(name))) {
      return null;
    }
    SPropertyId id = IdHelper.getPropId((jetbrains.mps.smodel.SNode) propNode);
    return new SPropertyAdapter(id);
  }



  @Override
  public Iterable<SProperty> getProperties() {
    ConceptDescriptor d = ConceptRegistry.getInstance().getConceptDescriptor(myConceptName);
    if (d instanceof IllegalConceptDescriptor) {
      illegalConceptDescriptorWarning();
      return Collections.<SProperty>emptyList();
    }

    final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(getConceptDeclarationNode());

    return SetSequence.fromSet(((Set<String>) d.getPropertyNames())).select(new ISelector<String, SProperty>() {
      public SProperty select(String it) {
        SNode propNode = scope.getPropertyDeclarationByName(it);
        if (propNode == null) {
          return null;
        }
        return ((SProperty) new SPropertyAdapter(IdHelper.getPropId((jetbrains.mps.smodel.SNode) propNode)));
      }
    });
  }



  @Override
  public boolean isSubConceptOf(SAbstractConcept concept) {
    // todo: hack, need for working node attributes on nodes of not generated concepts  
    // todo: remove  
    if ("jetbrains.mps.lang.core.structure.BaseConcept".equals(concept.getQualifiedName())) {
      return true;
    }
    ConceptDescriptor d = ConceptRegistry.getInstance().getConceptDescriptor(getQualifiedName());
    if (d instanceof IllegalConceptDescriptor) {
      illegalConceptDescriptorWarning();
      return false;
    }
    return d.isAssignableTo(concept.getQualifiedName());
  }



  @Override
  public SLanguage getLanguage() {
    fillBothIds();
    return new SLanguageAdapter(myConceptId.getLanguageId());
  }



  @Override
  public int hashCode() {
    return (myConceptId != null ? myConceptId.hashCode() : myConceptName.hashCode());
  }



  @Override
  public boolean equals(Object o) {
    if (o == null || o.getClass() != getClass()) {
      return false;
    }
    if (myConceptId != null) {
      return myConceptId.equals(((SAbstractConceptAdapter) o).myConceptId);
    } else {
      return myConceptName.equals(((SAbstractConceptAdapter) o).myConceptName);
    }
  }


  private static final Set<String> reportedLanguages = new HashSet<String>();


  protected void illegalConceptDescriptorWarning() {
    fillBothIds();
    String languageName = getLanguage().getQualifiedName();
    // report each language only once  
    if (reportedLanguages.contains(languageName)) {
      return;
    }
    reportedLanguages.add(languageName);
    if (LOG.isEnabledFor(Level.WARN)) {
      LOG.warn("No concept found for id " + myConceptId.serialize() + ". Please check the language " + languageName + " is built and compiled.");
    }
  }



  @Nullable
  @Override
  public SNode getConceptDeclarationNode() {
    fillBothIds();
    SModuleReference moduleRef = IdHelper.getModuleReference(myConceptId.getLanguageId());
    SModule module = moduleRef.resolve(MPSModuleRepository.getInstance());
    if (!((module instanceof Language))) {
      return null;
    }
    SModel strucModel = LanguageAspect.STRUCTURE.get(((Language) module));
    if (strucModel == null) {
      return null;
    }
    return strucModel.getNode(new SNodeId.Regular(myConceptId.getConceptId()));
  }



  protected void fillBothIds() {
    if (myConceptName != null && myConceptId != null) {
      return;
    }
    if (myConceptId == null) {
      String langName = NameUtil.namespaceFromConceptFQName(myConceptName);
      SLanguageAdapter lang = new SLanguageAdapter(langName);
      SNode concept = lang.getSourceModule().findConceptDeclaration(NameUtil.shortNameFromLongName(myConceptName));
      myConceptId = new SConceptId(lang.getId(), IdHelper.getNodeId((jetbrains.mps.smodel.SNode) concept));
    } else {
      Language lang = new SLanguageAdapter(myConceptId.getLanguageId()).getSourceModule();
      if (lang!=null) {
        myConceptName = NameUtil.nodeFQName(LanguageAspect.STRUCTURE.get(lang).getNode(new SNodeId.Regular(myConceptId.getConceptId())));
      }else{
        myConceptName = MPSModuleRepository.getInstance().getDebugRegistry().getConceptName(myConceptId);
      }
    }
    ourNames.put(myConceptId, myConceptName);
  }




  protected static Logger LOG = LogManager.getLogger(SAbstractConceptAdapter.class);
}
