package jetbrains.mps.smodel.adapter.structure.property;

/*Generated by MPS */

import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterById;
import jetbrains.mps.smodel.adapter.structure.datatype.SDataTypeAdapter;
import jetbrains.mps.smodel.adapter.structure.datatype.SPrimitiveDataTypeAdapter;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SDataType;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import org.jetbrains.mps.openapi.language.SPrimitiveDataType;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.smodel.search.ConceptAndSuperConceptsScope;

public class SPropertyAdapterById implements SProperty {
  private SPropertyId myPropertyId;

  private String conceptName;
  private String propertyName;

  public SPropertyAdapterById(String conceptName, String name) {
    this.conceptName = conceptName;
    this.propertyName = name;
  }

  public SPropertyAdapterById(SPropertyId propertyId) {
    this.myPropertyId = propertyId;
  }

  @Override
  public SConcept getContainingConcept() {
    return new SConceptAdapterById(myPropertyId.getConceptId());
  }

  public SPropertyId getId() {
    fillBothIds();
    return myPropertyId;
  }

  @Override
  public String getName() {
    fillBothIds();
    // todo here we should obtain name from a concept node, but since we now having code which doesn't work by id and therefore obtains the name 
    // todo frequently, we get a huge slowdown if obtaining name from a node here 
    // todo in 3.2, it is supposed that we either remove most accesses to this method or we'll return conceptName here and clear it in all propertyIds when renaming prop in IDE 
    return propertyName;
  }

  @Override
  public SDataType getType() {
    // TODO reimplement using ConceptDescriptor 
    SNode propertyNode = getPropertyNode();
    if (propertyNode == null) {
      return null;
    }

    SNode dataType = SLinkOperations.getTarget(propertyNode, "dataType", false);
    if (dataType == null) {
      return null;
    }
    if (SNodeOperations.isInstanceOf(dataType, "jetbrains.mps.lang.structure.structure.PrimitiveDataTypeDeclaration")) {
      SNode pdt = SNodeOperations.cast(dataType, "jetbrains.mps.lang.structure.structure.PrimitiveDataTypeDeclaration");
      return new SPrimitiveDataTypeAdapter((BehaviorReflection.invokeNonVirtual(Boolean.TYPE, pdt, "jetbrains.mps.lang.structure.structure.PrimitiveDataTypeDeclaration", "call_isBoolean_1220268791641", new Object[]{}) ? SPrimitiveDataType.BOOL : ((BehaviorReflection.invokeNonVirtual(Boolean.TYPE, pdt, "jetbrains.mps.lang.structure.structure.PrimitiveDataTypeDeclaration", "call_isInteger_1220268780075", new Object[]{}) ? SPrimitiveDataType.INT : SPrimitiveDataType.STRING))));
    }
    return new SDataTypeAdapter();
  }

  @Override
  public boolean isValid(String string) {
    // TODO implement 
    return true;
  }

  public final SNode getPropertyNode() {
    if (!(fillBothIds())) {
      return null;
    }
    SConceptAdapterById adapter = new SConceptAdapterById(myPropertyId.getConceptId());
    SModel model = adapter.getConceptDeclarationNode().getModel();
    return ((SNode) model.getNode(new SNodeId.Regular(myPropertyId.getPropertyId())));
  }
  public boolean fillBothIds() {
    if (myPropertyId != null && propertyName != null) {
      return true;
    }
    if (myPropertyId == null) {
      SNode concept = SModelUtil.findConceptDeclaration(conceptName);
      SConceptId cid = MetaIdByDeclaration.getConceptId((jetbrains.mps.smodel.SNode) concept);
      final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(concept);
      SNode propNode = scope.getPropertyDeclarationByName(propertyName);
      myPropertyId = new SPropertyId(cid, MetaIdByDeclaration.getNodeId((jetbrains.mps.smodel.SNode) propNode));
    } else {
      SAbstractConceptAdapterById adapter = new SAbstractConceptAdapterById(myPropertyId.getConceptId());
      conceptName = adapter.getQualifiedName();
      SNode node = adapter.getConceptDeclarationNode();
      if (node == null) {
        return false;
      }
      propertyName = node.getModel().getNode(new SNodeId.Regular(myPropertyId.getPropertyId())).getName();
    }
    return true;
  }
}
