package jetbrains.mps.debug;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.Map;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.TreeSet;
import org.jdom.Element;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.apache.commons.lang.ObjectUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jdom.DataConversionException;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.SModelDescriptor;
import java.io.File;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class DebugInfo {
  private static final String DEBUG_INFO = "debugInfo";
  private static final String NODE_INFO = "nodeInfo";
  private static final String VAR_INFO = "varInfo";
  private static final String ROOT = "root";
  private static final String ROOT_ID_ATTR = "nodeId";
  private static final String UNSPECIFIED_ROOT = "";
  private static Logger LOG = Logger.getLogger(DebugInfo.class);

  private Map<String, Set<PositionInfo>> myRootToPositions = MapSequence.fromMap(new LinkedHashMap<String, Set<PositionInfo>>(16, (float) 0.75, false));
  private Map<String, Set<VarPositionInfo>> myRootToVarPositions = MapSequence.fromMap(new LinkedHashMap<String, Set<VarPositionInfo>>(16, (float) 0.75, false));
  private SModel myModel;

  public DebugInfo() {
  }

  public void addPosition(PositionInfo position) {
    this.addPosition(position, UNSPECIFIED_ROOT);
  }

  public void addVarPosition(VarPositionInfo position) {
    this.addVarPosition(position, UNSPECIFIED_ROOT);
  }

  public void addPosition(PositionInfo position, String rootNodeId) {
    if (rootNodeId == null) {
      rootNodeId = UNSPECIFIED_ROOT;
    }
    Set<PositionInfo> info = MapSequence.fromMap(this.myRootToPositions).get(rootNodeId);
    if (info == null) {
      info = SetSequence.fromSet(new TreeSet<PositionInfo>());
      MapSequence.fromMap(this.myRootToPositions).put(rootNodeId, info);
    }
    SetSequence.fromSet(info).addElement(position);
  }

  public void addVarPosition(VarPositionInfo position, String rootNodeId) {
    if (rootNodeId == null) {
      rootNodeId = UNSPECIFIED_ROOT;
    }
    Set<VarPositionInfo> info = MapSequence.fromMap(this.myRootToVarPositions).get(rootNodeId);
    if (info == null) {
      info = SetSequence.fromSet(new TreeSet<VarPositionInfo>());
      MapSequence.fromMap(this.myRootToVarPositions).put(rootNodeId, info);
    }
    SetSequence.fromSet(info).addElement(position);
  }

  public Element toXml() {
    Element root = new Element(DEBUG_INFO);

    Set<PositionInfo> noRoot = MapSequence.fromMap(this.myRootToPositions).get(UNSPECIFIED_ROOT);
    if (noRoot != null) {
      for (PositionInfo position : noRoot) {
        Element e = new Element(NODE_INFO);
        position.saveTo(e);
        root.addContent(e);
      }
    }
    Set<VarPositionInfo> noRootVars = MapSequence.fromMap(this.myRootToVarPositions).get(UNSPECIFIED_ROOT);
    if (noRootVars != null) {
      for (PositionInfo position : noRootVars) {
        Element e = new Element(VAR_INFO);
        position.saveTo(e);
        root.addContent(e);
      }
    }
    Map<String, Element> rootsToElements = MapSequence.fromMap(new HashMap<String, Element>());
    for (String rootId : SetSequence.fromSet(MapSequence.fromMap(this.myRootToPositions).keySet()).where(new IWhereFilter<String>() {
      public boolean accept(String it) {
        return !(ObjectUtils.equals(it, UNSPECIFIED_ROOT));
      }
    }).sort(new ISelector<String, Comparable<?>>() {
      public Comparable<?> select(String it) {
        return it;
      }
    }, true)) {
      Element re = new Element(ROOT);
      re.setAttribute(ROOT_ID_ATTR, rootId);
      MapSequence.fromMap(rootsToElements).put(rootId, re);
      root.addContent(re);
      for (PositionInfo position : MapSequence.fromMap(this.myRootToPositions).get(rootId)) {
        Element e = new Element(NODE_INFO);
        position.saveTo(e);
        re.addContent(e);
      }
    }
    for (String rootId : SetSequence.fromSet(MapSequence.fromMap(this.myRootToVarPositions).keySet()).where(new IWhereFilter<String>() {
      public boolean accept(String it) {
        return !(ObjectUtils.equals(it, UNSPECIFIED_ROOT));
      }
    }).sort(new ISelector<String, Comparable<?>>() {
      public Comparable<?> select(String it) {
        return it;
      }
    }, true)) {
      Element re = MapSequence.fromMap(rootsToElements).get(rootId);
      if (re == null) {
        re = new Element(ROOT);
        MapSequence.fromMap(rootsToElements).put(rootId, re);
      }
      re.setAttribute(ROOT_ID_ATTR, rootId);
      root.addContent(re);
      for (PositionInfo position : MapSequence.fromMap(this.myRootToVarPositions).get(rootId)) {
        Element e = new Element(VAR_INFO);
        position.saveTo(e);
        re.addContent(e);
      }
    }
    return root;
  }

  public List<SNode> getNodesForLine(String str, SModel model) {
    List<SNode> result = new ArrayList<SNode>();
    for (Set<PositionInfo> val : MapSequence.fromMap(this.myRootToPositions).values()) {
      for (PositionInfo element : val) {
        if (ObjectUtils.equals(element.getFileAndLine(), str)) {
          String nodeId = element.getNodeId();
          SNode node = model.getNodeById(nodeId);
          ListSequence.fromList(result).addElement(node);
        }
      }
    }
    return result;
  }

  public SNode getNodeForLine(String file, int line, SModel model) {
    List<PositionInfo> resultList = ListSequence.fromList(new ArrayList<PositionInfo>());
    for (Set<PositionInfo> val : MapSequence.fromMap(this.myRootToPositions).values()) {
      for (PositionInfo element : val) {
        if (ObjectUtils.equals(element.getFileName(), file) && element.getStartLine() <= line && line <= element.getEndLine()) {
          ListSequence.fromList(resultList).addElement(element);
        }
      }
    }
    if (ListSequence.fromList(resultList).isEmpty()) {
      return null;
    }
    Iterable<PositionInfo> sorted = ListSequence.fromList(resultList).sort(new ISelector<PositionInfo, Comparable<?>>() {
      public Comparable<?> select(PositionInfo it) {
        return it;
      }
    }, true);
    PositionInfo firstPositionInfo = Sequence.fromIterable(sorted).first();
    String nodeId = firstPositionInfo.getNodeId();
    // here we do some magic to fix the following bug: 
    // each node in base language owns a '\n' symbol in a previous line 
    // in the following code we will never get 'for' node quering line 1: 
    // 1.  for (...) { 
    // 2.    some statement 
    // 3.  } 
    // since 'some statement' takes lines 1-2 instead of just line 2 
    if (Sequence.fromIterable(sorted).count() > 1 && firstPositionInfo.getStartLine() == line && firstPositionInfo.getLineDistance() > 0) {
      nodeId = ListSequence.fromList(Sequence.fromIterable(sorted).toListSequence()).getElement(1).getNodeId();
    }
    return model.getNodeById(nodeId);
  }

  public SNode getVarForLine(String file, int line, SModel model, String varName) {
    List<VarPositionInfo> resultList = ListSequence.fromList(new ArrayList<VarPositionInfo>());
    VarPositionInfo secondGuess = null;
    for (Set<VarPositionInfo> val : MapSequence.fromMap(this.myRootToVarPositions).values()) {
      for (VarPositionInfo element : val) {
        if (ObjectUtils.equals(element.getFileName(), file)) {
          if (element.getStartLine() <= line && line <= element.getEndLine()) {
            ListSequence.fromList(resultList).addElement(element);
          } else if (line >= element.getEndLine() && element.getVarName().equals(varName)) {
            // here we are searching the nearest possible variable 
            // TODO this is a hack 
            if (secondGuess == null || secondGuess.getEndLine() <= element.getEndLine()) {
              secondGuess = element;
            }
          }
        }
      }
    }
    if (ListSequence.fromList(resultList).isEmpty() && secondGuess == null) {
      return null;
    }
    Iterable<VarPositionInfo> sorted = ListSequence.fromList(resultList).sort(new ISelector<VarPositionInfo, Comparable<?>>() {
      public Comparable<?> select(VarPositionInfo it) {
        return it;
      }
    }, true);
    String nodeId = null;
    for (VarPositionInfo varPosition : sorted) {
      if (varPosition.getVarName().equals(varName)) {
        nodeId = varPosition.getNodeId();
        break;
      }
    }
    if (nodeId == null) {
      if (secondGuess == null) {
        return null;
      }
      nodeId = secondGuess.getNodeId();
    }
    return model.getNodeById(nodeId);
  }

  public PositionInfo getPositionForNode(String nodeId) {
    for (Set<PositionInfo> val : MapSequence.fromMap(this.myRootToPositions).values()) {
      for (PositionInfo positionInfo : val) {
        if (ObjectUtils.equals(positionInfo.getNodeId(), nodeId)) {
          return positionInfo;
        }
      }
    }
    return null;
  }

  public List<String> getRoots() {
    return SetSequence.fromSet(MapSequence.fromMap(this.myRootToPositions).keySet()).toListSequence();
  }

  public Set<PositionInfo> getPositions(String rootId) {
    return MapSequence.fromMap(this.myRootToPositions).get(rootId);
  }

  public void updateFrom(DebugInfo debugInfo) {
    for (String rootId : debugInfo.getRoots()) {
      Set<PositionInfo> pinfo = MapSequence.fromMap(this.myRootToPositions).get(rootId);
      if (pinfo == null) {
        pinfo = SetSequence.fromSet(new TreeSet<PositionInfo>());
        MapSequence.fromMap(this.myRootToPositions).put(rootId, pinfo);
      }
      SetSequence.fromSet(pinfo).addSequence(SetSequence.fromSet(debugInfo.getPositions(rootId)));
    }
  }

  public SModel getModel() {
    return this.myModel;
  }

  public void setModel(SModel model) {
    this.myModel = model;
  }

  public static DebugInfo fromXml(Element element) {
    Element root = element;
    DebugInfo result = new DebugInfo();
    try {
      for (Element e : ((List<Element>) root.getChildren(NODE_INFO))) {
        result.addPosition(new PositionInfo(e));
      }
      for (Element e : ((List<Element>) root.getChildren(VAR_INFO))) {
        result.addVarPosition(new VarPositionInfo(e));
      }
      for (Element re : ((List<Element>) root.getChildren(ROOT))) {
        String rootId = re.getAttributeValue(ROOT_ID_ATTR);
        for (Element e : ((List<Element>) re.getChildren(NODE_INFO))) {
          result.addPosition(new PositionInfo(e), rootId);
        }
        for (Element e : ((List<Element>) re.getChildren(VAR_INFO))) {
          result.addVarPosition(new VarPositionInfo(e), rootId);
        }
      }
    } catch (DataConversionException e) {
      throw new RuntimeException(e);
    }
    return result;
  }

  public static IFile getDebugFileOfModel(String outputDir, SModelDescriptor model) {
    String modelName = model.getLongName().replace(".", File.separator);
    String debugPath = modelName.substring(0, modelName.length()) + File.separator + ".debug";
    return FileSystem.getFile(outputDir + File.separator + debugPath);
  }

  public static boolean isNodeSutable(SNode node) {
    return SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Statement") || SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.FieldDeclaration") || SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration");
  }
}
