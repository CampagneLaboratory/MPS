package jetbrains.mps.makeTest.test;

/*Generated by MPS */

import jetbrains.mps.project.MPSProject;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.project.tester.EditorGenerateType;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.ide.progress.IAdaptiveProgressMonitor;

import java.lang.reflect.Method;

import junit.framework.Assert;

import java.io.File;

import jetbrains.mps.ide.IdeMain;
import jetbrains.mps.TestMain;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.generator.IGenerationType;
import jetbrains.mps.plugin.CompilationResult;
import jetbrains.mps.make.ModuleMaker;

import java.util.Collections;

import com.intellij.openapi.progress.EmptyProgressIndicator;

import java.util.List;
import java.util.ArrayList;

import jetbrains.mps.generator.GeneratorManager;
import jetbrains.mps.ide.messages.IMessageHandler;
import jetbrains.mps.ide.messages.Message;
import jetbrains.mps.ide.messages.MessageKind;
import jetbrains.mps.project.ModuleContext;
import jetbrains.mps.generator.generationTypes.GenerateFilesGenerationType;

public class MakeAssert {
  private static final String MESSAGE_COMPILATION_FAILED = "Compilation failed";
  private static final String MESSAGE_DEPENDENCY_NOT_CHECKED = "Compilation finished with Unchecked Dependencies";
  private static final String PROJECT_FILE = "core/kernel/testMake/testMake.mpr";
  private static final String TEST_RESOURCES_PATH = "core/kernel/testMake/solutions/jetbrains.mps.testModels/jetbrains/mps/testModels/";
  private static final String STEP_TYPE_CHANGE = "changed";
  private static final String STEP_TYPE_REVERT = "reverted";

  public static void assertNotMake(final String modelName, final ChangeModel changer) {
    MPSProject project = launchProject();
    final String changedModelName = modelName + '2';
    final SModel[] model = new SModel[]{null};
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        model[0] = getModel(changedModelName).getSModel();
      }
    });
    boolean baseIsOk = step(modelName, project, new Runnable() {
      public void run() {
        model[0].runLoadingAction(new Runnable() {
          public void run() {
            changer.change(model[0]);
          }
        });
      }
    }, STEP_TYPE_CHANGE, getFilesGenType());
    boolean newIsOk = step(modelName, project, new Runnable() {
      public void run() {
        changer.rollback(model[0]);
      }
    }, STEP_TYPE_REVERT, getFilesGenType());
    model[0].setLoading(false);
    generate(changedModelName, project, getFilesGenType());
    disposeProject(project);
    assertNoProblems(baseIsOk);
    assertDependenciesChecked(newIsOk);
  }

  public static void assertDependenciesChecked(final String modelName, final ChangeModel changer) {
    final MPSProject project = launchProject();
    final String changedModelName = modelName + '2';
    final SModel[] model = new SModel[]{null};
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        model[0] = getModel(changedModelName).getSModel();
      }
    });
    model[0].setLoading(true);
    step(modelName, project, new Runnable() {
      public void run() {
        changer.change(model[0]);
      }
    }, STEP_TYPE_CHANGE, getFilesGenType());
    final EditorGenerateType genType = new EditorGenerateType(true);
    generate(modelName + '1', project, genType);
    generate(modelName + '2', project, genType);
    final Boolean[] returnValue = new Boolean[]{null};
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        try {
          SModel testModel = getModel(modelName + '1').getSModel();
          SNode test = ListSequence.fromList(SModelOperations.getRoots(testModel, null)).first();
          String className = NameUtil.nodeFQName(test);
          genType.compile(IAdaptiveProgressMonitor.NULL_PROGRESS_MONITOR);
          ClassLoader classLoader = genType.getCompiler().getClassLoader(MakeAssert.class.getClassLoader());
          Class testClass = classLoader.loadClass(className);
          Method method = testClass.getMethods()[0];
          returnValue[0] = (Boolean) method.invoke(null);
          System.out.println("Test " + className + "." + method.getName() + " return " + returnValue[0]);
          step(modelName, project, new Runnable() {
            public void run() {
              changer.rollback(model[0]);
            }
          }, STEP_TYPE_REVERT, getFilesGenType());
          generate(modelName + '2', project, getFilesGenType());
        } catch (Throwable t) {
          disposeProject(project);
          t.printStackTrace();
          Assert.assertTrue("Exception: " + t, false);
        }
      }
    });
    disposeProject(project);
    Assert.assertFalse(MESSAGE_DEPENDENCY_NOT_CHECKED, returnValue[0]);
  }

  public static void assertDependenciesChecked(boolean isOk) {
    Assert.assertFalse(MESSAGE_DEPENDENCY_NOT_CHECKED, isOk);
  }

  public static void assertNoProblems(boolean isOk) {
    Assert.assertTrue(MESSAGE_COMPILATION_FAILED, isOk);
  }

  private static MPSProject launchProject() {
    File projectFile = new File(PROJECT_FILE);
    IdeMain.setTestMode(IdeMain.TestMode.CORE_TEST);
    TestMain.configureMPS();
    if (!(projectFile.exists())) {
      return null;
    }
    System.out.println("Loading project");
    return TestMain.loadProject(projectFile);
  }

  private static void disposeProject(final MPSProject project) {
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        project.dispose();
      }
    });
  }

  private static SModelDescriptor getModel(String name) {
    String path = TEST_RESOURCES_PATH + name + ".mps";
    IFile file = FileSystem.getFile(path);
    return SModelRepository.getInstance().findModel(file);
  }

  private static boolean step(final String modelName, MPSProject project, final Runnable runnable, String type, IGenerationType genType) {
    generate(modelName + '2', project, genType);
    final CompilationResult[] cr = new CompilationResult[]{null};
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        cr[0] = new ModuleMaker().make(Collections.singleton(getModel(modelName + '1').getModule()), new EmptyProgressIndicator());
      }
    });
    if (cr[0].isOk()) {
      System.out.println("No compilation problem");
    } else {
      System.out.println("Compilation failed");
    }
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        runnable.run();
      }
    });
    System.out.println("Model " + modelName + " " + type);
    return cr[0].isOk();
  }

  private static List<String> generate(String modelName, MPSProject project, IGenerationType genType) {
    final SModelDescriptor model = getModel(modelName);
    final List<String> results = ListSequence.fromList(new ArrayList<String>());
    List<SModelDescriptor> models = Collections.singletonList(model);
    GeneratorManager gm = project.getComponentSafe(GeneratorManager.class);
    IMessageHandler handler = new IMessageHandler() {
      public void handle(Message msg) {
        if (msg.getKind() == MessageKind.ERROR) {
          ListSequence.fromList(results).addElement(msg.getText());
        }
      }
    };
    model.getModule().getModuleDescriptor().setCompileInMPS(false);
    gm.generateModels(models, new ModuleContext(model.getModule(), project), genType, new EmptyProgressIndicator(), handler);
    model.getModule().getModuleDescriptor().setCompileInMPS(true);
    return results;
  }

  private static GenerateFilesGenerationType getFilesGenType() {
    return new GenerateFilesGenerationType();
  }
}
