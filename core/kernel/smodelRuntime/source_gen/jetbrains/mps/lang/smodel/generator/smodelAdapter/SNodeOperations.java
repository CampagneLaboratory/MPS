package jetbrains.mps.lang.smodel.generator.smodelAdapter;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.smodel.SModelUtil_new;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.mps.util.Condition;
import jetbrains.mps.kernel.model.SModelUtil;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.search.ISearchScope;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.smodel.constraints.ModelConstraints;
import jetbrains.mps.scope.ErrorScope;
import jetbrains.mps.scope.ScopeAdapter;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.smodel.search.SModelSearchUtil;
import org.jetbrains.mps.openapi.model.SReference;

public class SNodeOperations {
  private static final Logger LOG = Logger.wrap(LogManager.getLogger(SNodeOperations.class));
  private static boolean ourCastsEnabled = !(("true".equals(System.getProperty("mps.disableNodeCastExceptions"))));

  public SNodeOperations() {
  }

  public static SNode copyNode(SNode node) {
    if (node == null) {
      return null;
    }
    return CopyUtil.copy(node);
  }

  public static SNode getContainingRoot(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getContainingRoot();
  }

  @Deprecated
  public static SNode getParent(SNode node, String parentConceptFqName, boolean inclusion, boolean root) {
    // use node.getParent() 
    return SNodeOperations.getAncestor(node, parentConceptFqName, inclusion, root);
  }

  public static SNode getParent(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getParent();
  }

  public static SNode getAncestor(SNode node, String ancestorConceptFqName, boolean inclusion, boolean root) {
    return SNodeOperations.getAncestor(node, ancestorConceptFqName, inclusion, root, false);
  }

  public static SNode getAncestor(SNode node, String ancestorConceptFqName, boolean inclusion, boolean root, boolean sameMetaLevel) {
    if (node == null) {
      return null;
    }
    int metaLevel = (sameMetaLevel ?
      SModelUtil_new.getMetaLevel(node) :
      0
    );

    // look up for certain concept 
    if (root) {
      SNode rootParent = node.getContainingRoot();
      if (rootParent.getModel() != null && SNodeOperations.nullSafeInstanceOf(rootParent, ancestorConceptFqName)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(rootParent) == metaLevel) {
          return rootParent;
        }
      }
      return null;
    }

    // look-up parent of required type 
    SNode outputNode;
    if (inclusion) {
      outputNode = node;
    } else {
      outputNode = node.getParent();
    }
    if (outputNode == null) {
      return null;
    }
    if (SNodeOperations.nullSafeInstanceOf(outputNode, ancestorConceptFqName)) {
      if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
        return outputNode;
      }
    }
    while ((outputNode = outputNode.getParent()) != null) {
      if (SNodeOperations.nullSafeInstanceOf(outputNode, ancestorConceptFqName)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
          break;
        }
      }
    }
    return outputNode;
  }

  private static boolean nullSafeInstanceOf(SNode node, String conceptFQName) {
    if (conceptFQName == null) {
      return true;
    }
    return SNodeUtil.isInstanceOf(node, jetbrains.mps.util.SNodeOperations.getConcept(conceptFQName));
  }

  public static SNode getAncestorWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion, boolean root) {
    return SNodeOperations.getAncestorWhereConceptInList(node, ancestorConceptFqNames, inclusion, root, false);
  }

  public static SNode getAncestorWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion, boolean root, boolean sameMetaLevel) {
    if (node == null) {
      return null;
    }
    int metaLevel = (sameMetaLevel ?
      SModelUtil_new.getMetaLevel(node) :
      0
    );
    if (ancestorConceptFqNames.length == 0) {
      return null;
    }
    if (root) {
      SNode rootParent = node.getContainingRoot();
      if (SNodeOperations._isInstanceOf(rootParent, ancestorConceptFqNames)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(rootParent) == metaLevel) {
          return rootParent;
        }
      }
      return null;
    }

    // look-up parent of required type 
    SNode outputNode;
    if (inclusion) {
      outputNode = node;
    } else {
      outputNode = node.getParent();
    }
    if (outputNode == null) {
      return null;
    }
    if (SNodeOperations._isInstanceOf(outputNode, ancestorConceptFqNames)) {
      if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
        return outputNode;
      }
    }
    while ((outputNode = outputNode.getParent()) != null) {
      if (SNodeOperations._isInstanceOf(outputNode, ancestorConceptFqNames)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
          return outputNode;
        }
      }
    }
    return outputNode;
  }

  public static List<SNode> getAncestors(SNode node, String ancestorConceptFqName, boolean inclusion) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null) {
      return result;
    }
    if (!(inclusion)) {
      node = node.getParent();
    }
    while (node != null) {
      if (ancestorConceptFqName == null || SNodeUtil.isInstanceOf(node, jetbrains.mps.util.SNodeOperations.getConcept(ancestorConceptFqName))) {
        result.add(node);
      }
      node = node.getParent();
    }
    return result;
  }

  public static List<SNode> getAncestorsWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion) {
    if (node == null) {
      new ArrayList<SNode>();
    }
    List<SNode> result = new ArrayList<SNode>();
    if (!(inclusion) && node != null) {
      node = node.getParent();
    }
    while (node != null) {
      if (SNodeOperations._isInstanceOf(node, ancestorConceptFqNames)) {
        result.add(node);
      }
      node = node.getParent();
    }
    return result;
  }

  public static List<SNode> getDescendants(SNode node, final String childConceptFqName, boolean inclusion) {
    return SNodeOperations.getDescendants(node, childConceptFqName, inclusion, new String[0]);
  }

  public static List<SNode> getDescendants(SNode node, final String childConceptFqName, boolean inclusion, final String[] stopConceptFqNames) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null) {
      return result;
    }

    if (childConceptFqName == null) {
      result = (List<SNode>) jetbrains.mps.util.SNodeOperations.getDescendants(node, null);
      if (inclusion) {
        result.add(0, node);
      }
      return result;
    }

    if (inclusion) {
      if (SNodeUtil.isInstanceOf(node, jetbrains.mps.util.SNodeOperations.getConcept(childConceptFqName))) {
        result.add(node);
      }
    }
    Condition<SNode> stopCondition = (stopConceptFqNames.length == 0 ?
      Condition.FALSE_CONDITION :
      new Condition<SNode>() {
        @Override
        public boolean met(SNode node) {
          return SNodeOperations._isInstanceOf(node, stopConceptFqNames);
        }
      }
    );
    SNodeOperations._populateListOfDescendants(result, node, new Condition<SNode>() {
      @Override
      public boolean met(SNode node) {
        return SNodeUtil.isInstanceOf(node, jetbrains.mps.util.SNodeOperations.getConcept(childConceptFqName));
      }
    }, stopCondition);
    return result;
  }

  public static List<SNode> getDescendantsWhereConceptInList(SNode node, final String[] descendantConceptFqNames, boolean inclusion) {
    return SNodeOperations.getDescendantsWhereConceptInList(node, descendantConceptFqNames, inclusion, new String[0]);
  }

  public static List<SNode> getDescendantsWhereConceptInList(SNode node, final String[] descendantConceptFqNames, boolean inclusion, final String[] stopConceptFqNames) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null || descendantConceptFqNames.length == 0) {
      return result;
    }

    if (inclusion) {
      if (SNodeOperations._isInstanceOf(node, descendantConceptFqNames)) {
        result.add(node);
      }
    }
    Condition<SNode> stopCondition = (stopConceptFqNames.length == 0 ?
      Condition.FALSE_CONDITION :
      new Condition<SNode>() {
        @Override
        public boolean met(SNode node) {
          return SNodeOperations._isInstanceOf(node, stopConceptFqNames);
        }
      }
    );
    SNodeOperations._populateListOfDescendants(result, node, new Condition<SNode>() {
      @Override
      public boolean met(SNode node) {
        return SNodeOperations._isInstanceOf(node, descendantConceptFqNames);
      }
    }, stopCondition);
    return result;
  }

  private static void _populateListOfDescendants(List<SNode> list, SNode node, Condition<SNode> condition, Condition<SNode> stopCondition) {
    for (SNode child : jetbrains.mps.util.SNodeOperations.getChildren(node)) {
      if (condition.met(child)) {
        list.add(child);
      }
      if (stopCondition == null || !(stopCondition.met(child))) {
        SNodeOperations._populateListOfDescendants(list, child, condition, stopCondition);
      }
    }
  }

  private static boolean _isInstanceOf(SNode node, String[] conceptFqNames) {
    for (String conceptFqName : conceptFqNames) {
      if (conceptFqName == null) {
        continue;
      }
      if (SNodeUtil.isInstanceOf(node, jetbrains.mps.util.SNodeOperations.getConcept(conceptFqName))) {
        return true;
      }
    }
    return false;
  }

  public static List<SNode> getChildren(SNode node) {
    if (node == null) {
      return new ArrayList<SNode>();
    }
    return jetbrains.mps.util.SNodeOperations.getChildren(node);
  }

  public static List<SNode> getChildren(SNode node, SNode linkDeclaration) {
    if (node == null || linkDeclaration == null) {
      return new ArrayList<SNode>(0);
    }
    linkDeclaration = SModelUtil.getGenuineLinkDeclaration(linkDeclaration);
    return SLinkOperations.getTargets(node, SPropertyOperations.getString(linkDeclaration, "role"), true);
  }

  public static SModel getModel(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getModel();
  }

  public static boolean isInstanceOf(SNode node, String conceptFQName) {
    if (node == null) {
      return false;
    }
    if (conceptFQName == null) {
      return false;
    }
    return SNodeUtil.isInstanceOf(node, jetbrains.mps.util.SNodeOperations.getConcept(conceptFQName));
  }

  public static SNode getNextSibling(SNode node) {
    SNode p = node.getParent();
    if (p == null) return null;

    SNode current = node;
    String currentRole = node.getRoleInParent();
    assert currentRole != null : "role must be not null";

    // to ensure that role is loaded
    while (current.getNextSibling() != null) {
      current = current.getNextSibling();
      if (current.getRoleInParent().equals(currentRole)) return current;
    }

    return null;
  }

  public static SNode getPrevSibling(SNode node) {
    SNode p = node.getParent();
    if (p == null) return null;

    SNode current = node;
    String currentRole = node.getRoleInParent();
    assert currentRole != null : "role must be not null";

    SNode fc = p.getFirstChild();
    while (current != fc) {
      current = current.getPrevSibling();
      if (current.getRoleInParent().equals(currentRole)) return current;
    }

    return null;
  }

  public static List<SNode> getPrevSiblings(SNode node, boolean inclusion) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null) {
      return result;
    }
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    String role = node.getRoleInParent();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        if (inclusion) {
          result.add(child);
        }
        break;
      }
      result.add(child);
    }
    return result;
  }

  public static List<SNode> getNextSiblings(SNode node, boolean inclusion) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null) {
      return result;
    }
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    if (inclusion) {
      result.add(node);
    }
    boolean childFound = false;
    String role = node.getRoleInParent();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        childFound = true;
      } else
      if (childFound) {
        result.add(child);
      }
    }
    return result;
  }

  public static List<SNode> getAllSiblings(SNode node, boolean inclusion) {
    List<SNode> result = new ArrayList<SNode>();
    if (node == null) {
      return result;
    }
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    String role = node.getRoleInParent();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        if (inclusion) {
          result.add(child);
        }
      } else {
        result.add(child);
      }
    }
    return result;
  }

  public static SNode insertNewNextSiblingChild(SNode node, String conceptFQName) {
    if (node == null || node.getParent() == null) {
      return null;
    }
    SNode parent = node.getParent();
    SNode newChild = SModelOperations.createNewNode(node.getModel(), conceptFQName);
    if (newChild == null) {
      return null;
    }
    String role = node.getRoleInParent();
    assert parent != null && role != null;
    jetbrains.mps.util.SNodeOperations.insertChild(parent, role, newChild, node);
    return newChild;
  }

  public static SNode insertNewPrevSiblingChild(SNode node, String conceptFqName) {
    if (node == null) {
      return null;
    }
    SNode parent = node.getParent();
    if (parent == null) {
      return null;
    }
    SNode newChild = SModelOperations.createNewNode(node.getModel(), conceptFqName);
    if (newChild == null) {
      return null;
    }
    String role = node.getRoleInParent();
    assert role != null;
    parent.insertChildBefore(role, node, newChild);
    return newChild;
  }

  public static SNode insertNextSiblingChild(SNode node, SNode siblingNode) {
    if (node == null) {
      return null;
    }
    SNode nodeParent = node.getParent();
    if (nodeParent == null || siblingNode == null || node == siblingNode) {
      return siblingNode;
    }
    SNode parent = siblingNode.getParent();
    if (parent != null) {
      parent.removeChild(siblingNode);
    }
    String role = node.getRoleInParent();
    assert role != null;
    jetbrains.mps.util.SNodeOperations.insertChild(nodeParent, role, siblingNode, node);
    return siblingNode;
  }

  public static SNode insertPrevSiblingChild(SNode node, SNode siblingNode) {
    if (node == null) {
      return null;
    }
    SNode nodeParent = node.getParent();
    if (nodeParent == null || siblingNode == null || node == siblingNode) {
      return siblingNode;
    }
    SNode siblingParent = siblingNode.getParent();
    if (siblingParent != null) {
      siblingParent.removeChild(siblingNode);
    }
    String role = node.getRoleInParent();
    assert role != null;
    nodeParent.insertChildBefore(role, siblingNode, node);
    return siblingNode;
  }

  public static SNode replaceWithNewChild(SNode oldChild, String conceptFqName) {
    assert oldChild != null : "can't replace node. node is NULL";
    SNode oldChildParent = oldChild.getParent();
    if (oldChildParent == null && (oldChild.getModel() == null || oldChild.getParent() != null)) {
      return null;
    }
    SModel model = oldChild.getModel();
    SNode newChild = SModelOperations.createNewNode(model, conceptFqName);
    if (newChild == null) {
      return null;
    }
    SNodeUtil.replaceWithAnother(oldChild, newChild);
    SNodeOperations.copyAllAttributes(oldChild, newChild);
    return newChild;
  }

  private static void copyAllAttributes(SNode oldChild, SNode newChild) {
    for (SNode attribute : AttributeOperations.getAllAttributes(oldChild)) {
      if (SNodeOperations.isInstanceOf(attribute, "jetbrains.mps.lang.core.structure.PropertyAttribute")) {
        String propertyName = AttributeOperations.getPropertyName(SNodeOperations.cast(attribute, "jetbrains.mps.lang.core.structure.PropertyAttribute"));
        if ((BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.getConceptDeclaration(newChild), "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", "call_findPropertyDeclaration_1219835742593", new Object[]{propertyName}) == null)) {
          // no such property in new child : don't copy the attribute 
          LOG.error("couldn't copy attribute " + attribute.getConcept().getName() + " for property '" + propertyName + "' : so such property in concept " + newChild.getConcept().getName(), newChild);
          continue;
        }
      }
      if (SNodeOperations.isInstanceOf(attribute, "jetbrains.mps.lang.core.structure.LinkAttribute")) {
        String linkRole = AttributeOperations.getLinkRole(SNodeOperations.cast(attribute, "jetbrains.mps.lang.core.structure.LinkAttribute"));
        if ((BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.getConceptDeclaration(newChild), "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", "call_findLinkDeclaration_1213877394467", new Object[]{linkRole}) == null)) {
          // no such link in new child : don't copy the attribute 
          LOG.error("couldn't copy attribute " + attribute.getConcept().getName() + " for link '" + linkRole + "' : so such link in concept " + newChild.getConcept().getName(), newChild);
          continue;
        }
      }

      newChild.addChild(SNodeOperations.getContainingLinkRole(attribute), SNodeOperations.copyNode(attribute));
    }
  }

  public static SNode replaceWithAnother(SNode node, SNode anotherNode) {
    assert node != null : "can't replace node. node is NULL";
    return ((SNode) SNodeUtil.replaceWithAnother(node, anotherNode));
  }

  public static void deleteNode(SNode node) {
    if (node != null) {
      node.delete();
    }
  }

  public static SNode detachNode(SNode node) {
    if (node != null && node.getModel() != null) {
      SNode parent = node.getParent();
      if (parent != null) {
        parent.removeChild(node);
      } else {
        node.getModel().removeRootNode(node);
      }
    }
    return node;
  }

  public static boolean hasRole(SNode node, String conceptOfParentFqName, String role) {
    if (node == null || node.getParent() == null || conceptOfParentFqName == null || conceptOfParentFqName.length() == 0 || role == null || role.length() == 0) {
      return false;
    }
    SNode expectedConcept = SModelUtil.findConceptDeclaration(conceptOfParentFqName, GlobalScope.getInstance());
    if (expectedConcept == null) {
      return false;
    }
    SNode nodeParent = node.getParent();
    assert nodeParent != null;
    SNode conceptOfParent = SNodeOperations.getConceptDeclaration(nodeParent);
    if (!(SModelUtil.isAssignableConcept(conceptOfParent, expectedConcept))) {
      return false;
    }
    return role.equals(node.getRoleInParent());
  }

  public static SNode getConceptDeclaration(SNode node) {
    return (node == null ?
      null :
      SModelUtil.findConceptDeclaration(node.getConcept().getId(), GlobalScope.getInstance())
    );
  }

  public static int getIndexInParent(SNode node) {
    if (node == null || node.getParent() == null) {
      return -1;
    }
    String role = node.getRoleInParent();
    if (role == null) {
      return -1;
    }
    return IterableUtil.asList(node.getParent().getChildren(role)).indexOf(node);
  }

  public static List<SNode> getAllAttributes(SNode node) {
    return AttributeOperations.getAllAttributes(node);
  }

  public static boolean isAttribute(SNode node) {
    return AttributeOperations.isAttribute(node);
  }

  public static SNode getNode(String modelUID, String nodeID) {
    return new SNodePointer(modelUID, nodeID).getNode();
  }

  /**
   * use ModelConstraints.getScope() and ModelConstraints.getReferenceDescriptor()
   */
  @Deprecated
  public static ISearchScope getReferentSearchScope(SNode referenceNode, String referenceRole, IOperationContext context) {
    if (referenceNode == null) {
      return null;
    }
    Scope scope = ModelConstraints.getReferenceDescriptor(referenceNode, referenceRole).getScope();
    if (scope instanceof ErrorScope) {
      return null;
    }
    if (scope instanceof ISearchScope.Adapter) {
      return ((ISearchScope.Adapter) scope).getSearchScope();
    }
    return new ScopeAdapter(scope);
  }

  public static SNode cast(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(node, castTo))) {
      if (ourCastsEnabled) {
        throw new NodeCastException("Can't cast " + node.getConcept().getId() + " to " + castTo);
      } else {
        LOG.warning("Can't cast " + node.getConcept().getId() + " to " + castTo);
      }
    }
    return node;
  }

  public static SNode as(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(node, castTo))) {
      return null;
    }
    return node;
  }

  public static SNode castConcept(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SModelUtil.isAssignableConcept(NameUtil.nodeFQName(node), castTo))) {
      if (ourCastsEnabled) {
        throw new NodeCastException("Can't cast " + NameUtil.nodeFQName(node) + " to " + castTo);
      } else {
        LOG.warning("Can't cast " + NameUtil.nodeFQName(node) + " to " + castTo);
      }
    }
    return node;
  }

  public static SNode asConcept(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SModelUtil.isAssignableConcept(NameUtil.nodeFQName(node), castTo))) {
      return null;
    }
    return node;
  }

  public static SNode getContainingLinkDeclaration(SNode childNode) {
    if (childNode == null) {
      return null;
    }
    String role = childNode.getRoleInParent();
    if (role == null) {
      return null;
    }
    SNode c = SNodeOperations.getConceptDeclaration(SNodeOperations.getParent(childNode));
    return SModelSearchUtil.findLinkDeclaration(c, role);
  }

  public static String getContainingLinkRole(SNode childNode) {
    if (childNode == null) {
      return null;
    }
    return ((SNode) childNode).getRoleInParent();
  }

  public static List<SReference> getReferences(SNode node) {
    if (node == null) {
      return new ArrayList<SReference>(0);
    }
    return ((List) IterableUtil.asList(node.getReferences()));
  }

  public static SReference getReference(SNode node, SNode linkDeclaration) {
    if (node == null || linkDeclaration == null) {
      return null;
    }
    linkDeclaration = SModelUtil.getGenuineLinkDeclaration(linkDeclaration);
    return node.getReference(SPropertyOperations.getString(linkDeclaration, "role"));
  }
}
