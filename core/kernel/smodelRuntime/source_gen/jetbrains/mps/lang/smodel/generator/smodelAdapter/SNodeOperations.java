package jetbrains.mps.lang.smodel.generator.smodelAdapter;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.RuntimeFlags;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SConceptRepository;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.util.annotation.ToRemove;
import jetbrains.mps.smodel.SModelUtil_new;
import java.util.ArrayList;
import jetbrains.mps.util.IterableUtil;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import org.jetbrains.mps.util.InstanceOfCondition;
import org.jetbrains.mps.util.Condition;
import org.jetbrains.mps.util.DescendantsTreeIterator;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.UUID;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.search.ISearchScope;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.smodel.constraints.ModelConstraints;
import jetbrains.mps.scope.ErrorScope;
import jetbrains.mps.scope.ScopeAdapter;
import jetbrains.mps.util.NameUtil;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.util.ConditionalIterable;

public class SNodeOperations {
  private static final Logger LOG = Logger.wrap(LogManager.getLogger(SNodeOperations.class));
  private static boolean ourCastExceptionsEnabled = RuntimeFlags.isExceptionOnBadCast();
  /**
   * Empty list of nodes that can't be modified helps to detect otherwise hard to catch
   * errors when role of non-existent parent is modified.
   * For example, if there's NodeA.nodeB [0..1] and NodeB.nodeC[0..*], the query
   * <code>myA.nodeB.nodeC.add(new NodeC)</code> used to pass silently even if nodeB was not set.
   */
  /*package*/ static final List<SNode> EMPTY_LIST = new EmptyList<SNode>("Attempt to add node to nonexistent parent or role. Node: %s");
  public SNodeOperations() {
  }
  private static SConcept stringToConcept(String conceptFqName) {
    if (conceptFqName == null) {
      return null;
    }
    return SConceptRepository.getInstance().getInstanceConcept(conceptFqName);
  }
  private static SConcept[] stringArrayToConceptArray(String[] conceptFqNames) {
    int n = conceptFqNames.length;
    SConcept[] result = new SConcept[n];
    for (int i = 0; i < n; i++) {
      result[i] = stringToConcept(conceptFqNames[i]);
    }
    return result;
  }
  public static SNode copyNode(SNode node) {
    if (node == null) {
      return null;
    }
    return CopyUtil.copy(node);
  }
  public static SNode getContainingRoot(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getContainingRoot();
  }
  public static SNode getParent(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getParent();
  }
  public static SNode getNodeAncestor(SNode node, SConcept ancestorConcept, boolean inclusion, boolean root) {
    return SNodeOperations.getNodeAncestor(node, ancestorConcept, inclusion, root, false);
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static SNode getAncestor(SNode node, String ancestorConceptFqName, boolean inclusion, boolean root) {
    return SNodeOperations.getAncestor(node, ancestorConceptFqName, inclusion, root, false);
  }
  public static SNode getNodeAncestor(SNode node, SConcept ancestorConcept, boolean inclusion, boolean root, boolean sameMetaLevel) {
    if (node == null) {
      return null;
    }
    int metaLevel = (sameMetaLevel ? SModelUtil_new.getMetaLevel(node) : 0);

    // look up for certain concept 
    if (root) {
      SNode rootParent = node.getContainingRoot();
      if (rootParent.getModel() != null && SNodeOperations.nullSafeInstanceOf(rootParent, ancestorConcept)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(rootParent) == metaLevel) {
          return rootParent;
        }
      }
      return null;
    }

    // look-up parent of required type 
    SNode outputNode;
    if (inclusion) {
      outputNode = node;
    } else {
      outputNode = node.getParent();
    }
    if (outputNode == null) {
      return null;
    }
    if (SNodeOperations.nullSafeInstanceOf(outputNode, ancestorConcept)) {
      if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
        return outputNode;
      }
    }
    while ((outputNode = outputNode.getParent()) != null) {
      if (SNodeOperations.nullSafeInstanceOf(outputNode, ancestorConcept)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
          break;
        }
      }
    }
    return outputNode;
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static SNode getAncestor(SNode node, String ancestorConceptFqName, boolean inclusion, boolean root, boolean sameMetaLevel) {
    return SNodeOperations.getNodeAncestor(node, stringToConcept(ancestorConceptFqName), inclusion, root, sameMetaLevel);
  }
  private static boolean nullSafeInstanceOf(SNode node, SConcept concept) {
    if (concept == null) {
      return true;
    }
    return SNodeOperations._isInstanceOf(node, concept);
  }
  public static SNode getNodeAncestorWhereConceptInList(SNode node, SConcept[] ancestorConcepts, boolean inclusion, boolean root) {
    return SNodeOperations.getNodeAncestorWhereConceptInList(node, ancestorConcepts, inclusion, root, false);
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static SNode getAncestorWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion, boolean root) {
    return SNodeOperations.getAncestorWhereConceptInList(node, ancestorConceptFqNames, inclusion, root, false);
  }
  public static SNode getNodeAncestorWhereConceptInList(SNode node, SConcept[] ancestorConceptFqNames, boolean inclusion, boolean root, boolean sameMetaLevel) {
    if (node == null) {
      return null;
    }
    int metaLevel = (sameMetaLevel ? SModelUtil_new.getMetaLevel(node) : 0);
    if (ancestorConceptFqNames.length == 0) {
      return null;
    }
    if (root) {
      SNode rootParent = node.getContainingRoot();
      if (SNodeOperations._isInstanceOf(rootParent, ancestorConceptFqNames)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(rootParent) == metaLevel) {
          return rootParent;
        }
      }
      return null;
    }

    // look-up parent of required type 
    SNode outputNode;
    if (inclusion) {
      outputNode = node;
    } else {
      outputNode = node.getParent();
    }
    if (outputNode == null) {
      return null;
    }
    if (SNodeOperations._isInstanceOf(outputNode, ancestorConceptFqNames)) {
      if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
        return outputNode;
      }
    }
    while ((outputNode = outputNode.getParent()) != null) {
      if (SNodeOperations._isInstanceOf(outputNode, ancestorConceptFqNames)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
          return outputNode;
        }
      }
    }
    return null;
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static SNode getAncestorWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion, boolean root, boolean sameMetaLevel) {
    return getNodeAncestorWhereConceptInList(node, stringArrayToConceptArray(ancestorConceptFqNames), inclusion, root, sameMetaLevel);
  }
  public static List<SNode> getNodeAncestors(SNode node, SConcept ancestorConcept, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    List<SNode> result = new ArrayList<SNode>();
    if (!(inclusion)) {
      node = node.getParent();
    }
    while (node != null) {
      if (ancestorConcept == null || SNodeOperations._isInstanceOf(node, ancestorConcept)) {
        result.add(node);
      }
      node = node.getParent();
    }
    return result;
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static List<SNode> getAncestors(SNode node, String ancestorConceptFqName, boolean inclusion) {
    return getNodeAncestors(node, stringToConcept(ancestorConceptFqName), inclusion);
  }
  public static List<SNode> getNodeAncestorsWhereConceptInList(SNode node, SConcept[] ancestorConcepts, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    List<SNode> result = new ArrayList<SNode>();
    if (!(inclusion)) {
      node = node.getParent();
    }
    while (node != null) {
      if (SNodeOperations._isInstanceOf(node, ancestorConcepts)) {
        result.add(node);
      }
      node = node.getParent();
    }
    return result;
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static List<SNode> getAncestorsWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion) {
    return getNodeAncestorsWhereConceptInList(node, stringArrayToConceptArray(ancestorConceptFqNames), inclusion);
  }
  public static List<SNode> getNodeDescendants(SNode node, final SConcept childConcept, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    return IterableUtil.asList(SNodeUtil.getDescendants(node, (childConcept == null ? null : new InstanceOfCondition(childConcept)), inclusion));
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static List<SNode> getDescendants(SNode node, final String childConceptFqName, boolean inclusion) {
    return getNodeDescendants(node, stringToConcept(childConceptFqName), inclusion);
  }
  public static List<SNode> getNodeDescendants(SNode node, final SConcept childConcept, boolean inclusion, final SConcept[] stopConceptFqNames) {
    if (node == null) {
      return EMPTY_LIST;
    }
    if (stopConceptFqNames == null || stopConceptFqNames.length == 0) {
      return getNodeDescendants(node, childConcept, inclusion);
    }
    if (childConcept == null) {
      // It's odd to ignore stop condition when there's no designated childConcept, 
      // but this is how it used to be from revision ad249caf since 2009. 
      return getDescendants(node, null, inclusion);
    }
    return descendantsAsList(node, inclusion, new InstanceOfCondition(childConcept), new InstanceOfCondition(stopConceptFqNames));
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static List<SNode> getDescendants(SNode node, final String childConceptFqName, boolean inclusion, final String[] stopConceptFqNames) {
    return getNodeDescendants(node, stringToConcept(childConceptFqName), inclusion, stringArrayToConceptArray(stopConceptFqNames));
  }
  public static List<SNode> getNodeDescendantsWhereConceptInList(SNode node, final SConcept[] descendantConcepts, boolean inclusion) {
    if (node == null || descendantConcepts.length == 0) {
      return EMPTY_LIST;
    }
    return IterableUtil.asList(SNodeUtil.getDescendants(node, new InstanceOfCondition(descendantConcepts), inclusion));
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static List<SNode> getDescendantsWhereConceptInList(SNode node, final String[] descendantConceptFqNames, boolean inclusion) {
    return getNodeDescendantsWhereConceptInList(node, stringArrayToConceptArray(descendantConceptFqNames), inclusion);
  }
  public static List<SNode> getNodeDescendantsWhereConceptInList(SNode node, final SConcept[] descendantConcepts, boolean inclusion, final SConcept[] stopConcepts) {
    if (node == null || descendantConcepts.length == 0) {
      return EMPTY_LIST;
    }
    if (stopConcepts == null || stopConcepts.length == 0) {
      return getNodeDescendantsWhereConceptInList(node, descendantConcepts, inclusion);
    }
    return descendantsAsList(node, inclusion, new InstanceOfCondition(descendantConcepts), new InstanceOfCondition(stopConcepts));
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static List<SNode> getDescendantsWhereConceptInList(SNode node, final String[] descendantConceptFqNames, boolean inclusion, final String[] stopConceptFqNames) {
    return getNodeDescendantsWhereConceptInList(node, stringArrayToConceptArray(descendantConceptFqNames), inclusion, stringArrayToConceptArray(stopConceptFqNames));
  }
  private static List<SNode> descendantsAsList(SNode node, boolean inclusion, Condition<SNode> condition, Condition<SNode> stopCondition) {
    // can't use TreeFilterIterator as nodes that match both condition and stopCondition are proper return values 
    ArrayList<SNode> rv = new ArrayList<SNode>();
    final DescendantsTreeIterator it = new DescendantsTreeIterator(node);
    if (!(inclusion) && it.hasNext()) {
      it.next();
    }
    while (it.hasNext()) {
      SNode next = it.next();
      if (condition.met(next)) {
        rv.add(next);
      }
      if (stopCondition.met(next)) {
        it.skipChildren();
      }
    }
    return rv;
  }
  private static boolean _isInstanceOf(SNode node, SConcept[] concepts) {
    for (SConcept concept : concepts) {
      if (concept == null) {
        continue;
      }
      if (SNodeOperations._isInstanceOf(node, concept)) {
        return true;
      }
    }
    return false;
  }
  private static boolean _isInstanceOf(SNode node, SConcept concept) {
    if (node == null) {
      return false;
    }
    return SNodeUtil.isInstanceOf(node, concept);
  }
  public static List<SNode> getChildren(SNode node) {
    if (node == null) {
      return EMPTY_LIST;
    }
    return jetbrains.mps.util.SNodeOperations.getChildren(node);
  }
  public static List<SNode> getChildren(SNode node, SContainmentLink linkDeclaration) {
    if (node == null || linkDeclaration == null) {
      return EMPTY_LIST;
    }
    return SLinkOperations.getChildren(node, linkDeclaration);
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static List<SNode> getChildren(SNode node, SNode linkDeclaration) {
    if (node == null || linkDeclaration == null) {
      return EMPTY_LIST;
    }
    linkDeclaration = SModelUtil.getGenuineLinkDeclaration(linkDeclaration);
    return SLinkOperations.getChildren(node, MetaAdapterByDeclaration.getContainmentLink((jetbrains.mps.smodel.SNode) linkDeclaration));
  }
  public static SModel getModel(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getModel();
  }
  public static boolean isInstanceOf(SNode node, SConcept concept) {
    if (node == null) {
      return false;
    }
    if (concept == null) {
      return false;
    }
    return SNodeOperations._isInstanceOf(node, concept);
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static boolean isInstanceOf(SNode node, String conceptFQName) {
    return isInstanceOf(node, stringToConcept(conceptFQName));
  }
  public static SNode getNextSibling(SNode node) {
    SNode p = node.getParent();
    if (p == null) {
      return null;
    }
    SNode current = node;
    String currentRole = node.getRoleInParent();
    assert currentRole != null : "role must be not null";
    while (current.getNextSibling() != null) {
      current = current.getNextSibling();
      if (current.getRoleInParent().equals(currentRole)) {
        return current;
      }
    }
    return null;
  }
  public static SNode getPrevSibling(SNode node) {
    SNode p = node.getParent();
    if (p == null) {
      return null;
    }
    SNode current = node;
    String currentRole = node.getRoleInParent();
    assert currentRole != null : "role must be not null";
    SNode fc = p.getFirstChild();
    while (current != fc) {
      current = current.getPrevSibling();
      if (current.getRoleInParent().equals(currentRole)) {
        return current;
      }
    }
    return null;
  }
  public static List<SNode> getPrevSiblings(SNode node, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    List<SNode> result = new ArrayList<SNode>();
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    String role = node.getRoleInParent();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        if (inclusion) {
          result.add(child);
        }
        break;
      }
      result.add(child);
    }
    return result;
  }
  public static List<SNode> getNextSiblings(SNode node, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    List<SNode> result = new ArrayList<SNode>();
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    if (inclusion) {
      result.add(node);
    }
    boolean childFound = false;
    String role = node.getRoleInParent();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        childFound = true;
      } else
      if (childFound) {
        result.add(child);
      }
    }
    return result;
  }
  public static List<SNode> getAllSiblings(SNode node, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    List<SNode> result = new ArrayList<SNode>();
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    String role = node.getRoleInParent();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        if (inclusion) {
          result.add(child);
        }
      } else {
        result.add(child);
      }
    }
    return result;
  }
  public static SNode insertNewNextSiblingChild(SNode node, String conceptFQName) {
    if (node == null || node.getParent() == null) {
      return null;
    }
    SNode parent = node.getParent();
    SNode newChild = SModelOperations.createNewNode(node.getModel(), conceptFQName);
    if (newChild == null) {
      return null;
    }
    SContainmentLink role = node.getContainmentLink();
    assert parent != null && role != null;
    jetbrains.mps.util.SNodeOperations.insertChild(parent, role, newChild, node);
    return newChild;
  }
  public static SNode insertNewPrevSiblingChild(SNode node, String conceptFqName) {
    if (node == null) {
      return null;
    }
    SNode parent = node.getParent();
    if (parent == null) {
      return null;
    }
    SNode newChild = SModelOperations.createNewNode(node.getModel(), conceptFqName);
    if (newChild == null) {
      return null;
    }
    SContainmentLink role = node.getContainmentLink();
    assert role != null;
    parent.insertChildBefore(role, newChild, node);
    return newChild;
  }
  public static SNode insertNextSiblingChild(SNode node, SNode siblingNode) {
    if (node == null) {
      return null;
    }
    SNode nodeParent = node.getParent();
    if (nodeParent == null || siblingNode == null || node == siblingNode) {
      return siblingNode;
    }
    SNode parent = siblingNode.getParent();
    if (parent != null) {
      parent.removeChild(siblingNode);
    }
    SContainmentLink role = node.getContainmentLink();
    assert role != null;
    jetbrains.mps.util.SNodeOperations.insertChild(nodeParent, role, siblingNode, node);
    return siblingNode;
  }
  public static SNode insertPrevSiblingChild(SNode node, SNode siblingNode) {
    if (node == null) {
      return null;
    }
    SNode nodeParent = node.getParent();
    if (nodeParent == null || siblingNode == null || node == siblingNode) {
      return siblingNode;
    }
    SNode siblingParent = siblingNode.getParent();
    if (siblingParent != null) {
      siblingParent.removeChild(siblingNode);
    }
    SContainmentLink role = node.getContainmentLink();
    assert role != null;
    nodeParent.insertChildBefore(role, siblingNode, node);
    return siblingNode;
  }
  public static SNode replaceWithNewChild(SNode oldChild, String conceptFqName) {
    assert oldChild != null : "can't replace node. node is NULL";
    SNode oldChildParent = oldChild.getParent();
    if (oldChildParent == null && (oldChild.getModel() == null || oldChild.getParent() != null)) {
      return null;
    }
    SModel model = oldChild.getModel();
    SNode newChild = SModelOperations.createNewNode(model, conceptFqName);
    if (newChild == null) {
      return null;
    }
    SNodeUtil.replaceWithAnother(oldChild, newChild);
    SNodeOperations.copyAllAttributes(oldChild, newChild);
    return newChild;
  }
  private static void copyAllAttributes(SNode oldChild, SNode newChild) {
    for (SNode attribute : AttributeOperations.getAllAttributes(oldChild)) {
      if (SNodeOperations.isInstanceOf(attribute, MetaAdapterFactory.getConcept(new UUID(-3554657779850784990l, -7236703803128771572l), 3364660638048049750l, "jetbrains.mps.lang.core.structure.PropertyAttribute"))) {
        String propertyName = AttributeOperations.getPropertyName(SNodeOperations.cast(attribute, MetaAdapterFactory.getConcept(new UUID(-3554657779850784990l, -7236703803128771572l), 3364660638048049750l, "jetbrains.mps.lang.core.structure.PropertyAttribute")));
        if ((BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.getConceptDeclaration(newChild), "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", "call_findPropertyDeclaration_1219835742593", new Object[]{propertyName}) == null)) {
          // no such property in new child : don't copy the attribute 
          LOG.error("couldn't copy attribute " + attribute.getConcept().getName() + " for property '" + propertyName + "' : so such property in concept " + newChild.getConcept().getName(), newChild);
          continue;
        }
      }
      if (SNodeOperations.isInstanceOf(attribute, MetaAdapterFactory.getConcept(new UUID(-3554657779850784990l, -7236703803128771572l), 3364660638048049745l, "jetbrains.mps.lang.core.structure.LinkAttribute"))) {
        String linkRole = AttributeOperations.getLinkRole(SNodeOperations.cast(attribute, MetaAdapterFactory.getConcept(new UUID(-3554657779850784990l, -7236703803128771572l), 3364660638048049745l, "jetbrains.mps.lang.core.structure.LinkAttribute")));
        if ((BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.getConceptDeclaration(newChild), "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", "call_findLinkDeclaration_1213877394467", new Object[]{linkRole}) == null)) {
          // no such link in new child : don't copy the attribute 
          LOG.error("couldn't copy attribute " + attribute.getConcept().getName() + " for link '" + linkRole + "' : so such link in concept " + newChild.getConcept().getName(), newChild);
          continue;
        }
      }

      newChild.addChild(SNodeOperations.getContainingLinkRole(attribute), SNodeOperations.copyNode(attribute));
    }
  }
  public static SNode replaceWithAnother(SNode node, SNode anotherNode) {
    assert node != null : "can't replace node. node is NULL";
    return ((SNode) SNodeUtil.replaceWithAnother(node, anotherNode));
  }
  public static void deleteNode(SNode node) {
    if (node != null) {
      node.delete();
    }
  }
  public static SNode detachNode(SNode node) {
    if (node != null && node.getModel() != null) {
      SNode parent = node.getParent();
      if (parent != null) {
        parent.removeChild(node);
      } else {
        node.getModel().removeRootNode(node);
      }
    }
    return node;
  }
  public static boolean hasRole(SNode node, SContainmentLink role) {
    if (node == null || node.getParent() == null || role == null) {
      return false;
    }
    return node.getParent().getConcept().isSubConceptOf(role.getContainingConcept()) && role.equals(node.getContainmentLink());
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static boolean hasRole(SNode node, String conceptOfParentFqName, String role) {
    if (node == null || node.getParent() == null || conceptOfParentFqName == null || conceptOfParentFqName.length() == 0 || role == null || role.length() == 0) {
      return false;
    }
    SNode expectedConcept = SModelUtil.findConceptDeclaration(conceptOfParentFqName);
    if (expectedConcept == null) {
      return false;
    }
    SNode nodeParent = node.getParent();
    assert nodeParent != null;
    SNode conceptOfParent = SNodeOperations.getConceptDeclaration(nodeParent);
    if (!(SModelUtil.isAssignableConcept(conceptOfParent, expectedConcept))) {
      return false;
    }
    return role.equals(node.getRoleInParent());
  }
  public static SNode getConceptDeclaration(SNode node) {
    return (node == null ? null : SModelUtil.findConceptDeclaration(node.getConcept().getQualifiedName()));
  }
  public static int getIndexInParent(SNode node) {
    if (node == null || node.getParent() == null) {
      return -1;
    }
    SContainmentLink role = node.getContainmentLink();
    if (role == null) {
      return -1;
    }
    return IterableUtil.asList(node.getParent().getChildren(role)).indexOf(node);
  }
  public static List<SNode> getAllAttributes(SNode node) {
    return AttributeOperations.getAllAttributes(node);
  }
  public static boolean isAttribute(SNode node) {
    return AttributeOperations.isAttribute(node);
  }
  public static SNode getNode(String modelUID, String nodeID) {
    return new SNodePointer(modelUID, nodeID).resolve(MPSModuleRepository.getInstance());
  }
  /**
   * use ModelConstraints.getScope() and ModelConstraints.getReferenceDescriptor()
   */
  @Deprecated
  public static ISearchScope getReferentSearchScope(SNode referenceNode, String referenceRole, IOperationContext context) {
    if (referenceNode == null) {
      return null;
    }
    Scope scope = ModelConstraints.getReferenceDescriptor(referenceNode, referenceRole).getScope();
    if (scope instanceof ErrorScope) {
      return null;
    }
    if (scope instanceof ISearchScope.Adapter) {
      return ((ISearchScope.Adapter) scope).getSearchScope();
    }
    return new ScopeAdapter(scope);
  }
  public static SNode cast(SNode node, SConcept castTo) {
    if (node == null) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(node, castTo))) {
      String message = "Can't cast node: " + node.getNodeId().toString() + ", concept: " + node.getConcept().getQualifiedName() + " to concept: " + castTo;
      if (ourCastExceptionsEnabled) {
        throw new NodeCastException(message);
      } else {
        LOG.warning(message);
      }
    }
    return node;
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static SNode cast(SNode node, String castTo) {
    return cast(node, stringToConcept(castTo));
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static SNode as(SNode node, String castTo) {
    if (!(SNodeOperations.isInstanceOf(node, castTo))) {
      return null;
    }
    return node;
  }
  public static SNode as(SNode node, SConcept castTo) {
    if (!(SNodeOperations.isInstanceOf(node, castTo))) {
      return null;
    }
    return node;
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static SNode castConcept(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SModelUtil.isAssignableConcept(NameUtil.nodeFQName(node), castTo))) {
      String message = "Can't cast concept: " + node.getNodeId().toString() + ", FQName: " + NameUtil.nodeFQName(node) + " to concept: " + castTo;
      if (ourCastExceptionsEnabled) {
        throw new NodeCastException(message);
      } else {
        LOG.warning(message);
      }
    }
    return node;
  }
  public static SNode castConcept(SNode node, SConcept castTo) {
    if (node == null) {
      return null;
    }
    if (!(MetaAdapterByDeclaration.getConcept((jetbrains.mps.smodel.SNode) node).isSubConceptOf(castTo))) {
      String message = "Can't cast concept: " + node.getNodeId().toString() + ", FQName: " + NameUtil.nodeFQName(node) + " to concept: " + castTo;
      if (ourCastExceptionsEnabled) {
        throw new NodeCastException(message);
      } else {
        LOG.warning(message);
      }
    }
    return node;
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static SNode asConcept(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SModelUtil.isAssignableConcept(NameUtil.nodeFQName(node), castTo))) {
      return null;
    }
    return node;
  }
  public static SNode asConcept(SNode node, SConcept castTo) {
    if (node == null) {
      return null;
    }
    if (!(MetaAdapterByDeclaration.getConcept((jetbrains.mps.smodel.SNode) node).isSubConceptOf(castTo))) {
      return null;
    }
    return node;
  }
  public static SNode getContainingLinkDeclaration(SNode childNode) {
    if (childNode == null) {
      return null;
    }
    return childNode.getContainmentLink().getDeclarationNode();
  }
  public static String getContainingLinkRole(SNode childNode) {
    if (childNode == null) {
      return null;
    }
    return childNode.getContainmentLink().getRoleName();
  }
  public static List<SReference> getReferences(SNode node) {
    if (node == null) {
      return new EmptyList<SReference>("Attempt to add reference to unexistent parent. Reference: %s");
    }
    return IterableUtil.asList(node.getReferences());
  }
  public static SReference getReference(SNode node, SReferenceLink linkDeclaration) {
    if (node == null || linkDeclaration == null) {
      return null;
    }
    return node.getReference(linkDeclaration);
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static SReference getReference(SNode node, SNode linkDeclaration) {
    if (node == null || linkDeclaration == null) {
      return null;
    }
    linkDeclaration = SModelUtil.getGenuineLinkDeclaration(linkDeclaration);
    return node.getReference(SPropertyOperations.getString(linkDeclaration, MetaAdapterFactory.getProperty(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489288298l, 1071599776563l, "role")));
  }
  @Deprecated
  @ToRemove(version = 3.2)
  public static Iterable<SNode> ofConcept(Iterable<SNode> nodes, String conceptName) {
    if (conceptName == null) {
      return Sequence.fromIterable(Collections.<SNode>emptyList());
    }
    InstanceOfCondition condition = new InstanceOfCondition(conceptName).tolerateNulls();
    Iterable<SNode> rv = new ConditionalIterable<SNode>(nodes, condition);
    return rv;
  }
  public static Iterable<SNode> ofConcept(Iterable<SNode> nodes, SConcept concept) {
    if (concept == null) {
      return Sequence.fromIterable(Collections.<SNode>emptyList());
    }
    InstanceOfCondition condition = new InstanceOfCondition(concept).tolerateNulls();
    Iterable<SNode> rv = new ConditionalIterable<SNode>(nodes, condition);
    return rv;
  }
}
