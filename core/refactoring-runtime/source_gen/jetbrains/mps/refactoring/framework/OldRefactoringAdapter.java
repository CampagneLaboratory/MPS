package jetbrains.mps.refactoring.framework;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Map;
import jetbrains.mps.project.IModule;
import java.util.ArrayList;
import jetbrains.mps.ide.findusages.model.SearchResults;
import org.jetbrains.mps.openapi.model.SModel;

@Deprecated
public class OldRefactoringAdapter implements IRefactoring {
  private List<SNode> myNodesToOpen;
  protected AbstractLoggableRefactoring myOldRefactoring;

  @Deprecated
  public OldRefactoringAdapter(AbstractLoggableRefactoring oldRefactoring) {
    myOldRefactoring = oldRefactoring;
  }

  @Override
  public String getUserFriendlyName() {
    return myOldRefactoring.getUserFriendlyName();
  }

  public String getKeyStroke() {
    return myOldRefactoring.getKeyStroke();
  }

  @Override
  public Class getOverridenRefactoringClass() {
    return myOldRefactoring.getOverridenRefactoringClass();
  }

  @Override
  public IRefactoringTarget getRefactoringTarget() {
    return new OldRefactoringAdapter.MyRefactoringTarget();
  }

  @Override
  public boolean init(RefactoringContext refactoringContext) {
    return false;
  }

  @Override
  public void refactor(final RefactoringContext refactoringContext) {
    myOldRefactoring.doRefactor(refactoringContext);
    myNodesToOpen = myOldRefactoring.getNodesToOpen(refactoringContext);
  }

  @Override
  public List<SModel> getModelsToGenerate(RefactoringContext refactoringContext) {
    Map<IModule, List<SModel>> modelsToGenerate = myOldRefactoring.getModelsToGenerate(refactoringContext);
    if (modelsToGenerate == null) {
      return new ArrayList<SModel>();
    }
    List<SModel> result = new ArrayList<SModel>();
    for (List<SModel> models : modelsToGenerate.values()) {
      result.addAll(models);
    }
    return result;
  }

  @Override
  public void doWhenDone(final RefactoringContext refactoringContext) {
  }

  @Override
  public SearchResults getAffectedNodes(RefactoringContext refactoringContext) {
    return myOldRefactoring.getAffectedNodes(refactoringContext);
  }

  public String getRefactoringClassName() {
    return myOldRefactoring.getClass().getName();
  }

  public Class getRefactoringClass() {
    return myOldRefactoring.getClass();
  }

  public static IRefactoring createAdapterFor(AbstractLoggableRefactoring oldRefactoring) {
    if (oldRefactoring.doesUpdateModel()) {
      return new OldLoggableRefactoringAdapter(oldRefactoring);
    } else {
      return new OldRefactoringAdapter(oldRefactoring);
    }
  }

  private class MyRefactoringTarget implements IRefactoringTarget {
    private RefactoringTarget myTarget = myOldRefactoring.getRefactoringTarget();

    private MyRefactoringTarget() {
    }

    @Override
    public IRefactoringTarget.TargetType getTarget() {
      if (myTarget == RefactoringTarget.NODE) {
        return IRefactoringTarget.TargetType.NODE;
      } else
      if (myTarget == RefactoringTarget.MODEL) {
        return IRefactoringTarget.TargetType.MODEL;
      } else {
        return IRefactoringTarget.TargetType.MODULE;
      }
    }

    @Override
    public boolean allowMultipleTargets() {
      return !(myOldRefactoring.isOneTargetOnly());
    }

    @Override
    public boolean isApplicable(Object o) {
      if (myTarget == RefactoringTarget.NODE) {
        return myOldRefactoring.isApplicableWRTConcept((SNode) o);
      } else
      if (myTarget == RefactoringTarget.MODEL) {
        return myOldRefactoring.isApplicableToModel((SModel) o);
      } else {
        return myOldRefactoring.isApplicableToModule((IModule) o);
      }
    }
  }
}
