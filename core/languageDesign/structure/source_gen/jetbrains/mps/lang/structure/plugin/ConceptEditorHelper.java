package jetbrains.mps.lang.structure.plugin;

/*Generated by MPS */

import jetbrains.mps.smodel.IScope;
import jetbrains.mps.ide.tabbedEditor.ILazyTab;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.structure.behavior.IConceptAspect_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.plugins.pluginparts.tabbedEditor.BaseMultiTab;
import jetbrains.mps.plugins.pluginparts.tabbedEditor.BaseSingleTab;
import jetbrains.mps.ide.tabbedEditor.AbstractLazyTab;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.SModelAdapter;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import java.util.Map;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.util.Pair;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.util.Condition;
import jetbrains.mps.smodel.Generator;

public class ConceptEditorHelper {
  public static IScope getScope(ILazyTab tab) {
    return tab.getTabbedEditor().getOperationContext().getScope();
  }

  public static List<SNode> getAvailableConceptAspects(SModel structureModel, SNode node) {
    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());
    for (SNode root : SModelOperations.getRoots(structureModel, "jetbrains.mps.lang.structure.structure.ConceptDeclaration")) {
      if (SConceptOperations.isSubConceptOf(root, "jetbrains.mps.lang.structure.structure.IConceptAspect") && SPropertyOperations.getBoolean(root, "rootable")) {
        SNode candidate = (SNode) root;
        if (IConceptAspect_Behavior.call_isApplicable_7839831476331657915(SNodeOperations.cast(SConceptOperations.createNewNode(NameUtil.nodeFQName(candidate), null), "jetbrains.mps.lang.structure.structure.IConceptAspect"), node)) {
          ListSequence.fromList(result).addElement(candidate);
        }
      }
    }
    return result;
  }

  public static List<SNode> getAvailableConceptAspects(LanguageAspect aspect, SNode node) {
    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());
    Language language = GlobalScope.getInstance().getLanguage(aspect.getMainLanguage());
    SModel structureModel = language.getStructureModelDescriptor().getSModel();
    ListSequence.fromList(result).addSequence(ListSequence.fromList(getAvailableConceptAspects(structureModel, node)));
    return result;
  }

  public static SNode createNewConceptAspectInstance(SNode applicableNode, SNode concept, SModel model) {
    SNode conceptAspect = SConceptOperations.createNewNode(NameUtil.nodeFQName(concept), null);
    IConceptAspect_Behavior.call_setBaseConcept_6261424444345963020(conceptAspect, applicableNode);
    SModelOperations.addRootNode(model, conceptAspect);

    return conceptAspect;
  }

  public static SNode createNewConceptAspectInstance(LanguageAspect aspect, SNode applicableNode, SNode concept, ILazyTab lazyTab) {
    Language language = SModelUtil.getDeclaringLanguage(applicableNode);
    assert language != null : "Language shouldn't be null for " + applicableNode;

    SModelDescriptor md = aspect.get(language);
    if (md == null) {
      md = aspect.createNew(language);
    }
    return createNewConceptAspectInstance(applicableNode, concept, md.getSModel());
  }

  public static void addMultitabbedListener(final BaseMultiTab tab, final LanguageAspect aspect, boolean listenNonRootEvents) {
    final Language language = ConceptEditorHelper.getLanguageForTab(tab);
    tab.addNodeAdditionListener(new ConceptEditorHelper.ModelCondition(language, aspect), new ConceptEditorHelper.MultitabbedListener(tab, listenNonRootEvents));
  }

  public static void addGeneratorListener(final BaseMultiTab tab) {
    final Language language = ConceptEditorHelper.getLanguageForTab(tab);
    tab.addNodeAdditionListener(new ConceptEditorHelper.GeneratorCondition(language), new ConceptEditorHelper.MultitabbedListener(tab, true));
  }

  public static void addSingletabbedListener(final BaseSingleTab tab, final LanguageAspect aspect, boolean listenNonRootEvents) {
    final Language language = ConceptEditorHelper.getLanguageForTab(tab);
    tab.addNodeAdditionListener(new ConceptEditorHelper.ModelCondition(language, aspect), new ConceptEditorHelper.SingletabbedListener(tab, listenNonRootEvents));
  }

  private static Language getLanguageForTab(final AbstractLazyTab tab) {
    SNode node = ((SNode) tab.getBaseNode());
    assert node != null : "base node of tabbed editor is null";
    Language language = SModelUtil.getDeclaringLanguage(node);
    assert language != null : "language is null for node " + node;
    return language;
  }

  /*package*/ static List<SNode> sortRootsByConcept(List<SNode> roots, final SNode[] conceptOrder) {
    return ListSequence.fromList(roots).sort(new ISelector<SNode, Comparable<?>>() {
      public Comparable<?> select(SNode root) {
        int conceptIndex = Sequence.fromIterable(Sequence.fromArray(conceptOrder)).indexOf(SNodeOperations.getConceptDeclaration(root));
        return (conceptIndex == -1 ?
          conceptOrder.length :
          conceptIndex
        );
      }
    }, true).toListSequence();
  }

  public static class MultitabbedListener extends SModelAdapter {
    private BaseMultiTab tab;
    private boolean listenNonRootEvents;

    public MultitabbedListener(BaseMultiTab tab, boolean listenNonRootEvents) {
      this.tab = tab;
      this.listenNonRootEvents = listenNonRootEvents;
    }

    public void referenceAdded(SModelReferenceEvent event) {
      SNode root = event.getReference().getSourceNode().getContainingRoot();
      if (!(SNodeOperations.isInstanceOf(root, "jetbrains.mps.lang.structure.structure.IConceptAspect"))) {
        return;
      }

      Map<SNode, IOperationContext> nodesMap = this.createNodesMap();

      List<SNode> nodes = ListSequence.fromListWithValues(new ArrayList<SNode>(), MapSequence.fromMap(nodesMap).keySet());
      ListSequence.fromList(nodes).removeSequence(ListSequence.fromList(this.tab.getLoadableNodes()));
      if (ListSequence.fromList(nodes).isNotEmpty()) {
        SNode n = ListSequence.fromList(nodes).getElement(0);
        this.tab.addEditableNode(n, MapSequence.fromMap(nodesMap).get(n));
      }
    }

    private Map<SNode, IOperationContext> createNodesMap() {
      Map<SNode, IOperationContext> nodesMap = MapSequence.fromMap(new HashMap<SNode, IOperationContext>());
      for (Pair<SNode, IOperationContext> pair : ListSequence.fromList(this.tab.tryToLoadNodes())) {
        MapSequence.fromMap(nodesMap).put(pair.o1, pair.o2);
      }
      return nodesMap;
    }

    public void childAdded(SModelChildEvent event) {
      if (!(this.listenNonRootEvents)) {
        return;
      }

      SNode child = event.getChild();
      if (!(SNodeOperations.isInstanceOf(child, "jetbrains.mps.lang.structure.structure.IConceptAspect"))) {
        return;
      }
      if (this.tab.getLoadableNodes().contains(child)) {
        return;
      }

      IOperationContext context = null;
      for (Pair<SNode, IOperationContext> pair : ListSequence.fromList(this.tab.tryToLoadNodes())) {
        if (pair.o1 == SNodeOperations.getContainingRoot(child)) {
          context = pair.o2;
          break;
        }
      }
      if (context == null) {
        return;
      }
      this.tab.addEditableNode(SNodeOperations.getContainingRoot(child), context);
    }

    public void rootAdded(SModelRootEvent event) {
      SNode root = event.getRoot();
      if (!(SNodeOperations.isInstanceOf(root, "jetbrains.mps.lang.structure.structure.IConceptAspect"))) {
        return;
      }
      if (this.tab.getLoadableNodes().contains(root)) {
        return;
      }

      IOperationContext context = null;
      for (Pair<SNode, IOperationContext> pair : ListSequence.fromList(this.tab.tryToLoadNodes())) {
        if (pair.o1 == root) {
          context = pair.o2;
          break;
        }
      }
      if (context == null) {
        return;
      }
      this.tab.addEditableNode(root, context);
    }
  }

  public static class SingletabbedListener extends SModelAdapter {
    private BaseSingleTab tab;
    private boolean listenNonRootEvents;

    public SingletabbedListener(BaseSingleTab tab, boolean listenNonRootEvents) {
      this.tab = tab;
      this.listenNonRootEvents = listenNonRootEvents;
    }

    public void referenceAdded(SModelReferenceEvent event) {
      this.reinitIfNeeded(event.getReference().getSourceNode().getContainingRoot());
    }

    public void childAdded(SModelChildEvent event) {
      if (!(this.listenNonRootEvents)) {
        return;
      }
      this.reinitIfNeeded(event.getChild());
    }

    public void rootAdded(SModelRootEvent event) {
      this.reinitIfNeeded(event.getRoot());
    }

    private void reinitIfNeeded(SNode root) {
      if (!(SNodeOperations.isInstanceOf(root, "jetbrains.mps.lang.structure.structure.IConceptAspect"))) {
        return;
      }
      if (!(this.tab.newNode())) {
        return;
      }

      this.tab.reinit();
    }
  }

  public static class ModelCondition implements Condition<SModelDescriptor> {
    private Language myLanguage;
    private LanguageAspect myAspect;

    public ModelCondition(Language language, LanguageAspect aspect) {
      this.myLanguage = language;
      this.myAspect = aspect;
    }

    public boolean met(SModelDescriptor modelDescriptor) {
      return Language.getLanguageFor(modelDescriptor) == this.myLanguage && Language.getModelAspect(modelDescriptor) == this.myAspect;
    }
  }

  public static class GeneratorCondition implements Condition<SModelDescriptor> {
    private Language myLanguage;

    public GeneratorCondition(Language language) {
      this.myLanguage = language;
    }

    public boolean met(SModelDescriptor modelDescriptor) {
      for (Generator generator : ListSequence.fromList(this.myLanguage.getGenerators())) {
        if (generator.getOwnTemplateModels().contains(modelDescriptor)) {
          return true;
        }
      }
      return false;
    }
  }
}
