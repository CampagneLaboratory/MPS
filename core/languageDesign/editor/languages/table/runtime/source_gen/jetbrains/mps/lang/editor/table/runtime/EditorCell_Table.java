package jetbrains.mps.lang.editor.table.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Vertical;
import jetbrains.mps.nodeEditor.style.StyleAttributes;
import jetbrains.mps.nodeEditor.style.TableComponent;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.nodeEditor.CellActionType;
import jetbrains.mps.nodeEditor.EditorCellAction;
import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.nodeEditor.cellMenu.AbstractNodeSubstituteInfo;
import java.util.List;
import jetbrains.mps.smodel.action.INodeSubstituteAction;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.action.AbstractNodeSubstituteAction;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.awt.Color;
import java.util.Iterator;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import jetbrains.mps.editor.runtime.EditorCell_Empty;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Table;

public class EditorCell_Table extends EditorCell_Collection {
  private TableModel myModel;
  private String myUniquePrefix;

  public EditorCell_Table(EditorContext editorContext, SNode node, CellLayout cellLayout, TableModel model, String uniquePrefix) {
    super(editorContext, node, new CellLayout_Vertical(), null);
    setGridLayout(true);
    myModel = model;
    myUniquePrefix = uniquePrefix;
    this.setSelectable(false);
    this.getStyle().set(StyleAttributes.TABLE_COMPONENT, TableComponent.VERTICAL_COLLECTION);
    createChildrenCells();
  }

  public void createChildrenCells() {
    for (int row = 0; row < myModel.getRowCount(); row++) {
      EditorCell_Collection rowCell = this.createRowCell(row);
      String rowId = myUniquePrefix + "_row_" + row;
      rowCell.setCellId(rowId);
      rowCell.addEditorCell(createRowOutermostCell(row, rowId, true));
      final int finalRow = row;
      for (int column = 0; column < myModel.getColumnCount(); column++) {
        final int finalColumn = column;
        SNode value = myModel.getValueAt(row, column);
        EditorCell editorCell;
        if (value != null) {
          editorCell = getEditorContext().createNodeCell(value);
          editorCell.setAction(CellActionType.DELETE, new EditorCellAction() {
            public void execute(EditorContext editorContext) {
              myModel.deleteColumn(finalColumn);
            }
          });
          editorCell.setAction(CellActionType.INSERT, new EditorCellAction() {
            public void execute(EditorContext editorContext) {
              myModel.insertColumn(finalColumn + 1);
            }
          });
          editorCell.setAction(CellActionType.INSERT_BEFORE, new EditorCellAction() {
            public void execute(EditorContext editorContext) {
              myModel.insertColumn(finalColumn);
            }
          });
        } else {
          editorCell = new EditorCell_Constant(getEditorContext(), getSNode(), "", true);
          editorCell.setAction(CellActionType.INSERT, new EditorCellAction() {
            public void execute(EditorContext editorContext) {
              myModel.createElement(finalRow, finalColumn);
            }
          });
          editorCell.setSubstituteInfo(new AbstractNodeSubstituteInfo(getEditorContext()) {
            protected List<INodeSubstituteAction> createActions() {
              List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());
              ListSequence.fromList(result).addElement(new AbstractNodeSubstituteAction(null, getSNode()) {
                protected SNode doSubstitute(String p0) {
                  myModel.createElement(finalRow, finalColumn);
                  return null;
                }

                @Override
                protected String getMatchingText(String string, boolean b1, boolean b2) {
                  return "create new cell node";
                }

                @Override
                protected String getDescriptionText(String string, boolean b) {
                  return super.getDescriptionText(string, b);
                }
              });
              return result;
            }
          });
        }
        if (editorCell.getCellId() == null) {
          editorCell.setCellId(rowId + "_column_" + column);
        }
        editorCell.setLeftGap(4);
        editorCell.setRightGap(4);

        rowCell.addEditorCell(editorCell);
      }
      rowCell.addEditorCell(createRowOutermostCell(row, rowId, false));
      this.addEditorCell(rowCell);
    }
  }

  @Override
  public void paint(Graphics graphics, ParentSettings parentSettings) {
    super.paint(graphics, parentSettings);
    graphics.setColor(Color.GRAY);
    List<Integer> positionsX = ListSequence.fromList(new ArrayList<Integer>());
    List<Integer> positionsY = ListSequence.fromList(new ArrayList<Integer>());

    for (Iterator<EditorCell> rowsIterator = iterator(); rowsIterator.hasNext();) {
      EditorCell nextRow = rowsIterator.next();
      assert nextRow instanceof EditorCell_Collection;
      ListSequence.fromList(positionsY).addElement(nextRow.getY());
      if (!(rowsIterator.hasNext())) {
        // adding last row bottom coordinates 
        ListSequence.fromList(positionsY).addElement(nextRow.getY() + nextRow.getHeight());
      }
      int index = -1;
      for (Iterator<EditorCell> cellIterator = ((EditorCell_Collection) nextRow).iterator(); cellIterator.hasNext(); index++) {
        EditorCell nextCell = cellIterator.next();
        if (index < 0) {
          //  skipping first cell 
          continue;
        }
        int x = nextCell.getX();
        if (index >= ListSequence.fromList(positionsX).count()) {
          ListSequence.fromList(positionsX).addElement(x);
        } else {
          ListSequence.fromList(positionsX).setElement(index, Math.min(x, ListSequence.fromList(positionsX).getElement(index)));
        }
      }
      assert index > 0;
    }
    assert ListSequence.fromList(positionsX).count() > 1;
    int firstX = ListSequence.fromList(positionsX).first();
    int lastX = ListSequence.fromList(positionsX).last();
    for (int y : ListSequence.fromList(positionsY)) {
      graphics.drawLine(firstX, y, lastX, y);
    }

    assert ListSequence.fromList(positionsY).count() > 1;
    int firstY = ListSequence.fromList(positionsY).first();
    int lastY = ListSequence.fromList(positionsY).last();
    for (int x : ListSequence.fromList(positionsX)) {
      graphics.drawLine(x, firstY, x, lastY);
    }
  }

  private EditorCell_Collection createRowCell(final int row) {
    EditorCell_Collection rowCell = EditorCell_Collection.create(getEditorContext(), getSNode(), new CellLayout_Horizontal(), null);
    rowCell.getStyle().set(StyleAttributes.TABLE_COMPONENT, TableComponent.HORIZONTAL_COLLECTION);
    rowCell.setAction(CellActionType.DELETE, new EditorCellAction() {
      public void execute(EditorContext p0) {
        myModel.deleteRow(row);
      }
    });
    return rowCell;
  }

  private EditorCell createRowOutermostCell(final int rowNumber, String cellId, boolean beggining) {
    EditorCell emptyCell = new EditorCell_Empty(getEditorContext(), getSNode());
    if (beggining) {
      emptyCell.getStyle().set(StyleAttributes.LAST_POSITION_ALLOWED, false);
    } else {
      emptyCell.setAction(CellActionType.INSERT, new EditorCellAction() {
        public void execute(EditorContext editorContext) {
          myModel.insertRow(rowNumber + 1);
        }
      });
    }
    emptyCell.setAction(CellActionType.INSERT_BEFORE, new EditorCellAction() {
      public void execute(EditorContext editorContext) {
        myModel.insertRow(rowNumber);
      }
    });
    emptyCell.setCellId(cellId + ((beggining ?
      "_firstCell" :
      "_lastCell"
    )));
    return emptyCell;
  }

  public static EditorCell_Collection createTable(EditorContext editorContext, SNode node, final TableModel model, String uniquePrefix) {
    return new EditorCell_Table(editorContext, node, new CellLayout_Table(), model, uniquePrefix);
  }
}
