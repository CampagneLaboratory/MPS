package jetbrains.mps.lang.editor.generator.baseLanguage.template.util;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.nodeEditor.cellProviders.CellProviderNameUtil;
import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator;
import jetbrains.mps.internal.collections.runtime.ISequence;
import jetbrains.mps.internal.collections.runtime.ISequenceIterableAdapter;
import java.util.Iterator;
import jetbrains.mps.closures.runtime.YieldingIterator;
import jetbrains.mps.internal.collections.runtime.StopIteratingException;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SPropertyOperations;

public class QueriesUtil {
  public static Object CELL_READABLE_ID = new Object();

  public static String getProviderClassNameForCellWithRole(SNode node) {
    String conceptFqName = node.getConceptFqName();
    String something = NameUtil.removeStructureFromFqName(conceptFqName);
    return CellProviderNameUtil.getProviderClassName(something);
  }

  public static SNode getGeneratedClassByContainingRoot(SNode inputNode, TemplateQueryContext genctx) {
    SNode containingRoot = SNodeOperations.getContainingRoot(inputNode);
    return genctx.getOutputNodeByInputNodeAndMappingLabel(containingRoot, "generatedClass");
  }

  public static SNode getGeneratedClassByCellContainer(SNode inputCellModel, TemplateQueryContext genctx) {
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(inputCellModel), "jetbrains.mps.lang.editor.structure.CellModel_RefNodeList")) {
      if (SNodeOperations.hasRole(inputCellModel, "jetbrains.mps.lang.editor.structure.CellModel_RefNodeList", "emptyCellModel")) {
        return genctx.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getParent(inputCellModel), "nodeListHandler");
      }
    }
    // otherwise get 'generatedClass' by enclosing 'editor component'
    SNode ancestor = SNodeOperations.getAncestor(inputCellModel, "jetbrains.mps.lang.editor.structure.BaseEditorComponent", false, false);
    return genctx.getOutputNodeByInputNodeAndMappingLabel(ancestor, "generatedClass");
  }

  public static SNode getGeneratedClassByAncestor(SNode inputNode, final TemplateQueryContext genctx) {
    List<SNode> ancestors = SNodeOperations.getAncestors(inputNode, null, false);
    Iterable<SNode> outputClasses = ListSequence.fromList(ancestors).translate(new ITranslator <SNode, SNode>() {

      public ISequence<SNode> translate(final SNode it) {
        return new ISequenceIterableAdapter <SNode>() {

          public Iterator<SNode> iterator() {
            return new YieldingIterator <SNode>() {

              private int __CP__ = 0;
              private SNode _3_output;

              protected boolean moveToNext() {
__loop__:
                do {
__switch__:
                  switch (this.__CP__) {
                    case -1:
                      assert false : "Internal error";
                      return false;
                    case 4:
                      if (this._3_output != null) {
                        this.__CP__ = 5;
                        break;
                      }
                      this.__CP__ = 1;
                      break;
                    case 6:
                      this.__CP__ = 7;
                      this.yield(this._3_output);
                      return true;
                    case 0:
                      this._3_output = genctx.getOutputNodeByInputNodeAndMappingLabel(it, "generatedClass");
                      this.__CP__ = 4;
                      break;
                    case 5:
                      this.__CP__ = 6;
                      break;
                    case 7:
                      throw new StopIteratingException();
                    default:
                      break __loop__;
                  }
                } while(true);
                return false;
              }

            };
          }

        };
      }

    });
    return Sequence.fromIterable(outputClasses).first();
  }

  public static String keyMapActionClassName(SNode keyMapItem) {
    SNode keyMapDeclaration = SNodeOperations.getParent(keyMapItem);
    int index = 0;
    for(SNode curItem : SLinkOperations.getTargets(keyMapDeclaration, "item", true)) {
      if (curItem == keyMapItem) {
        break;
      }
      index = index + 1;
    }
    return SPropertyOperations.getString(keyMapDeclaration, "name") + "_Action" + index;
  }

}
