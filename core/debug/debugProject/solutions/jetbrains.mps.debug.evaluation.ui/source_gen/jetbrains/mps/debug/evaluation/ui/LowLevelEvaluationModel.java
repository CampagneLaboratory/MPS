package jetbrains.mps.debug.evaluation.ui;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.baseLanguage.search.AbstractClassifiersScope;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.debug.runtime.DebugSession;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.AttributesRolesUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.reloading.IClassPathItem;
import java.util.Set;
import jetbrains.mps.project.StubPath;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.reloading.EachClassPathItemVisitor;
import jetbrains.mps.reloading.JarFileClassPathItem;
import jetbrains.mps.reloading.FileClassPathItem;
import jetbrains.mps.stubs.StubReloadManager;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import jetbrains.mps.util.Condition;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.traceInfo.TraceInfoManager;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.stubs.javastub.classpath.StubHelper;
import jetbrains.mps.baseLanguage.search.ReachableClassifiersScope;
import jetbrains.mps.baseLanguage.search.IClassifiersSearchScope;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.sun.jdi.InvalidStackFrameException;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;

public class LowLevelEvaluationModel extends AbstractEvaluationModel {
  private static final Logger LOG = Logger.getLogger(LowLevelEvaluationModel.class);

  private AbstractClassifiersScope myScope;
  private final Map<String, SNode> myUsedVars = MapSequence.fromMap(new HashMap<String, SNode>());

  public LowLevelEvaluationModel(Project project, @NotNull DebugSession session, @NotNull EvaluationAuxModule module) {
    super(project, session, module, new StackFrameContext(session.getUiState()));

    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        SLinkOperations.setNewChild(myEvaluator, "evaluatedStatement", "jetbrains.mps.baseLanguage.structure.BlockStatement");
        SLinkOperations.setNewChild(SLinkOperations.getTarget(myEvaluator, "evaluatedStatement", true), AttributesRolesUtil.childRoleFromAttributeRole("toEvaluateAnnotation"), "jetbrains.mps.debug.evaluation.structure.ToEvaluateAnnotation");
        SPropertyOperations.set(myEvaluator, "isRuntime", "" + (true));
      }
    });
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        IClassPathItem classPath = myEvaluationContext.getClassPathItem();
        final Set<StubPath> pathsToAdd = SetSequence.fromSet(new HashSet<StubPath>());
        classPath.accept(new EachClassPathItemVisitor() {
          @Override
          public void visit(JarFileClassPathItem item) {
            String path = item.getFile().getAbsolutePath();
            StubPath stubPath = myAuxModule.addStubPath(path);
            if (stubPath != null) {
              SetSequence.fromSet(pathsToAdd).addElement(stubPath);
            }
          }

          @Override
          public void visit(FileClassPathItem item) {
            String path = item.getClassPath();
            StubPath stubPath = myAuxModule.addStubPath(path);
            if (stubPath != null) {
              SetSequence.fromSet(pathsToAdd).addElement(stubPath);
            }
          }
        });
        StubReloadManager.getInstance().loadImmediately(myAuxModule, pathsToAdd);
      }
    });
  }

  @Nullable
  private SNode createClassifierType(final String unitFqName) {
    int lastDot = unitFqName.lastIndexOf(".");
    if (lastDot > 0) {
      String unitPackage = unitFqName.substring(0, lastDot);
      importStubForFqName(unitPackage);
    }
    final String normalizedUnitFqName = unitFqName.replace('$', '.');
    List<SNode> classifiers = myScope.getNodes(new Condition<SNode>() {
      public boolean met(@NotNull SNode node) {
        if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
          return false;
        }

        String nodesUnitName = TraceInfoManager.getInstance().getUnitName(node);
        if (StringUtils.isEmpty(nodesUnitName)) {
          return false;
        }
        return nodesUnitName.equals(normalizedUnitFqName);
      }
    });
    if (classifiers.isEmpty()) {
      return null;
    }
    SNode classifierType = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierType", null);
    SLinkOperations.setTarget(classifierType, "classifier", SNodeOperations.cast(classifiers.get(0), "jetbrains.mps.baseLanguage.structure.Classifier"), false);
    return classifierType;
  }

  @NotNull
  public SNode getNodeToShow() {
    return myEvaluator;
  }

  @NotNull
  public SNode getRootToShow() {
    return myEvaluator;
  }

  @Override
  public void updateState() {
    super.updateState();
    createVars();
  }

  @Override
  public void setModel(EditableSModelDescriptor model) {
    super.setModel(model);

    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        LowLevelEvaluationModel.this.importStubForFqName(getLocationModel().getSModelFqName().toString());
      }
    });
    createVars();
  }

  private void importStubForFqName(String fqName) {
    SModelReference stubReference = StubHelper.uidForPackageInStubs(fqName);
    if (stubReference == null) {
      LowLevelEvaluationModel.LOG.error("Stub for " + fqName + " was not found.");
      return;
    }
    myAuxModel.getSModel().addModelImport(stubReference, false);
  }

  private void createVars() {
    if (myScope == null) {
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          // creating scope 
          myScope = new ReachableClassifiersScope(myAuxModel.getSModel(), IClassifiersSearchScope.CLASSIFFIER, getModule().getScope());
        }
      });
    }

    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        fillVariables();
      }
    });
  }

  private void fillVariables() {
    SNode evaluatorConcept = myEvaluator;
    try {
      _FunctionTypes._return_P1_E0<? extends SNode, ? super String> createClassifierType = new _FunctionTypes._return_P1_E0<SNode, String>() {
        public SNode invoke(String name) {
          return createClassifierType(name);
        }
      };
      Map<String, SNode> contextVariables = myEvaluationContext.getVariables(createClassifierType);
      final Set<SNode> foundVars = SetSequence.fromSet(new HashSet<SNode>());
      for (String variable : SetSequence.fromSet(MapSequence.fromMap(contextVariables).keySet())) {
        String name = variable;
        SNode lowLevelVarNode;
        if (!(MapSequence.fromMap(myUsedVars).containsKey(name))) {
          lowLevelVarNode = SConceptOperations.createNewNode("jetbrains.mps.debug.evaluation.structure.LowLevelVariable", null);
          SPropertyOperations.set(lowLevelVarNode, "name", name);
          ListSequence.fromList(SLinkOperations.getTargets(evaluatorConcept, "variables", true)).addElement(lowLevelVarNode);
          MapSequence.fromMap(myUsedVars).put(name, lowLevelVarNode);
        } else {
          lowLevelVarNode = MapSequence.fromMap(myUsedVars).get(name);
        }
        SNode deducedType = MapSequence.fromMap(contextVariables).get(name);
        if (deducedType == null) {
          LowLevelEvaluationModel.LOG.error("Could not deduce type for variable " + name);
          continue;
        }
        SLinkOperations.setTarget(lowLevelVarNode, "type", deducedType, true);
        SetSequence.fromSet(foundVars).addElement(lowLevelVarNode);
      }

      // now mark vars which are currently out of scope 
      Sequence.fromIterable(MapSequence.fromMap(myUsedVars).values()).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          SPropertyOperations.set(it, "isOutOfScope", "" + (!(SetSequence.fromSet(foundVars).contains(it))));
        }
      });

      // create static context type 
      SLinkOperations.setTarget(evaluatorConcept, "staticContextType", myEvaluationContext.getStaticContextType(createClassifierType), true);
      // create this 
      SLinkOperations.setTarget(evaluatorConcept, "thisType", myEvaluationContext.getThisClassifierType(createClassifierType), true);
    } catch (InvalidStackFrameException e) {
      LowLevelEvaluationModel.LOG.warning("InvalidStackFrameException", e);
    }
  }

  public LowLevelEvaluationModel copy() {
    final Wrappers._T<LowLevelEvaluationModel> model = new Wrappers._T<LowLevelEvaluationModel>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        model.value = new LowLevelEvaluationModel(myDebugSession.getProject(), myDebugSession, myAuxModule);
        copyInto(model.value);
      }
    });
    return model.value;
  }
}
