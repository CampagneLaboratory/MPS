package jetbrains.mps.make.runtime.internal.util;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ISelector;

public abstract class CycleDetector<V> {
  private Map<V, CycleDetector.Data> dataMap = MapSequence.fromMap(new HashMap<V, CycleDetector.Data>());

  public CycleDetector() {
  }

  public abstract Iterable<V> forwardEdges(V v);

  public abstract Iterable<V> backwardEdges(V v);

  public List<List<V>> findCycles(Iterable<V> vertices) {
    this.init(vertices);
    this.calcTimes(vertices);
    return this.collectCycles(vertices);
  }

  private void init(Iterable<V> vertices) {
    MapSequence.fromMap(dataMap).clear();
    Sequence.fromIterable(vertices).visitAll(new IVisitor<V>() {
      public void visit(V v) {
        MapSequence.fromMap(dataMap).put(v, new CycleDetector.Data());
      }
    });
  }

  private void calcTimes(Iterable<V> vertices) {
    final Wrappers._int time = new Wrappers._int(0);
    Sequence.fromIterable(vertices).visitAll(new IVisitor<V>() {
      public void visit(V v) {
        if (CycleDetector.Color.WHITE == MapSequence.fromMap(dataMap).get(v).color) {
          time.value = visitForward(v, time.value);
        }
      }
    });
  }

  private int visitForward(V v, int time) {
    final Wrappers._int _time = new Wrappers._int(time);
    CycleDetector.Data data = MapSequence.fromMap(dataMap).get(v);
    data.color = CycleDetector.Color.GRAY;
    data.startTime = ++_time.value;
    Sequence.fromIterable(forwardEdges(v)).visitAll(new IVisitor<V>() {
      public void visit(V next) {
        if (CycleDetector.Color.WHITE == MapSequence.fromMap(dataMap).get(next).color) {
          _time.value = visitForward(next, _time.value);
        }
      }
    });
    data.color = CycleDetector.Color.BLACK;
    data.endTime = ++_time.value;
    return _time.value;
  }

  private List<List<V>> collectCycles(Iterable<V> vertices) {
    final List<List<V>> cycles = ListSequence.fromList(new ArrayList<List<V>>());
    Sequence.fromIterable(vertices).sort(new ISelector<V, Comparable<?>>() {
      public Comparable<?> select(V v) {
        return MapSequence.fromMap(dataMap).get(v).endTime;
      }
    }, false).visitAll(new IVisitor<V>() {
      public void visit(V v) {
        if (CycleDetector.Color.BLACK == MapSequence.fromMap(dataMap).get(v).color) {
          visitBackward(v);
          if (ListSequence.fromList(MapSequence.fromMap(dataMap).get(v).successors).isNotEmpty()) {
            List<V> cycle = ListSequence.fromListAndArray(new ArrayList<V>(), v);
            collectSuccessors(v, cycle);
            ListSequence.fromList(cycles).addElement(cycle);
          }
        }
      }
    });
    return cycles;
  }

  private void collectSuccessors(V v, final List<V> list) {
    ListSequence.fromList(MapSequence.fromMap(dataMap).get(v).successors).visitAll(new IVisitor<V>() {
      public void visit(V succ) {
        ListSequence.fromList(list).addElement(succ);
        collectSuccessors(succ, list);
      }
    });

  }

  private void visitBackward(final V v) {
    CycleDetector.Data data = MapSequence.fromMap(dataMap).get(v);
    data.color = CycleDetector.Color.GRAY;
    Sequence.fromIterable(backwardEdges(v)).sort(new ISelector<V, Comparable<?>>() {
      public Comparable<?> select(V prev) {
        return MapSequence.fromMap(dataMap).get(prev).endTime;
      }
    }, false).visitAll(new IVisitor<V>() {
      public void visit(V prev) {
        if (CycleDetector.Color.BLACK == MapSequence.fromMap(dataMap).get(prev).color) {
          ListSequence.fromList(MapSequence.fromMap(dataMap).get(v).successors).addElement(prev);
          visitBackward(prev);
        }
      }
    });
    data.color = CycleDetector.Color.WHITE;
  }

  private static   enum Color {
    WHITE(),
    GRAY(),
    BLACK();

    Color() {
    }
  }

  private class Data {
    private CycleDetector.Color color = CycleDetector.Color.WHITE;
    private int startTime = 0;
    private int endTime = 0;
    private List<V> successors = ListSequence.fromList(new ArrayList<V>());

    private Data() {
    }
  }
}
