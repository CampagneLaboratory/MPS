package jetbrains.mps.make.runtime.internal.util;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ISequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.List;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public abstract class CycleDetector<V> {
  private Map<V, CycleDetector.Wrapper<V>> wrapMap = MapSequence.fromMap(new HashMap<V, CycleDetector.Wrapper<V>>());
  private _FunctionTypes._return_P1_E0<? extends Iterable<CycleDetector.Wrapper<V>>, ? super CycleDetector.Wrapper<V>> forward = new _FunctionTypes._return_P1_E0<ISequence<CycleDetector.Wrapper<V>>, CycleDetector.Wrapper<V>>() {
    public ISequence<CycleDetector.Wrapper<V>> invoke(CycleDetector.Wrapper<V> d) {
      return Sequence.fromIterable(forwardEdges(d.vertex)).select(new ISelector<V, CycleDetector.Wrapper<V>>() {
        public CycleDetector.Wrapper<V> select(V v) {
          return MapSequence.fromMap(wrapMap).get(v);
        }
      });
    }
  };
  private _FunctionTypes._return_P1_E0<? extends Iterable<CycleDetector.Wrapper<V>>, ? super CycleDetector.Wrapper<V>> backward = new _FunctionTypes._return_P1_E0<ISequence<CycleDetector.Wrapper<V>>, CycleDetector.Wrapper<V>>() {
    public ISequence<CycleDetector.Wrapper<V>> invoke(CycleDetector.Wrapper<V> d) {
      return Sequence.fromIterable(backwardEdges(d.vertex)).select(new ISelector<V, CycleDetector.Wrapper<V>>() {
        public CycleDetector.Wrapper<V> select(V v) {
          return MapSequence.fromMap(wrapMap).get(v);
        }
      });
    }
  };

  public CycleDetector() {
  }

  public abstract Iterable<V> forwardEdges(V v);

  public abstract Iterable<V> backwardEdges(V v);

  public List<List<V>> findCycles(Iterable<V> vertices) {
    Iterable<CycleDetector.Wrapper<V>> datas = this.init(vertices);
    this.calcTimes(datas);
    return this.collectCycles(datas);
  }

  private Iterable<CycleDetector.Wrapper<V>> init(Iterable<V> vertices) {
    return Sequence.fromIterable(vertices).select(new ISelector<V, CycleDetector.Wrapper<V>>() {
      public CycleDetector.Wrapper<V> select(V v) {
        CycleDetector.Wrapper<V> data = new CycleDetector.Wrapper<V>(v);
        MapSequence.fromMap(wrapMap).put(v, data);
        return data;
      }
    }).toListSequence();
  }

  private void calcTimes(Iterable<CycleDetector.Wrapper<V>> ws) {
    final Wrappers._int time = new Wrappers._int(0);
    dfs(ws, new _FunctionTypes._void_P2_E0<CycleDetector.Wrapper<V>, _FunctionTypes._void_P0_E0>() {
      public void invoke(CycleDetector.Wrapper<V> w, _FunctionTypes._void_P0_E0 cont) {
        time.value = w.setStartTime(++time.value);
        cont.invoke();
        time.value = w.setEndTime(++time.value);
      }
    }, forward);
  }

  private List<List<V>> collectCycles(Iterable<CycleDetector.Wrapper<V>> ws) {
    final List<List<V>> cycles = ListSequence.fromList(new ArrayList<List<V>>());
    Sequence.fromIterable(ws).visitAll(new IVisitor<CycleDetector.Wrapper<V>>() {
      public void visit(CycleDetector.Wrapper<V> w) {
        w.clear();
      }
    });
    Sequence.fromIterable(ws).sort(new ISelector<CycleDetector.Wrapper<V>, Comparable<?>>() {
      public Comparable<?> select(CycleDetector.Wrapper<V> w) {
        return w.endTime;
      }
    }, false).where(new IWhereFilter<CycleDetector.Wrapper<V>>() {
      public boolean accept(CycleDetector.Wrapper<V> w) {
        return !(w.entered);
      }
    }).visitAll(new IVisitor<CycleDetector.Wrapper<V>>() {
      public void visit(final CycleDetector.Wrapper<V> w) {
        dfsVisit(w, new _FunctionTypes._void_P2_E0<CycleDetector.Wrapper<V>, _FunctionTypes._void_P0_E0>() {
          public void invoke(CycleDetector.Wrapper<V> ww, _FunctionTypes._void_P0_E0 cont) {
            cont.invoke();
            w.successor(ww);
          }
        }, backward);
        if (ListSequence.fromList(w.successors).isNotEmpty()) {
          ListSequence.fromList(cycles).addElement(collectSuccessors(w, ListSequence.fromListAndArray(new ArrayList<V>(), w.vertex)));
        }
      }
    });
    return cycles;
  }

  private List<V> collectSuccessors(CycleDetector.Wrapper<V> w, final List<V> list) {
    ListSequence.fromList(w.successors).visitAll(new IVisitor<CycleDetector.Wrapper<V>>() {
      public void visit(CycleDetector.Wrapper<V> ww) {
        ListSequence.fromList(list).addElement(ww.vertex);
        collectSuccessors(ww, list);
      }
    });
    return list;
  }

  public void dfs(Iterable<CycleDetector.Wrapper<V>> ws, final _FunctionTypes._void_P2_E0<? super CycleDetector.Wrapper<V>, ? super _FunctionTypes._void_P0_E0> visitor, final _FunctionTypes._return_P1_E0<? extends Iterable<CycleDetector.Wrapper<V>>, ? super CycleDetector.Wrapper<V>> edges) {
    Sequence.fromIterable(ws).visitAll(new IVisitor<CycleDetector.Wrapper<V>>() {
      public void visit(CycleDetector.Wrapper<V> w) {
        w.clear();
      }
    });
    Sequence.fromIterable(ws).where(new IWhereFilter<CycleDetector.Wrapper<V>>() {
      public boolean accept(CycleDetector.Wrapper<V> w) {
        return !(w.entered);
      }
    }).visitAll(new IVisitor<CycleDetector.Wrapper<V>>() {
      public void visit(CycleDetector.Wrapper<V> w) {
        dfsVisit(w, visitor, edges);
      }
    });
  }

  public void dfsVisit(final CycleDetector.Wrapper<V> w, final _FunctionTypes._void_P2_E0<? super CycleDetector.Wrapper<V>, ? super _FunctionTypes._void_P0_E0> visitor, final _FunctionTypes._return_P1_E0<? extends Iterable<CycleDetector.Wrapper<V>>, ? super CycleDetector.Wrapper<V>> edges) {
    w.enter();
    visitor.invoke(w, new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        Sequence.fromIterable(edges.invoke(w)).where(new IWhereFilter<CycleDetector.Wrapper<V>>() {
          public boolean accept(CycleDetector.Wrapper<V> ww) {
            return !(ww.entered);
          }
        }).visitAll(new IVisitor<CycleDetector.Wrapper<V>>() {
          public void visit(CycleDetector.Wrapper<V> ww) {
            dfsVisit(ww, visitor, edges);
          }
        });
      }
    });
    w.exit();
  }

  private static class Wrapper<V> {
    private V vertex;
    private int startTime = 0;
    private int endTime = 0;
    private boolean entered = false;
    private boolean exited = false;
    private List<CycleDetector.Wrapper<V>> successors = ListSequence.fromList(new ArrayList<CycleDetector.Wrapper<V>>());

    private Wrapper(V v) {
      this.vertex = v;
    }

    private int setStartTime(int t) {
      return (this.startTime = t);
    }

    private int setEndTime(int t) {
      return (this.endTime = t);
    }

    private void successor(CycleDetector.Wrapper<V> succ) {
      if (this != succ) {
        ListSequence.fromList(this.successors).addElement(succ);
      }
    }

    private void enter() {
      this.entered = true;
    }

    private void exit() {
      this.exited = true;
    }

    private void clear() {
      this.entered = false;
      this.exited = false;
    }
  }
}
