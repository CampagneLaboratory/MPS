package jetbrains.mps.persistence.java.library;

/*Generated by MPS */

import jetbrains.mps.extapi.persistence.FileBasedModelRoot;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SModelId;
import org.jetbrains.mps.openapi.persistence.Memento;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.LanguageID;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.stubs.javastub.classpath.StubHelper;
import jetbrains.mps.extapi.persistence.FolderSetDataSource;
import org.jetbrains.annotations.Nullable;

public class JavaClassStubsModelRoot extends FileBasedModelRoot {
  public JavaClassStubsModelRoot() {
    super();
  }
  @Override
  public String getType() {
    return JavaClassStubConstants.STUB_TYPE;
  }
  @Override
  public SModel getModel(SModelId id) {
    // todo implement 
    return null;
  }
  @Override
  public void load(Memento memento) {
    super.load(memento);
    if (memento.get("path") == null) {
      return;
    }
    String path = FileUtil.stripLastSlashes(memento.get("path"));
    IFile file = FileSystem.getInstance().getFileByPath(path);
    if (file != null && file.getParent() != null) {
      path = file.getParent().getPath();
    }
    setContentRoot(path);
    List<String> files = filesForKind.get(SOURCE_ROOTS);
    files.add(memento.get("path"));
  }
  @Override
  public Iterable<SModel> loadModels() {
    final List<SModel> result = ListSequence.fromList(new ArrayList<SModel>());
    final Collection<String> files = getFiles(FileBasedModelRoot.SOURCE_ROOTS);
    final Collection<String> excludedFiles = getFiles(FileBasedModelRoot.EXCLUDED);

    Set<IFile> jarsToLoad = new HashSet<IFile>();
    Set<IFile> cpRootsToLoad = new HashSet<IFile>();

    for (IFile file : CollectionSequence.fromCollection(files).select(new ISelector<String, IFile>() {
      public IFile select(String it) {
        return FileSystem.getInstance().getFileByPath(it);
      }
    })) {
      collectJarFiles(file, excludedFiles, jarsToLoad);

      // we suppose here that each path can be either a jar-file or a classes directory or a jar directory, 
      // but does not contain both jar-fils and class-files 
      if (SetSequence.fromSet(jarsToLoad).isNotEmpty()) {
        continue;
      }

      SetSequence.fromSet(cpRootsToLoad).addElement(file);
    }

    SetSequence.fromSet(jarsToLoad).select(new ISelector<IFile, IFile>() {
      public IFile select(IFile it) {
        return FileSystem.getInstance().getFileByPath(it.getPath() + "!/");
      }
    }).visitAll(new IVisitor<IFile>() {
      public void visit(IFile it) {
        getModelDescriptors(result, it, "", LanguageID.JAVA, getModule());
      }
    });
    SetSequence.fromSet(cpRootsToLoad).visitAll(new IVisitor<IFile>() {
      public void visit(IFile it) {
        getModelDescriptors(result, it, "", LanguageID.JAVA, getModule());
      }
    });

    return result;
  }
  private void collectJarFiles(final IFile file, Collection<String> excluded, Set<IFile> files) {
    if (CollectionSequence.fromCollection(excluded).contains(file.getPath())) {
      return;
    }
    if (file.getPath().endsWith(".jar") || file.getPath().endsWith(".zip")) {
      SetSequence.fromSet(files).addElement(file);
      return;
    }
    if (!(file.isDirectory())) {
      return;
    }
    for (IFile child : file.getChildren()) {
      collectJarFiles(child, excluded, files);
    }
  }
  @Override
  public boolean canCreateModels() {
    return false;
  }
  @Override
  public boolean canCreateModel(String string) {
    return false;
  }
  @Override
  public SModel createModel(String string) {
    return null;
  }
  public void getModelDescriptors(final List<SModel> result, IFile file, String prefix, String languageId, SModule module) {
    List<IFile> children = file.getChildren();
    for (IFile subdir : ListSequence.fromList(children).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile it) {
        return it.isDirectory();
      }
    })) {
      List<IFile> subchildren = subdir.getChildren();
      Iterable<IFile> rootClasses = ListSequence.fromList(subchildren).where(new IWhereFilter<IFile>() {
        public boolean accept(IFile it) {
          return it.getName().endsWith(".class") && !(it.getName().contains("$"));
        }
      });

      String pack = prefix + ((eq_jzcn2m_a0a0a0a3a1a9(prefix, "") ? "" : ".")) + subdir.getName();

      if (Sequence.fromIterable(rootClasses).isNotEmpty() && neq_jzcn2m_a0a5a1a9(pack, "")) {
        final SModelReference modelReference = StubHelper.uidForPackageInStubs(pack, languageId, module.getModuleReference());
        JavaClassStubModelDescriptor smd;
        // FIXME: hack, see comment below 
        SModel modelDescriptor = getModelAlreadyRegistered(module, modelReference);
        if (modelDescriptor != null) {
          assert modelDescriptor instanceof JavaClassStubModelDescriptor;
          smd = (JavaClassStubModelDescriptor) modelDescriptor;
          ListSequence.fromList(result).addElement(modelDescriptor);
        } else if (ListSequence.fromList(result).any(new IWhereFilter<SModel>() {
          public boolean accept(SModel it) {
            return it.getReference().equals(modelReference);
          }
        })) {
          modelDescriptor = ListSequence.fromList(result).findFirst(new IWhereFilter<SModel>() {
            public boolean accept(SModel it) {
              return it.getReference().equals(modelReference);
            }
          });
          assert modelDescriptor instanceof JavaClassStubModelDescriptor;
          smd = (JavaClassStubModelDescriptor) modelDescriptor;
        } else {
          smd = new JavaClassStubModelDescriptor(modelReference, new FolderSetDataSource(), this);
          smd.setModelRoot(this);
          ListSequence.fromList(result).addElement(smd);
        }
        smd.getSource().addPath(subdir.getPath(), this);
      }
      getModelDescriptors(result, subdir, pack, languageId, module);
    }
  }

  /**
   * DIRTY_HACK
   * AlexP:
   * Here we check whether some another classes root is already registered
   * Because of the model's name clash we cannot simply return new model with new root.
   * FIXME:
   * Probably the solution is to get rid of multiple *java_classes* stub roots and
   * Allow user to have only one stub root of this kind
   */
  @Nullable
  private SModel getModelAlreadyRegistered(SModule module, SModelReference modelReference) {
    return module.getModel(modelReference.getModelId());
  }
  private static boolean eq_jzcn2m_a0a0a0a3a1a9(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
  private static boolean neq_jzcn2m_a0a5a1a9(Object a, Object b) {
    return !(((a != null ? a.equals(b) : a == b)));
  }
}
