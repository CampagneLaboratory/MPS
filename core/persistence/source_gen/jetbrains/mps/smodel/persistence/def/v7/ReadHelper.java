package jetbrains.mps.smodel.persistence.def.v7;

/*Generated by MPS */

import jetbrains.mps.smodel.SModelReference;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.logging.Logger;

public class ReadHelper {
  private SModelReference myModelRef;
  private Map<String, SModelReference> myModelByIx;
  private int myMaxImportIndex = 0;

  public ReadHelper(SModelReference modelRef) {
    myModelByIx = MapSequence.fromMap(new HashMap<String, SModelReference>());
    myModelRef = modelRef;
  }

  public void addModelRef(String index, SModelReference modelRef) {
    MapSequence.fromMap(myModelByIx).put(index, modelRef);
  }

  public void addImportToModel(SModel model, String index, String modelUID, int version, boolean implicit) {
    if (modelUID == null) {
      LOG.error("Error loading import element for index " + index + " in " + myModelRef);
      return;
    }
    SModelReference modelRef = SModelReference.fromString(modelUID);
    SModel.ImportElement elem = new SModel.ImportElement(modelRef, ++myMaxImportIndex, version);
    if (implicit) {
      model.addAdditionalModelVersion(elem);
    } else {
      model.addModelImport(elem);
    }
    addModelRef(index, modelRef);
  }

  public org.jetbrains.mps.openapi.model.SModelReference getSModelReference(@NotNull String ix) {
    return ((ix == null || ix.length() == 0) ?
      myModelRef :
      MapSequence.fromMap(myModelByIx).get(ix)
    );
  }

  @NotNull
  public Pair<Boolean, SNodeReference> readLink_internal(String src) {
    // returns <true, xxx> - if src is Dynamic Reference 
    // [modelID.]nodeID[:version] | [modelID.]^[:version] 
    Pair<Boolean, SNodeReference> result = new Pair<Boolean, SNodeReference>(false, null);
    if (src == null) {
      return result;
    }
    int i0 = src.indexOf(WriteHelper.MODEL_SEPARATOR_CHAR);
    int i1 = src.lastIndexOf(WriteHelper.VERSION_SEPARATOR_CHAR);
    String text = WriteHelper.decode(src.substring(i0 + 1, (i1 < 0 ?
      src.length() :
      i1
    )));
    result.o1 = WriteHelper.DYNAMIC_REFERENCE_ID.equals(text);
    org.jetbrains.mps.openapi.model.SModelReference modelRef = getSModelReference((i0 < 0 ?
      "" :
      src.substring(0, i0)
    ));
    SNodeId nodeId = (result.o1 ?
      null :
      jetbrains.mps.smodel.SNodeId.fromString(text)
    );
    result.o2 = new SNodePointer(modelRef, nodeId);
    return result;
  }

  public SNodeReference readLinkId(String src) {
    // [modelID.]nodeID[:version] | [modelID.]^[:version] 
    return readLink_internal(src).o2;
  }

  public String readType(String s) {
    int ix = s.indexOf(WriteHelper.MODEL_SEPARATOR_CHAR);
    if (ix <= 0) {
      // no model ID - fqName is here 
      LOG.error("Broken reference to type=" + s + " in model " + myModelRef);
      return s.substring(ix + 1);
    }
    org.jetbrains.mps.openapi.model.SModelReference modelRef = getSModelReference(s.substring(0, ix));
    if (modelRef == null) {
      LOG.error("couldn't create node '" + s.substring(ix + 1) + "' : import for index [" + s.substring(0, ix) + "] not found");
      return s.substring(ix + 1);
    } else {
      return SModelStereotype.withoutStereotype(modelRef.getModelName()) + "." + s.substring(ix + 1);
    }
  }

  public String readRole(String s) {
    return s;
  }

  public String readName(String s) {
    return s;
  }

  private static Logger LOG = Logger.getLogger(ReadHelper.class);
}
