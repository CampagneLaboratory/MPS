package jetbrains.mps.lang.migration.runtime.base;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.util.Pair;
import java.util.Collections;
import jetbrains.mps.util.containers.EmptyIterable;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.util.Computable;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.List;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Map;

public abstract class MigrationScriptBase implements MigrationScript {
  private DataCollector myDC = new MigrationScriptBase.EmptyDataCollector();

  public String getCaption() {
    return "";
  }

  public void setDataCollector(DataCollector dataCollector) {
    myDC = dataCollector;
  }

  protected DataCollector getDataCollector() {
    return myDC;
  }

  @Nullable
  public SNode execute(SModule module) {
    // todo remove implementation after 3.2.  
    return null;
  }

  public SNode execute(SModule module, DataCollector c) {
    // todo remove after 3.2 
    setDataCollector(c);
    return execute(module);
  }

  public Iterable<Pair<SNode, String>> check(SModule module) {
    return Collections.emptyList();
  }

  public Iterable<MigrationScriptReference> requiresData() {
    return new EmptyIterable<MigrationScriptReference>();
  }

  public Iterable<MigrationScriptReference> executeAfter() {
    return new EmptyIterable<MigrationScriptReference>();
  }

  @Override
  public String toString() {
    return getCaption();
  }

  protected void adjustMigratedIds(SNode node, SNode migrated) {
    if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, false)).contains(migrated))) {
      ((jetbrains.mps.smodel.SNode) migrated).setId(node.getNodeId());
    }
  }

  private static interface SNodePlacePointer {
    public boolean isNodeInPlace();
    public void insertOrReplace(SNode newNode);
    public void remove();
    /*package*/ static class ChildPointer implements MigrationScriptBase.SNodePlacePointer {
      private SNode node;
      private SNode parent;
      private SContainmentLink link;
      private SNode nextSibling;
      /*package*/ ChildPointer(SNode node) {
        this.node = node;
        parent = node.getParent();
        link = node.getContainmentLink();
        nextSibling = node.getNextSibling();
      }
      public boolean isNodeInPlace() {
        return node.getParent() == parent;
      }
      public void insertOrReplace(SNode newNode) {
        if (isNodeInPlace()) {
          SNodeUtil.replaceWithAnother(node, newNode);
        } else {
          parent.insertChildBefore(link, newNode, nextSibling);
        }
      }
      public void remove() {
        if (!(isNodeInPlace())) {
          parent.removeChild(node);
        }
      }
    }
    /*package*/ static class RootPointer implements MigrationScriptBase.SNodePlacePointer {
      private SNode node;
      private SModel model;
      /*package*/ RootPointer(SNode node) {
        this.node = node;
        model = node.getModel();
      }
      public boolean isNodeInPlace() {
        return node.getParent() == null && node.getModel() == model;
      }
      public void insertOrReplace(SNode newNode) {
        if (isNodeInPlace()) {
          SNodeUtil.replaceWithAnother(node, newNode);
        } else {
          model.addRootNode(newNode);
        }
      }
      public void remove() {
        if (!(isNodeInPlace())) {
          model.removeRootNode(node);
        }
      }
    }
  }
  private static MigrationScriptBase.SNodePlacePointer createSNodePlacePointer(SNode node) {
    if (node.getParent() != null) {
      return new MigrationScriptBase.SNodePlacePointer.ChildPointer(node);
    } else {
      return new MigrationScriptBase.SNodePlacePointer.RootPointer(node);
    }
  }

  protected void applyTransormMigration(SNode origin, Computable<SNode> migration, _FunctionTypes._void_P2_E0<? super SNode, ? super SNode> postprocess) {
    MigrationScriptBase.SNodePlacePointer pointer = createSNodePlacePointer(origin);
    List<SNode> descendants = SNodeOperations.getNodeDescendants(origin, null, true, new SAbstractConcept[]{});

    SNode migrated = migration.compute();

    if (postprocess != null) {
      postprocess.invoke(origin, migrated);
    }

    if (migrated == null) {
      // origin should be removed 
      pointer.remove();
    } else {
      if (!(ListSequence.fromList(descendants).contains(migrated)) && migrated instanceof jetbrains.mps.smodel.SNode) {
        // returned value is new created node 
        if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(origin, null, false)).contains(migrated))) {
          // origin is not keeped 
          ((jetbrains.mps.smodel.SNode) migrated).setId(origin.getNodeId());
        }
      }
      pointer.insertOrReplace(migrated);
    }
  }

  private class EmptyDataCollector implements DataCollector {
    public EmptyDataCollector() {
    }
    public Map<SModule, SNode> collectData(SModule myModule, MigrationScriptReference scriptReference) {
      return Collections.<SModule,SNode>emptyMap();
    }
  }
}
