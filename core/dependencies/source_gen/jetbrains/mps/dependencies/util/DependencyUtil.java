package jetbrains.mps.dependencies.util;

/*Generated by MPS */

import jetbrains.mps.library.LibraryManager;
import jetbrains.mps.library.Library;
import jetbrains.mps.library.LibraryInitializer;
import java.util.List;
import jetbrains.mps.project.IModule;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.reloading.ClasspathStringCollector;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.ModuleUtil;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;


/**
 * I wrote this code in order to analize dependency classpath of charisma-testing modules.
 */
public class DependencyUtil {
  public DependencyUtil() {
  }

  /**
   * Loads a library if not already loaded.
   * 
   * @param name library name
   * @param path path to lib
   */
  public static void setupLibrary(String name, String path) {
    LibraryManager m = LibraryManager.getInstance();
    if (!(m.getLibraries().contains(name))) {
      Library addLibrary = m.addLibrary(name);
      addLibrary.setPath(path);
      LibraryInitializer.getInstance().update();
    }
  }

  /**
   * Somitimes we wonder, why the hell this jar is in dependency classpath?
   * Here is the answer.
   * This procedure find all dependencies of rootModule that contain given path in classpath and return path in dependency graph to them.
   * 
   * @param rootModule module from which to start
   * @param path path to find
   * @param g dependency graph
   * @return list of paths in the graph to modules that contain path in classpath
   */
  public static Iterable<List<IModule>> findAllDependenciesContainigPatternInClasspath(final IModule rootModule, String path, final ModuleGraph g) {
    Set<IModule> modules = SetSequence.fromSet(new LinkedHashSet<IModule>());
    for (ModuleGraph.ModuleVertex vertex : SetSequence.fromSet(g.getData())) {
      ClasspathStringCollector collector = new ClasspathStringCollector(false);
      vertex.getModule().getClassPathItem().accept(collector);
      for (String cp : SetSequence.fromSet(collector.getClasspath())) {
        if (cp.contains(path)) {
          SetSequence.fromSet(modules).addElement(vertex.getModule());
          break;
        }
      }
    }
    return SetSequence.fromSet(modules).select(new ISelector<IModule, List<IModule>>() {
      public List<IModule> select(IModule it) {
        return g.findPath(rootModule, it);
      }
    });
  }

  /**
   * Generally, solutions do not depend on languages.
   * Sut sometimes they do and this procedure find all such cases in the specific dependency graph.
   * 
   * @param g dependency graph
   * @return solutions which depend on modules
   */
  public static List<Tuples._2<Solution, Language>> findSolutionOnLanguageDependencies(ModuleGraph g) {
    List<Tuples._2<Solution, Language>> result = ListSequence.fromList(new ArrayList<Tuples._2<Solution, Language>>());
    for (ModuleGraph.ModuleVertex vertex : SetSequence.fromSet(g.getData())) {
      if (vertex.getModule() instanceof Solution) {
        for (IModule next : Sequence.fromIterable(ModuleUtil.getDependencies(vertex.getModule()))) {
          if (next instanceof Language) {
            ListSequence.fromList(result).addElement(MultiTuple.<Solution,Language>from((Solution) vertex.getModule(), (Language) next));
          }
        }
      }
    }
    return result;
  }
}
