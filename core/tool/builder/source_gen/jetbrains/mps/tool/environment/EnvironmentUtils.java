package jetbrains.mps.tool.environment;

/*Generated by MPS */

import jetbrains.mps.InternalFlag;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import java.io.File;
import jetbrains.mps.tool.builder.util.PathManager;
import jetbrains.mps.tool.builder.FileMPSProject;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.tool.builder.util.MapPathMacrosProvider;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.tool.common.util.CanonicalPath;
import jetbrains.mps.tool.common.util.UrlClassLoader;
import java.util.List;
import java.net.URL;
import java.util.ArrayList;
import java.net.MalformedURLException;
import jetbrains.mps.library.LibraryInitializer;
import java.util.Set;
import jetbrains.mps.library.contributor.LibraryContributor;
import java.util.LinkedHashSet;
import java.util.Collections;
import jetbrains.mps.tool.builder.util.SetLibraryContributor;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class EnvironmentUtils {
  private static final String MODULES_PREFIX = "!/modules";
  private static final String PLUGINS_PATH = "plugin.path";

  private EnvironmentUtils() {
  }

  public static void setSystemProperties(boolean loadIdeaPlugins) {
    boolean internalFlag = InternalFlag.isInternalMode();
    System.setProperty("idea.is.internal", internalFlag + "");
    System.setProperty("idea.no.jre.check", "true");
    System.setProperty("idea.load.plugins", loadIdeaPlugins + "");
    System.setProperty("idea.platform.prefix", "Idea");
  }

  public static void setIdeaPluginsToLoad(EnvironmentConfig config) {
    if (isEmptyString(System.getProperty(PLUGINS_PATH))) {
      setPluginPath();
      // Value of this property is comma-separated list of plugin IDs intended to load by platform 
      if (System.getProperty("idea.load.plugins") == null || System.getProperty("idea.load.plugins").equals("false")) {
        System.setProperty("idea.load.plugins.id", IterableUtils.join(config.getPlugins(), ","));
      }
    }
  }

  public static void setPluginPath() {
    StringBuilder pluginPath = new StringBuilder();
    File pluginDir = new File(PathManager.getPreinstalledPluginsPath());
    if (pluginDir.exists()) {
      for (File pluginFolder : pluginDir.listFiles()) {
        if (pluginPath.length() > 0) {
          pluginPath.append(File.pathSeparator);
        }
        pluginPath.append(pluginFolder.getPath());
      }
      System.setProperty(PLUGINS_PATH, pluginPath.toString());
    }
  }

  public static FileMPSProject createDummyFileProject() {
    File projectFile = FileUtil.createTmpFile();
    FileMPSProject project = new FileMPSProject(projectFile);
    project.init(new FileMPSProject.ProjectDescriptor(null));
    projectFile.deleteOnExit();
    return project;
  }

  public static MapPathMacrosProvider createMapMacrosProvider(Map<String, String> macros) {
    Map<String, String> realMacros = new HashMap<String, String>();
    for (String macroName : MapSequence.fromMap(macros).keySet()) {
      String macroValue = MapSequence.fromMap(macros).get(macroName);
      CanonicalPath path = new CanonicalPath(macroValue);
      if (path.isValidDirectory()) {
        realMacros.put(macroName, path.getValue());
      }
    }
    return new MapPathMacrosProvider(realMacros);
  }

  private static UrlClassLoader createPluginClassLoader(File lib) {
    List<URL> urls = new ArrayList<URL>();
    File[] files = lib.listFiles(PathManager.JARS);
    if (files == null) {
      return null;
    }
    for (File libjar : files) {
      try {
        urls.add(libjar.toURI().toURL());
      } catch (MalformedURLException ignored) {
      }
    }
    return new UrlClassLoader(urls, LibraryInitializer.class.getClassLoader());
  }

  private static Set<LibraryContributor.LibDescriptor> getPluginLibDescriptors(EnvironmentConfig config) {
    Set<LibraryContributor.LibDescriptor> paths = new LinkedHashSet<LibraryContributor.LibDescriptor>();
    for (String plugin : config.getPlugins()) {
      File lib = new File(plugin + File.separator + "lib");
      UrlClassLoader pluginCL = null;
      if (lib.exists() && lib.isDirectory()) {
        pluginCL = createPluginClassLoader(lib);
        for (File jar : lib.listFiles(PathManager.JARS)) {
          paths.add(new LibraryContributor.LibDescriptor(jar.getAbsolutePath() + MODULES_PREFIX, pluginCL));
        }
      }
      File languages = new File(plugin + File.separator + "languages");
      if (languages.exists() && languages.isDirectory()) {
        paths.add(new LibraryContributor.LibDescriptor(languages.getAbsolutePath(), pluginCL));
      }
    }
    return Collections.unmodifiableSet(paths);
  }

  public static LibraryContributor createPluginLibContributor(EnvironmentConfig config) {
    return new SetLibraryContributor(getPluginLibDescriptors(config));
  }

  public static LibraryContributor createLibContributor(EnvironmentConfig config) {
    Map<File, ClassLoader> libToCLMap = new LinkedHashMap<File, ClassLoader>();
    for (File lib : SetSequence.fromSet(config.getLibs())) {
      libToCLMap.put(lib, null);
    }

    return createLibContributor(libToCLMap);
  }

  public static LibraryContributor createLibContributor(Map<File, ClassLoader> libToClassLoader) {
    Set<LibraryContributor.LibDescriptor> libDescriptors = new LinkedHashSet<LibraryContributor.LibDescriptor>();
    for (File libFile : libToClassLoader.keySet()) {
      libDescriptors.add(new LibraryContributor.LibDescriptor(libFile.getAbsolutePath(), libToClassLoader.get(libFile)));
    }
    return new SetLibraryContributor(libDescriptors);
  }
  private static boolean isEmptyString(String str) {
    return str == null || str.length() == 0;
  }
}
