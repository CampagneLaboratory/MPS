package jetbrains.mps.tool.environment;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.project.Project;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.project.PathMacrosProvider;
import jetbrains.mps.library.contributor.LibraryContributor;
import jetbrains.mps.tool.builder.util.MpsPlatform;
import jetbrains.mps.generator.GenerationSettingsProvider;
import jetbrains.mps.generator.DefaultModifiableGenerationSettings;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.tool.builder.util.MapPathMacrosProvider;
import jetbrains.mps.project.PathMacros;
import jetbrains.mps.library.LibraryInitializer;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.io.File;
import jetbrains.mps.tool.builder.FileMPSProject;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MpsEnvironment implements Environment {
  private final Set<Project> openedProjects = SetSequence.fromSet(new HashSet<Project>());

  private final PathMacrosProvider macrosProvider;
  private final Set<LibraryContributor> libContributors;


  public MpsEnvironment(EnvironmentConfig config) {
    if (LOG.isInfoEnabled()) {
      LOG.info("Creating MPS environment");
    }
    ActiveEnvironment.activateEnvironment(this);
    MpsPlatform.init();
    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());

    try {
      EnvironmentUtils.setSystemProperties(false);
      EnvironmentUtils.setPluginPath();
    } catch (Exception ex) {
      throw new RuntimeException(ex);
    }

    libContributors = initLibs(config);
    macrosProvider = initMacros(config);
  }



  private PathMacrosProvider initMacros(EnvironmentConfig config) {
    Map<String, String> macros = MapSequence.fromMap(new HashMap<String, String>());
    for (String name : MapSequence.fromMap(config.macros()).keySet()) {
      MapSequence.fromMap(macros).put(name, MapSequence.fromMap(config.macros()).get(name).getAbsolutePath());
    }
    MapPathMacrosProvider macrosProvider = EnvironmentUtils.createMapMacrosProvider(macros);
    PathMacros.getInstance().addMacrosProvider(macrosProvider);
    return macrosProvider;
  }



  private Set<LibraryContributor> initLibs(EnvironmentConfig config) {
    final Set<LibraryContributor> libContribs = SetSequence.fromSetWithValues(new HashSet<LibraryContributor>(), createLibContributors(config));
    for (LibraryContributor libContrib : SetSequence.fromSet(libContribs)) {
      LibraryInitializer.getInstance().addContributor(libContrib);
    }
    ModelAccess.instance().runWriteAction(new Runnable() {
      @Override
      public void run() {
        LibraryInitializer.getInstance().update();
      }
    });
    return libContribs;
  }



  @Override
  public boolean hasIdeaInstance() {
    return false;
  }



  protected Iterable<LibraryContributor> createLibContributors(EnvironmentConfig config) {
    return Sequence.<LibraryContributor>singleton(EnvironmentUtils.createLibContributor(false, config.libs()));
  }



  /**
   * FIXME: Lazy open
   */
  @Override
  public Project openProject(File projectFile) {
    if (LOG.isInfoEnabled()) {
      LOG.info("Opening project");
    }
    FileMPSProject project = new FileMPSProject(projectFile);
    project.init(new FileMPSProject.ProjectDescriptor(projectFile));
    SetSequence.fromSet(openedProjects).addElement(project);
    return project;
  }



  @Override
  public Project createDummyProject() {
    Project project = EnvironmentUtils.createDummyFileProject();
    SetSequence.fromSet(openedProjects).addElement(project);
    return project;
  }



  @Override
  public Iterable<Project> openedProjects() {
    return ListSequence.fromListWithValues(new ArrayList<Project>(), openedProjects);
  }



  @Override
  public void disposeProject(final Project project) {
    project.dispose();
  }



  @Override
  public void dispose() {
    ModelAccess.instance().flushEventQueue();

    for (Project project : SetSequence.fromSetWithValues(new HashSet<Project>(), openedProjects)) {
      disposeProject(project);
    }

    PathMacros.getInstance().removeMacrosProvider(macrosProvider);
    for (LibraryContributor libContributor : SetSequence.fromSet(libContributors)) {
      LibraryInitializer.getInstance().removeContributor(libContributor);
    }

    MpsPlatform.dispose();

    ActiveEnvironment.deactivateEnvironment(this);
  }

  protected static Logger LOG = LogManager.getLogger(MpsEnvironment.class);
}
