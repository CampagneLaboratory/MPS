package jetbrains.mps.tool.environment;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.project.Project;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.tool.builder.util.MapPathMacrosProvider;
import jetbrains.mps.library.contributor.LibraryContributor;
import jetbrains.mps.tool.builder.util.MpsPlatform;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.generator.GenerationSettingsProvider;
import jetbrains.mps.generator.DefaultModifiableGenerationSettings;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.PathMacros;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.library.LibraryInitializer;
import jetbrains.mps.smodel.ModelAccess;
import java.io.File;
import jetbrains.mps.tool.builder.FileMPSProject;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public class MpsEnvironment implements Environment {
  private final Set<Project> openedProjects = SetSequence.fromSet(new HashSet<Project>());
  private final EnvironmentConfig config;

  private final MapPathMacrosProvider macroProvider;
  private final Iterable<LibraryContributor> libContributors;
  private MpsPlatform myPlatformLoader;


  public MpsEnvironment(EnvironmentConfig config) {
    this.config = config;

    // todo: if creationg of environment fails? is it publication before we need it? 
    ActiveEnvironment.activateEnvironment(this);

    // todo: plugins, libs 

    BasicConfigurator.configure(new ConsoleAppender(new SimpleLayout()));
    Logger.getRootLogger().setLevel(Level.INFO);

    myPlatformLoader = new MpsPlatform();
    myPlatformLoader.init();
    // todo: =( 
    RuntimeFlags.setTestMode(true);
    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());

    try {
      EnvironmentUtils.setSystemProperties(false);
      EnvironmentUtils.setPluginPath();
    } catch (Exception ex) {
      throw new RuntimeException(ex);
    }

    Map<String, String> macros = MapSequence.fromMap(new HashMap<String, String>());
    for (String name : MapSequence.fromMap(config.macros()).keySet()) {
      MapSequence.fromMap(macros).put(name, MapSequence.fromMap(config.macros()).get(name).getAbsolutePath());
    }
    macroProvider = EnvironmentUtils.createMapMacrosProvider(macros);
    PathMacros.getInstance().addMacrosProvider(macroProvider);

    libContributors = SetSequence.fromSetWithValues(new HashSet<LibraryContributor>(), createLibContributors(config));
    for (LibraryContributor libContributor : Sequence.fromIterable(libContributors)) {
      LibraryInitializer.getInstance().addContributor(libContributor);
    }
    ModelAccess.instance().runWriteAction(new Runnable() {
      @Override
      public void run() {
        LibraryInitializer.getInstance().update();
      }
    });
  }



  public EnvironmentConfig getConfig() {
    return config;
  }

  public boolean hasIdeaInstance() {
    return false;
  }



  protected Iterable<LibraryContributor> createLibContributors(EnvironmentConfig config) {
    return Sequence.<LibraryContributor>singleton(EnvironmentUtils.createLibContributor(false, config.libs()));
  }



  public Project openProject(File projectFile) {
    FileMPSProject project = new FileMPSProject(projectFile);
    project.init(new FileMPSProject.ProjectDescriptor(projectFile));
    SetSequence.fromSet(openedProjects).addElement(project);
    return project;
  }

  public Project createDummyProject() {
    Project project = EnvironmentUtils.createDummyFileProject();
    SetSequence.fromSet(openedProjects).addElement(project);
    return project;
  }



  public Iterable<Project> openedProjects() {
    return ListSequence.fromListWithValues(new ArrayList<Project>(), openedProjects);
  }



  public void disposeProject(final Project project) {
    project.dispose();
  }

  public void disposeEnvironment() {
    ModelAccess.instance().flushEventQueue();

    for (Project project : SetSequence.fromSetWithValues(new HashSet<Project>(), openedProjects)) {
      disposeProject(project);
    }

    PathMacros.getInstance().removeMacrosProvider(macroProvider);
    for (LibraryContributor libContributor : Sequence.fromIterable(libContributors)) {
      LibraryInitializer.getInstance().removeContributor(libContributor);
    }

    myPlatformLoader.dispose();
    myPlatformLoader = null;

    ActiveEnvironment.deactivateEnvironment(this);
  }
}
