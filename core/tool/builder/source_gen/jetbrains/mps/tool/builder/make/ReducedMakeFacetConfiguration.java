package jetbrains.mps.tool.builder.make;

/*Generated by MPS */

import jetbrains.mps.tool.builder.paths.IRedirects;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.make.script.IScriptController;
import java.util.Collections;
import jetbrains.mps.generator.IModifiableGenerationSettings;
import jetbrains.mps.generator.GenerationSettingsProvider;
import jetbrains.mps.generator.GenerationOptions;
import jetbrains.mps.make.script.IPropertiesPool;
import jetbrains.mps.make.facet.ITarget;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.vfs.IFile;

public class ReducedMakeFacetConfiguration {
  private IRedirects outputPathRedirects;
  private Map<String, String> fileHashes = MapSequence.fromMap(new HashMap<String, String>());
  private List<String> writtenFiles = ListSequence.fromList(new ArrayList<String>());
  private List<String> deletedFiles = ListSequence.fromList(new ArrayList<String>());

  public ReducedMakeFacetConfiguration(IRedirects pathRedirects) {
    this.outputPathRedirects = pathRedirects;
  }

  public IScriptController configureFacets() {
    return configureFacets(this.fileHashes, this.writtenFiles, this.deletedFiles);
  }

  public Map<String, String> getFileHashes() {
    return Collections.unmodifiableMap(fileHashes);
  }

  public List<String> getWrittenFiles() {
    return ListSequence.fromList(writtenFiles).asUnmodifiable();
  }

  public List<String> getDeletedFiles() {
    return ListSequence.fromList(deletedFiles).asUnmodifiable();
  }

  private IScriptController configureFacets(final Map<String, String> fileHashes, final List<String> writtenFiles, final List<String> deletedFiles) {
    IModifiableGenerationSettings settings = GenerationSettingsProvider.getInstance().getGenerationSettings();
    settings.setIncremental(true);
    settings.setIncrementalUseCache(false);
    final GenerationOptions.OptionsBuilder optBuilder = GenerationOptions.fromSettings(settings);
    optBuilder.rebuildAll(false);

    return new IScriptController.Stub() {
      @Override
      public void setup(IPropertiesPool pp, Iterable<ITarget> toExecute, Iterable<? extends IResource> input) {
        super.setup(pp, toExecute, input);

        Tuples._3<Project, IOperationContext, Boolean> vars = (Tuples._3<Project, IOperationContext, Boolean>) pp.properties(new ITarget.Name("jetbrains.mps.lang.core.Generate.checkParameters"), Object.class);
        // don't do rebuild all 
        vars._2(false);

        Tuples._2<Boolean, GenerationOptions.OptionsBuilder> params = (Tuples._2<Boolean, GenerationOptions.OptionsBuilder>) pp.properties(new ITarget.Name("jetbrains.mps.lang.core.Generate.configure"), Object.class);
        params._1(optBuilder);

        Tuples._1<Boolean> skipCopyTraceinfo = (Tuples._1<Boolean>) pp.properties(new ITarget.Name("jetbrains.mps.lang.traceable.CopyTraceInfo.copyTraceInfo"), Object.class);
        if (skipCopyTraceinfo != null) {
          skipCopyTraceinfo._0(true);
        }

        Tuples._2<Boolean, Boolean> compileProps = (Tuples._2<Boolean, Boolean>) pp.properties(new ITarget.Name("jetbrains.mps.baseLanguage.JavaCompile.compile"), Object.class);
        if (compileProps != null) {
          compileProps._1(true);
        }

        Tuples._2<List<String>, List<String>> report = (Tuples._2<List<String>, List<String>>) pp.properties(new ITarget.Name("jetbrains.mps.build.reduced.ReportFiles.report"), Object.class);
        report._0(writtenFiles);
        report._1(deletedFiles);

        Tuples._1<Map<String, String>> hashes = (Tuples._1<Map<String, String>>) pp.properties(new ITarget.Name("jetbrains.mps.build.reduced.CollectHashes.collect"), Object.class);
        hashes._0(fileHashes);

        Tuples._1<Boolean> skipReconcile = (Tuples._1<Boolean>) pp.properties(new ITarget.Name("jetbrains.mps.lang.core.Make.reconcile"), Object.class);
        skipReconcile._0(true);

        // override solution's output path 
        Tuples._1<_FunctionTypes._return_P1_E0<? extends IFile, ? super String>> pathToFile = (Tuples._1<_FunctionTypes._return_P1_E0<? extends IFile, ? super String>>) pp.properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"), Object.class);
        pathToFile._0(new _FunctionTypes._return_P1_E0<IFile, String>() {
          public IFile invoke(String path) {
            return outputPathRedirects.getRedirect(path);
          }
        });
      }
    };
  }


}
