package jetbrains.mps.tool.builder.check;

/*Generated by MPS */

import jetbrains.mps.tool.builder.make.MakeWorker;
import jetbrains.mps.tool.common.IMessageFormat;
import jetbrains.mps.tool.common.Script;
import jetbrains.mps.tool.builder.MpsWorker;
import jetbrains.mps.tool.builder.Environment;
import java.lang.management.MemoryMXBean;
import java.lang.management.ManagementFactory;
import java.io.File;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.tool.builder.FileMPSProject;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.IScope;
import jetbrains.mps.project.AbstractModule;
import java.util.List;
import jetbrains.mps.util.Computable;
import jetbrains.mps.project.validation.ModelValidator;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.project.GlobalScope;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.SNodeUtil;
import jetbrains.mps.tool.common.TeamCityMessageFormat;

public class TestBrokenReferencesWorker extends MakeWorker {
  private final IMessageFormat myBuildServerMessageFormat = TestBrokenReferencesWorker.getBuildServerMessageFormat();
  private long myUsedHeap;
  private long myUsedNonHeap;

  public TestBrokenReferencesWorker(Script whatToDo, MpsWorker.LogLogger systemOutLogger) {
    this(whatToDo, systemOutLogger, new Environment());
  }

  public TestBrokenReferencesWorker(Script whatToDo, MpsWorker.LogLogger systemOutLogger, Environment env) {
    super(whatToDo, systemOutLogger, env);
    MemoryMXBean mmbean = ManagementFactory.getMemoryMXBean();
    this.myUsedHeap = mmbean.getHeapMemoryUsage().getUsed();
    this.myUsedNonHeap = mmbean.getNonHeapMemoryUsage().getUsed();
  }

  @Override
  public void work() {
    setupEnvironment();

    File projectFile = FileUtil.createTmpFile();
    FileMPSProject project = new FileMPSProject(projectFile);
    project.init(new FileMPSProject.ProjectDescriptor(null));
    projectFile.deleteOnExit();

    MpsWorker.ObjectsToProcess go = new MpsWorker.ObjectsToProcess();
    collectModelsToGenerate(go);
    reload();
    executeTask(project, go);
    dispose();
  }

  @Override
  protected void executeTask(Project project, final MpsWorker.ObjectsToProcess go) {
    for (Project p : go.getProjects()) {
      extractModels(go.getModels(), p);
    }
    for (SModule m : go.getModules()) {
      extractModels(go.getModels(), m);
    }
    ModelAccess.instance().runReadAction(new Runnable() {
      @Override
      public void run() {
        for (SModel sm : go.getModels()) {
          if (!(SModelStereotype.isUserModel(sm))) {
            continue;
          }
          String testName = "test references for " + sm.getModelName();
          output(myBuildServerMessageFormat.formatTestStart(testName));
          StringBuffer errorMessages = checkModel(sm);
          if (errorMessages.length() > 0) {
            output(myBuildServerMessageFormat.formatTestFailure(testName, "Broken References", errorMessages.toString()));
          }
          output(myBuildServerMessageFormat.formatTestFinish(testName));
        }
      }
    });
  }

  protected void output(CharSequence s) {
    System.out.println(s);
  }

  private StringBuffer checkModel(final SModel sm) {
    final IScope scope = ((AbstractModule) ((AbstractModule) sm.getModule())).getScope();
    StringBuffer errorMessages = new StringBuffer();
    List<String> validationResult = ModelAccess.instance().runReadAction(new Computable<List<String>>() {
      @Override
      public List<String> compute() {
        return new ModelValidator(sm).validate(scope);
      }
    });
    for (String item : validationResult) {
      errorMessages.append(item);
      errorMessages.append("\n");
    }
    for (SNode node : sm.getRootNodes()) {
      debug("Checking node " + node);
      if (SModelUtil.findConceptDeclaration(node.getConcept().getConceptId(), GlobalScope.getInstance()) == null) {
        errorMessages.append("Unknown concept ");
        errorMessages.append(node.getConcept().getConceptId());
        errorMessages.append("\n");
      }
    }
    for (SNode node : sm.getRootNodes()) {
      for (SReference ref : ((SNode) node).getReferences()) {
        if (SNodeUtil.hasReferenceMacro((SNode) node, ref.getRole())) {
          continue;
        }
        if (ref.getTargetNode() == null) {
          errorMessages.append("Broken reference in node ");
          errorMessages.append(node.getNodeId().toString());
          errorMessages.append("(");
          errorMessages.append(node);
          errorMessages.append(")\n");
        }
      }
    }
    return myBuildServerMessageFormat.escapeBuildMessage(errorMessages);
  }

  @Override
  protected void showStatistic() {
    MemoryMXBean mmbean = ManagementFactory.getMemoryMXBean();
    output("Used heap: " + (mmbean.getHeapMemoryUsage().getUsed() - myUsedHeap));
    output("Used non-heap: " + (mmbean.getNonHeapMemoryUsage().getUsed() - myUsedNonHeap));
    failBuild("broken reference testing");
  }

  public static void main(String[] args) {
    MpsWorker generator = new TestBrokenReferencesWorker(Script.fromDumpInFile(new File(args[0])), new MpsWorker.LogLogger());
    generator.workFromMain();
  }

  public static IMessageFormat getBuildServerMessageFormat() {
    return new TeamCityMessageFormat();
  }
}
