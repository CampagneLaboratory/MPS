package jetbrains.mps.tool.builder.make;

/*Generated by MPS */

import jetbrains.mps.tool.common.IMessageFormat;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.tool.common.Script;
import jetbrains.mps.tool.builder.MpsWorker;
import java.io.File;
import java.io.IOException;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.project.Project;
import java.util.LinkedHashSet;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Collections;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.make.script.IScriptController;
import jetbrains.mps.make.script.IConfigMonitor;
import jetbrains.mps.make.script.IPropertiesPool;
import jetbrains.mps.make.facet.ITarget;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.vfs.IFile;
import java.util.Set;
import jetbrains.mps.tool.builder.unittest.UnitTestListener;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.script.ScriptBuilder;
import jetbrains.mps.make.facet.IFacet;
import java.util.concurrent.ExecutionException;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.library.LibraryInitializer;
import jetbrains.mps.util.Computable;
import jetbrains.mps.make.MPSCompilationResult;
import jetbrains.mps.make.ModuleMaker;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.classloading.ClassLoaderManager;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.smodel.resources.ModelsToResources;
import jetbrains.mps.generator.GenerationFacade;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.tool.common.TeamCityMessageFormat;
import jetbrains.mps.tool.common.ScriptProperties;
import jetbrains.mps.make.script.IProgress;
import jetbrains.mps.messages.IMessageHandler;
import jetbrains.mps.messages.IMessage;
import jetbrains.mps.tool.builder.unittest.UnitTestAdapter;
import jetbrains.mps.tool.builder.unittest.ITestReporter;
import jetbrains.mps.tool.builder.unittest.XmlTestReporter;
import jetbrains.mps.tool.builder.unittest.ConsoleTestReporter;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import jetbrains.mps.make.script.IJobMonitor;
import jetbrains.mps.make.script.IFeedback;
import jetbrains.mps.progress.ProgressMonitorBase;
import jetbrains.mps.progress.SubProgressKind;

public class DiffTestWorker extends GeneratorWorker {
  private final DiffTestWorker.MyMessageHandler myMessageHandler = new DiffTestWorker.MyMessageHandler();
  private boolean myTestFailed = false;
  private IMessageFormat myBuildServerMessageFormat;
  private Map<String, String> path2tmp = MapSequence.fromMap(new HashMap<String, String>());
  private String tmpPath;
  private DiffTestWorker.MyReporter myReporter = new DiffTestWorker.MyReporter();

  public DiffTestWorker(Script whatToDo, MpsWorker.AntLogger logger) {
    super(whatToDo, logger);
    myBuildServerMessageFormat = getBuildServerMessageFormat();
    File tmpDir;
    try {
      tmpDir = File.createTempFile("gentest_", "tmp");
      tmpDir.delete();
      tmpDir.mkdir();
    } catch (IOException ex) {
      throw new RuntimeException(ex);
    }
    this.tmpPath = tmpDir.getAbsolutePath();
  }

  @Override
  public void work() {
    myReporter.init();

    GeneratorWorker.MyEnvironment environment = new GeneratorWorker.MyEnvironment();
    Map<String, File> libraries = MapSequence.fromMap(new LinkedHashMap<String, File>(16, (float) 0.75, false));
    for (String jar : ListSequence.fromList(myWhatToDo.getLibraryJars())) {
      MapSequence.fromMap(libraries).put(jar, new File(jar));
    }
    environment.init(myWhatToDo.getMacro(), false, libraries, myWhatToDo.getLogLevel(), null);
    setEnvironment(environment);

    setupEnvironment();
    setGenerationProperties();

    Project project = createDummyProject();

    LinkedHashSet<SModule> modules = new LinkedHashSet<SModule>();
    for (File moduleFilePath : SetSequence.fromSet(myWhatToDo.getModules())) {
      processModuleFile(moduleFilePath, modules);
    }

    MpsWorker.ObjectsToProcess go = new MpsWorker.ObjectsToProcess(Collections.EMPTY_SET, modules, Collections.EMPTY_SET);
    if (go.hasAnythingToGenerate()) {
      loadAndMake(go);
      generate(project, go);
    } else {
      error("Could not find anything to test.");
    }

    dispose();
    showStatistic();

    myReporter.finishRun();
    cleanUp();
  }



  @Override
  protected void generate(Project project, MpsWorker.ObjectsToProcess go) {
    StringBuffer s = new StringBuffer("Generating:");
    for (Project p : go.getProjects()) {
      s.append("\n    ");
      s.append(p);
    }
    for (SModule m : go.getModules()) {
      s.append("\n    ");
      s.append(m);
    }
    for (SModel m : go.getModels()) {
      s.append("\n    ");
      s.append(m);
    }
    info(s.toString());

    final _FunctionTypes._void_P1_E0<? super String> startTestFormat = new _FunctionTypes._void_P1_E0<String>() {
      public void invoke(String msg) {
        myReporter.testStarted(((msg == null ?
          null :
          msg.trim()
        )));
      }
    };
    final _FunctionTypes._void_P1_E0<? super String> finishTestFormat = new _FunctionTypes._void_P1_E0<String>() {
      public void invoke(String msg) {
        myReporter.testFinished(((msg == null ?
          null :
          msg.trim()
        )));
      }
    };

    IScriptController ctl = new IScriptController.Stub(new IConfigMonitor.Stub(), new DiffTestWorker.MyJobMonitor(new DiffTestWorker.MyProgress(startTestFormat, finishTestFormat))) {
      @Override
      public void setup(IPropertiesPool ppool, Iterable<ITarget> toExecute, Iterable<? extends IResource> input) {
        super.setup(ppool, toExecute, input);
        Tuples._1<_FunctionTypes._return_P1_E0<? extends IFile, ? super String>> makeparams = (Tuples._1<_FunctionTypes._return_P1_E0<? extends IFile, ? super String>>) ppool.properties(new ITarget.Name("jetbrains.mps.make.facets.Make.make"), Object.class);
        makeparams._0(new _FunctionTypes._return_P1_E0<IFile, String>() {
          public IFile invoke(String path) {
            return tmpFile(path);
          }
        });

        Tuples._1<Boolean> tparams = (Tuples._1<Boolean>) ppool.properties(new ITarget.Name("jetbrains.mps.lang.core.TextGen.textGen"), Object.class);
        if (tparams != null) {
          tparams._0(false);
        }

        Tuples._2<_FunctionTypes._return_P1_E0<? extends String, ? super IFile>, Set<File>> dparams = (Tuples._2<_FunctionTypes._return_P1_E0<? extends String, ? super IFile>, Set<File>>) ppool.properties(new ITarget.Name("jetbrains.mps.tool.gentest.Diff.diff"), Object.class);
        if (dparams != null && isShowDiff()) {
          dparams._0(new _FunctionTypes._return_P1_E0<String, IFile>() {
            public String invoke(IFile f) {
              return pathOfTmpFile(f);
            }
          });
          dparams._1(myWhatToDo.getExcludedFromDiffFiles());
        }

        if (isInvokeTestsSet()) {
          Tuples._1<UnitTestListener> testParams = (Tuples._1<UnitTestListener>) ppool.properties(new ITarget.Name("jetbrains.mps.tool.gentest.Test.runTests"), Object.class);
          testParams._0(new DiffTestWorker.MyUnitTestAdapter());
        }
        myReporter.finishRun();
        myReporter.startRun(DiffTestWorker.this.myWhatToDo.getProperty("ant.project.name"));
      }
    };
    IOperationContext context = new ProjectOperationContext(project);
    try {
      BuildMakeService bms = new BuildMakeService();
      MakeSession ms = new MakeSession(context, myMessageHandler, true) {
        @Override
        public IScript toScript(ScriptBuilder scriptBuilder) {
          if (isInvokeTestsSet()) {
            scriptBuilder.withFacetName(new IFacet.Name("jetbrains.mps.tool.gentest.Test"));
          }
          if (isShowDiff()) {
            scriptBuilder.withFacetName(new IFacet.Name("jetbrains.mps.tool.gentest.Diff"));
          }
          return scriptBuilder.toScript();
        }
      };
      bms.make(ms, collectResources(context, go.getModules(), go.getModels()), null, ctl, new DiffTestWorker.MyProgressMonitorBase(startTestFormat, finishTestFormat)).get();
    } catch (InterruptedException ignore) {
    } catch (ExecutionException ignore) {
    }
  }

  private void loadAndMake(final MpsWorker.ObjectsToProcess go) {
    ModelAccess.instance().runWriteAction(new Runnable() {
      @Override
      public void run() {
        LibraryInitializer.getInstance().update();
      }
    });
    ModelAccess.instance().runReadAction(new Computable<MPSCompilationResult>() {
      public MPSCompilationResult compute() {
        return new ModuleMaker().make(go.getModules(), new EmptyProgressMonitor() {
          @Override
          public void step(String text) {
            // silently 
          }

          @Override
          public void start(String taskName, int work) {
            // silently 
          }
        });
      }
    });
    // load classes 
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
      }
    });
  }

  private void reportIfStartsWith(String prefix, String work, _FunctionTypes._void_P1_E0<? super String> format) {
    if (work != null && work.startsWith(prefix)) {
      format.invoke(work.substring(prefix.length()) + "." + ((prefix == null ?
        null :
        prefix.trim()
      )));
    }
  }

  private void cleanUp() {
    for (Queue<File> dirs = QueueSequence.fromQueueAndArray(new LinkedList<File>(), new File(tmpPath)); QueueSequence.fromQueue(dirs).isNotEmpty();) {
      File dir = QueueSequence.fromQueue(dirs).removeFirstElement();
      dir.deleteOnExit();
      for (File f : dir.listFiles()) {
        if (f.isDirectory()) {
          QueueSequence.fromQueue(dirs).addLastElement(f);
        } else {
          f.deleteOnExit();
        }
      }
    }
    this.tmpPath = null;
    MapSequence.fromMap(path2tmp).clear();
  }

  private Iterable<IResource> collectResources(IOperationContext context, final Iterable<SModule> modules, final Iterable<SModel> models) {
    final Wrappers._T<Iterable<SModel>> result = new Wrappers._T<Iterable<SModel>>(null);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        result.value = Sequence.fromIterable(result.value).concat(Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {
          public Iterable<SModel> translate(SModule m) {
            return m.getModels();
          }
        }));
        result.value = Sequence.fromIterable(result.value).concat(Sequence.fromIterable(modules).where(new IWhereFilter<SModule>() {
          public boolean accept(SModule it) {
            return it instanceof Language;
          }
        }).translate(new ITranslator2<SModule, Generator>() {
          public Iterable<Generator> translate(SModule it) {
            return ((Language) it).getGenerators();
          }
        }).translate(new ITranslator2<Generator, SModel>() {
          public Iterable<SModel> translate(Generator gen) {
            return gen.getModels();
          }
        }));
        result.value = Sequence.fromIterable(result.value).concat(Sequence.fromIterable(models));
      }
    });
    return new ModelsToResources(context, Sequence.fromIterable(result.value).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel smd) {
        return GenerationFacade.canGenerate(smd);
      }
    })).resources(false);
  }

  private IFile tmpFile(String path) {
    if (MapSequence.fromMap(path2tmp).containsKey(path)) {
      return FileSystem.getInstance().getFileByPath(MapSequence.fromMap(path2tmp).get(path));
    }
    int idx = path.indexOf("/");
    if (idx > 0) {
      throw new IllegalArgumentException("not an absolute path '" + path + "'");
    }
    idx = (idx < 0 ?
      path.indexOf(File.separator) :
      idx
    );
    if (idx > "C:\\".length() && path.indexOf(":") < 0) {
      throw new IllegalArgumentException("not an absolute path '" + path + "'");
    }
    String tmp = tmpPath + "/" + ((idx != 0 ?
      path.replace(":", "_w_") :
      path.substring(1)
    ));
    MapSequence.fromMap(path2tmp).put(path, tmp);
    return FileSystem.getInstance().getFileByPath(tmp);
  }

  private String pathOfTmpFile(IFile file) {
    String p = file.getPath();
    if (!(p.startsWith(tmpPath))) {
      throw new IllegalArgumentException("unknown tmp path '" + file.getParent() + "'");
    }
    p = p.substring(tmpPath.length() + 1);
    if (p.contains("_w_")) {
      return FileSystem.getInstance().getFileByPath(p.replace("_w_", ":")).getPath();
    }
    String prefix = (File.separatorChar == '/' ?
      "/" :
      "\\\\"
    );
    return FileSystem.getInstance().getFileByPath(prefix + p).getPath();
  }

  public IMessageFormat getBuildServerMessageFormat() {
    if (isRunningOnTeamCity()) {
      return new TeamCityMessageFormat();
    } else {
      return new ConsoleMessageFormat();
    }
  }

  private boolean isRunningOnTeamCity() {
    return myWhatToDo.getProperty("teamcity.version") != null;
  }

  private boolean isInvokeTestsSet() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(ScriptProperties.INVOKE_TESTS)) && isCompileSet();
  }

  private boolean isCompileSet() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(ScriptProperties.COMPILE));
  }

  private boolean isShowDiff() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(ScriptProperties.SHOW_DIFF));
  }

  @Override
  protected void showStatistic() {
    if (myTestFailed && myWhatToDo.getFailOnError()) {
      throw new RuntimeException("Tests Failed");
    }
  }

  public static void main(String[] args) {
    DiffTestWorker generator = new DiffTestWorker(Script.fromDumpInFile(new File(args[0])), new MpsWorker.SystemOutLogger());
    generator.workFromMain();
  }

  private class MyProgress extends IProgress.Stub {
    private final _FunctionTypes._void_P1_E0<? super String> myStartTestFormat;
    private final _FunctionTypes._void_P1_E0<? super String> myFinishTestFormat;

    public MyProgress(_FunctionTypes._void_P1_E0<? super String> startTestFormat, _FunctionTypes._void_P1_E0<? super String> finishTestFormat) {
      myStartTestFormat = startTestFormat;
      myFinishTestFormat = finishTestFormat;
    }

    @Override
    public void beginWork(String name, int estimate, int ofTotal) {
      reportIfStartsWith("Generating ", name, MyProgress.this.myStartTestFormat);
    }

    @Override
    public void finishWork(String name) {
      reportIfStartsWith("Generating ", name, MyProgress.this.myFinishTestFormat);
    }

    @Override
    public void advanceWork(String name, int done, String comment) {
      if (comment != null) {
        _FunctionTypes._void_P1_E0<? super String> format = MyProgress.this.myStartTestFormat;
        if (done > 1) {
          format = MyProgress.this.myFinishTestFormat;
        }
        reportIfStartsWith("Diffing ", name + " " + comment, format);
      }
    }
  }

  private class MyMessageHandler implements IMessageHandler {
    public MyMessageHandler() {
    }

    @Override
    public void handle(IMessage msg) {
      switch (msg.getKind()) {
        case ERROR:
          DiffTestWorker.this.error(msg.getText());
          myReporter.errorLine("[ERROR] " + msg.getText());
          break;
        case WARNING:
          DiffTestWorker.this.warning(msg.getText());
          myReporter.outputLine("[WARNING]" + msg.getText());
          break;
        case INFORMATION:
          DiffTestWorker.this.info(msg.getText());
          myReporter.outputLine("[INFO]" + msg.getText());
          break;
        default:
      }
    }

    @Override
    public void clear() {
    }
  }

  private class MyUnitTestAdapter extends UnitTestAdapter {
    private MyUnitTestAdapter() {
    }

    @Override
    public void testStarted(String testName) {
      myReporter.testStarted(testName);
    }

    @Override
    public void testFailed(String test, String message, String details) {
      myReporter.testFailed(test, message, details);
      myTestFailed = true;
    }

    @Override
    public void testFinished(String testName) {
      myReporter.testFinished(testName);
    }

    @Override
    public void logMessage(String message) {
      if (message != null && !(message.isEmpty())) {
        info(message);
        myReporter.outputLine(message);
      }
    }

    @Override
    public void logError(String errorMessage) {
      if (errorMessage != null && !(errorMessage.isEmpty())) {
        error(errorMessage);
        myReporter.errorLine(errorMessage);
      }
    }
  }

  private class MyReporter {
    private ITestReporter testReporter;
    private String currentTestName;
    private File gentestdir;

    private MyReporter() {
    }

    private void init() {
      if (gentestdir != null) {
        return;
      }
      if (isRunningOnTeamCity()) {
        String wd = myWhatToDo.getProperty("mps.gentest.reportsDir");
        wd = (wd == null ?
          System.getProperty("user.dir") :
          wd
        );
        gentestdir = new File(wd, ".gentest");
        if (!(gentestdir.exists())) {
          if (!(gentestdir.mkdirs())) {
            File tmpDir;
            try {
              tmpDir = File.createTempFile("gentest", "reports");
              tmpDir.delete();
              tmpDir.mkdir();
            } catch (IOException ex) {
              throw new RuntimeException(ex);
            }
            gentestdir = tmpDir;
          }
        } else if (gentestdir.isDirectory()) {
          for (File f : gentestdir.listFiles()) {
            f.delete();
          }
        }
      }
    }

    private String getCurrentTestName() {
      return currentTestName;
    }

    private void startRun(String name) {
      this.testReporter = (isRunningOnTeamCity() ?
        new XmlTestReporter(name) :
        new ConsoleTestReporter()
      );
    }

    private void finishRun() {
      if (testReporter == null) {
        return;
      }
      if (currentTestName != null) {
        testReporter.testFinished(currentTestName);
      }
      testReporter.runFinished();
      if (isRunningOnTeamCity()) {
        BufferedOutputStream os = null;
        try {
          File reportFile = File.createTempFile("gentest_report-", ".xml", gentestdir);
          os = new BufferedOutputStream(new FileOutputStream(reportFile));
          ((XmlTestReporter) testReporter).dump(os);
          System.out.println("##teamcity[importData type='junit' path='" + reportFile.getAbsolutePath() + "']");
        } catch (IOException ex) {
        } finally {
          if (os != null) {
            try {
              os.close();
            } catch (IOException ignore) {
            }
          }
        }
      }
      this.testReporter = null;
    }

    private String normalizeTestName(String name) {
      return name.replace("@", "_");
    }

    private void testStarted(String testname) {
      testname = normalizeTestName(testname);
      if (currentTestName != null) {
        testReporter.testFinished(currentTestName);
      }
      this.currentTestName = testname;
      testReporter.testStarted(testname);
    }

    private void testFinished(String testname) {
      testname = normalizeTestName(testname);
      testReporter.testFinished(testname);
      this.currentTestName = null;
    }

    private void testFailed(String testname, String msg, String longmsg) {
      testname = normalizeTestName(testname);
      testReporter.testFailed(testname, msg, longmsg);
    }

    private void outputLine(String out) {
      if (currentTestName != null) {
        testReporter.testOutputLine(currentTestName, out);
      } else if (testReporter != null) {
        testReporter.outputLine(out);
      } else {
        System.out.println(out);
      }
    }

    private void errorLine(String err) {
      if (currentTestName != null) {
        testReporter.testErrorLine(currentTestName, err);
      } else if (testReporter != null) {
        testReporter.errorLine(err);
      } else {
        System.err.println(err);
      }
    }
  }

  private class MyJobMonitor extends IJobMonitor.Stub {
    public MyJobMonitor(IProgress pstub) {
      super(pstub);
    }

    @Override
    public void reportFeedback(IFeedback fdbk) {
      if (fdbk.getSeverity() == IFeedback.Severity.ERROR) {
        String test = myReporter.getCurrentTestName();
        if (test == null) {
          test = "unknown";
        }
        Throwable thr = fdbk.getException();
        String msg = fdbk.getMessage();
        String details = (thr == null ?
          "(no details)" :
          String.valueOf(MpsWorker.extractStackTrace(thr))
        );
        int eol = msg.indexOf("\n");
        if (eol >= 0) {
          details = msg.substring(eol + 1) + "\n" + details;
          msg = msg.substring(0, eol);
        }
        myReporter.testFailed(test, msg, details);
      }
    }
  }

  private class MyProgressMonitorBase extends ProgressMonitorBase {
    private String prevTitle;
    private final _FunctionTypes._void_P1_E0<? super String> myStartTestFormat;
    private final _FunctionTypes._void_P1_E0<? super String> myFinishTestFormat;

    public MyProgressMonitorBase(_FunctionTypes._void_P1_E0<? super String> startTestFormat, _FunctionTypes._void_P1_E0<? super String> finishTestFormat) {
      myStartTestFormat = startTestFormat;
      myFinishTestFormat = finishTestFormat;
    }

    @Override
    protected void update(double p0) {
    }

    @Override
    protected void startInternal(String text) {
    }

    @Override
    protected void doneInternal(String text) {
    }

    @Override
    protected void setTitleInternal(String text) {
      prevTitle = text;
    }

    @Override
    protected void setStepInternal(String p0) {
    }

    @Override
    public boolean isCanceled() {
      return false;
    }

    @Override
    public void cancel() {
    }

    private ProgressMonitorBase.SubProgressMonitor customSubProgress(ProgressMonitorBase parent, int work, SubProgressKind kind) {
      if (prevTitle != null && prevTitle.startsWith("Generating :: ")) {
        return new ProgressMonitorBase.SubProgressMonitor(parent, work, kind) {
          @Override
          protected void startInternal(String text) {
            reportIfStartsWith("Generating ", "Generating " + text, MyProgressMonitorBase.this.myStartTestFormat);
          }

          @Override
          protected void doneInternal(String text) {
            reportIfStartsWith("Generating ", "Generating " + text, MyProgressMonitorBase.this.myFinishTestFormat);
          }
        };
      }
      return new ProgressMonitorBase.SubProgressMonitor(parent, work, kind) {
        @Override
        protected ProgressMonitorBase.SubProgressMonitor subTaskInternal(int work, SubProgressKind kind) {
          return customSubProgress(this, work, kind);
        }
      };
    }

    @Override
    protected ProgressMonitorBase.SubProgressMonitor subTaskInternal(int work, SubProgressKind kind) {
      return customSubProgress(this, work, kind);
    }
  }
}
