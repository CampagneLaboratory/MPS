package jetbrains.mps.tool.builder.paths;

/*Generated by MPS */

import jetbrains.mps.project.IModule;
import jetbrains.mps.internal.make.runtime.util.DirUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.generator.fileGenerator.FileGenerationUtil;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.extapi.persistence.FolderModelRootBase;
import jetbrains.mps.extapi.persistence.FileBasedModelRoot;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.vfs.impl.JarEntryFile;

public class ModuleOutputPaths {
  private String[] sortedOutDirs;
  private String[] sortedTestOutDirs;
  private String[] sortedOutCacheDirs;
  private String[] sortedTestOutCacheDirs;
  private String[] sortedModelDirs;

  public ModuleOutputPaths(Iterable<IModule> modules) {
    // todo: use union of output paths for models? 
    this.sortedOutDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).where(new IWhereFilter<IModule>() {
      public boolean accept(IModule it) {
        return it instanceof AbstractModule && ((AbstractModule) it).getOutputPath() != null;
      }
    }).select(new ISelector<IModule, String>() {
      public String select(IModule it) {
        return ((AbstractModule) it).getOutputPath().getPath();
      }
    }));
    this.sortedOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(Sequence.fromArray(this.sortedOutDirs)).select(new ISelector<String, String>() {
      public String select(String outDir) {
        return FileGenerationUtil.getCachesPath(outDir);
      }
    }));

    this.sortedTestOutDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).where(new IWhereFilter<IModule>() {
      public boolean accept(IModule it) {
        return it.getFacet(TestsFacet.class) != null;
      }
    }).select(new ISelector<IModule, String>() {
      public String select(IModule it) {
        IFile dir = it.getFacet(TestsFacet.class).getTestsOutputPath();
        return (dir != null ?
          dir.getPath() :
          null
        );
      }
    }));
    this.sortedTestOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(Sequence.fromArray(this.sortedTestOutDirs)).select(new ISelector<String, String>() {
      public String select(String outDir) {
        return FileGenerationUtil.getCachesPath(outDir);
      }
    }));

    Iterable<String> modelRootPaths = Sequence.fromIterable(modules).translate(new ITranslator2<IModule, ModelRoot>() {
      public Iterable<ModelRoot> translate(IModule mod) {
        return mod.getModelRoots();
      }
    }).where(new IWhereFilter<ModelRoot>() {
      public boolean accept(ModelRoot it) {
        return it instanceof FolderModelRootBase;
      }
    }).select(new ISelector<ModelRoot, String>() {
      public String select(ModelRoot smr) {
        return ((FolderModelRootBase) smr).getPath();
      }
    });
    modelRootPaths = Sequence.fromIterable(modelRootPaths).concat(Sequence.fromIterable(modules).translate(new ITranslator2<IModule, ModelRoot>() {
      public Iterable<ModelRoot> translate(IModule mod) {
        return mod.getModelRoots();
      }
    }).where(new IWhereFilter<ModelRoot>() {
      public boolean accept(ModelRoot it) {
        return it instanceof FileBasedModelRoot;
      }
    }).select(new ISelector<ModelRoot, String>() {
      public String select(ModelRoot smr) {
        return ((FileBasedModelRoot) smr).getContentRoot();
      }
    }));

    this.sortedModelDirs = DirUtil.sortDirs(Sequence.fromIterable(modelRootPaths).select(new ISelector<String, IFile>() {
      public IFile select(String path) {
        return FileSystem.getInstance().getFileByPath(path);
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile f) {
        return f.isDirectory() && !(f instanceof JarEntryFile);
      }
    }).select(new ISelector<IFile, String>() {
      public String select(IFile dir) {
        return dir.getPath();
      }
    }));
  }

  public String toLocalPath(String path) {
    String localOut = toLocal(path, sortedOutDirs);
    if (localOut != null) {
      return localOut;
    }
    return toLocal(path, sortedTestOutDirs);
  }

  public String toLocalCachePath(String path) {
    String localCacheOut = toLocal(path, sortedOutCacheDirs);
    if (localCacheOut != null) {
      return localCacheOut;
    }
    return toLocal(path, sortedTestOutCacheDirs);
  }

  private String toLocal(String path, String[] sortedDirs) {
    String normPath = DirUtil.normalizeAsDir(path);
    int idx = DirUtil.findPrefixAsDir(normPath, sortedDirs);
    if (idx >= 0) {
      return DirUtil.withoutPrefix(normPath, sortedDirs[idx]);
    }
    // not found 
    return null;
  }

  public Iterable<String> getOutputPaths() {
    return Sequence.fromIterable(Sequence.fromArray(sortedOutDirs)).concat(Sequence.fromIterable(Sequence.fromArray(sortedTestOutDirs))).concat(Sequence.fromIterable(Sequence.fromArray(sortedModelDirs)));
  }
}
