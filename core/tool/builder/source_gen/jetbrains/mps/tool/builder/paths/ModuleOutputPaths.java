package jetbrains.mps.tool.builder.paths;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.make.runtime.util.DirUtil;
import jetbrains.mps.generator.fileGenerator.FileGenerationUtil;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.extapi.persistence.FolderModelRootBase;
import jetbrains.mps.extapi.persistence.FileBasedModelRoot;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.vfs.impl.JarEntryFile;

public class ModuleOutputPaths {
  private String[] sortedOutDirs;
  private String[] sortedTestOutDirs;
  private String[] sortedOutCacheDirs;
  private String[] sortedTestOutCacheDirs;
  private String[] sortedModelDirs;

  public ModuleOutputPaths(Iterable<SModule> _modules) {
    Iterable<AbstractModule> modules = Sequence.fromIterable(_modules).where(new IWhereFilter<SModule>() {
      public boolean accept(SModule it) {
        return it instanceof AbstractModule;
      }
    }).select(new ISelector<SModule, AbstractModule>() {
      public AbstractModule select(SModule it) {
        return ((AbstractModule) it);
      }
    });
    this.sortedOutDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {
      public String select(AbstractModule mod) {
        return ((AbstractModule) mod).getGeneratorOutputPath();
      }
    }));
    this.sortedOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {
      public String select(AbstractModule mod) {
        return FileGenerationUtil.getCachesPath(mod.getGeneratorOutputPath());
      }
    }));
    // todo: use union of output paths for models? 
    this.sortedTestOutDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {
      public String select(AbstractModule mod) {
        // todo: tmp hack 
        String path = mod.getTestsGeneratorOutputPath();
        return (path != null ?
          path :
          mod.getGeneratorOutputPath()
        );
      }
    }));
    this.sortedTestOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(modules).select(new ISelector<AbstractModule, String>() {
      public String select(AbstractModule mod) {
        // todo: tmp hack 
        String path = mod.getTestsGeneratorOutputPath();
        if (path == null) {
          path = mod.getGeneratorOutputPath();
        }
        return FileGenerationUtil.getCachesPath(path);
      }
    }));

    Iterable<String> modelRootPaths = Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {
      public Iterable<ModelRoot> translate(SModule mod) {
        return mod.getModelRoots();
      }
    }).where(new IWhereFilter<ModelRoot>() {
      public boolean accept(ModelRoot it) {
        return it instanceof FolderModelRootBase;
      }
    }).select(new ISelector<ModelRoot, String>() {
      public String select(ModelRoot smr) {
        return ((FolderModelRootBase) smr).getPath();
      }
    });
    modelRootPaths = Sequence.fromIterable(modelRootPaths).concat(Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {
      public Iterable<ModelRoot> translate(SModule mod) {
        return mod.getModelRoots();
      }
    }).where(new IWhereFilter<ModelRoot>() {
      public boolean accept(ModelRoot it) {
        return it instanceof FileBasedModelRoot;
      }
    }).select(new ISelector<ModelRoot, String>() {
      public String select(ModelRoot smr) {
        return ((FileBasedModelRoot) smr).getContentRoot();
      }
    }));

    this.sortedModelDirs = DirUtil.sortDirs(Sequence.fromIterable(modelRootPaths).select(new ISelector<String, IFile>() {
      public IFile select(String path) {
        return FileSystem.getInstance().getFileByPath(path);
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile f) {
        return f.isDirectory() && !(f instanceof JarEntryFile);
      }
    }).select(new ISelector<IFile, String>() {
      public String select(IFile dir) {
        return dir.getPath();
      }
    }));
  }

  public String toLocalPath(String path) {
    String localOut = toLocal(path, sortedOutDirs);
    if (localOut != null) {
      return localOut;
    }
    return toLocal(path, sortedTestOutDirs);
  }

  public String toLocalCachePath(String path) {
    String localCacheOut = toLocal(path, sortedOutCacheDirs);
    if (localCacheOut != null) {
      return localCacheOut;
    }
    return toLocal(path, sortedTestOutCacheDirs);
  }

  private String toLocal(String path, String[] sortedDirs) {
    String normPath = DirUtil.normalizeAsDir(path);
    int idx = DirUtil.findPrefixAsDir(normPath, sortedDirs);
    if (idx >= 0) {
      return DirUtil.withoutPrefix(normPath, sortedDirs[idx]);
    }
    // not found 
    return null;
  }

  public Iterable<String> getOutputPaths() {
    return Sequence.fromIterable(Sequence.fromArray(sortedOutDirs)).concat(Sequence.fromIterable(Sequence.fromArray(sortedTestOutDirs))).concat(Sequence.fromIterable(Sequence.fromArray(sortedModelDirs)));
  }
}
