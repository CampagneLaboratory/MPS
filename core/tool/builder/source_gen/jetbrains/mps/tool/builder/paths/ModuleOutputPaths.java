package jetbrains.mps.tool.builder.paths;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.make.runtime.util.DirUtil;
import jetbrains.mps.generator.fileGenerator.FileGenerationUtil;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.extapi.persistence.FolderModelRootBase;
import jetbrains.mps.extapi.persistence.FileBasedModelRoot;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.vfs.impl.JarEntryFile;

public class ModuleOutputPaths {
  private String[] sortedOutDirs;
  private String[] sortedTestOutDirs;
  private String[] sortedOutCacheDirs;
  private String[] sortedTestOutCacheDirs;
  private String[] sortedModelDirs;
  public ModuleOutputPaths(Iterable<SModule> _modules) {
    // FIXME consider re-use of SModuleOperations#getOutputRoots, avoid code duplication 
    Iterable<AbstractModule> modules = Sequence.fromIterable(_modules).ofType(AbstractModule.class);
    Iterable<IFile> outputRoots = Sequence.fromIterable(modules).select(new ISelector<AbstractModule, IFile>() {
      public IFile select(AbstractModule it) {
        return it.getOutputPath();
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile it) {
        return it != null;
      }
    });
    this.sortedOutDirs = DirUtil.sortDirs(Sequence.fromIterable(outputRoots).select(new ISelector<IFile, String>() {
      public String select(IFile it) {
        return it.getPath();
      }
    }));
    this.sortedOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(outputRoots).select(new ISelector<IFile, String>() {
      public String select(IFile it) {
        return FileGenerationUtil.getCachesPath(it.getPath());
      }
    }));
    // todo: use union of output paths for models? 
    Iterable<IFile> testOutputRoots = Sequence.fromIterable(modules).select(new ISelector<AbstractModule, IFile>() {
      public IFile select(AbstractModule mod) {
        if (mod.getFacet(TestsFacet.class) != null) {
          return mod.getFacet(TestsFacet.class).getTestsOutputPath();
        }
        return null;
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile it) {
        return it != null;
      }
    });
    this.sortedTestOutDirs = DirUtil.sortDirs(Sequence.fromIterable(testOutputRoots).select(new ISelector<IFile, String>() {
      public String select(IFile it) {
        return it.getPath();
      }
    }));
    this.sortedTestOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(testOutputRoots).select(new ISelector<IFile, String>() {
      public String select(IFile it) {
        return FileGenerationUtil.getCachesPath(it.getPath());
      }
    }));

    Iterable<String> modelRootPaths = Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {
      public Iterable<ModelRoot> translate(SModule mod) {
        return mod.getModelRoots();
      }
    }).where(new IWhereFilter<ModelRoot>() {
      public boolean accept(ModelRoot it) {
        return it instanceof FolderModelRootBase;
      }
    }).select(new ISelector<ModelRoot, String>() {
      public String select(ModelRoot smr) {
        return ((FolderModelRootBase) smr).getPath();
      }
    });
    modelRootPaths = Sequence.fromIterable(modelRootPaths).concat(Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {
      public Iterable<ModelRoot> translate(SModule mod) {
        return mod.getModelRoots();
      }
    }).where(new IWhereFilter<ModelRoot>() {
      public boolean accept(ModelRoot it) {
        return it instanceof FileBasedModelRoot;
      }
    }).select(new ISelector<ModelRoot, String>() {
      public String select(ModelRoot smr) {
        return ((FileBasedModelRoot) smr).getContentRoot();
      }
    }));

    this.sortedModelDirs = DirUtil.sortDirs(Sequence.fromIterable(modelRootPaths).select(new ISelector<String, IFile>() {
      public IFile select(String path) {
        return FileSystem.getInstance().getFileByPath(path);
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile f) {
        return f.isDirectory() && !(f instanceof JarEntryFile);
      }
    }).select(new ISelector<IFile, String>() {
      public String select(IFile dir) {
        return dir.getPath();
      }
    }));
  }
  public String toLocalPath(String path) {
    String localOut = toLocal(path, sortedOutDirs);
    if (localOut != null) {
      return localOut;
    }
    return toLocal(path, sortedTestOutDirs);
  }
  public String toLocalCachePath(String path) {
    String localCacheOut = toLocal(path, sortedOutCacheDirs);
    if (localCacheOut != null) {
      return localCacheOut;
    }
    return toLocal(path, sortedTestOutCacheDirs);
  }
  private String toLocal(String path, String[] sortedDirs) {
    String normPath = DirUtil.normalizeAsDir(path);
    int idx = DirUtil.findPrefixAsDir(normPath, sortedDirs);
    if (idx >= 0) {
      return DirUtil.withoutPrefix(normPath, sortedDirs[idx]);
    }
    // not found 
    return null;
  }
  public Iterable<String> getOutputPaths() {
    return Sequence.fromIterable(Sequence.fromArray(sortedOutDirs)).concat(Sequence.fromIterable(Sequence.fromArray(sortedTestOutDirs))).concat(Sequence.fromIterable(Sequence.fromArray(sortedModelDirs)));
  }
}
