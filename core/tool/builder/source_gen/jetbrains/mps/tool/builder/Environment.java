package jetbrains.mps.tool.builder;

/*Generated by MPS */

import java.util.Map;
import java.io.File;
import org.apache.log4j.Level;
import jetbrains.mps.tool.builder.util.SetLibraryContributor;
import jetbrains.mps.project.PathMacrosProvider;
import jetbrains.mps.logging.MpsAppenderSkeleton;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.Logger;
import jetbrains.mps.tool.builder.util.MpsPlatform;
import jetbrains.mps.MPSCore;
import jetbrains.mps.generator.GenerationSettingsProvider;
import jetbrains.mps.generator.DefaultModifiableGenerationSettings;
import jetbrains.mps.project.PathMacros;
import jetbrains.mps.library.LibraryInitializer;
import jetbrains.mps.project.Project;
import java.util.HashMap;
import jetbrains.mps.tool.common.util.PathUtil;
import jetbrains.mps.tool.builder.util.MapPathMacrosProvider;
import java.util.Set;
import jetbrains.mps.library.contributor.LibraryContributor;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.tool.builder.util.PathManager;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.FileUtil;

public class Environment {
  private Map<String, String> myMacro;
  private boolean myLoadBootstrapLibraries;
  protected Map<String, File> myLibraries;
  protected Level myLogLevel;
  protected SetLibraryContributor myLibraryContibutor;
  private PathMacrosProvider myMacroProvider;
  protected MpsAppenderSkeleton myMessageHandler;

  public Environment() {
  }

  public void init(Map<String, String> macro, boolean isLoadBootstarpLibraries, Map<String, File> libraries, Level logLevel, MpsAppenderSkeleton lh) {
    myMacro = macro;
    myLoadBootstrapLibraries = isLoadBootstarpLibraries;
    myLibraries = libraries;
    myLogLevel = logLevel;
    myMessageHandler = lh;
  }

  public void setup() {
    BasicConfigurator.configure(new ConsoleAppender(new SimpleLayout()));
    Logger.getRootLogger().setLevel(myLogLevel);
    if (myMessageHandler != null) {
      myMessageHandler.register();
    }
    MpsPlatform.init();
    MPSCore.getInstance().setTestMode();
    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());
    try {
      configureMPS(false);
    } catch (Exception ex) {
      throw new RuntimeException(ex);
    }
    setMacro();
    loadLibraries();
  }

  public void dispose() {
    if (myMacroProvider != null) {
      PathMacros.getInstance().removeMacrosProvider(myMacroProvider);
      this.myMacroProvider = null;
    }
    if (myLibraryContibutor != null) {
      LibraryInitializer.getInstance().removeContributor(myLibraryContibutor);
      this.myLibraryContibutor = null;
    }
    MpsPlatform.dispose();
    if (myMessageHandler != null) {
      myMessageHandler.unRegister();
    }
  }

  public Project createDummyProject() {
    return Environment.createTmpDummyProject();
  }

  public Project loadProject(File projectFile) {
    FileMPSProject project = new FileMPSProject(projectFile);
    project.init(new FileMPSProject.ProjectDescriptor(projectFile));
    return project;
  }

  protected void setMacro() {
    Map<String, String> realMacros = new HashMap<String, String>();
    for (String macroName : myMacro.keySet()) {
      String canonicalPath = PathUtil.getCanonicalPath(myMacro.get(macroName));
      File file = new File(canonicalPath);
      if (file.exists() && file.isDirectory()) {
        realMacros.put(macroName, canonicalPath);
      }
    }
    if (myMacroProvider == null) {
      this.myMacroProvider = new MapPathMacrosProvider(realMacros);
      PathMacros.getInstance().addMacrosProvider(myMacroProvider);
    }
  }

  protected void loadLibraries() {
    if (myLibraryContibutor == null) {
      Set<LibraryContributor.LibDescriptor> libraryPaths = new HashSet<LibraryContributor.LibDescriptor>();
      if (myLoadBootstrapLibraries) {
        for (String bpath : CollectionSequence.fromCollection(PathManager.getBootstrapPaths())) {
          libraryPaths.add(new LibraryContributor.LibDescriptor(bpath, null));
        }
        libraryPaths.add(new LibraryContributor.LibDescriptor(PathManager.getLanguagesPath(), null));
        libraryPaths.addAll(PathManager.getExtensionsPaths());
      }
      for (String libName : myLibraries.keySet()) {
        libraryPaths.add(new LibraryContributor.LibDescriptor(myLibraries.get(libName).getAbsolutePath(), null));

      }
      this.myLibraryContibutor = new SetLibraryContributor(libraryPaths);
      LibraryInitializer.getInstance().addContributor(myLibraryContibutor);
    }
    ModelAccess.instance().runWriteAction(new Runnable() {
      @Override
      public void run() {
        LibraryInitializer.getInstance().update();
      }
    });
  }

  protected void configureMPS(boolean loadIdeaPlugins) {
    setProperties(loadIdeaPlugins);
    collectPluginPaths();
  }

  private void collectPluginPaths() {
    StringBuffer pluginPath = new StringBuffer();
    File pluginDir = new File(PathManager.getPreinstalledPluginsPath());
    if (pluginDir.exists()) {
      for (File pluginFolder : pluginDir.listFiles()) {
        if (pluginPath.length() > 0) {
          pluginPath.append(File.pathSeparator);
        }
        pluginPath.append(pluginFolder.getPath());
      }
      System.setProperty("plugin.path", pluginPath.toString());
    }
  }

  protected void setProperties(boolean loadIdeaPlugins) {
    String mpsInternal = System.getProperty("mps.internal");
    System.setProperty("idea.is.internal", (mpsInternal == null ?
      "false" :
      mpsInternal
    ));
    System.setProperty("idea.no.jre.check", "true");
    if (!(loadIdeaPlugins)) {
      System.setProperty("idea.load.plugins", "false");
    }
    System.setProperty("idea.platform.prefix", "Idea");
  }

  public static Project createTmpDummyProject() {
    File projectFile = FileUtil.createTmpFile();
    FileMPSProject project = new FileMPSProject(projectFile);
    project.init(new FileMPSProject.ProjectDescriptor(null));
    projectFile.deleteOnExit();
    return project;
  }
}
