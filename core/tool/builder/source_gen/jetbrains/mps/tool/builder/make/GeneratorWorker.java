package jetbrains.mps.tool.builder.make;

/*Generated by MPS */

import jetbrains.mps.tool.builder.MpsWorker;
import jetbrains.mps.tool.common.Script;
import jetbrains.mps.project.Project;
import jetbrains.mps.tool.common.ScriptProperties;
import jetbrains.mps.generator.GenerationSettingsProvider;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.smodel.resources.MResource;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.ModelAccess;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.progress.EmptyProgressMonitor;
import java.util.concurrent.ExecutionException;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.Map;
import java.io.File;
import java.util.List;
import jetbrains.mps.project.MPSExtentions;
import jetbrains.mps.tool.builder.FileMPSProject;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import jetbrains.mps.reloading.ClassLoaderManager;
import jetbrains.mps.make.ModuleMaker;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.generator.GenerationFacade;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.smodel.resources.ModelsToResources;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.messages.IMessageHandler;
import java.util.ArrayList;
import jetbrains.mps.messages.IMessage;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.make.runtime.util.GraphAnalyzer;

public class GeneratorWorker extends MpsWorker {
  private final GeneratorWorker.MyMessageHandler myMessageHandler = new GeneratorWorker.MyMessageHandler();
  private boolean myTestFailed = false;

  public GeneratorWorker(Script whatToDo) {
    super(whatToDo);
  }

  public GeneratorWorker(Script whatToDo, MpsWorker.AntLogger logger) {
    super(whatToDo, logger);
  }

  protected GeneratorWorker.MyMessageHandler getMyMessageHandler() {
    return myMessageHandler;
  }

  @Override
  protected void executeTask(final Project project, MpsWorker.ObjectsToProcess go) {
    setGenerationProperties();
    if (go.hasAnythingToGenerate()) {
      generate(project, go);
    }
  }

  protected void setGenerationProperties() {
    boolean strictMode = Boolean.parseBoolean(myWhatToDo.getProperty(ScriptProperties.STRICT_MODE));
    GenerationSettingsProvider.getInstance().getGenerationSettings().setStrictMode(strictMode);
    if (strictMode) {
      boolean parallelMode = Boolean.parseBoolean(myWhatToDo.getProperty(ScriptProperties.PARALLEL_MODE));
      GenerationSettingsProvider.getInstance().getGenerationSettings().setParallelGenerator(parallelMode);
      if (parallelMode) {
        GenerationSettingsProvider.getInstance().getGenerationSettings().setNumberOfParallelThreads(8);
      }
      info("Generating in strict mode, parallel generation = " + ((parallelMode ?
        "on" :
        "off"
      )));
    }
  }

  @Override
  protected void showStatistic() {
    failBuild("generation");
  }

  protected void generate(Project project, MpsWorker.ObjectsToProcess go) {
    StringBuffer s = new StringBuffer("Generating:");
    for (Project p : go.getProjects()) {
      s.append("\n    ");
      s.append(p);
    }
    for (SModule m : go.getModules()) {
      s.append("\n    ");
      s.append(m);
    }
    for (SModel m : go.getModels()) {
      s.append("\n    ");
      s.append(m);
    }
    info(s.toString());
    ProjectOperationContext ctx = new ProjectOperationContext(project);

    Iterable<MResource> resources = Sequence.fromIterable(collectResources(ctx, go)).toListSequence();
    ModelAccess.instance().flushEventQueue();
    Future<IResult> res = new BuildMakeService().make(new MakeSession(ctx, myMessageHandler, true), resources, null, null, new EmptyProgressMonitor());

    try {
      if (!(res.get().isSucessful())) {
        myErrors.add("Make was not successful");
      }
    } catch (InterruptedException e) {
      myErrors.add(e.toString());
    } catch (ExecutionException e) {
      myErrors.add(e.toString());
    }
    ModelAccess.instance().flushEventQueue();
  }

  @Override
  public void work() {
    setupEnvironment();
    final Wrappers._boolean doneSomething = new Wrappers._boolean(false);
    //  for each project 
    Map<File, List<String>> mpsProjects = myWhatToDo.getMPSProjectFiles();
    for (File file : mpsProjects.keySet()) {
      if (!(file.getName().endsWith(MPSExtentions.DOT_MPS_PROJECT))) {
        continue;
      }

      FileMPSProject p = new FileMPSProject(file);
      p.init(new FileMPSProject.ProjectDescriptor(file));
      makeProject();
      p.projectOpened();

      info("Loaded project " + p);

      executeTask(p, new MpsWorker.ObjectsToProcess(Collections.singleton(p), new HashSet<SModule>(), new HashSet<SModel>()));

      p.projectClosed();
      disposeProject(p);
      doneSomething.value = true;
    }

    // the rest -- using dummy project 
    LinkedHashSet<SModule> modules = new LinkedHashSet<SModule>();
    LinkedHashSet<SModel> models = new LinkedHashSet<SModel>();
    collectFromModuleFiles(modules);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        if (doneSomething.value) {
          ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
        } else {
          ClassLoaderManager.getInstance().updateModels();
        }
      }
    });
    collectFromModelFiles(models);
    MpsWorker.ObjectsToProcess go = new MpsWorker.ObjectsToProcess(Collections.EMPTY_SET, modules, models);
    if (go.hasAnythingToGenerate()) {
      Project project = createDummyProject();
      executeTask(project, go);
      doneSomething.value = true;
    }
    if (!(doneSomething.value)) {

      error("Could not find anything to generate.");
      myTestFailed = true;
    }

    dispose();
    showStatistic();
  }

  protected void makeProject() {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ClassLoaderManager.getInstance().updateClassPath();
        new ModuleMaker().make(IterableUtil.asCollection(MPSModuleRepository.getInstance().getModules()), new EmptyProgressMonitor());
      }
    });
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
      }
    });
  }

  private Iterable<SModule> withGenerators(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).concat(Sequence.fromIterable(modules).where(new IWhereFilter<SModule>() {
      public boolean accept(SModule it) {
        return it instanceof Language;
      }
    }).translate(new ITranslator2<SModule, SModule>() {
      public Iterable<SModule> translate(SModule it) {
        return (List<SModule>) (List) ((Language) it).getGenerators();
      }
    }));
  }

  private Iterable<SModelDescriptor> getModelsToGenerate(SModule mod) {
    return Sequence.fromIterable(((Iterable<SModel>) mod.getModels())).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel it) {
        return GenerationFacade.canGenerate(it);
      }
    }).select(new ISelector<SModel, SModelDescriptor>() {
      public SModelDescriptor select(SModel it) {
        return (SModelDescriptor) it;
      }
    });
  }

  protected Iterable<MResource> collectResources(IOperationContext context, final MpsWorker.ObjectsToProcess go) {
    final Wrappers._T<Iterable<SModel>> models = new Wrappers._T<Iterable<SModel>>(null);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        for (Project p : go.getProjects()) {
          for (SModule mod : withGenerators((Iterable<SModule>) p.getModules())) {
            models.value = Sequence.fromIterable(models.value).concat(Sequence.fromIterable((getModelsToGenerate(mod))));

          }
        }
        for (SModule mod : withGenerators(go.getModules())) {
          models.value = Sequence.fromIterable(models.value).concat(Sequence.fromIterable(getModelsToGenerate(mod)));
        }
        if (go.getModels() != null) {
          models.value = Sequence.fromIterable(models.value).concat(SetSequence.fromSet(go.getModels()));
        }
      }
    });
    return Sequence.fromIterable(new ModelsToResources(context, Sequence.fromIterable(models.value).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel smd) {
        return GenerationFacade.canGenerate(smd);
      }
    })).resources(false)).select(new ISelector<IResource, MResource>() {
      public MResource select(IResource r) {
        return (MResource) r;
      }
    });
  }

  public static void main(String[] args) {
    MpsWorker mpsWorker = new GeneratorWorker(Script.fromDumpInFile(new File(args[0])), new MpsWorker.SystemOutLogger());
    mpsWorker.workFromMain();
  }

  private class MyMessageHandler implements IMessageHandler {
    private final List<String> myGenerationErrors = new ArrayList<String>();
    private final List<String> myGenerationWarnings = new ArrayList<String>();

    /*package*/ MyMessageHandler() {
    }

    @Override
    public void handle(IMessage msg) {
      switch (msg.getKind()) {
        case ERROR:
          GeneratorWorker.this.error(msg.getText());
          if (msg.getException() != null) {
            myGenerationErrors.add(MpsWorker.extractStackTrace(msg.getException()).toString());
          } else {
            myGenerationErrors.add(msg.getText());
          }
          break;
        case WARNING:
          GeneratorWorker.this.warning(msg.getText());
          myGenerationWarnings.add(msg.getText());
          break;
        case INFORMATION:
          GeneratorWorker.this.info(msg.getText());
          break;
        default:
      }
    }

    public List<String> getGenerationErrors() {
      return myGenerationErrors;
    }

    public List<String> getGenerationWarnings() {
      return myGenerationWarnings;
    }

    public void clean() {
      myGenerationErrors.clear();
      myGenerationWarnings.clear();
    }

    @Override
    public void clear() {
    }
  }

  /**
   * We already have graphs in MPS, why we need this class here?
   * V vertex type
   */
  public static class Graph<V> {
    private Set<V> vertices = SetSequence.fromSet(new HashSet<V>());
    private Map<V, List<V>> fwEdges = MapSequence.fromMap(new HashMap<V, List<V>>());
    private Map<V, List<V>> bkEdges = MapSequence.fromMap(new HashMap<V, List<V>>());
    private _FunctionTypes._return_P1_E0<? extends Comparable<?>, ? super V> sorter;
    private boolean asc;

    public Graph() {
    }

    public void addEdges(V from, V... to) {
      List<V> fw = MapSequence.fromMap(fwEdges).get(from);
      if (fw == null) {
        fw = ListSequence.fromList(new ArrayList<V>());
        MapSequence.fromMap(fwEdges).put(from, fw);
      }
      SetSequence.fromSet(vertices).addElement(from);
      for (V next : to) {
        ListSequence.fromList(fw).addElement(next);
        List<V> bk = MapSequence.fromMap(bkEdges).get(next);
        if (bk == null) {
          bk = ListSequence.fromList(new ArrayList<V>());
          MapSequence.fromMap(bkEdges).put(next, bk);
        }
        ListSequence.fromList(bk).addElement(from);
        SetSequence.fromSet(vertices).addElement(next);
      }
    }

    public void sort(_FunctionTypes._return_P1_E0<? extends Comparable<?>, ? super V> sorter, boolean asc) {
      this.sorter = sorter;
      this.asc = asc;
    }

    public Iterable<V> getVertices() {
      return (sorter != null ?
        SetSequence.fromSet(vertices).sort(sorter, asc) :
        vertices
      );
    }

    public GraphAnalyzer<V> getCycleDetector() {
      return new GraphAnalyzer<V>() {
        @Override
        public Iterable<V> forwardEdges(V v) {
          return MapSequence.fromMap(fwEdges).get(v);
        }

        @Override
        public Iterable<V> vertices() {
          return getVertices();
        }

        @Override
        public Iterable<V> backwardEdges(V v) {
          return MapSequence.fromMap(bkEdges).get(v);
        }
      };
    }
  }
}
