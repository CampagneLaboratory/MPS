package jetbrains.mps.tool.builder.make;

/*Generated by MPS */

import jetbrains.mps.tool.common.util.UrlClassLoader;
import jetbrains.mps.tool.common.Script;
import jetbrains.mps.tool.builder.MpsWorker;
import org.apache.log4j.Logger;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.project.Project;
import java.util.List;
import java.util.LinkedHashSet;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.Collections;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.tool.environment.MpsEnvironment;
import jetbrains.mps.library.contributor.LibraryContributor;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.tool.builder.util.SetLibraryContributor;
import org.jetbrains.mps.openapi.module.FacetsFacade;
import jetbrains.mps.classloading.DumbIdeaPluginFacet;
import org.jetbrains.mps.openapi.module.SModuleFacet;
import jetbrains.mps.tool.common.ScriptProperties;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.tool.builder.util.PathManager;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.net.URL;
import java.net.MalformedURLException;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.library.LibraryInitializer;

public class GeneratorWorker extends BaseGeneratorWorker {
  private final UrlClassLoader myClassLoader;

  public GeneratorWorker(Script whatToDo) {
    super(whatToDo);
    myClassLoader = createClassloader();
  }

  public GeneratorWorker(Script whatToDo, MpsWorker.AntLogger logger) {
    super(whatToDo, logger);
    myClassLoader = createClassloader();
  }

  @Override
  public void work() {
    Logger.getRootLogger().setLevel(myWhatToDo.getLogLevel());

    EnvironmentConfig config = EnvironmentConfig.emptyEnvironment();

    for (String jar : myWhatToDo.getLibraryJars()) {
      File jarFile = new File(jar);
      if (!(jarFile.exists())) {
        warning("Library " + jar + " does not exist.");
      }
      config = config.addLib(jar, jarFile);
    }
    for (IMapping<String, String> macro : MapSequence.fromMap(myWhatToDo.getMacro())) {
      config = config.addMacro(macro.key(), new File(macro.value()));
    }

    Environment environment = new GeneratorWorker.MyEnvironment(config);
    setupEnvironment();
    setGenerationProperties();
    boolean doneSomething = false;

    Project project = createDummyProject();

    for (IMapping<List<String>, Boolean> chunk : MapSequence.fromMap(myWhatToDo.getChunks())) {
      List<String> modulePaths = chunk.key();
      LinkedHashSet<SModule> modules = new LinkedHashSet<SModule>();
      for (String modulePath : modulePaths) {
        processModuleFile(new File(modulePath), modules);
      }
      Boolean bootstrap = chunk.value();
      if (bootstrap) {
        warning("Found bootstrap chunk " + chunk.key() + ". Generation may be impossible.");
      }
      MpsWorker.ObjectsToProcess go = new MpsWorker.ObjectsToProcess(Collections.EMPTY_SET, modules, Collections.EMPTY_SET);
      if (go.hasAnythingToGenerate()) {
        generate(project, go);
        doneSomething = true;

        ModelAccess.instance().runWriteAction(new Runnable() {
          public void run() {
            ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
          }
        });
      }
    }

    if (!(doneSomething)) {
      error("Could not find anything to generate.");
    }

    environment.dispose();
    dispose();
    showStatistic();
  }

  public static void main(String[] args) {
    MpsWorker mpsWorker = new GeneratorWorker(Script.fromDumpInFile(new File(args[0])), new MpsWorker.SystemOutLogger());
    mpsWorker.workFromMain();
  }

  protected class MyEnvironment extends MpsEnvironment {
    public MyEnvironment(EnvironmentConfig config) {
      super(config);
    }

    @Override
    protected Iterable<LibraryContributor> createLibContributors(EnvironmentConfig config) {
      registerFactory();
      // todo: !next line was removed  <node> 
      Set<LibraryContributor.LibDescriptor> libraryPaths = new HashSet<LibraryContributor.LibDescriptor>();
      for (String libName : MapSequence.fromMap(config.libs()).keySet()) {
        libraryPaths.add(new LibraryContributor.LibDescriptor(MapSequence.fromMap(config.libs()).get(libName).getAbsolutePath(), myClassLoader));

      }
      return Sequence.<LibraryContributor>singleton(new SetLibraryContributor(libraryPaths));
    }



    private void registerFactory() {
      FacetsFacade.FacetFactory dumbFactory = FacetsFacade.getInstance().getFacetFactory(DumbIdeaPluginFacet.FACET_TYPE);
      assert dumbFactory != null;
      FacetsFacade.getInstance().removeFactory(dumbFactory);
      FacetsFacade.getInstance().addFactory(DumbIdeaPluginFacet.FACET_TYPE, new FacetsFacade.FacetFactory() {
        @Override
        public SModuleFacet create() {
          return new DumbIdeaPluginFacet() {
            @Override
            public ClassLoader getClassLoader() {
              return myClassLoader;
            }
          };
        }
      });
    }
  }

  private UrlClassLoader createClassloader() {
    String pluginsPath = myWhatToDo.getProperty(ScriptProperties.PLUGIN_PATHS);
    Set<File> pluginsClasspath = SetSequence.fromSet(new LinkedHashSet<File>());
    if (pluginsPath != null) {
      for (String plugin : pluginsPath.split(File.pathSeparator)) {
        File lib = new File(plugin + File.separator + "lib");
        if (lib.exists() && lib.isDirectory()) {
          SetSequence.fromSet(pluginsClasspath).addSequence(Sequence.fromIterable(Sequence.fromArray(lib.listFiles(PathManager.JARS))));
        }
      }
    }
    if ((pluginsPath == null || pluginsPath.length() == 0)) {
      return null;
    }
    return new UrlClassLoader(SetSequence.fromSet(pluginsClasspath).select(new ISelector<File, URL>() {
      public URL select(File it) {
        try {
          return it.toURI().toURL();
        } catch (MalformedURLException e) {
          return null;
        }
      }
    }).where(new IWhereFilter<URL>() {
      public boolean accept(URL it) {
        return it != null;
      }
    }).toGenericArray(URL.class), LibraryInitializer.class.getClassLoader());
  }
}
