package jetbrains.mps.tool.environment;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.Project;
import java.util.List;
import jetbrains.mps.library.ModulesMiner;
import jetbrains.mps.make.MPSCompilationResult;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import jetbrains.mps.make.ModuleMaker;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.progress.EmptyProgressMonitor;
import java.lang.reflect.InvocationTargetException;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.classloading.ClassLoaderManager;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public abstract class ProjectStrategyBase implements ProjectStrategy {
  @Override
  public boolean isApplicable() {
    return true;
  }

  @NotNull
  public Project create(@NotNull Environment env) {
    if (isApplicable()) {
      Project emptyProject = env.createEmptyProject();
      return construct(emptyProject);
    }
    throw new IllegalStateException("Strategy " + this + " is not applicable -- cannot create project");
  }

  @NotNull
  protected abstract Project construct(@NotNull Project emptyProject);

  @NotNull
  protected Project loadProjectFromModuleHandles(@NotNull Project emptyProject, List<ModulesMiner.ModuleHandle> moduleHandles) {
    Project projectFilledWithModules = new ProjectModulesFiller(emptyProject, moduleHandles).load();
    return projectFilledWithModules;
  }

  private static MPSCompilationResult makeAllInCreatedEnvironment(final Project project) {
    if (LOG.isInfoEnabled()) {
      LOG.info("Making modules within project");
    }
    return new ModelAccessHelper(project.getModelAccess()).runReadAction(new Computable<MPSCompilationResult>() {
      public MPSCompilationResult compute() {
        return new ModuleMaker().make(IterableUtil.asCollection(project.getRepository().getModules()), new EmptyProgressMonitor());
      }
    });
  }

  @NotNull
  protected Project makeOnFirstTimeOpened(@NotNull Project project) {
    MPSCompilationResult result = makeAllInCreatedEnvironment(project);
    try {
      reloadAllAfterMake(result);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
    return project;
  }

  public static void reloadAllAfterMake(final MPSCompilationResult mpsCompilationResult) throws InterruptedException, InvocationTargetException {
    if (LOG.isInfoEnabled()) {
      LOG.info("Reloading built modules");
    }

    // why we need it? because some classes loaded before maker - LanguageRuntime and TypeSystem classes 
    if (mpsCompilationResult.isReloadingNeeded()) {
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          ClassLoaderManager.getInstance().reloadModules(mpsCompilationResult.getChangedModules());
        }
      });
    }
  }
  protected static Logger LOG = LogManager.getLogger(ProjectStrategyBase.class);
}
