package jetbrains.mps.build.ant.generation;

/*Generated by MPS */

import jetbrains.mps.build.ant.MpsLoadTask;
import jetbrains.mps.tool.common.ScriptProperties;
import jetbrains.mps.build.ant.LibraryDataType;
import java.io.File;
import java.util.Set;
import java.util.LinkedHashSet;
import org.apache.tools.ant.BuildException;

public class GenerateChunksTask extends MpsLoadTask {
  {
    myWhatToDo.putProperty(ScriptProperties.STRICT_MODE, Boolean.toString(true));
    myWhatToDo.putProperty(ScriptProperties.PARALLEL_MODE, Boolean.toString(false));
  }

  public GenerateChunksTask() {
    setUsePropertiesAsMacro(true);
  }

  @Override
  protected String getWorkerClass() {
    return "jetbrains.mps.tool.builder.make.ChunksGeneratorWorker";
  }

  public void addConfiguredChunk(Chunk chunk) {
    myWhatToDo.addChunk(chunk.getModules(), chunk.getBootstrap());
  }

  @Override
  public void addConfiguredLibrary(LibraryDataType jar) {
    File file = jar.getFile();
    if (file != null) {
      myWhatToDo.addLibraryJar(file.getAbsolutePath());
    }
  }

  public void setStrictMode(boolean strictMode) {
    myWhatToDo.putProperty(ScriptProperties.STRICT_MODE, Boolean.toString(strictMode));
  }

  protected boolean getStrictMode() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(ScriptProperties.STRICT_MODE));
  }

  public void setParallelMode(boolean parallelMode) {
    myWhatToDo.putProperty(ScriptProperties.PARALLEL_MODE, Boolean.toString(parallelMode));
  }

  protected boolean getParallelMode() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(ScriptProperties.PARALLEL_MODE));
  }

  public void addConfiguredPlugin(Plugin plugin) {
    String property = myWhatToDo.getProperty(ScriptProperties.PLUGIN_PATHS);
    if ((property == null || property.length() == 0)) {
      property = plugin.getPath().getAbsolutePath();
    } else {
      property += File.pathSeparator + plugin.getPath().getAbsolutePath();
    }
    myWhatToDo.putProperty(ScriptProperties.PLUGIN_PATHS, property);
  }



  @Override
  protected Set<File> calculateClassPath(boolean fork) {
    Set<File> classPath = new LinkedHashSet<File>();
    String mpsHome = getProject().getProperty("artifacts.mps");
    String pluginHome = getProject().getProperty("artifacts.mpsPlugin");
    String ideaHome = getProject().getProperty("artifacts.IDEA");
    String mpsCoreHome = getProject().getProperty("artifacts.mpsBootstrapCore");
    String mpsWorkbenchHome = getProject().getProperty("artifacts.mpsWorkbench");

    if ((mpsHome != null && mpsHome.length() > 0)) {
      // buildMPS 
      gatherAllClassesAndJarsUnder(new File(mpsHome, "lib"), classPath);
    } else if ((pluginHome != null && pluginHome.length() > 0) && (ideaHome != null && ideaHome.length() > 0)) {
      // buildPlugin + IDEA 
      gatherAllClassesAndJarsUnder(new File(ideaHome, "lib"), classPath);
      gatherAllClassesAndJarsUnder(new File(pluginHome, "mps-core/lib"), classPath);
    } else if ((mpsCoreHome != null && mpsCoreHome.length() > 0) && (ideaHome != null && ideaHome.length() > 0)) {
      // buildCore + IDEA 
      gatherAllClassesAndJarsUnder(new File(mpsCoreHome, "lib"), classPath);
      gatherAllClassesAndJarsUnder(new File(ideaHome, "lib"), classPath);
      if ((mpsWorkbenchHome != null && mpsWorkbenchHome.length() > 0)) {
        gatherAllClassesAndJarsUnder(new File(mpsWorkbenchHome, "lib"), classPath);
      }
    } else {
      throw new BuildException("Dependency on MPS build scripts is required to generate MPS modules.");
    }

    return classPath;
  }

  protected void gatherAllClassesAndJarsUnder(File dir, Set<File> result) {
    if (dir.getName().equals("classes") || dir.getName().equals("classes_gen") || dir.getName().equals("apiclasses")) {
      result.add(dir);
      return;
    }
    File[] children = dir.listFiles();
    //  we do not want trove different from ours in $mps.home$/lib 
    String troveJar = "trove" + File.separator + "lib" + File.separator + "trove";
    //  to provide right order of class loading, 
    //  files go first 
    for (File f : children) {
      if (!(f.isDirectory())) {
        if (f.getName().endsWith(".jar") && !(f.getName().contains("ant.jar")) && !(f.getPath().contains(troveJar))) {
          result.add(f);
        }
      }
    }
    for (File f : children) {
      if (f.isDirectory()) {
        if (f.getName().equals("classes") || f.getName().equals("classes_gen")) {
          result.add(f);
        } else {
          gatherAllClassesAndJarsUnder(f, result);
        }
      }
    }
  }


}
