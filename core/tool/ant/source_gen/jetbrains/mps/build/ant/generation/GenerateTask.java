package jetbrains.mps.build.ant.generation;

/*Generated by MPS */

import jetbrains.mps.build.ant.MpsLoadTask;
import jetbrains.mps.tool.common.GeneratorProperties;
import jetbrains.mps.build.ant.LibraryDataType;
import java.io.File;
import jetbrains.mps.tool.common.ScriptProperties;
import java.util.Set;
import java.util.List;
import jetbrains.mps.build.ant.MPSClasspathUtil;
import org.apache.tools.ant.BuildException;
import java.util.LinkedHashSet;

public class GenerateTask extends MpsLoadTask {
  private final GeneratorProperties myGenProps;
  public GenerateTask() {
    myGenProps = new GeneratorProperties(myWhatToDo);
    myGenProps.setStrictMode(true).setParallelMode(false).setInplaceTransform(false).setHideWarnings(false);
  }
  @Override
  protected String getWorkerClass() {
    return "jetbrains.mps.tool.builder.make.GeneratorWorker";
  }
  public void addConfiguredChunk(Chunk chunk) {
    myWhatToDo.addChunk(chunk.getModules(), chunk.getBootstrap());
  }
  public void addConfiguredLibrary(LibraryDataType jar) {
    File file = jar.getFile();
    if (file != null) {
      myWhatToDo.addLibraryJar(file.getAbsolutePath());
    }
  }
  public void setStrictMode(boolean strictMode) {
    myGenProps.setStrictMode(strictMode);
  }
  public void setParallelMode(boolean parallelMode) {
    myGenProps.setParallelMode(parallelMode);
  }
  public void setUseInplaceTransform(boolean inplaceEnabled) {
    myGenProps.setInplaceTransform(inplaceEnabled);
  }
  public void setParallelThreads(int threadCount) {
    myGenProps.setParallelThreads(threadCount);
  }
  public void setHideWarnings(boolean hideWarnings) {
    myGenProps.setHideWarnings(hideWarnings);
  }
  public void addConfiguredPlugin(Plugin plugin) {
    String property = myWhatToDo.getProperty(ScriptProperties.PLUGIN_PATHS);
    if ((property == null || property.length() == 0)) {
      property = plugin.getPath().getAbsolutePath();
    } else {
      property += File.pathSeparator + plugin.getPath().getAbsolutePath();
    }
    myWhatToDo.putProperty(ScriptProperties.PLUGIN_PATHS, property);
  }

  @Override
  protected Set<File> calculateClassPath(boolean fork) {
    List<File> classPathRoots = MPSClasspathUtil.getClassPathRootsFromDependencies(getProject());
    if (classPathRoots.isEmpty()) {
      throw new BuildException("Dependency on MPS build scripts is required to generate MPS modules.");

    }
    Set<File> classPath = new LinkedHashSet<File>();
    for (File file : classPathRoots) {
      MPSClasspathUtil.gatherAllClassesAndJarsUnder(file, classPath);
    }

    return classPath;
  }

}
