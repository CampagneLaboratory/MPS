package jetbrains.mps.build.ant.generation;

/*Generated by MPS */

import jetbrains.mps.build.ant.MpsLoadTask;
import jetbrains.mps.tool.common.ScriptProperties;
import jetbrains.mps.build.ant.LibraryDataType;
import java.io.File;
import java.util.Set;
import java.util.List;
import jetbrains.mps.build.ant.MPSClasspathUtil;
import org.apache.tools.ant.BuildException;
import java.util.LinkedHashSet;

public class GenerateTask extends MpsLoadTask {
  {
    myWhatToDo.putProperty(ScriptProperties.STRICT_MODE, Boolean.toString(true));
    myWhatToDo.putProperty(ScriptProperties.PARALLEL_MODE, Boolean.toString(false));
  }

  public GenerateTask() {
    setUsePropertiesAsMacro(true);
  }

  @Override
  protected String getWorkerClass() {
    return "jetbrains.mps.tool.builder.make.GeneratorWorker";
  }

  public void addConfiguredChunk(Chunk chunk) {
    myWhatToDo.addChunk(chunk.getModules(), chunk.getBootstrap());
  }

  public void addConfiguredLibrary(LibraryDataType jar) {
    File file = jar.getFile();
    if (file != null) {
      myWhatToDo.addLibraryJar(file.getAbsolutePath());
    }
  }

  public void setStrictMode(boolean strictMode) {
    myWhatToDo.putProperty(ScriptProperties.STRICT_MODE, Boolean.toString(strictMode));
  }

  protected boolean getStrictMode() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(ScriptProperties.STRICT_MODE));
  }

  public void setParallelMode(boolean parallelMode) {
    myWhatToDo.putProperty(ScriptProperties.PARALLEL_MODE, Boolean.toString(parallelMode));
  }

  protected boolean getParallelMode() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(ScriptProperties.PARALLEL_MODE));
  }

  public void addConfiguredPlugin(Plugin plugin) {
    String property = myWhatToDo.getProperty(ScriptProperties.PLUGIN_PATHS);
    if ((property == null || property.length() == 0)) {
      property = plugin.getPath().getAbsolutePath();
    } else {
      property += File.pathSeparator + plugin.getPath().getAbsolutePath();
    }
    myWhatToDo.putProperty(ScriptProperties.PLUGIN_PATHS, property);
  }



  @Override
  protected Set<File> calculateClassPath(boolean fork) {
    List<File> classPathRoots = MPSClasspathUtil.getClassPathRootsFromDependencies(getProject());
    if (classPathRoots.isEmpty()) {
      throw new BuildException("Dependency on MPS build scripts is required to generate MPS modules.");

    }
    Set<File> classPath = new LinkedHashSet<File>();
    for (File file : classPathRoots) {
      MPSClasspathUtil.gatherAllClassesAndJarsUnder(file, classPath);
    }

    return classPath;
  }


}
