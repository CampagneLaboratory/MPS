package jetbrains.mps.core.util.merge;

/*Generated by MPS */

import jetbrains.mps.messages.IMessageHandler;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.DefaultSModelDescriptor;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.messages.Message;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.util.ArrayList;
import java.util.Collections;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class MergeSession {
  private IMessageHandler messageHandler;
  private Map<SNode, SNode> mapping;
  private Map<SNode, SNode> reverseMapping;
  private Map<DefaultSModelDescriptor, SModel> newContent;

  public MergeSession(IMessageHandler messageHandler) {
    this.messageHandler = messageHandler;
    this.mapping = MapSequence.fromMap(new HashMap<SNode, SNode>());
    this.reverseMapping = MapSequence.fromMap(new HashMap<SNode, SNode>());
    this.newContent = MapSequence.fromMap(new HashMap<DefaultSModelDescriptor, SModel>());
  }

  public boolean isMapped(SNode node) {
    return MapSequence.fromMap(mapping).containsKey(node);
  }

  public void replace(DefaultSModelDescriptor descriptor, Iterable<SNode> roots) {
    SModel existing = descriptor.getSModel();
    if (existing == null) {
      messageHandler.handle(new Message(MessageKind.ERROR, "no " + descriptor.getSModelReference().getLongName() + " model"));
      return;
    }

    final SModel newmodel = new SModel(descriptor.getSModelReference());
    newmodel.getSModelHeader().updateDefaults(descriptor.getSModelHeader());
    Sequence.fromIterable(mergeLists(SModelOperations.getRoots(existing, null), roots, newmodel)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        newmodel.addRoot(it);
      }
    });
    MapSequence.fromMap(newContent).put(descriptor, newmodel);
  }

  public void restoreRefs() {
    for (IMapping<SNode, SNode> m : MapSequence.fromMap(mapping)) {
      SNode input = m.key();
      SNode output = m.value();

      for (SReference ref : input.getReferencesIterable()) {
        SNode targetNode = ref.getTargetNodeSilently();
        if (targetNode == null) {
          messageHandler.handle(new Message(MessageKind.ERROR, "broken reference `" + ref.getRole() + "' in " + input.getDebugText()));
          continue;
        }
        if (MapSequence.fromMap(mapping).containsKey(targetNode)) {
          output.setReferent(ref.getRole(), MapSequence.fromMap(mapping).get(targetNode));
        } else {
          output.setReferent(ref.getRole(), targetNode);
        }
      }
    }

    this.mapping = null;
    this.reverseMapping = null;
  }

  public void apply() {
    ModelAccess.assertLegalWrite();

    for (IMapping<DefaultSModelDescriptor, SModel> entry : MapSequence.fromMap(newContent)) {
      final DefaultSModelDescriptor descriptor = entry.key();
      messageHandler.handle(new Message(MessageKind.INFORMATION, "replacing " + descriptor.getLongName()));
      descriptor.updateDiskTimestamp();
      descriptor.replaceModel(entry.value(), ModelLoadingState.FULLY_LOADED);
      descriptor.setChanged(true);
      ModelAccess.instance().runWriteInEDT(new Runnable() {
        public void run() {
          descriptor.save();
        }
      });
    }
  }

  private Iterable<SNode> mergeLists(Iterable<SNode> existing, Iterable<SNode> created, final SModel newmodel) {
    final Map<String, List<SNode>> existingNodes = MapSequence.fromMap(new HashMap<String, List<SNode>>());
    Sequence.fromIterable(existing).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        String signature = getSignature(it);
        if (!(MapSequence.fromMap(existingNodes).containsKey(signature))) {
          MapSequence.fromMap(existingNodes).put(signature, ListSequence.fromList(new LinkedList<SNode>()));
        }
        ListSequence.fromList(MapSequence.fromMap(existingNodes).get(signature)).addElement(it);
      }
    });
    final List<SNode> result = new ArrayList<SNode>();
    Sequence.fromIterable(created).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        String signature = getSignature(it);
        SNode existingNode = (MapSequence.fromMap(existingNodes).containsKey(signature) ?
          ListSequence.fromList(MapSequence.fromMap(existingNodes).get(signature)).removeElementAt(0) :
          null
        );
        ListSequence.fromList(result).addElement(merge(existingNode, it, newmodel));
      }
    });
    return result;
  }

  protected SNode merge(SNode existing, SNode node, SModel newmodel) {
    if (node == null) {
      return null;
    }
    SNode result = new SNode(newmodel, node.getConceptFqName(), false);
    MapSequence.fromMap(mapping).put(node, result);
    MapSequence.fromMap(reverseMapping).put(result, node);
    result.putProperties(node);
    result.putUserObjects(node);
    if (existing != null) {
      result.setId(existing.getSNodeId());
    }
    for (SNode child : mergeLists((existing == null ?
      Sequence.fromIterable(Collections.<SNode>emptyList()) :
      existing.getChildren(true)
    ), node.getChildren(true), newmodel)) {
      String role = MapSequence.fromMap(reverseMapping).get(child).getRole_();
      assert role != null;
      result.addChild(role, child);
    }
    return result;
  }

  protected String getSignature(SNode node) {
    String signature = ((SNodeOperations.getParent(node) == null) ?
      "{root}" :
      SNodeOperations.getContainingLinkRole(node)
    );
    assert signature != null;
    if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.lang.core.structure.INamedConcept")) {
      signature = "#" + SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.lang.core.structure.INamedConcept"), "name");
    }
    return signature;
  }
}
