package jetbrains.mps.ypath.generator.baseLanguage.template.helper;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.ext.collections.internal.query.ListOperations;
import jetbrains.mps.helgins.inference.TypeChecker;
import jetbrains.mps.ypath.constraints.ITreePathExpression_Behavior;
import jetbrains.mps.ypath.runtime.TraversalAxis;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.ext.collections.internal.query.SequenceOperations;

public class OperationsUtil {

  public static List<SNode> substituteApplicableOperations(SNode wildCardOp) {
    final zClosureContext _zClosureContext = new zClosureContext();
    if(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(wildCardOp, "usedFeature", false), "jetbrains.mps.ypath.structure.IParamFeature") && (SLinkOperations.getTarget(wildCardOp, "paramObject", true) != null)) {
      return ListOperations.createList(new SNode[]{wildCardOp});
    }
    SNode tpoe = SNodeOperations.getAncestor(wildCardOp, "jetbrains.mps.ypath.structure.TreePathOperationExpression", false, false);
    _zClosureContext.nodeType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(tpoe, "expression", true));
    SNode tp = ITreePathExpression_Behavior.call_getTreePath_1194366873089(tpoe);
    _zClosureContext.axis = TraversalAxis.parseValue(SPropertyOperations.getString_def(wildCardOp, "axis", "DESCENDANTS"));
    List<SNode> features = ((SLinkOperations.getTarget(wildCardOp, "usedFeature", false) == null) ?
      SequenceOperations.toList(SequenceOperations.where(SLinkOperations.getTargets(tp, "features", true), new zPredicate(null, _zClosureContext))) :
      ListOperations.createList(new SNode[]{SLinkOperations.getTarget(wildCardOp, "usedFeature", false)})
    );
    return SequenceOperations.toList(SequenceOperations.map(features, new zMapper(null, _zClosureContext)));
  }

  public static SNode unwrapExpression(SNode wrappedExp) {
    SNode expression = wrappedExp;
    if(SNodeOperations.isInstanceOf(expression, "jetbrains.mps.baseLanguage.structure.ParenthesizedExpression")) {
      expression = SLinkOperations.getTarget(expression, "expression", true);
    }
    if(SNodeOperations.isInstanceOf(expression, "jetbrains.mps.ypath.structure.TreePathAdapterExpression")) {
      expression = SLinkOperations.getTarget(expression, "expression", true);
    }
    if(SNodeOperations.isInstanceOf(expression, "jetbrains.mps.baseLanguage.structure.CastExpression")) {
      expression = SLinkOperations.getTarget(expression, "expression", true);
    }
    return expression;
  }

}
