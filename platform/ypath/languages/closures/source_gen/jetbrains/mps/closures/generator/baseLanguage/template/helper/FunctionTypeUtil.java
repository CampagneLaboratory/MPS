package jetbrains.mps.closures.generator.baseLanguage.template.helper;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SModelOperations;
import java.util.ArrayList;
import jetbrains.mps.helgins.inference.TypeChecker;
import java.util.Collections;
import java.util.Iterator;
import java.text.Collator;
import jetbrains.mps.closures.constraints.FunctionType_Behavior;
import jetbrains.mps.generator.template.ITemplateGenerator;
import java.util.Comparator;

public class FunctionTypeUtil {

  public static String getRuntimeSignature(SNode ft) {
    String[] paramTypes = new String[]{"_P","_Q","_S","_T"};
    StringBuilder sb = new StringBuilder();
    if((SLinkOperations.getTarget(ft, "resultType", true) != null) && !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ft, "resultType", true), "jetbrains.mps.baseLanguage.structure.VoidType"))) {
      sb.append("_R");
    } else
    {
      sb.append("_void");
    }
    int idx = paramTypes.length - SLinkOperations.getCount(ft, "parameterType");
    String sep = "_from";
    for(SNode t : SLinkOperations.getTargets(ft, "parameterType", true)) {
      sb.append(sep);
      sep = "_and";
      if(idx >= paramTypes.length) {
        sb.append("_not_enough_type_variables");
        break;
      }
      sb.append(paramTypes[idx]);
      idx = idx + 1;
    }
    return sb.toString();
  }

  public static List<SNode> getAllFunctionTypes(SModel sourceModel) {
    List<SNode> cls = SModelOperations.getNodes(sourceModel, "jetbrains.mps.closures.structure.ClosureLiteral");
    List<SNode> typesList = new ArrayList<SNode>();
    for(SNode cl : cls) {
      typesList.add(TypeChecker.getInstance().getTypeOf(cl));
    }
    List<SNode> funTypes = SModelOperations.getNodes(sourceModel, "jetbrains.mps.closures.structure.FunctionType");
    typesList.addAll(funTypes);
    Collections.sort(typesList, new FunctionTypeUtil.FunctionTypeComparator());
    SNode prev = null;
    for(Iterator it = typesList.iterator() ; it.hasNext() ; ) {
      SNode next = ((SNode)it.next());
      if(prev != null) {
        if(Collator.getInstance().compare(FunctionType_Behavior.call_getSignature_1199633062014(((SNode)prev)), FunctionType_Behavior.call_getSignature_1199633062014(((SNode)next))) == 0) {
          it.remove();
          continue;
        }
      }
      prev = next;
    }
    return typesList;
  }

  public static void addAdaptableFunctionTypeTarget(SNode adaptable, SNode target, ITemplateGenerator generator) {
    List<SNode> trgList = (List<SNode>)generator.getGeneratorSessionContext().getSessionObject("needs_adapted_" + FunctionType_Behavior.call_getSignature_1199633062014(adaptable));
    if(trgList == null) {
      trgList = new ArrayList<SNode>();
      generator.getGeneratorSessionContext().putSessionObject("needs_adapted_" + FunctionType_Behavior.call_getSignature_1199633062014(adaptable), trgList);
    }
    boolean hasOneAlready = false;
    for(SNode ft : trgList) {
      if(FunctionType_Behavior.call_getSignature_1199633062014(target).equals(FunctionType_Behavior.call_getSignature_1199633062014(ft))) {
        hasOneAlready = true;
        break;
      }
    }
    if(!(hasOneAlready)) {
      SNode trg = SNodeOperations.copyNode(target);
      trgList.add(trg);
      ((SNode)trg).putUserObject("adaptable", adaptable);
    }
  }

  public static List<SNode> getAdaptableFunctionTypeTargets(SNode adaptable, ITemplateGenerator generator) {
    return (List<SNode>)generator.getGeneratorSessionContext().getSessionObject("needs_adapted_" + FunctionType_Behavior.call_getSignature_1199633062014(adaptable));
  }

  public static void putPrepData(SNode sn, Object data, ITemplateGenerator generator) {
    generator.getGeneratorSessionContext().putSessionObject("functionType_prepdata_" + ((SNode)sn).getId(), data);
  }

  public static Object getPrepData(SNode sn, ITemplateGenerator generator) {
    return generator.getGeneratorSessionContext().getSessionObject("functionType_prepdata_" + ((SNode)sn).getId());
  }

  public static void putPostData(SNode sn, Object data, ITemplateGenerator generator) {
    generator.getGeneratorSessionContext().putSessionObject("functionType_postData_" + ((SNode)sn).getId(), data);
  }

  public static Object getPostData(SNode sn, ITemplateGenerator generator) {
    return generator.getGeneratorSessionContext().getSessionObject("functionType_postData_" + ((SNode)sn).getId());
  }

  public static class FunctionTypeComparator implements Comparator<SNode> {

    public  FunctionTypeComparator() {
    }

    public int compare(SNode x, SNode y) {
      return Collator.getInstance().compare(FunctionType_Behavior.call_getSignature_1199633062014(((SNode)x)), FunctionType_Behavior.call_getSignature_1199633062014(((SNode)y)));
    }

}

}
