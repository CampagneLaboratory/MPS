package treepathFeatures;

/*Generated by MPS */

import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ITranslator;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.ISequence;
import jetbrains.mps.internal.collections.runtime.ISequenceIterableAdapter;
import java.util.Iterator;
import jetbrains.mps.closures.runtime.YieldingIterator;
import jetbrains.mps.baseLanguage.ext.collections.internal.query.SequenceOperations;
import jetbrains.mps.baseLanguage.ext.collections.internal.SequenceWithSupplier;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.ext.collections.internal.query.ListOperations;
import java.util.List;
import jetbrains.mps.ypath.runtime.TreeTraversalFactory;

public class SnodeDemo {

  public static void main(String[] args) {
    final zClosureContext _zClosureContext = new zClosureContext();
    _zClosureContext.foo = null;
    ListSequence.fromList((SLinkOperations.getTargets(_zClosureContext.foo, "implements", true))).translate(new ITranslator <SNode, SNode>() {

      public ISequence<SNode> translate(final SNode it) {
        return new ISequenceIterableAdapter <SNode>() {

          public Iterator<SNode> iterator() {
            return new YieldingIterator <SNode>() {

              private int __CP__ = 0;

              protected boolean moveToNext() {
__loop__:
                do {
__switch__:
                  switch (this.__CP__) {
                    case -1:
                      assert false : "Internal error";
                      return false;
                    case 2:
                      this.__CP__ = 1;
                      this.yield(SLinkOperations.getTarget(it, "intfc", false));
                      return true;
                    case 0:
                      this.__CP__ = 2;
                      break;
                    default:
                      break __loop__;
                  }
                } while(true);
                return false;
              }

            };
          }

        };
      }

    }).translate(new ITranslator <SNode, SNode>() {

      public ISequence<SNode> translate(final SNode it) {
        return new ISequenceIterableAdapter <SNode>() {

          public Iterator<SNode> iterator() {
            return new YieldingIterator <SNode>() {

              private int __CP__ = 0;
              private SNode _2__zzz_;
              private Iterator<SNode> _2__zzz__it;

              protected boolean moveToNext() {
__loop__:
                do {
__switch__:
                  switch (this.__CP__) {
                    case -1:
                      assert false : "Internal error";
                      return false;
                    case 2:
                      this._2__zzz__it = SLinkOperations.getTargets(it, "extends", true).iterator();
                    case 3:
                      if (!(this._2__zzz__it.hasNext())) {
                        this.__CP__ = 1;
                        break;
                      }
                      this._2__zzz_ = this._2__zzz__it.next();
                      this.__CP__ = 4;
                      break;
                    case 5:
                      this.__CP__ = 3;
                      this.yield(this._2__zzz_);
                      return true;
                    case 0:
                      this.__CP__ = 2;
                      break;
                    case 4:
                      this.__CP__ = 5;
                      break;
                    default:
                      break __loop__;
                  }
                } while(true);
                return false;
              }

            };
          }

        };
      }

    });
    // The following ypath construct should result in the same expression as above
    SequenceOperations.map(SequenceOperations.map(new SequenceWithSupplier<SNode>(new zValueSupplier(null, _zClosureContext)), new zMapper1(null, _zClosureContext)), new zMapper(null, _zClosureContext));
    // Another pair of tests
    ListSequence.fromList(ListSequence.<SNode>fromArray(SLinkOperations.getTarget(_zClosureContext.foo, "extends", false))).translate(new ITranslator <SNode, SNode>() {

      public ISequence<SNode> translate(final SNode it) {
        return new ISequenceIterableAdapter <SNode>() {

          public Iterator<SNode> iterator() {
            return new YieldingIterator <SNode>() {

              private int __CP__ = 0;
              private SNode _2_p;
              private Iterator<SNode> _2_p_it;
              private SNode _5_c;
              private Iterator<SNode> _5_c_it;

              protected boolean moveToNext() {
__loop__:
                do {
__switch__:
                  switch (this.__CP__) {
                    case -1:
                      assert false : "Internal error";
                      return false;
                    case 2:
                      this._2_p_it = ListSequence.<SNode>fromArray(SNodeOperations.getParent(it, null, false, false)).iterator();
                    case 3:
                      if (!(this._2_p_it.hasNext())) {
                        this.__CP__ = 1;
                        break;
                      }
                      this._2_p = this._2_p_it.next();
                      this.__CP__ = 4;
                      break;
                    case 5:
                      this._5_c_it = SNodeOperations.getChildren(this._2_p).iterator();
                    case 6:
                      if (!(this._5_c_it.hasNext())) {
                        this.__CP__ = 8;
                        break;
                      }
                      this._5_c = this._5_c_it.next();
                      this.__CP__ = 7;
                      break;
                    case 9:
                      if (it == this._5_c) {
                        this.__CP__ = 10;
                        break;
                      }
                      this.__CP__ = 6;
                      break;
                    case 8:
                      this.__CP__ = 3;
                      this.yield(this._2_p);
                      return true;
                    case 0:
                      this.__CP__ = 2;
                      break;
                    case 4:
                      this.__CP__ = 5;
                      break;
                    case 7:
                      this.__CP__ = 9;
                      break;
                    case 10:
                      this.__CP__ = 1;
                      break;
                    default:
                      break __loop__;
                  }
                } while(true);
                return false;
              }

            };
          }

        };
      }

    });
    SequenceOperations.map(ListOperations.<SNode>createList(SLinkOperations.getTarget(_zClosureContext.foo, "extends", false)), new zMapper2(null, _zClosureContext));
    // And another one
    ListSequence.fromList(ListSequence.<SNode>fromArray(_zClosureContext.foo)).translate(new ITranslator <SNode, SNode>() {

      public ISequence<SNode> translate(final SNode it) {
        return new ISequenceIterableAdapter <SNode>() {

          public Iterator<SNode> iterator() {
            return new YieldingIterator <SNode>() {

              private int __CP__ = 0;
              private List<SNode> _3__yyy_;
              private SNode _7__xxx_;

              protected boolean moveToNext() {
__loop__:
                do {
__switch__:
                  switch (this.__CP__) {
                    case -1:
                      assert false : "Internal error";
                      return false;
                    case 4:
                      if (ListSequence.fromList(this._3__yyy_).isNotEmpty()) {
                        this.__CP__ = 5;
                        break;
                      }
                      this.__CP__ = 1;
                      break;
                    case 8:
                      this.__CP__ = 9;
                      this.yield(this._7__xxx_);
                      return true;
                    case 0:
                      this._3__yyy_ = ListSequence.<SNode>fromArray();
                      ListSequence.fromList(this._3__yyy_).addSequence(ListSequence.fromList(SNodeOperations.getChildren(it)));
                      this.__CP__ = 4;
                      break;
                    case 5:
                      this._7__xxx_ = ListSequence.fromList(this._3__yyy_).first();
                      ListSequence.fromList(this._3__yyy_).removeElement(this._7__xxx_);
                      this.__CP__ = 8;
                      break;
                    case 9:
                      ListSequence.fromList(this._3__yyy_).addSequence(ListSequence.fromList(SNodeOperations.getChildren(this._7__xxx_)));
                      this.__CP__ = 4;
                      break;
                    default:
                      break __loop__;
                  }
                } while(true);
                return false;
              }

            };
          }

        };
      }

    });
    new SequenceWithSupplier<SNode>(new zValueSupplier1(null, _zClosureContext));
    // Following is just a test
    SequenceOperations.map(new SequenceWithSupplier<SNode>(new zValueSupplier2(null, _zClosureContext)), new zMapper3(null, _zClosureContext));
    TreeTraversalFactory.Traverse(new SNODE().startTraversal(_zClosureContext.foo), TreeTraversalFactory.Axis("ANCESTORS"));
  }

}
