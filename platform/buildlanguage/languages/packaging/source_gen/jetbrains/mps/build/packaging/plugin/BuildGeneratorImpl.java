package jetbrains.mps.build.packaging.plugin;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import java.util.List;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.Solution;
import jetbrains.mps.vfs.MPSExtentions;
import jetbrains.mps.smodel.SModelDescriptor;
import com.intellij.openapi.vfs.VirtualFile;
import java.io.File;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.MPSProjectHolder;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.workbench.editors.MPSEditorOpener;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import java.util.LinkedHashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class BuildGeneratorImpl extends AbstractBuildGenerator {

  private final Project myProject;
  private List<Language> myLanguages;
  private List<Solution> mySolutions;

  public BuildGeneratorImpl(Project project) {
    this.myProject = project;
    String projectName = this.myProject.getName();
    if (projectName.endsWith(MPSExtentions.DOT_MPS_PROJECT)) {
      projectName = projectName.substring(0, projectName.length() - MPSExtentions.DOT_MPS_PROJECT.length());
    }
    this.setProjectName(projectName);
    this.setValidDefaultSolutionName(projectName);
  }

  public void generate() {
    this.generateInternal();
  }

  private void generateInternal() {
    this.generate(this.getSModelDescriptor(), this.getProjectName(), this.myProject.getBaseDir().getPath(), this.getModules());
  }

  public SModelDescriptor getSModelDescriptor() {
    if (this.getCreateModel()) {
      Solution solution;
      if (this.getCreateSolution()) {
        VirtualFile projectBaseDir = this.myProject.getBaseDir();
        //  get solution
        String solutionName = this.getNewSolutionName();
        String solutionBaseDir = projectBaseDir.getPath() + File.separator + "solutions" + File.separator + solutionName;
        MPSProject mpsProject = this.myProject.getComponent(MPSProjectHolder.class).getMPSProject();
        solution = BuildGeneratorUtil.createSolution(mpsProject, solutionName, solutionBaseDir);
      } else
      {
        solution = this.getSolution();
      }
      return BuildGeneratorUtil.createModel(this.getNewModelName(), solution);
    } else
    {
      return this.getModel();
    }
  }

  private void setValidDefaultSolutionName(String projectName) {
    String solutionNamePrefix = projectName + ".build";
    String solutionName = solutionNamePrefix;
    int count = 0;
    while (!(this.isValidSolutionName(solutionName))) {
      solutionName = solutionNamePrefix + count;
      count++ ;
    }
    this.setNewSolutionName(solutionName);
  }

  public void generate(SModelDescriptor targetModelDescriptor, String name, String basedir, List<NodeData> selectedData) {
    // create mps layout
    SNode mpsLayout = SConceptOperations.createNewNode("jetbrains.mps.build.packaging.structure.MPSLayout", null);
    // add mps layout to the target model
    SModel targetSModel = targetModelDescriptor.getSModel();
    targetSModel.addRoot(mpsLayout);
    // set properties
    SPropertyOperations.set(mpsLayout, "name", name);
    SPropertyOperations.set(mpsLayout, "basedir", basedir);
    SPropertyOperations.set(mpsLayout, "compile", "" + (true));
    SPropertyOperations.set(ListSequence.fromList(SLinkOperations.getTargets(mpsLayout, "configuration", true)).first(), "name", "default");
    // create zip
    SNode zip = SConceptOperations.createNewNode("jetbrains.mps.build.packaging.structure.Zip", null);
    SLinkOperations.setTarget(zip, "title", PackagingLanguageGenerator.createSimpleString(name + ".zip", targetSModel), true);
    SLinkOperations.addChild(mpsLayout, "component", zip);
    // create folder inside zip
    SNode folder = SConceptOperations.createNewNode("jetbrains.mps.build.packaging.structure.Folder", null);
    SLinkOperations.setTarget(folder, "title", PackagingLanguageGenerator.createSimpleString(name, targetSModel), true);
    SLinkOperations.addChild(zip, "entry", folder);
    // add modules to folder
    BuildGeneratorImpl.createContent(selectedData, folder, targetSModel);
    targetModelDescriptor.save();
    MPSEditorOpener editorOpener = this.myProject.getComponent(MPSEditorOpener.class);
    editorOpener.openNode(mpsLayout);
  }


  public static SNode createComponent(NodeData data, SModel targetSModel) {
    if (data instanceof ModuleData) {
      return PackagingLanguageGenerator.createModule(((ModuleData)data).getModule(), targetSModel);
    } else if (data instanceof NamespaceData) {
      String namespace = ((NamespaceData)data).getText();
      return PackagingLanguageGenerator.createFolder(namespace, targetSModel);
    }
    return null;
  }

  private static void createContent(List<NodeData> selectedData, SNode folder, SModel targetSModel) {
    Map<NodeData, SNode> createdComponent = MapSequence.fromMap(new HashMap<NodeData, SNode>());
    Set<SNode> topLevel = new LinkedHashSet<SNode>();
    for(NodeData data : selectedData) {
      // creating component
      SNode component = createComponent(data, targetSModel);
      if (component == null) {
        continue;
      }
      MapSequence.fromMap(createdComponent).put(data, component);
      topLevel.add(component);
      // dealing with children
      if (SNodeOperations.isInstanceOf(component, "jetbrains.mps.build.packaging.structure.ICompositeComponent")) {
        List<NodeData> children = data.getChildren();
        for(NodeData child : children) {
          if (MapSequence.fromMap(createdComponent).containsKey(child)) {
            SNode childComponent = MapSequence.fromMap(createdComponent).get(child);
            SLinkOperations.addChild(component, "entry", childComponent);
            if (topLevel.contains(childComponent)) {
              topLevel.remove(childComponent);
            }
          }
        }
      }
      // dealing with parent
      NodeData parent = data.getParent();
      if (parent == null) {
        break;
      }
      if (MapSequence.fromMap(createdComponent).containsKey(parent)) {
        SLinkOperations.addChild(MapSequence.fromMap(createdComponent).get(parent), "entry", component);
        topLevel.remove(component);
      }
    }
    // 
    for(SNode topLevelComponent : topLevel) {
      SLinkOperations.addChild(folder, "entry", topLevelComponent);
    }
  }

}
