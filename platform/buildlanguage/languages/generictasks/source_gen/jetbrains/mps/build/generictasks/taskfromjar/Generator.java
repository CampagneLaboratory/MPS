package jetbrains.mps.build.generictasks.taskfromjar;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.util.PathManager;
import jetbrains.mps.smodel.SModel;
import java.util.List;
import jetbrains.mps.build.generictasks.structure.BuiltInTaskDeclaration;
import java.io.IOException;
import java.util.Map;
import java.util.LinkedHashMap;
import java.util.Set;
import jetbrains.mps.build.generictasks.structure.NestedDeclaration;
import java.util.HashSet;
import jetbrains.mps.build.generictasks.structure.TaskReference;
import jetbrains.mps.build.generictasks.structure.AttributeDeclaration;
import jetbrains.mps.buildlanguage.structure.Enum;
import jetbrains.mps.buildlanguage.structure.StringEnum;
import jetbrains.mps.buildlanguage.structure.PropertyValueExpression;
import jetbrains.mps.buildlanguage.structure.StringLiteral;
import jetbrains.mps.build.generictasks.structure.TaskInterfaceDeclaration;
import jetbrains.mps.buildlanguage.structure.PropertyType;
import jetbrains.mps.buildlanguage.structure.IntegerType;
import jetbrains.mps.buildlanguage.structure.BooleanType;
import java.io.File;
import jetbrains.mps.buildlanguage.structure.FileType;
import org.apache.tools.ant.types.Reference;
import jetbrains.mps.buildlanguage.structure.CallReferenceType;
import jetbrains.mps.buildlanguage.structure.StringType;

public class Generator {
  private static final Logger LOG = Logger.getLogger(Generator.class);
  /*package*/ static final String ANT_PATH = PathManager.getHomePath() + "/lib/ant-1.7.0";
  private static final BuildLanguageGenerator GENERATOR = BuildLanguageGenerator.getInstance();

  public Generator() {
  }

  private String getPath(Generator.Modes m) {
    switch (m) {
      case CORE:
        return Generator.ANT_PATH + Scanner.LIB_ANT_JAR;
      case NODEPS:
        return Generator.ANT_PATH + Scanner.LIB_NODEPS_JAR;
      case JUNIT:
        return Generator.ANT_PATH + Scanner.LIB_ANT_JUNIT_JAR;
      default:
    }
    throw new IllegalArgumentException("Unknown mode " + m);
  }

  public void generateTasks(SModel model, Generator.Modes m, SModel[] allModels) {
    try {
      Scanner scanner = new Scanner(Generator.ANT_PATH, getPath(m));
      List<ClassInfo> toImport = scanner.scan();
      Importer.IClassInfoProvider provider = scanner.createClassInfoProvider();
      NamesMap namesMap = scanner.getNamesMap();
      Importer<BuiltInTaskDeclaration> importer = new Importer<BuiltInTaskDeclaration>(toImport, this.getExistingDeclarations(allModels), provider);
      Generator.Builder builder = new Generator.Builder(model, namesMap);
      for (ClassInfo cl : scanner.getRoots()) {
        importer.createDeclaration(builder, cl);
      }
      importer.importAll(builder);
    } catch (IOException e) {
      Generator.LOG.error(e);
    } catch (ClassNotFoundException e) {
      Generator.LOG.error(e);
    }
  }

  private Map<String, BuiltInTaskDeclaration> getExistingDeclarations(SModel[] models) {
    Map<String, BuiltInTaskDeclaration> declarations = new LinkedHashMap<String, BuiltInTaskDeclaration>();
    for (SModel model : models) {
      List<BuiltInTaskDeclaration> roots = model.getRootsAdapters(BuiltInTaskDeclaration.class);
      for (BuiltInTaskDeclaration decl : roots) {
        this.cleanDeclaration(decl);
        declarations.put(decl.getClassname(), decl);
      }
    }
    return declarations;
  }

  private void cleanDeclaration(BuiltInTaskDeclaration decl) {
    Set<NestedDeclaration> toRemoveNestedReference = new HashSet<NestedDeclaration>();
    for (NestedDeclaration nref : decl.getNesteds()) {
      for (NestedDeclaration ref : decl.getNesteds()) {
        if (ref.equals(nref)) {
          continue;
        }
        if (ref.getDeclaration().getClassname().equals(nref.getDeclaration().getClassname())) {
          toRemoveNestedReference.add(ref);
        }
      }
    }
    for (NestedDeclaration nref : toRemoveNestedReference) {
      decl.removeChild(nref);
      for (TaskReference roleRef : nref.getRoles()) {
        if (((BuiltInTaskDeclaration) roleRef.getDeclaration()).getFake()) {
          decl.removeChild(roleRef.getDeclaration());
        }
      }
    }
    for (BuiltInTaskDeclaration fakedecl : decl.getFakeDeclarations()) {
      fakedecl.setFake(true);
    }
    Set<BuiltInTaskDeclaration> toRemoveFakeDeclaration = new HashSet<BuiltInTaskDeclaration>();
    toRemoveFakeDeclaration.addAll(decl.getFakeDeclarations());
    for (NestedDeclaration nref : decl.getNesteds()) {
      for (TaskReference roleRef : nref.getRoles()) {
        if (((BuiltInTaskDeclaration) roleRef.getDeclaration()).getFake()) {
          toRemoveFakeDeclaration.remove(roleRef.getDeclaration());
        }
      }
    }
    for (BuiltInTaskDeclaration fakedecl : toRemoveFakeDeclaration) {
      decl.removeChild(fakedecl);
    }
    for (NestedDeclaration nref : decl.getNesteds()) {
      for (TaskReference roleRef : nref.getRoles()) {
        if (((BuiltInTaskDeclaration) roleRef.getDeclaration()).getFake() && roleRef.getDeclaration().getName().equals(nref.getDeclaration().getName())) {
          nref.removeChild(roleRef);
          decl.removeChild(roleRef.getDeclaration());
          break;
        }
      }
    }
  }

  public static   enum Modes {
    CORE(),
    NODEPS(),
    JUNIT();

    Modes() {
    }
  }

  public static class Builder implements Importer.IBuilder<BuiltInTaskDeclaration> {
    protected final SModel myModel;
    private final NamesMap myNamesMap;

    public Builder(SModel model, NamesMap namesMap) {
      this.myModel = model;
      this.myNamesMap = namesMap;
    }

    public BuiltInTaskDeclaration createDeclaration(ClassInfo ci) {
      String classname = ci.getDeclarationClass().getName();
      String name = this.myNamesMap.getNameForClass(ci.getDeclarationClass());
      if (ci.isInterface()) {
        return Generator.GENERATOR.createInterfaceDeclaration(this.myModel, name, classname, ci.isDeprecated(), true);
      }
      return Generator.GENERATOR.createDeclaration(this.myModel, name, classname, ci.isAbstract(), ci.canHaveInternalText(), ci.isDeprecated(), true);
    }

    public void addParent(BuiltInTaskDeclaration declaration, BuiltInTaskDeclaration parent) {
      TaskReference ref = Generator.GENERATOR.createDeclarationReference(this.myModel, parent);
      declaration.setParentRef(ref);
    }

    public void addInterface(BuiltInTaskDeclaration declaration, BuiltInTaskDeclaration interfaceDeclaration) {
      List<TaskReference> interfaces = declaration.getInterfaceses();
      for (TaskReference in : interfaces) {
        if (in.getDeclaration().getName().equals(interfaceDeclaration.getName())) {
          return;
        }
      }
      TaskReference ref = Generator.GENERATOR.createDeclarationReference(this.myModel, interfaceDeclaration);
      declaration.addInterfaces(ref);
    }

    public void addAttribute(BuiltInTaskDeclaration declaration, ClassInfo.MyAttribute attribute) {
      List<AttributeDeclaration> attrDecls = declaration.getAttributesDecls();
      for (AttributeDeclaration attributeDeclaration : attrDecls) {
        if (attributeDeclaration.getName().equals(attribute.getName())) {
          if (ImportOptions.getInstance().isNeedUpdateAttributes()) {
            this.updateAttribute(attributeDeclaration, attribute);
          } else {
          }
          return;
        }
      }
      this.createAttribute(declaration, attribute);
    }

    private void updateAttribute(AttributeDeclaration attributeDeclaration, ClassInfo.MyAttribute attribute) {
      attributeDeclaration.setAttributeType(Generator.Builder.getType(attribute.getType(), this.myModel));
      if (attribute.getEnumValues() != null) {
        Enum anEnum = attributeDeclaration.getEnum();
        if ((anEnum != null) && (anEnum instanceof StringEnum)) {
          this.updateEnum((StringEnum) anEnum, attribute.getEnumValues());
        } else {
          this.addEnum(attributeDeclaration, attribute.getEnumValues());
        }
      }
      if (!(attributeDeclaration.getDeprecated()) && attribute.isDeprecated()) {
        attributeDeclaration.setDeprecated(attribute.isDeprecated());
      }
    }

    private void createAttribute(BuiltInTaskDeclaration decl, ClassInfo.MyAttribute attribute) {
      AttributeDeclaration attrDecl = Generator.GENERATOR.createAttributeDeclaration(this.myModel, attribute.getName(), Generator.Builder.getType(attribute.getType(), this.myModel));
      attrDecl.setDeprecated(attribute.isDeprecated());
      this.addEnum(attrDecl, attribute.getEnumValues());
      decl.addAttributesDecl(attrDecl);
    }

    private void addEnum(AttributeDeclaration attrDecl, String[] enumValues) {
      if (enumValues == null) {
        return;
      }
      StringEnum stringEnum = StringEnum.newInstance(this.myModel, true);
      this.updateEnum(stringEnum, enumValues);
      attrDecl.setEnum(stringEnum);
    }

    private void updateEnum(StringEnum stringEnum, String[] enumValues) {
      Set<String> set = new HashSet<String>();
      for (PropertyValueExpression lit : stringEnum.getConstantses()) {
        set.add(lit.toString());
      }
      for (String str : enumValues) {
        if (set.contains(str)) {
          continue;
        }
        StringLiteral literal = Generator.GENERATOR.createStringLiteral(this.myModel, str);
        stringEnum.addConstants(literal);
      }
    }

    public void addNested(BuiltInTaskDeclaration declaration, BuiltInTaskDeclaration nestedDeclaration, ClassInfo.Nested nested) {
      for (NestedDeclaration nref : declaration.getNesteds()) {
        if (nref.getDeclaration().equals(nestedDeclaration)) {
          for (String name : nested.getNames()) {
            this.addNestedName(declaration, nref, name);
          }
          return;
        }
      }
      NestedDeclaration nref = Generator.GENERATOR.createNestedReference(this.myModel, nestedDeclaration);
      if (nref.getDeclaration().equals(nestedDeclaration)) {
        for (String name : nested.getNames()) {
          this.addNestedName(declaration, nref, name);
        }
      }
      declaration.addNested(nref);
    }

    private void addNestedName(BuiltInTaskDeclaration declaration, NestedDeclaration nref, String name) {
      for (TaskReference reference : nref.getRoles()) {
        if (reference.getDeclaration().getName().equals(name)) {
          return;
        }
      }
      if (name.equals(nref.getDeclaration().getName())) {
        nref.addRole(Generator.GENERATOR.createDeclarationReference(this.myModel, ((BuiltInTaskDeclaration) nref.getDeclaration())));
        return;
      }
      BuiltInTaskDeclaration parentDeclaration = ((BuiltInTaskDeclaration) nref.getDeclaration());
      TaskReference parentRef = Generator.GENERATOR.createDeclarationReference(this.myModel, parentDeclaration);
      BuiltInTaskDeclaration fake;
      if (parentDeclaration instanceof TaskInterfaceDeclaration) {
        fake = Generator.GENERATOR.createInterfaceDeclaration(this.myModel, name, parentDeclaration.getClassname(), parentDeclaration.getDepracated(), false);
        fake.addInterfaces(parentRef);
      } else {
        fake = Generator.GENERATOR.createDeclaration(this.myModel, name, parentDeclaration.getClassname(), parentDeclaration.getAbstract(), parentDeclaration.getCanHaveInternalText(), parentDeclaration.getDepracated(), false);
        fake.setParentRef(parentRef);
      }
      fake.setFake(true);
      nref.addRole(Generator.GENERATOR.createDeclarationReference(this.myModel, fake));
      declaration.addFakeDeclaration(fake);
    }

    public void updateDeclaration(BuiltInTaskDeclaration declaration, ClassInfo ci) {
      if (ImportOptions.getInstance().isNeedUpdateDeclarations()) {
        String name = this.myNamesMap.getNameForClass(ci.getDeclarationClass());
        if ((declaration.getName() == null) || !(declaration.getName().equals(name))) {
          declaration.setName(name);
          System.out.format("Declaration %s name has been set to %s.\n", ci.getDeclarationClass().getName(), name);
        }
        if (declaration.getClassname() == null) {
          declaration.setClassname(ci.getDeclarationClass().getName());
        }
        if (declaration.getAbstract() != ci.isAbstract()) {
          System.out.format("Declaration %s abstract proprety has been set to %b.\n", ci.getDeclarationClass().getName(), ci.isAbstract());
          declaration.setAbstract(ci.isAbstract());
        }
        if (declaration.getCanHaveInternalText() != ci.canHaveInternalText()) {
          System.out.format("Declaration %s can have internal name proprety has been set to %b.\n", ci.getDeclarationClass().getName(), ci.canHaveInternalText());
          declaration.setCanHaveInternalText(ci.canHaveInternalText());
        }
        if (!(declaration.getDepracated()) && ci.isDeprecated()) {
          declaration.setDepracated(ci.isDeprecated());
          System.out.format("Declaration %s has been set deprecated.\n", ci.getDeclarationClass().getName());
        }
      }
    }

    private static PropertyType getType(Class<?> clazz, SModel model) {
      if (clazz.equals(int.class)) {
        return IntegerType.newInstance(model, true);
      } else
      if (clazz.equals(boolean.class)) {
        return BooleanType.newInstance(model, true);
      } else
      if (clazz.equals(File.class)) {
        return FileType.newInstance(model, true);
      } else
      if (clazz.getName().equals(Reference.class.getName())) {
        return CallReferenceType.newInstance(model, true);
      } else {
        return StringType.newInstance(model, true);
      }
    }
  }
}
