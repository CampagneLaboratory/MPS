package jetbrains.mps.buildlanguage.plugin;

/*Generated by MPS */

import javax.swing.table.TableModel;
import java.util.List;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import javax.swing.event.TableModelListener;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import javax.swing.event.TableModelEvent;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SNodeId;

public class BuildTableModel implements TableModel {
  private static String[] NAMES = {"Script Name" ,"Model" ,"Command Line"};

  private List<SNodePointer> mySNodes = ListSequence.fromList(new ArrayList<SNodePointer>());
  private Map<SNodePointer, String> myCommandLines = MapSequence.fromMap(new HashMap<SNodePointer, String>());
  private final Set<TableModelListener> myListeners = SetSequence.fromSet(new LinkedHashSet<TableModelListener>());

  public BuildTableModel(Map<String, String> data) {
    this.updateStateInternal(loadState(data));
  }

  public void updateState(Map<String, String> data) {
    Map<SNodePointer, String> pointersToMap = loadState(data);
    this.updateStateInternal(pointersToMap);
  }

  private void updateStateInternal(Map<SNodePointer, String> pointersToMap) {
    ListSequence.fromList(this.mySNodes).clear();
    MapSequence.fromMap(this.myCommandLines).clear();
    for (SNodePointer pointer : SetSequence.fromSet(MapSequence.fromMap(pointersToMap).keySet())) {
      ListSequence.fromList(this.mySNodes).addElement(pointer);
      MapSequence.fromMap(this.myCommandLines).put(pointer, MapSequence.fromMap(pointersToMap).get(pointer));
    }
  }

  public void addTableModelListener(TableModelListener listener) {
    SetSequence.fromSet(this.myListeners).addElement(listener);
  }

  public Class<?> getColumnClass(int column) {
    if (column != 0) {
      return String.class;
    } else {
      return SNodePointer.class;
    }
  }

  public int getColumnCount() {
    return NAMES.length;
  }

  public String getColumnName(int p0) {
    return NAMES[p0];
  }

  public int getRowCount() {
    return ListSequence.fromList(this.mySNodes).count();
  }

  public Object getValueAt(int row, int column) {
    final SNodePointer snode = ListSequence.fromList(this.mySNodes).getElement(row);
    if (column == 0) {
      final Wrappers._T<String> name = new Wrappers._T<String>();
      ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<String>() {
        public String invoke() {
          return name.value = snode.getNode().getName();
        }
      }));
      return name.value;
    } else if (column == 1) {
      return snode.getModelReference().getSModelFqName();
    }
    return MapSequence.fromMap(this.myCommandLines).get(snode);
  }

  public boolean isCellEditable(int row, int column) {
    return column == 2;
  }

  public void removeTableModelListener(TableModelListener listener) {
    SetSequence.fromSet(this.myListeners).removeElement(listener);
  }

  public void setValueAt(Object value, int row, int column) {
    assert column == 2;
    MapSequence.fromMap(this.myCommandLines).put(ListSequence.fromList(this.mySNodes).getElement(row), (String) value);
    this.notifyListeners();
  }

  private void notifyListeners() {
    TableModelEvent event = new TableModelEvent(this);
    for (TableModelListener l : SetSequence.fromSet(this.myListeners)) {
      l.tableChanged(event);
    }
  }

  public Map<String, String> saveState() {
    Map<String, String> mapToSerialize = MapSequence.fromMap(new HashMap<String, String>());
    for (SNodePointer pointer : ListSequence.fromList(this.mySNodes)) {
      MapSequence.fromMap(mapToSerialize).put(pointerToString(pointer), MapSequence.fromMap(this.myCommandLines).get(pointer));
    }
    return mapToSerialize;
  }

  public static Map<SNodePointer, String> loadState(Map<String, String> state) {
    Map<SNodePointer, String> result = MapSequence.fromMap(new HashMap<SNodePointer, String>());
    if (state == null) {
      return result;
    }
    for (String name : SetSequence.fromSet(MapSequence.fromMap(state).keySet())) {
      final SNodePointer pointer = stringToPointer(name);
      final Wrappers._T<SNode> node = new Wrappers._T<SNode>();
      ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          return node.value = pointer.getNode();
        }
      }));
      if (node.value != null) {
        MapSequence.fromMap(result).put(pointer, MapSequence.fromMap(state).get(name));
      }
    }
    return result;
  }

  private static SNodePointer stringToPointer(String pointerString) {
    String[] split = pointerString.split("#");
    SModelReference smodelId = SModelReference.fromString(split[0]);
    SNodeId id = SNodeId.fromString(split[1]);
    return new SNodePointer(smodelId, id);
  }

  public static String pointerToString(final SNodePointer pointer) {
    final Wrappers._T<String> value = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<String>() {
      public String invoke() {
        return value.value = pointer.getModel().getSModelReference().toString() + "#" + pointer.getNode().getId();
      }
    }));
    return value.value;
  }
}
