package jetbrains.mps.build.ant.generation.workers;

/*Generated by MPS */

import jetbrains.mps.build.ant.MpsWorker;
import jetbrains.mps.build.ant.WhatToDo;
import org.apache.tools.ant.ProjectComponent;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.build.ant.generation.GenerateTask;
import jetbrains.mps.ide.generator.GenerationSettings;
import org.apache.tools.ant.BuildException;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.generator.GeneratorManager;
import jetbrains.mps.generator.GenerationListener;
import java.util.List;
import jetbrains.mps.generator.GenerationAdapter;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.generator.generationTypes.java.JavaGenerationHandler;
import jetbrains.mps.util.Pair;
import jetbrains.mps.ide.progress.util.ModelsProgressUtil;
import jetbrains.mps.ide.progress.ITaskProgressHelper;
import java.io.IOException;
import jetbrains.mps.generator.GenerationCanceledException;
import jetbrains.mps.reloading.ClassLoaderManager;
import com.intellij.openapi.progress.EmptyProgressIndicator;
import java.util.Map;
import java.util.LinkedHashMap;
import java.util.Set;
import com.intellij.openapi.util.Computable;
import jetbrains.mps.make.dependencies.StronglyConnectedModules;
import java.util.ArrayList;
import java.io.File;
import jetbrains.mps.generator.generationTypes.IGenerationHandler;
import jetbrains.mps.messages.IMessageHandler;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.generator.GenerationOptions;
import java.util.Collections;
import jetbrains.mps.messages.IMessage;
import java.util.HashSet;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.make.dependencies.graph.IVertex;

public class GeneratorWorker extends MpsWorker {
  protected final GeneratorWorker.MyMessageHandler myMessageHandler = new GeneratorWorker.MyMessageHandler();

  public GeneratorWorker(WhatToDo whatToDo) {
    super(whatToDo);
  }

  public GeneratorWorker(WhatToDo whatToDo, ProjectComponent component) {
    super(whatToDo, component);
  }

  public GeneratorWorker(WhatToDo whatToDo, MpsWorker.AntLogger logger) {
    super(whatToDo, logger);
  }

  protected void executeTask(final MPSProject project, MpsWorker.ObjectsToProcess go) {
    setGenerationProperties();
    if (go.hasAnythingToGenerate()) {
      generate(project, go);
    }
  }

  private void setGenerationProperties() {
    if (myWhatToDo.getProperty(GenerateTask.PER_ROOT_GENERATION) != null) {
      boolean perRootGeneration = Boolean.parseBoolean(myWhatToDo.getProperty(GenerateTask.PER_ROOT_GENERATION));
      GenerationSettings.getInstance().setParallelGenerator(perRootGeneration);
      GenerationSettings.getInstance().setStrictMode(perRootGeneration);
      info("Per-root generation set to " + perRootGeneration);
    }
  }

  protected void showStatistic() {
    if (!(myErrors.isEmpty()) && myWhatToDo.getFailOnError()) {
      StringBuffer sb = new StringBuffer();
      sb.append(myErrors.size());
      sb.append(" errors during generation:\n");
      for (String error : myErrors) {
        sb.append(error);
        sb.append("\n");
      }
      throw new BuildException(sb.toString());
    }
  }

  private void generate(MPSProject project, MpsWorker.ObjectsToProcess go) {
    StringBuffer s = new StringBuffer("Generating:");
    for (MPSProject p : go.getProjects()) {
      s.append("\n    ");
      s.append(p);
    }
    for (IModule m : go.getModules()) {
      s.append("\n    ");
      s.append(m);
    }
    for (SModelDescriptor m : go.getModels()) {
      s.append("\n    ");
      s.append(m);
    }
    info(s.toString());
    final GeneratorManager gm = project.getProject().getComponent(GeneratorManager.class);
    final GenerationListener generationListener = getGenerationListener();
    gm.addGenerationListener(generationListener);
    List<GeneratorWorker.Cycle> order = computeGenerationOrder(project, go);
    for (final GeneratorWorker.Cycle cycle : order) {
      generateModulesCycle(gm, cycle);
    }
    gm.removeGenerationListener(generationListener);
  }

  protected GenerationListener getGenerationListener() {
    return new GenerationAdapter();
  }

  protected void generateModulesCycle(final GeneratorManager gm, final GeneratorWorker.Cycle cycle) {
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        info("Start " + cycle);
        cycle.generate(gm, new JavaGenerationHandler() {
          @Override
          public long estimateCompilationMillis(List<Pair<IModule, List<SModelDescriptor>>> input) {
            if (requiresCompilationAfterGeneration()) {
              return super.estimateCompilationMillis(input);
            }
            return ModelsProgressUtil.estimateReloadAllTimeMillis();
          }

          @Override
          protected boolean compileModuleInMPS(IModule module, ITaskProgressHelper progressHelper) throws IOException, GenerationCanceledException {
            return !(requiresCompilationAfterGeneration()) || super.compileModuleInMPS(module, progressHelper);
          }

          private boolean requiresCompilationAfterGeneration() {
            return Boolean.parseBoolean(myWhatToDo.getProperty(GenerateTask.COMPILE));
          }
        }, myMessageHandler);
        info("Reloading classes...");
        ClassLoaderManager.getInstance().reloadAll(new EmptyProgressIndicator());
        info("Finished " + cycle);
      }
    });
  }

  protected List<GeneratorWorker.Cycle> computeGenerationOrder(MPSProject project, MpsWorker.ObjectsToProcess go) {
    final Map<IModule, List<SModelDescriptor>> moduleToModels = new LinkedHashMap<IModule, List<SModelDescriptor>>();
    extractModels(go.getProjects(), go.getModules(), go.getModels(), moduleToModels);
    List<Set<IModule>> modulesOrder = ModelAccess.instance().runReadAction(new Computable<List<Set<IModule>>>() {
      public List<Set<IModule>> compute() {
        return StronglyConnectedModules.getInstance().getStronglyConnectedComponents(moduleToModels.keySet(), new StronglyConnectedModules.IModuleDecoratorBuilder<IModule, StronglyConnectedModules.IModuleDecorator<IModule>>() {
          public StronglyConnectedModules.IModuleDecorator<IModule> decorate(IModule module) {
            return new GeneratorWorker.ModuleDecorator(module);
          }
        });
      }
    });
    List<GeneratorWorker.Cycle> cycles = new ArrayList<GeneratorWorker.Cycle>();
    for (Set<IModule> modulesSet : modulesOrder) {
      GeneratorWorker.SimpleModuleCycle cycle = new GeneratorWorker.SimpleModuleCycle(project, modulesSet, moduleToModels);
      cycles.add(cycle);
    }
    return cycles;
  }

  protected void extractModels(Set<MPSProject> projects, Set<IModule> modules, Set<SModelDescriptor> models, Map<IModule, List<SModelDescriptor>> moduleToModels) {
    for (MPSProject mpsProject : projects) {
      extractModels(models, mpsProject);
    }
    for (IModule m : modules) {
      List<SModelDescriptor> modelsList = new ArrayList<SModelDescriptor>();
      moduleToModels.put(m, modelsList);
      extractModels(modelsList, m);
    }
    for (final SModelDescriptor model : models) {
      assert model != null;
      IModule owningModule = ModelAccess.instance().runReadAction(new Computable<IModule>() {
        public IModule compute() {
          return model.getModule();
        }
      });
      if (owningModule == null) {
        warning("Model " + model.getLongName() + " won't be generated because module for it can not be found.");
      } else {
        List<SModelDescriptor> modelsList = moduleToModels.get(owningModule);
        if (modelsList == null) {
          modelsList = new ArrayList<SModelDescriptor>();
          moduleToModels.put(owningModule, modelsList);
        }
        modelsList.add(model);
      }
    }
  }

  public static void main(String[] args) {
    MpsWorker mpsWorker = new GeneratorWorker(WhatToDo.fromDumpInFile(new File(args[0])), new MpsWorker.LogLogger());
    mpsWorker.workFromMain();
  }

  protected static interface Cycle {
    public void generate(GeneratorManager gm, IGenerationHandler generationHandler, IMessageHandler messageHandler);
    public List<File> getClassPath();
  }

  protected static class SimpleModuleCycle implements GeneratorWorker.Cycle {
    private final Set<IModule> myModules;
    private final MPSProject myProject;
    private final Map<IModule, List<SModelDescriptor>> myModuleToModels;

    public SimpleModuleCycle(MPSProject project, Set<IModule> modules, Map<IModule, List<SModelDescriptor>> moduleToModels) {
      myModules = modules;
      myProject = project;
      myModuleToModels = moduleToModels;
    }

    public void generate(GeneratorManager gm, IGenerationHandler generationHandler, IMessageHandler messageHandler) {
      List<SModelDescriptor> inputModels = new ArrayList<SModelDescriptor>();
      for (IModule module : myModules) {
        List<SModelDescriptor> modelsToGenerateNow = myModuleToModels.get(module);
        for (SModelDescriptor model : modelsToGenerateNow) {
          inputModels.add(model);
        }
      }
      gm.generateModels(inputModels, ProjectOperationContext.get(myProject.getProject()), generationHandler, new EmptyProgressIndicator(), messageHandler, GenerationOptions.getDefaults().create());
    }

    @Override
    public List<File> getClassPath() {
      return Collections.emptyList();
    }

    @Override
    public String toString() {
      return "generate " + myModules.toString();
    }
  }

  /*package*/ class MyMessageHandler implements IMessageHandler {
    private final List<String> myGenerationErrors = new ArrayList<String>();
    private final List<String> myGenerationWarnings = new ArrayList<String>();

    /*package*/ MyMessageHandler() {
    }

    public void handle(IMessage msg) {
      switch (msg.getKind()) {
        case ERROR:
          GeneratorWorker.this.error(msg.getText());
          if (msg.getException() != null) {
            myGenerationErrors.add(MpsWorker.extractStackTrace(msg.getException()).toString());
          } else {
            myGenerationErrors.add(msg.getText());
          }
          break;
        case WARNING:
          GeneratorWorker.this.warning(msg.getText());
          myGenerationWarnings.add(msg.getText());
          break;
        case INFORMATION:
          GeneratorWorker.this.verbose(msg.getText());
          break;
        default:
      }
    }

    public List<String> getGenerationErrors() {
      return myGenerationErrors;
    }

    public List<String> getGenerationWarnings() {
      return myGenerationWarnings;
    }

    public void clean() {
      myGenerationErrors.clear();
      myGenerationWarnings.clear();
    }

    public void clear() {
    }
  }

  private static class ModuleDecorator implements StronglyConnectedModules.IModuleDecorator<IModule> {
    private final IModule myModule;
    private final Set<GeneratorWorker.ModuleDecorator> myNext = new HashSet<GeneratorWorker.ModuleDecorator>();

    public ModuleDecorator(IModule module) {
      myModule = module;
    }

    public IModule getModule() {
      return myModule;
    }

    public void fill(Map<IModule, StronglyConnectedModules.IModuleDecorator<IModule>> map) {
      for (IModule m : new ArrayList<IModule>(myModule.getDependenciesManager().getDependOnModules())) {
        GeneratorWorker.ModuleDecorator next = (GeneratorWorker.ModuleDecorator) map.get(m);
        if (next != null) {
          myNext.add(next);
        }
      }
      if (myModule instanceof Language) {
        Language language = (Language) myModule;
        for (Generator gen : language.getGenerators()) {
          GeneratorWorker.ModuleDecorator generatorDecorator = (GeneratorWorker.ModuleDecorator) map.get(gen);
          if (generatorDecorator != null) {
            generatorDecorator.myNext.add(this);
            myNext.add(generatorDecorator);
          }
        }
      }
    }

    public Set<? extends IVertex> getNexts() {
      return Collections.unmodifiableSet(myNext);
    }

    public int compareTo(StronglyConnectedModules.IModuleDecorator<IModule> o) {
      return myModule.getModuleFqName().compareTo(o.getModule().getModuleFqName());
    }
  }
}
