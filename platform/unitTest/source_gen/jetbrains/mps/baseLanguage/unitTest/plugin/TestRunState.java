package jetbrains.mps.baseLanguage.unitTest.plugin;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.util.Key;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestCase_Behavior;
import jetbrains.mps.baseLanguage.unitTest.behavior.ITestMethod_Behavior;
import jetbrains.mps.baseLanguage.unitTest.runtime.TestEvent;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class TestRunState {
  private static final Object lock = new Object();

  private final List<String> myTestMethods = ListSequence.fromList(new ArrayList<String>());
  private Map<SNode, List<SNode>> myTestToMethodsMap = MapSequence.fromMap(new LinkedHashMap<SNode, List<SNode>>(16, (float) 0.75, false));
  private final Set<TestView> myViewsList = SetSequence.fromSet(new HashSet<TestView>());
  private final List<TestStateListener> myListeners = ListSequence.fromList(new ArrayList<TestStateListener>());
  private String myCurrentClass;
  private String myCurrentMethod;
  private String myCurrentToken;
  private String myLostTest;
  private String myLostMethod;
  private int myTotalTests = 0;
  private int myCompletedTests = 0;
  private int myDefectTests = 0;
  private boolean myIsTerminated;
  private String myAvailableText = null;
  private Key myKey = null;

  public TestRunState(List<SNode> testCases, List<SNode> testMethods, StatisticsTableModel statisticsModel) {
    this.initTestState(testCases, testMethods);
  }

  public TestRunState(List<SNode> tests) {
    this.initTestState(ListSequence.fromList(tests).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.unitTest.structure.ITestCase");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.unitTest.structure.ITestCase");
      }
    }).toListSequence(), ListSequence.fromList(tests).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.unitTest.structure.ITestMethod");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.unitTest.structure.ITestMethod");
      }
    }).toListSequence());
  }

  private void initTestState(final List<SNode> testCases, final List<SNode> testMethods) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        TestRunState.this.addTestCases(testCases);
        TestRunState.this.addTestMethods(testMethods);
        for (SNode testCase : MapSequence.fromMap(TestRunState.this.myTestToMethodsMap).keySet()) {
          for (SNode testMethod : MapSequence.fromMap(TestRunState.this.myTestToMethodsMap).get(testCase)) {
            ListSequence.fromList(TestRunState.this.myTestMethods).addElement(ITestCase_Behavior.call_getClassName_1216136193905(testCase) + '.' + ITestMethod_Behavior.call_getTestName_1216136419751(testMethod));
          }
        }
      }
    });
    this.myTotalTests = ListSequence.fromList(this.myTestMethods).count();

    this.initView();
  }

  private void addTestCases(List<SNode> testCases) {
    for (SNode testCase : ListSequence.fromList(testCases)) {
      List<SNode> testMethods = new ArrayList<SNode>();
      MapSequence.fromMap(this.myTestToMethodsMap).put(testCase, testMethods);
      ListSequence.fromList(testMethods).addSequence(ListSequence.fromList(ITestCase_Behavior.call_getTestSet_1216130724401(testCase)));
    }
  }

  private void addTestMethods(List<SNode> testMethods) {
    for (SNode testMethod : ListSequence.fromList(testMethods)) {
      SNode testCase = ITestMethod_Behavior.call_getTestCase_1216134500045(testMethod);
      List<SNode> curTestMethods = MapSequence.fromMap(this.myTestToMethodsMap).get(testCase);
      if (curTestMethods == null) {
        curTestMethods = new ArrayList<SNode>();
        MapSequence.fromMap(this.myTestToMethodsMap).put(testCase, curTestMethods);
      }
      if (!(ListSequence.fromList(curTestMethods).contains(testMethod))) {
        ListSequence.fromList(curTestMethods).addElement(testMethod);
      }
    }
  }

  private void updateView() {
    for (TestView view : this.myViewsList) {
      view.update();
    }
  }

  private void initView() {
    for (TestView view : this.myViewsList) {
      view.init();
    }
  }

  public void addView(TestView testView) {
    SetSequence.fromSet(this.myViewsList).addElement(testView);
  }

  public void startTest(final TestEvent event) {
    ListSequence.fromList(this.myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestStart(event);
      }
    });
    this.startTest(event.getTestCaseName(), event.getTestMethodName());
  }

  public void endTest(final TestEvent event) {
    ListSequence.fromList(this.myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestEnd(event);
      }
    });
    this.endTest();
  }

  public void testError(final TestEvent event) {
    ListSequence.fromList(this.myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestError(event);
      }
    });
    this.defectTest();
  }

  public void testFailure(final TestEvent event) {
    ListSequence.fromList(this.myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onTestFailure(event);
      }
    });
    this.defectTest();
  }

  public void looseTest(final String className, final String testName) {
    ListSequence.fromList(this.myListeners).visitAll(new IVisitor<TestStateListener>() {
      public void visit(TestStateListener it) {
        it.onLooseTest(className, testName);
      }
    });
    this.looseTestInternal(className, testName);
  }

  private void startTest(String className, String methodName) {
    if (className.equals(this.myCurrentClass) && methodName.equals(this.myCurrentMethod)) {
      return;
    }
    synchronized (lock) {
      this.myCurrentClass = className;
      this.myCurrentMethod = methodName;
      this.updateView();
    }
  }

  private void endTest() {
    synchronized (lock) {
      this.myCompletedTests++;
      this.updateView();
      this.myCurrentClass = null;
      this.myCurrentMethod = null;
    }
  }

  private void defectTest() {
    synchronized (lock) {
      this.myDefectTests++;
      this.updateView();
    }
  }

  private void looseTestInternal(String test, String method) {
    synchronized (lock) {
      this.myLostTest = test;
      this.myLostMethod = method;
      this.myDefectTests++;
      this.myCompletedTests++;
      this.updateView();
      this.myLostTest = null;
      this.myLostMethod = null;
    }
  }

  public void terminate() {
    synchronized (lock) {
      this.myIsTerminated = true;
      this.updateView();
    }
  }

  public void outputText(String text, Key key) {
    synchronized (lock) {
      this.myAvailableText = text;
      this.myKey = key;
      this.updateView();
      this.myAvailableText = null;
      this.myKey = null;
    }
  }

  public void completeTestEvent(TestEvent event) {
    String token = event.getToken();
    if (token.equals(TestEvent.END_TEST_PREFIX) || token.equals(TestEvent.ERROR_TEST_SUFFIX) || token.equals(TestEvent.FAILURE_TEST_SUFFIX)) {
      String testClassName = event.getTestCaseName();
      String testMethodName = event.getTestMethodName();
      String key = testClassName + '.' + testMethodName;
      synchronized (this.myTestMethods) {
        if (ListSequence.fromList(this.myTestMethods).contains(key)) {
          ListSequence.fromList(this.myTestMethods).removeElement(key);
        }
      }
    }
  }

  public List<String> getUnusedMethods() {
    return this.myTestMethods;
  }

  public int getTotalTests() {
    return this.myTotalTests;
  }

  public int getDefectTests() {
    return this.myDefectTests;
  }

  public int getCompletedTests() {
    return this.myCompletedTests;
  }

  public String getCurrentClass() {
    return this.myCurrentClass;
  }

  public String getCurrentMethod() {
    return this.myCurrentMethod;
  }

  public void setToken(String token) {
    this.myCurrentToken = token;
  }

  public String getToken() {
    return this.myCurrentToken;
  }

  public String getLoseMethod() {
    return this.myLostMethod;
  }

  public String getLoseClass() {
    return this.myLostTest;
  }

  public boolean isTerminated() {
    return this.myIsTerminated;
  }

  public String getAvailableText() {
    return this.myAvailableText;
  }

  public Key getKey() {
    return this.myKey;
  }

  public void addListener(TestStateListener listener) {
    ListSequence.fromList(this.myListeners).addElement(listener);
  }

  public void removeListener(TestStateListener listener) {
    ListSequence.fromList(this.myListeners).removeElement(listener);
  }

  public Map<SNode, List<SNode>> getTestsMap() {
    return this.myTestToMethodsMap;
  }
}
