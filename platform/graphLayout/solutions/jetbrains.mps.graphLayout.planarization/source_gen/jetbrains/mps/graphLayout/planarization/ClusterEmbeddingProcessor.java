package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.ClusteredGraph;
import jetbrains.mps.graphLayout.graph.INode;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.graph.Edge;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.graphLayout.graph.IEdge;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.graphLayout.algorithms.ConnectivityComponents;
import jetbrains.mps.graphLayout.planarGraph.Face;
import jetbrains.mps.graphLayout.planarGraph.CheckEmbeddedGraph;

public class ClusterEmbeddingProcessor {
  private static int debugMode = 1;

  private ClusteredGraph myGraph;
  private INode myCluster;
  private Graph mySubclustersGraph;
  private EmbeddedGraph mySubEmbeddedGraph;
  private Map<INode, Node> mySubclustersMap;
  private Map<Node, Map<Edge, INode>> mySubOuterNodes;

  public ClusterEmbeddingProcessor(ClusteredGraph graph, INode cluster) {
    myGraph = graph;
    myCluster = cluster;
  }

  public EmbeddedGraph constructEmbedding(List<INode> outerConnections) {
    Iterable<INode> subclusters = Sequence.fromIterable(myCluster.getOutEdges()).select(new ISelector<IEdge, INode>() {
      public INode select(IEdge edge) {
        return edge.getTarget();
      }
    });
    if (Sequence.fromIterable(subclusters).count() == 0) {
      return new EmbeddedGraph(myGraph);
    }
    constructSubclusterGraph(subclusters, outerConnections);
    for (INode subcluster : Sequence.fromIterable(subclusters)) {
      findSubclusterEmbedding(subcluster);
    }
    return null;
  }

  private EmbeddedGraph findSubclusterEmbedding(INode subcluster) {
    Node node = MapSequence.fromMap(mySubclustersMap).get(subcluster);
    List<Dart> darts = mySubEmbeddedGraph.getOrderedDarts(node);
    List<INode> subOuterConnections = ListSequence.fromList(new ArrayList<INode>(ListSequence.fromList(darts).count()));
    for (Dart dart : ListSequence.fromList(darts)) {
      ListSequence.fromList(subOuterConnections).addElement(MapSequence.fromMap(MapSequence.fromMap(mySubOuterNodes).get(node)).get(dart.getEdge()));
    }
    ClusterEmbeddingProcessor subProcessor = new ClusterEmbeddingProcessor(myGraph, subcluster);
    return subProcessor.constructEmbedding(subOuterConnections);
  }

  private void constructSubclusterGraph(Iterable<INode> subclusters, List<INode> outerConnections) {
    // Creating a subcluster graph, where each subcluster is represented by single node, 
    // and finding embedding for it. 
    mySubclustersGraph = new Graph();
    Map<INode, Node> nodeMap = MapSequence.fromMap(new HashMap<INode, Node>());
    mySubclustersMap = MapSequence.fromMap(new HashMap<INode, Node>());
    for (INode subcluster : Sequence.fromIterable(subclusters)) {
      Node clusterNode = mySubclustersGraph.createNode();
      for (INode node : myGraph.getNodesInCluster(subcluster)) {
        MapSequence.fromMap(nodeMap).put(node, clusterNode);
      }
      MapSequence.fromMap(mySubclustersMap).put(subcluster, clusterNode);
    }
    Set<Edge> initialEdges = SetSequence.fromSet(new HashSet<Edge>());
    Map<Edge, IEdge> invertedEdgesMap = MapSequence.fromMap(new HashMap<Edge, IEdge>());
    Set<INode> clusterNodes = MapSequence.fromMap(nodeMap).keySet();
    for (INode source : SetSequence.fromSet(clusterNodes)) {
      for (IEdge edge : source.getOutEdges()) {
        INode target = edge.getTarget();
        if (SetSequence.fromSet(clusterNodes).contains(target) && MapSequence.fromMap(nodeMap).get(source) != MapSequence.fromMap(nodeMap).get(target)) {
          Edge newEdge = mySubclustersGraph.connect(MapSequence.fromMap(nodeMap).get(source), MapSequence.fromMap(nodeMap).get(target));
          SetSequence.fromSet(initialEdges).addElement(newEdge);
          MapSequence.fromMap(invertedEdgesMap).put(newEdge, edge);
        }
      }
    }
    ConnectivityComponents.makeConnected(mySubclustersGraph);
    mySubEmbeddedGraph = EmbeddingFinderFactory.getFinder().find(mySubclustersGraph);

    // OuterConnections has zero size only in case of subclusters of a root.  
    // Otherwise there is connections produced by graph connectivity that have been demanded on supercluster. 
    Map<Edge, INode> outerEdgeConnections = MapSequence.fromMap(new HashMap<Edge, INode>());
    if (ListSequence.fromList(outerConnections).count() > 0) {

      // Making a special construction to process outer edges. 
      List<Edge> circle = ListSequence.fromList(new ArrayList<Edge>(ListSequence.fromList(outerConnections).count()));
      Node prev = null;
      Face outerFace = new Face(mySubclustersGraph);
      for (INode node : ListSequence.fromList(outerConnections)) {
        Node circleNode = mySubclustersGraph.addNode();
        if (prev != null) {
          Edge newEdge = mySubclustersGraph.connect(prev, circleNode);
          ListSequence.fromList(circle).addElement(newEdge);
          outerFace.addLast(new Dart(newEdge, circleNode));
        }
        prev = circleNode;
      }
      Node first = ListSequence.fromList(circle).first().getSource();
      Edge lastEdge = mySubclustersGraph.connect(prev, first);
      ListSequence.fromList(circle).addElement(lastEdge);
      outerFace.addLast(new Dart(lastEdge, first));

      // Including this construction into subclusters graph embedding as a outer face. 
      Face clusterOuterFace = mySubEmbeddedGraph.getOuterFace();
      Node clusterFirstNode = ListSequence.fromList(clusterOuterFace.getDarts()).first().getSource();
      Edge bridge = mySubclustersGraph.connect(first, clusterFirstNode);
      Face ringFace = new Face(mySubclustersGraph);
      ringFace.addLast(new Dart(bridge, clusterFirstNode));
      for (Edge edge : ListSequence.fromList(circle)) {
        ringFace.addLast(new Dart(edge, edge.getSource()));
      }
      ringFace.addLast(new Dart(bridge, first));
      for (Dart dart : ListSequence.fromList(clusterOuterFace.getDarts())) {
        ringFace.addLast(dart);
      }
      mySubEmbeddedGraph.removeFace(clusterOuterFace);
      mySubEmbeddedGraph.addFace(ringFace);
      mySubEmbeddedGraph.addFace(outerFace);
      if (debugMode > 0) {
        CheckEmbeddedGraph.checkEmbeddedGraph(mySubEmbeddedGraph);
      }

      // Processing outer edges. 
      int i = 0;
      for (INode node : ListSequence.fromList(outerConnections)) {
        Node outerNode = ListSequence.fromList(circle).getElement(i++).getSource();
        Node clusterNode = MapSequence.fromMap(nodeMap).get(node);
        Edge edge = mySubclustersGraph.connect(outerNode, clusterNode);
        MapSequence.fromMap(outerEdgeConnections).put(edge, node);
        SetSequence.fromSet(initialEdges).addElement(edge);
        edge.removeFromGraph();
        ShortestPathEmbeddingFinder.restoreEdge(mySubEmbeddedGraph, edge);
      }
    }

    // Constructing a map to store real nodes with which outer edges of subclusters are connected. 
    mySubOuterNodes = MapSequence.fromMap(new HashMap<Node, Map<Edge, INode>>());
    for (Node node : Sequence.fromIterable(MapSequence.fromMap(nodeMap).values())) {
      MapSequence.fromMap(mySubOuterNodes).put(node, MapSequence.fromMap(new HashMap<Edge, INode>()));
    }
    for (Edge subclusterEdge : SetSequence.fromSet(initialEdges)) {
      List<Edge> history = mySubEmbeddedGraph.findFullHistory(subclusterEdge);
      Node node = subclusterEdge.getSource();
      MapSequence.fromMap(MapSequence.fromMap(mySubOuterNodes).get(node)).put(ListSequence.fromList(history).first(), findRealNode(subclusterEdge, node, invertedEdgesMap, outerEdgeConnections, nodeMap));
      node = subclusterEdge.getTarget();
      MapSequence.fromMap(MapSequence.fromMap(mySubOuterNodes).get(node)).put(ListSequence.fromList(history).last(), findRealNode(subclusterEdge, node, invertedEdgesMap, outerEdgeConnections, nodeMap));
    }

  }

  private INode findRealNode(Edge subclusterEdge, Node subclusterEdgeEnd, Map<Edge, IEdge> invertedEdgesMap, Map<Edge, INode> outerEdgeConnections, Map<INode, Node> nodeMap) {
    if (MapSequence.fromMap(invertedEdgesMap).containsKey(subclusterEdge)) {
      IEdge realEdge = MapSequence.fromMap(invertedEdgesMap).get(subclusterEdge);
      INode candidate = realEdge.getSource();
      if (MapSequence.fromMap(nodeMap).get(candidate) == subclusterEdgeEnd) {
        return candidate;
      } else {
        return realEdge.getTarget();
      }
    } else {
      return MapSequence.fromMap(outerEdgeConnections).get(subclusterEdge);
    }
  }
}
