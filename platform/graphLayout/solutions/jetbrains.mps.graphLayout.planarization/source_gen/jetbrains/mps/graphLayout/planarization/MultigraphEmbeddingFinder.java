package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.graph.Graph;
import java.util.Set;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.graphLayout.planarGraph.Face;
import java.util.ArrayList;

public class MultigraphEmbeddingFinder implements IEmbeddingFinder {
  private IEmbeddingFinder myInitialFinder;

  public MultigraphEmbeddingFinder(IEmbeddingFinder initialFinder) {
    myInitialFinder = initialFinder;
  }

  public EmbeddedGraph find(Graph graph) {
    final Set<Edge> badEdges = SetSequence.fromSet(new HashSet<Edge>());
    Map<Node, Set<Node>> connected = MapSequence.fromMap(new HashMap<Node, Set<Node>>());
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      MapSequence.fromMap(connected).put(node, SetSequence.fromSetAndArray(new HashSet<Node>(), node));
    }
    for (Edge edge : ListSequence.fromList(graph.getEdges())) {
      Node source = edge.getSource();
      Node target = edge.getTarget();
      if (source == target) {
        SetSequence.fromSet(badEdges).addElement(edge);
      } else {
        SetSequence.fromSet(MapSequence.fromMap(connected).get(source)).addElement(target);
        SetSequence.fromSet(MapSequence.fromMap(connected).get(target)).addElement(source);
      }
    }
    for (Edge edge : SetSequence.fromSet(badEdges)) {
      edge.removeFromGraph();
    }
    EmbeddedGraph embeddedGraph = myInitialFinder.find(graph);
    for (Edge edge : SetSequence.fromSet(badEdges)) {
      final Node source = edge.getSource();
      final Node target = edge.getTarget();
      Edge faceEdge;
      if (source == target) {
        faceEdge = ListSequence.fromList(source.getEdges()).first();
      } else {
        faceEdge = ListSequence.fromList(source.getEdges()).findFirst(new IWhereFilter<Edge>() {
          public boolean accept(Edge it) {
            return it.getOpposite(source) == target;
          }
        });
      }
      Face face = ListSequence.fromList(embeddedGraph.getAdjacentFaces(faceEdge)).first();
      embeddedGraph.splitFace(face, ListSequence.fromListAndArray(new ArrayList<Edge>(), edge), source, target);
      edge.addToGraph();
    }
    return embeddedGraph;
  }
}
