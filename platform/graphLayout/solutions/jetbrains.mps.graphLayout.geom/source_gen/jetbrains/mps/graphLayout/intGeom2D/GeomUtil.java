package jetbrains.mps.graphLayout.intGeom2D;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;

public class GeomUtil {
  public static boolean intersects(Point p1, Point p2, Point q1, Point q2) {
    boolean sameQ = GeomUtil.isOnSameSide(p1, p2, q1, q2);
    boolean sameP = GeomUtil.isOnSameSide(q1, q2, p1, p2);
    if (sameP || sameQ) {
      return false;
    } else {
      return inside(p1, p2, q1) || inside(p1, p2, q2) || inside(q1, q2, p1) || inside(q1, q2, p2);
    }
  }

  private static boolean inside(Point e1, Point e2, Point p) {
    return scalar(p.x - e1.x, p.y - e1.y, p.x - e2.x, p.y - e2.y) <= 0;
  }

  public static boolean intersects(int minX, int maxX, int minY, int maxY) {
    return Math.min(maxX, maxY) >= Math.max(minX, minY);
  }

  private static boolean isOnSameSide(Point p1, Point p2, Point q1, Point q2) {
    int x = p1.x - p2.x;
    int y = p1.y - p2.y;
    int c1 = crossproduct2D(x, y, q1.x - p2.x, q1.y - p2.y);
    int c2 = crossproduct2D(x, y, q2.x - p2.x, q2.y - p2.y);
    return (c1 > 0 && c2 > 0) || (c1 < 0 && c2 < 0);
  }

  private static int crossproduct2D(int x1, int y1, int x2, int y2) {
    return x1 * y2 - x2 * y1;
  }

  public static int scalar(int x1, int y1, int x2, int y2) {
    return x1 * x2 + y1 * y2;
  }

  public static List<Point> shiftPolyline(List<Point> polyline, int xShift, int yShift) {
    List<Point> shiftedPolyline = ListSequence.fromList(new LinkedList<Point>());
    for (Point p : ListSequence.fromList(polyline)) {
      ListSequence.fromList(shiftedPolyline).addElement(new Point(p.x + xShift, p.y + yShift));
    }
    return shiftedPolyline;
  }

  public static Point intersectGrid(Point p1, Point q1, Point p2, Point q2) {
    // intersects vertical and horizontal segments 
    boolean ver1 = p1.x == q1.x;
    boolean ver2 = p2.x == q2.x;
    if (ver1 == ver2) {
      return null;
    }
    Point res = new Point();
    if (ver1) {
      res.x = p1.x;
    } else {
      res.x = p2.x;
    }
    if (ver2) {
      res.y = p1.y;
    } else {
      res.y = p2.y;
    }
    if (!(insideGrid(res, p1, q1))) {
      return null;
    }
    if (!(insideGrid(res, p2, q2))) {
      return null;
    }
    return res;
  }

  public static boolean insideGrid(Point res, Point p1, Point q1) {
    return (res.x - p1.x) * (res.x - q1.x) <= 0 && (res.y - p1.y) * (res.y - q1.y) <= 0;
  }
}
