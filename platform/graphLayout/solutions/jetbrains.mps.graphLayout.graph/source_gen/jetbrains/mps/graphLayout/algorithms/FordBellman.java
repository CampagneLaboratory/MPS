package jetbrains.mps.graphLayout.algorithms;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.graph.Node;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.graphLayout.util.NodeMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;

public class FordBellman {
  private Graph myGraph;
  private Node mySource;
  private Map<Edge, Integer> myWeights;
  private Map<Node, Edge> myPrev;
  private Map<Node, Integer> myDist;

  public FordBellman(Graph graph, Node source, Map<Edge, Integer> weights) {
    myGraph = graph;
    mySource = source;
    myWeights = weights;
  }

  public void doAlgorithm(final _FunctionTypes._return_P1_E0<? extends Boolean, ? super Edge> edgeFilter, Edge.Direction direction) {
    init();
    for (int iter = 0; iter < myGraph.getNumNodes() - 1; iter++) {
      for (Node node : ListSequence.fromList(myGraph.getNodes())) {
        for (Edge edge : ListSequence.fromList(node.getEdges(direction)).where(new IWhereFilter<Edge>() {
          public boolean accept(Edge it) {
            return edgeFilter.invoke(it);
          }
        })) {
          Node target = edge.getOpposite(node);
          int sourceDist = MapSequence.fromMap(myDist).get(node);
          int targetDist = MapSequence.fromMap(myDist).get(target);
          if (sourceDist < ShortestPath.INF && sourceDist + MapSequence.fromMap(myWeights).get(edge) < targetDist) {
            MapSequence.fromMap(myDist).put(target, sourceDist + MapSequence.fromMap(myWeights).get(edge));
            MapSequence.fromMap(myPrev).put(target, edge);
          }
        }
      }
    }
  }

  public void doAlgorithm() {
    doAlgorithm(new _FunctionTypes._return_P1_E0<Boolean, Edge>() {
      public Boolean invoke(Edge edge) {
        return true;
      }
    }, Edge.Direction.FRONT);
  }

  private void init() {
    myPrev = new NodeMap<Edge>(myGraph);
    myDist = new NodeMap<Integer>(myGraph);
    for (Node node : ListSequence.fromList(myGraph.getNodes())) {
      MapSequence.fromMap(myDist).put(node, ShortestPath.INF);
    }
    MapSequence.fromMap(myDist).put(mySource, 0);
  }

  public List<Edge> getShortestPath(Node target) {
    List<Edge> path = ListSequence.fromList(new LinkedList<Edge>());
    if (MapSequence.fromMap(myDist).get(target) == ShortestPath.INF) {
      return null;
    }
    Node cur = target;
    while (cur != mySource) {
      Edge prev = MapSequence.fromMap(myPrev).get(cur);
      ListSequence.fromList(path).insertElement(0, prev);
      cur = prev.getOpposite(cur);
    }
    return path;
  }
}
