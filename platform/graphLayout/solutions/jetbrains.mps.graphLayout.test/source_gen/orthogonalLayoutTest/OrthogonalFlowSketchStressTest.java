package orthogonalLayoutTest;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graphLayout.ILayouter;
import jetbrains.mps.graphLayout.flowOrthogonalLayout.OrthogonalPointLayouter;
import jetbrains.mps.graphLayout.graph.Graph;
import sampleGraphs.RandomGraphGenerator;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.algorithms.ConnectivityComponents;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.io.PrintWriter;
import visualization.GraphIO;
import jetbrains.mps.graphLayout.graphLayout.GraphLayoutPoint;
import junit.framework.Assert;
import java.util.List;
import jetbrains.mps.graphLayout.graph.Edge;
import java.awt.Point;
import jetbrains.mps.graphLayout.util.GeomUtil;

public class OrthogonalFlowSketchStressTest {
  public OrthogonalFlowSketchStressTest() {
  }

  public static void main(String[] args) throws Exception {
    String fileName = "C:\\work\\stressFlow.txt";
    ILayouter layouter = new OrthogonalPointLayouter();
    int numNodes = Integer.parseInt(args[0]);
    int numEdges = Integer.parseInt(args[1]);
    int numIter = Integer.parseInt(args[2]);
    for (int iter = 0; iter < numIter; iter++) {
      System.out.println("ITERATION: " + iter);
      Graph graph = RandomGraphGenerator.generateSimple(numNodes, numEdges);
      Map<Node, Integer> components = ConnectivityComponents.getComponents(graph);
      boolean oneComponent = true;
      for (Node n1 : ListSequence.fromList(graph.getNodes())) {
        for (Node n2 : ListSequence.fromList(graph.getNodes())) {
          if (MapSequence.fromMap(components).get(n1) != MapSequence.fromMap(components).get(n2)) {
            oneComponent = false;
          }
        }
      }
      if (oneComponent) {
        PrintWriter out = new PrintWriter(fileName);
        GraphIO.writeGraph(graph, out);
        out.close();
        GraphLayoutPoint graphLayoutPoint = layouter.doLayout(graph);
        checkPointLayout(graphLayoutPoint);
      } else {
        System.out.println("many components, skipped!");
      }
    }
    System.out.println("END!");
  }

  private static void checkPointLayout(GraphLayoutPoint graphLayout) {
    Graph graph = graphLayout.getGraph();
    for (Node node : ListSequence.fromList(graph.getNodes())) {
      Assert.assertTrue(MapSequence.fromMap(graphLayout.getNodeLayout()).containsKey(node));
    }
    List<Edge> edges = graph.getEdges();
    for (Edge edge : ListSequence.fromList(edges)) {
      Assert.assertTrue(MapSequence.fromMap(graphLayout.getEdgeLayout()).containsKey(edge));
      List<Point> edgeLayout = graphLayout.getLayoutFor(edge);
      Assert.assertTrue(ListSequence.fromList(edgeLayout).count() == 2);
      Assert.assertTrue(ListSequence.fromList(edgeLayout).getElement(0).x == ListSequence.fromList(edgeLayout).getElement(1).x || ListSequence.fromList(edgeLayout).getElement(0).y == ListSequence.fromList(edgeLayout).getElement(1).y);
    }
    for (int i = 0; i < ListSequence.fromList(edges).count(); i++) {
      for (int j = i + 1; j < ListSequence.fromList(edges).count(); j++) {
        List<Point> edgeLayout1 = graphLayout.getLayoutFor(ListSequence.fromList(edges).getElement(i));
        List<Point> edgeLayout2 = graphLayout.getLayoutFor(ListSequence.fromList(edges).getElement(j));
        int[] x = new int[4];
        int[] y = new int[4];
        int cur = 0;
        for (Point point : ListSequence.fromList(edgeLayout1)) {
          x[cur] = point.x;
          y[cur++] = point.y;
        }
        for (Point point : ListSequence.fromList(edgeLayout2)) {
          x[cur] = point.x;
          y[cur++] = point.y;
        }
        if (x[0] != x[1]) {
          for (int k = 0; k < 4; k++) {
            int p = x[k];
            x[k] = y[k];
            y[k] = p;
          }
        }
        if (x[2] == x[3]) {
          Assert.assertFalse(GeomUtil.insideOpenSegment(x[0], x[1], x[2]));
          Assert.assertFalse(GeomUtil.insideOpenSegment(x[0], x[1], x[3]));
        } else {
          boolean vInside = GeomUtil.insideOpenSegment(y[0], y[1], y[2]);
          boolean hInside = GeomUtil.insideOpenSegment(x[2], x[3], x[0]);
          Assert.assertFalse(vInside && hInside);
        }
      }
    }
  }
}
