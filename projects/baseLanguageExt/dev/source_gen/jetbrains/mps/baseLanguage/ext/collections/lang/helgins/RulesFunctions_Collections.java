package jetbrains.mps.baseLanguage.ext.collections.lang.helgins;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.helgins.inference.TypeChecker;
import jetbrains.mps.baseLanguage.ext.collections.lang.CollectionsLanguageUtil;
import jetbrains.mps.baseLanguage.ext.collections.internal.query.SequenceOperations;
import jetbrains.mps.baseLanguage.ext.collections.lang.helgins.zMapper;
import jetbrains.mps.baseLanguage.ext.collections.lang.helgins.QuotationClass_;
import jetbrains.mps.baseLanguage.ext.collections.lang.helgins.QuotationClass_1;
import jetbrains.mps.baseLanguage.ext.collections.lang.helgins.QuotationClass_2;
import jetbrains.mps.baseLanguage.ext.collections.lang.helgins.QuotationClass_3;
import jetbrains.mps.baseLanguage.ext.collections.lang.helgins.QuotationClass_4;
import jetbrains.mps.baseLanguage.ext.collections.lang.helgins.QuotationClass_5;
import jetbrains.mps.baseLanguage.ext.collections.lang.helgins.QuotationClass_6;
import jetbrains.mps.baseLanguage.ext.collections.lang.helgins.QuotationClass_7;
import jetbrains.mps.baseLanguage.ext.collections.lang.helgins.QuotationClass_8;

public class RulesFunctions_Collections {

  public static SNode get_inputSequenceType_elementType(SNode op) {
    SNode sequenceType = RulesFunctions_Collections.get_inputSequenceType(op);
    return SLinkOperations.getTarget(sequenceType, "elementType", true);
  }
  public static SNode get_inputSequenceType(SNode op) {
    SNode parent = SNodeOperations.getParent(op, null, false, false);
    if(SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.ext.collections.lang.structure.SequenceOperationExpression")) {
      SNode leftExpression = SLinkOperations.getTarget(parent, "leftExpression", true);
      SNode sequenceType = RulesFunctions_Collections.tryObtain_SequenceType(leftExpression);
      if(sequenceType != null) {
        return sequenceType;
      } else 
      {
        TypeChecker.getInstance().reportTypeError(leftExpression, "sequence is expected");
      }
    } else 
    {
      TypeChecker.getInstance().reportTypeError(op, "not expected here: is only applicable to sequence");
    }
    return null;
  }
  public static SNode tryObtain_SequenceType(SNode expression) {
    if(expression == null) {
      return null;
    }
    SNode type = TypeChecker.getInstance().getRuntimeSupport().checkedTypeOf(expression);
    SNode sequenceType = CollectionsLanguageUtil.coerceTo_SequenceType(type);
    return sequenceType;
  }
  public static SNode tryObtain_Sequence_elementType(SNode expression) {
    SNode sequenceType = RulesFunctions_Collections.tryObtain_SequenceType(expression);
    return SLinkOperations.getTarget(sequenceType, "elementType", true);
  }
  public static SNode get_inputListType_elementType(SNode op) {
    SNode listType = RulesFunctions_Collections.get_inputListType(op);
    return SLinkOperations.getTarget(listType, "elementType", true);
  }
  public static SNode get_inputListType(SNode op) {
    SNode parent = SNodeOperations.getParent(op, null, false, false);
    if(SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.ext.collections.lang.structure.SequenceOperationExpression")) {
      SNode leftExpression = SLinkOperations.getTarget(parent, "leftExpression", true);
      SNode listType = RulesFunctions_Collections.tryObtain_ListType(leftExpression);
      if(listType != null) {
        return listType;
      } else 
      {
        TypeChecker.getInstance().reportTypeError(leftExpression, "list is expected");
      }
    } else 
    {
      TypeChecker.getInstance().reportTypeError(op, "not expected here: is only applicable to list");
    }
    return null;
  }
  public static SNode tryObtain_ListType(SNode expression) {
    if(expression == null) {
      return null;
    }
    SNode type = TypeChecker.getInstance().getRuntimeSupport().checkedTypeOf(expression);
    SNode listType = CollectionsLanguageUtil.coerceTo_ListType(type);
    return listType;
  }
  public static Iterable<SNode> collectYieldStatements(SNode node) {
    Iterable<SNode> yieldStatements = SequenceOperations.map(SNodeOperations.getChildren(node), new zMapper(null, null));
    return yieldStatements;
  }
  public static SNode computeLeastCommonSupertype(SNode exprWithType, SNode currentLeastCommonSupertype) {
    SNode exprType = TypeChecker.getInstance().getRuntimeSupport().typeOf(exprWithType);
    if(exprType == null) {
      TypeChecker.getInstance().reportTypeError(exprWithType, "no type");
      return currentLeastCommonSupertype;
    }
    if(currentLeastCommonSupertype == null) {
      return exprType;
    }
    if(TypeChecker.getInstance().getSubtypingManager().isSubtype(currentLeastCommonSupertype, exprType)) {
      return exprType;
    }
    if(TypeChecker.getInstance().getSubtypingManager().isSubtype(exprType, currentLeastCommonSupertype)) {
      return currentLeastCommonSupertype;
    }
    TypeChecker.getInstance().reportTypeError(exprWithType, "type " + exprType + " is not compatible with infered " + currentLeastCommonSupertype);
    return currentLeastCommonSupertype;
  }
  public static SNode boxPrimitive1(SNode primitiveType, SNode nodeToReportError) {
    if(SNodeOperations.isInstanceOf(primitiveType, "jetbrains.mps.baseLanguage.structure.IntegerType")) {
      return new QuotationClass_().createNode();
    }
    if(SNodeOperations.isInstanceOf(primitiveType, "jetbrains.mps.baseLanguage.structure.BooleanType")) {
      return new QuotationClass_1().createNode();
    }
    if(SNodeOperations.isInstanceOf(primitiveType, "jetbrains.mps.baseLanguage.structure.ByteType")) {
      return new QuotationClass_2().createNode();
    }
    if(SNodeOperations.isInstanceOf(primitiveType, "jetbrains.mps.baseLanguage.structure.CharType")) {
      return new QuotationClass_3().createNode();
    }
    if(SNodeOperations.isInstanceOf(primitiveType, "jetbrains.mps.baseLanguage.structure.DoubleType")) {
      return new QuotationClass_4().createNode();
    }
    if(SNodeOperations.isInstanceOf(primitiveType, "jetbrains.mps.baseLanguage.structure.FloatType")) {
      return new QuotationClass_5().createNode();
    }
    if(SNodeOperations.isInstanceOf(primitiveType, "jetbrains.mps.baseLanguage.structure.LongType")) {
      return new QuotationClass_6().createNode();
    }
    if(SNodeOperations.isInstanceOf(primitiveType, "jetbrains.mps.baseLanguage.structure.ShortType")) {
      return new QuotationClass_7().createNode();
    }
    TypeChecker.getInstance().reportTypeError(nodeToReportError, "couldn't coerse " + primitiveType + " to classifier");
    return new QuotationClass_8().createNode();
  }
}
