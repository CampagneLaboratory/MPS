package jetbrains.mps.baseLanguage.ext.collections.lang.helgins;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.helgins.inference.TypeChecker;
import jetbrains.mps.baseLanguage.ext.collections.internal.query.SequenceOperations;

public class RulesFunctions_Collections {

  public static SNode getInput(SNode op) {
    SNode input = null;
    SNode parent = SNodeOperations.getParent(op, null, false, false);
    if(SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.ext.collections.lang.structure.SequenceOperationExpression")) {
      input = SLinkOperations.getTarget(parent, "leftExpression", true);
    } else
    {
      TypeChecker.getInstance().reportTypeError(op, "not expected here", "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184783963366");
    }
    return input;
  }

  public static SNode getOutput(SNode op) {
    SNode output = null;
    SNode parent = SNodeOperations.getParent(op, null, false, false);
    if(SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.ext.collections.lang.structure.SequenceOperationExpression")) {
      output = SLinkOperations.getTarget(parent, "operation", true);
      return output;
    } else
    {
      return null;
    }
  }

  public static void setInputSequenceType(SNode op, SNode target) {
    // 1. Take input expression
    // 2. Assert that it is coerceable to sequence
    // 3. Assign the sequence type to the target
    SNode input = RulesFunctions_Collections.getInput(op);
    if((input != null)) {
      final SNode elementType_typevar_1184784638219 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);
      TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(input, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184843134901"), new QuotationClass_().createNode(TypeChecker.getInstance().getEquationManager().getRepresentator(elementType_typevar_1184784638219)), input, null, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184843140648");
      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(target, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184844094867"), new QuotationClass_1().createNode(TypeChecker.getInstance().getEquationManager().getRepresentator(elementType_typevar_1184784638219)), target, null, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184844101686");
    }
  }

  public static void setInputElementType(SNode op, SNode target) {
    // 1. Take input expression
    // 2. Assert that it is coerceable to sequence
    // 3. Assign the sequence element type to the target
    SNode input = RulesFunctions_Collections.getInput(op);
    if((input != null)) {
      final SNode elementType_typevar_1184844804662 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);
      TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(input, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184844804669"), new QuotationClass_2().createNode(TypeChecker.getInstance().getEquationManager().getRepresentator(elementType_typevar_1184844804662)), input, null, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184844804663");
      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(target, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184844804677"), TypeChecker.getInstance().getEquationManager().getRepresentator(elementType_typevar_1184844804662), target, null, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184844804671");
    }
  }

  public static void isInputElementType(SNode op, SNode target) {
    // 1. Take input expression
    // 2. Assert that it is coerceable to sequence
    // 3. Assert that target has sequence element type
    SNode input = RulesFunctions_Collections.getInput(op);
    if((input != null)) {
      final SNode elementType_typevar_1184850451264 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);
      TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(input, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184850451271"), new QuotationClass_3().createNode(TypeChecker.getInstance().getEquationManager().getRepresentator(elementType_typevar_1184850451264)), input, null, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184850451265");
      TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(target, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184850492037"), TypeChecker.getInstance().getEquationManager().getRepresentator(elementType_typevar_1184850451264), target, null, "jetbrains.mps.baseLanguage.ext.collections.lang.helgins", "1184850492036");
    }
  }

  public static Iterable<SNode> collectYieldStatements(SNode node) {
    Iterable<SNode> yieldStatements = SequenceOperations.map(SNodeOperations.getChildren(node), new zMapper(null, null));
    return yieldStatements;
  }

}
