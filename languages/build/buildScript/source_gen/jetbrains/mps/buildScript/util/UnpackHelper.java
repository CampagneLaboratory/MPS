package jetbrains.mps.buildScript.util;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.buildScript.behavior.BuildLayout_PathElement_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.buildScript.behavior.BuildStringPart_Behavior;

public class UnpackHelper extends DependenciesHelper {
  private final VisibleArtifacts visible;
  private final List<SNode> required = new ArrayList<SNode>();
  private final Set<SNode> requiredSet = new HashSet<SNode>();
  private boolean evaluated = false;
  private final List<SNode> statements = new ArrayList<SNode>();
  private PathProvider myPathProvider;

  public UnpackHelper(VisibleArtifacts visible, Iterable<SNode> required, TemplateQueryContext genContext) {
    super(genContext, visible.getProject());
    this.visible = visible;
    this.myPathProvider = new PathProvider(genContext, visible.getProject());

    for (SNode node : required) {
      add(node);
    }
  }

  private void add(SNode n) {
    if (!(requiredSet.add(n))) {
      return;
    }

    SNode parent = visible.parent(n);
    if (parent != null) {
      add(parent);
    }
    ListSequence.fromList(required).addElement(n);
  }

  public void eval() {
    if (evaluated) {
      return;
    }
    evaluated = true;

    for (SNode n : required) {
      BuildLayout_PathElement_Behavior.call_unpack_7128123785277710736(n, this);
    }
  }

  public boolean isRequired(SNode n) {
    return requiredSet.contains(n);
  }

  public void emit(SNode st) {
    ListSequence.fromList(statements).addElement(st);
  }

  public SNode parent(SNode node) {
    return visible.parent(node);
  }

  public String toString(SNode text) {
    StringBuilder sb = new StringBuilder();
    for (SNode n : ListSequence.fromList(SLinkOperations.getTargets(text, "parts", true))) {
      if (SNodeOperations.isInstanceOf(n, "jetbrains.mps.buildScript.structure.BuildVarRefStringPart")) {
        sb.append("${");
        SNode macro = SLinkOperations.getTarget(SNodeOperations.cast(n, "jetbrains.mps.buildScript.structure.BuildVarRefStringPart"), "macro", false);
        sb.append("varsof." + SPropertyOperations.getString(SNodeOperations.getAncestor(macro, "jetbrains.mps.buildScript.structure.BuildProject", false, false), "name") + "." + SPropertyOperations.getString(macro, "name"));
        sb.append("}");
        // TODO register macro 
        continue;
      }
      sb.append(BuildStringPart_Behavior.call_getText_4380385936562037054(n));
    }
    return sb.toString();
  }

  public List<SNode> getStatements() {
    return ListSequence.fromList(statements).asUnmodifiable();
  }

  public PathProvider getPathProvider() {
    return myPathProvider;
  }
}
