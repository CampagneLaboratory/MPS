package jetbrains.mps.build.workflow.generator.util;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.make.dependencies.graph.Graph;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.make.dependencies.graph.Graphs;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.make.dependencies.graph.IVertex;
import java.util.Set;
import java.util.LinkedHashSet;

public class SubTaskOrderHelper {
  private final List<SNode> list;
  private final Map<SNode, SubTaskOrderHelper.SubTask> map = new HashMap<SNode, SubTaskOrderHelper.SubTask>();
  private final TemplateQueryContext genContext;

  public SubTaskOrderHelper(List<SNode> list, TemplateQueryContext genContext) {
    this.list = list;
    this.genContext = genContext;
  }

  public void sort() {
    Graph<SubTaskOrderHelper.SubTask> graph = new Graph();
    for (SNode st : list) {
      SubTaskOrderHelper.SubTask module = new SubTaskOrderHelper.SubTask(st);
      map.put(st, module);
    }
    for (SubTaskOrderHelper.SubTask st : map.values()) {
      for (SNode dep : SLinkOperations.getTargets(st.getTask(), "after", true)) {
        SubTaskOrderHelper.SubTask afterTask = map.get(SLinkOperations.getTarget(dep, "target", false));
        if (afterTask == null) {
          genContext.showErrorMessage(dep, "dependency on non-existing subtask");
          continue;
        }
        st.targets.add(afterTask);
      }
      for (SNode dep : SLinkOperations.getTargets(st.getTask(), "before", true)) {
        SubTaskOrderHelper.SubTask beforeTask = map.get(SLinkOperations.getTarget(dep, "target", false));
        if (beforeTask == null) {
          genContext.showErrorMessage(dep, "dependency on non-existing subtask");
          continue;
        }
        beforeTask.targets.add(st);
      }
    }

    for (SubTaskOrderHelper.SubTask st : map.values()) {
      graph.add(st);
    }
    List<List<SubTaskOrderHelper.SubTask>> cycles = Graphs.findStronglyConnectedComponents(graph);
    Collections.reverse(cycles);

    ListSequence.fromList(list).clear();
    for (List<SubTaskOrderHelper.SubTask> cycle : cycles) {
      if (cycle.size() > 1) {
        StringBuilder sb = new StringBuilder();
        sb.append("subtasks cycle detected: ");
        for (int i = 0; i < 5 && i < cycle.size(); i++) {
          if (i > 0) {
            sb.append(", ");
          }
          sb.append(SPropertyOperations.getString(cycle.get(i).getTask(), "name"));
        }
        if (cycle.size() > 5) {
          sb.append(" ...");
        }
        genContext.showErrorMessage(cycle.get(0).getTask(), sb.toString());
        continue;
      }
      ListSequence.fromList(list).addElement(cycle.get(0).getTask());
    }
  }

  private class SubTask implements IVertex {
    private final SNode task;
    public Set<SubTaskOrderHelper.SubTask> targets = new LinkedHashSet<SubTaskOrderHelper.SubTask>();

    public SubTask(SNode task) {
      this.task = task;
    }

    public Set<? extends IVertex> getNexts() {
      return targets;
    }

    public SNode getTask() {
      return task;
    }
  }
}
