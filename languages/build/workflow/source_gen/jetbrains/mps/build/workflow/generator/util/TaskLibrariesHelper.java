package jetbrains.mps.build.workflow.generator.util;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.generator.template.TemplateQueryContext;
import java.util.Set;
import java.util.LinkedHashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.CopyUtil;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class TaskLibrariesHelper {
  private SNode project;
  private TemplateQueryContext genContext;

  public TaskLibrariesHelper(SNode project, TemplateQueryContext genContext) {
    this.project = project;
    this.genContext = genContext;
  }

  public void importLibs() {
    Set<SNode> libsSet = new LinkedHashSet<SNode>();
    for (SNode tldep : SLinkOperations.getTargets(project, "imports", true)) {
      libsSet.add(SLinkOperations.getTarget(tldep, "target", false));
    }
    closure(libsSet);
    List<SNode> libs = new ArrayList<SNode>(libsSet);
    for (SNode lib : libs) {
      for (SNode n : lib.getDescendantsIterable(null, true)) {
        for (SReference ref : n.getReferencesIterable()) {
          SNode targetNode = ref.getTargetNodeSilently();
          if (targetNode == null) {
            genContext.showErrorMessage(n, "cannot import library `" + SPropertyOperations.getString(lib, "name") + "': unresolved reference");
          } else if (!(libsSet.contains(targetNode.getTopmostAncestor()))) {
            genContext.showErrorMessage(n, "cannot import library `" + SPropertyOperations.getString(lib, "name") + "': broken reference, target is not imported");
          }
        }
      }
    }
    List<SNode> parts = ListSequence.fromList(libs).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return SLinkOperations.getTargets(it, "parts", true);
      }
    }).toListSequence();
    Map<SNode, SNode> map = new HashMap<SNode, SNode>();
    parts = (List<SNode>) CopyUtil.copy((List<SNode>) parts, map);
    ListSequence.fromList(SLinkOperations.getTargets(project, "imports", true)).clear();
    for (SNode n : project.getDescendantsIterable(null, true)) {
      for (SReference ref : n.getReferences()) {
        SNode targetNode = ref.getTargetNodeSilently();
        if (map.containsKey(targetNode)) {
          n.setReferent(ref.getRole(), map.get(targetNode));
        }
      }
    }
    ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true)).addSequence(ListSequence.fromList(parts));
  }

  public static void closure(Set<SNode> libs) {
    Queue<SNode> queue = QueueSequence.fromQueue(new LinkedList<SNode>());
    QueueSequence.fromQueue(queue).addSequence(SetSequence.fromSet(libs));
    while (!(QueueSequence.fromQueue(queue).isEmpty())) {
      SNode lib = QueueSequence.fromQueue(queue).removeFirstElement();
      for (SNode dep : SLinkOperations.getTargets(lib, "imports", true)) {
        if (!(libs.contains(SLinkOperations.getTarget(dep, "target", false)))) {
          libs.add(SLinkOperations.getTarget(dep, "target", false));
          QueueSequence.fromQueue(queue).addLastElement(SLinkOperations.getTarget(dep, "target", false));
        }
      }
    }
  }
}
