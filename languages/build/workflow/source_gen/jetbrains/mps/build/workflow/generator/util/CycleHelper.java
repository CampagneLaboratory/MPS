package jetbrains.mps.build.workflow.generator.util;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.generator.template.TemplateQueryContext;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.make.dependencies.graph.Graph;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.make.dependencies.graph.Graphs;
import java.util.Collections;
import java.util.Set;
import java.util.HashSet;
import java.util.Comparator;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.util.LinkedHashSet;
import jetbrains.mps.make.dependencies.graph.IVertex;

public class CycleHelper {
  private final SNode project;
  private final Map<SNode, CycleHelper.Module> map = new HashMap<SNode, CycleHelper.Module>();
  private final TemplateQueryContext genContext;

  public CycleHelper(SNode project, TemplateQueryContext genContext) {
    this.project = project;
    this.genContext = genContext;
  }

  public void processCycles() {
    List<SNode> modules = new ArrayList<SNode>();
    Graph<CycleHelper.Module> graph = new Graph();
    ListSequence.fromList(modules).addSequence(ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.workflow.structure.BwfJavaModule");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.build.workflow.structure.BwfJavaModule");
      }
    }));
    for (SNode jm : modules) {
      CycleHelper.Module module = new CycleHelper.Module(jm);
      map.put(jm, module);
      if (StringUtils.isEmpty(SPropertyOperations.getString(jm, "outputFolder"))) {
        genContext.showErrorMessage(jm, "empty output path");
      } else if (SPropertyOperations.getString(jm, "outputFolder").endsWith("/") || SPropertyOperations.getString(jm, "outputFolder").endsWith("\\")) {
        genContext.showErrorMessage(jm, "output path shouldn't end with slash");
      }
    }
    for (CycleHelper.Module module : map.values()) {
      graph.add(module);
    }
    List<List<CycleHelper.Module>> cycles = Graphs.findStronglyConnectedComponents(graph);
    Collections.reverse(cycles);
    int cycleCounter = 0;
    for (List<CycleHelper.Module> cycle : cycles) {
      if (cycle.size() < 2) {
        continue;
      }
      final Set<SNode> cycleModules = new HashSet<SNode>();
      for (CycleHelper.Module m : cycle) {
        cycleModules.add(m.getModule());
      }

      Collections.sort(cycle, new Comparator<CycleHelper.Module>() {
        public int compare(CycleHelper.Module m1, CycleHelper.Module m2) {
          return new Integer(SNodeOperations.getIndexInParent(m1.getModule())).compareTo(SNodeOperations.getIndexInParent(m2.getModule()));
        }
      });
      SNode first = cycle.get(0).getModule();
      SModel model = SNodeOperations.getModel(first);
      SNode cycleX = SModelOperations.createNewNode(model, "jetbrains.mps.build.workflow.structure.BwfJavaModule", null);
      SPropertyOperations.set(cycleX, "name", "java.modules.cycle." + ++cycleCounter);
      SPropertyOperations.set(cycleX, "outputFolder", SPropertyOperations.getString(project, "temporaryFolder") + "/" + SPropertyOperations.getString(cycleX, "name"));
      SNodeOperations.insertPrevSiblingChild(first, cycleX);
      Set<String> sources = new LinkedHashSet<String>();
      Set<String> classpath = new LinkedHashSet<String>();
      Set<SNode> deps = new LinkedHashSet<SNode>();

      for (CycleHelper.Module m : cycle) {
        SNode module = m.getModule();
        ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).removeWhere(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return cycleModules.contains(SLinkOperations.getTarget(it, "target", false));
          }
        });
        deps.addAll(ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SLinkOperations.getTarget(it, "target", false) != null);
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, "target", false);
          }
        }).toListSequence());
        SNode mref = SModelOperations.createNewNode(model, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference", null);
        SLinkOperations.setTarget(mref, "target", cycleX, false);
        ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).addElement(mref);
        sources.addAll(ListSequence.fromList(SLinkOperations.getTargets(module, "sources", true)).select(new ISelector<SNode, String>() {
          public String select(SNode it) {
            return SPropertyOperations.getString(it, "path");
          }
        }).toListSequence());
        classpath.addAll(ListSequence.fromList(SLinkOperations.getTargets(module, "classpath", true)).select(new ISelector<SNode, String>() {
          public String select(SNode it) {
            return SPropertyOperations.getString(it, "path");
          }
        }).toListSequence());
      }
      for (String src : sources) {
        SNode path = SModelOperations.createNewNode(model, "jetbrains.mps.build.workflow.structure.BwfPath", null);
        SPropertyOperations.set(path, "path", src);
        ListSequence.fromList(SLinkOperations.getTargets(cycleX, "sources", true)).addElement(path);
      }
      for (String cpath : classpath) {
        SNode path = SModelOperations.createNewNode(model, "jetbrains.mps.build.workflow.structure.BwfPath", null);
        SPropertyOperations.set(path, "path", cpath);
        ListSequence.fromList(SLinkOperations.getTargets(cycleX, "classpath", true)).addElement(path);
      }
      for (SNode dep : deps) {
        SNode ref = SModelOperations.createNewNode(model, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference", null);
        SLinkOperations.setTarget(ref, "target", dep, false);
        ListSequence.fromList(SLinkOperations.getTargets(cycleX, "dependencies", true)).addElement(ref);
      }
    }
  }

  public class Module implements IVertex {
    private final SNode module;
    private Set<CycleHelper.Module> targets;

    public Module(SNode module) {
      this.module = module;
    }

    public Set<? extends IVertex> getNexts() {
      if (targets == null) {
        if (ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).isEmpty()) {
          targets = Collections.emptySet();
        } else {
          targets = new HashSet<CycleHelper.Module>();
          for (SNode ref : SLinkOperations.getTargets(module, "dependencies", true)) {
            CycleHelper.Module tm = map.get(SLinkOperations.getTarget(ref, "target", false));
            if (tm == null) {
              genContext.showErrorMessage(ref, "internal problem: unsatisfied local dependency");
            } else {
              targets.add(tm);
            }
          }
        }
      }
      return targets;
    }

    public SNode getModule() {
      return module;
    }
  }
}
