package jetbrains.mps.build.workflow.generator.util;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.generator.template.TemplateQueryContext;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.make.dependencies.graph.Graph;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.make.dependencies.graph.Graphs;
import java.util.Collections;
import java.util.Set;
import java.util.HashSet;
import java.util.Comparator;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.build.workflow.behavior.BwfJavaDependency_Behavior;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.make.dependencies.graph.IVertex;

public class CycleHelper {
  private final SNode project;
  private final Map<SNode, CycleHelper.Module> map = new HashMap<SNode, CycleHelper.Module>();
  private final TemplateQueryContext genContext;

  public CycleHelper(SNode project, TemplateQueryContext genContext) {
    this.project = project;
    this.genContext = genContext;
  }

  public void processCycles() {
    List<SNode> modules = new ArrayList<SNode>();
    Graph<CycleHelper.Module> graph = new Graph();
    ListSequence.fromList(modules).addSequence(ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.workflow.structure.BwfJavaModule");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.build.workflow.structure.BwfJavaModule");
      }
    }));
    for (SNode jm : modules) {
      CycleHelper.Module module = new CycleHelper.Module(jm);
      map.put(jm, module);
      if (StringUtils.isEmpty(SPropertyOperations.getString(jm, "outputFolder"))) {
        genContext.showErrorMessage(jm, "empty output path");
      } else if (SPropertyOperations.getString(jm, "outputFolder").endsWith("/") || SPropertyOperations.getString(jm, "outputFolder").endsWith("\\")) {
        genContext.showErrorMessage(jm, "output path shouldn't end with slash");
      }
    }
    for (CycleHelper.Module module : map.values()) {
      graph.add(module);
    }
    List<List<CycleHelper.Module>> cycles = Graphs.findStronglyConnectedComponents(graph);
    Collections.reverse(cycles);
    int cycleCounter = 0;
    for (List<CycleHelper.Module> cycle : cycles) {
      if (cycle.size() < 2) {
        continue;
      }
      final Set<SNode> cycleModules = new HashSet<SNode>();
      for (CycleHelper.Module m : cycle) {
        cycleModules.add(m.getModule());
      }

      Collections.sort(cycle, new Comparator<CycleHelper.Module>() {
        public int compare(CycleHelper.Module m1, CycleHelper.Module m2) {
          return new Integer(SNodeOperations.getIndexInParent(m1.getModule())).compareTo(SNodeOperations.getIndexInParent(m2.getModule()));
        }
      });
      SNode first = cycle.get(0).getModule();
      SModel model = SNodeOperations.getModel(first);
      SNode cycleX = SModelOperations.createNewNode(model, "jetbrains.mps.build.workflow.structure.BwfJavaModule", null);
      SPropertyOperations.set(cycleX, "name", "java.modules.cycle." + ++cycleCounter);
      SPropertyOperations.set(cycleX, "outputFolder", SPropertyOperations.getString(project, "temporaryFolder") + "/" + SPropertyOperations.getString(cycleX, "name"));
      SNodeOperations.insertPrevSiblingChild(first, cycleX);
      Set<String> seenSources = new HashSet<String>();
      List<SNode> sources = new ArrayList<SNode>();

      List<SNode> deps = new ArrayList<SNode>();
      Set<String> usedDependencies = new HashSet<String>();

      for (CycleHelper.Module m : cycle) {
        SNode module = m.getModule();
        ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).removeWhere(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference") && cycleModules.contains(SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference"), "target", false));
          }
        });
        for (SNode dep : SLinkOperations.getTargets(module, "dependencies", true)) {
          String signature = BwfJavaDependency_Behavior.call_getSignature_6647099934207246778(dep);
          if (signature != null) {
            if (usedDependencies.add(signature)) {
              deps.add(dep);
            }
          } else {
            genContext.showErrorMessage(dep, "unexpected dependency type");
          }
        }

        SNode mref = SModelOperations.createNewNode(model, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference", null);
        SLinkOperations.setTarget(mref, "target", cycleX, false);
        ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).addElement(mref);

        for (SNode n : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(module, "sources", true), "elements", true))) {
          XmlSignature s = new XmlSignature().add(n);
          String id = (s.hasErrors() ?
            "path." + n.getId() :
            s.getResult()
          );
          if (seenSources.add(id)) {
            sources.add(n);
          }
        }
      }
      SLinkOperations.setNewChild(cycleX, "sources", "jetbrains.mps.build.workflow.structure.BwfFileSet");
      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(cycleX, "sources", true), "elements", true)).addSequence(Sequence.fromIterable(((Iterable<SNode>) sources)).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return CopyUtil.copy(it);
        }
      }));
      for (SNode jm : deps) {
        SNode nref = BwfJavaDependency_Behavior.call_clone_6647099934207248130(jm);
        if (nref == null) {
          genContext.showErrorMessage(jm, "cannot clone dependency to use in cycle");
          continue;
        }
        ListSequence.fromList(SLinkOperations.getTargets(cycleX, "dependencies", true)).addElement(nref);
      }
    }
  }

  public class Module implements IVertex {
    private final SNode module;
    private Set<CycleHelper.Module> targets;

    public Module(SNode module) {
      this.module = module;
    }

    public Set<? extends IVertex> getNexts() {
      if (targets == null) {
        if (ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).isEmpty()) {
          targets = Collections.emptySet();
        } else {
          targets = new HashSet<CycleHelper.Module>();
          for (SNode ref : ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference");
            }
          })) {
            CycleHelper.Module tm = map.get(SLinkOperations.getTarget(SNodeOperations.cast(ref, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference"), "target", false));
            if (tm == null) {
              genContext.showErrorMessage(ref, "internal problem: unsatisfied local dependency");
            } else {
              targets.add(tm);
            }
          }
        }
      }
      return targets;
    }

    public SNode getModule() {
      return module;
    }
  }
}
