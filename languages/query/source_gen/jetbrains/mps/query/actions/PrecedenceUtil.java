package jetbrains.mps.query.actions;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.query.behavior.MqlExpression_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.query.behavior.MqlBinaryExpr_Behavior;

public class PrecedenceUtil {
  public PrecedenceUtil() {
  }

  /*package*/ static SNode getTargetForLeftTransform(SNode context, SNode result) {
    int prio = MqlExpression_Behavior.call_getPriority_7352592509980890960(result);
    SNode targetNode = context;
    for (SNode parentNode = SNodeOperations.getParent(targetNode); parentNode != null && SNodeOperations.isInstanceOf(parentNode, "jetbrains.mps.query.structure.MqlExpression") && MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, "jetbrains.mps.query.structure.MqlExpression")) < prio; parentNode = SNodeOperations.getParent(targetNode)) {
      if (MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, "jetbrains.mps.query.structure.MqlExpression")) == -1) {
        // we do not go through expressions like parentheses or calls 
        break;
      }
      if (SNodeOperations.isInstanceOf(parentNode, "jetbrains.mps.query.structure.MqlTriplex") && SNodeOperations.isInstanceOf(result, "jetbrains.mps.query.structure.MqlComma")) {
        // comma in triplex is ok, need to parenthesise 
        break;
      }
      if (SNodeOperations.isInstanceOf(parentNode, "jetbrains.mps.query.structure.MqlBinaryExpr") && SNodeOperations.getContainingLinkDeclaration(targetNode) == SLinkOperations.findLinkDeclaration("jetbrains.mps.query.structure.MqlBinaryExpr", "right")) {
        // if parent expression is BinaryOperation having higher priority and target is rhigh child of it 
        // then we should rather transform current target and add additional parenthesis around resulting expression 
        break;
      }
      targetNode = SNodeOperations.cast(parentNode, "jetbrains.mps.query.structure.MqlExpression");
    }
    return targetNode;
  }

  /*package*/ static SNode getTargetForRightTransform(@NotNull SNode contextNode, SNode result) {
    int prio = MqlExpression_Behavior.call_getPriority_7352592509980890960(result);
    SNode targetNode = contextNode;
    for (SNode parentNode = SNodeOperations.getParent(targetNode); parentNode != null && SNodeOperations.isInstanceOf(parentNode, "jetbrains.mps.query.structure.MqlExpression") && MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, "jetbrains.mps.query.structure.MqlExpression")) < prio; parentNode = SNodeOperations.getParent(targetNode)) {
      if (MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, "jetbrains.mps.query.structure.MqlExpression")) == -1) {
        // we do not go through expressions like parentheses or calls 
        break;
      }
      if (SNodeOperations.isInstanceOf(parentNode, "jetbrains.mps.query.structure.MqlTriplex") && SNodeOperations.isInstanceOf(result, "jetbrains.mps.query.structure.MqlComma")) {
        // comma in triplex is ok, need to parenthesise 
        break;
      }
      if (SNodeOperations.isInstanceOf(parentNode, "jetbrains.mps.query.structure.MqlBinaryExpr") && SNodeOperations.getContainingLinkDeclaration(targetNode) == SLinkOperations.findLinkDeclaration("jetbrains.mps.query.structure.MqlBinaryExpr", "left")) {
        // if parent expression is BinaryOperation and target is left child of it 
        // then we should rather transform current target 
        break;
      }
      if (SNodeOperations.isInstanceOf(parentNode, "jetbrains.mps.query.structure.MqlDotExpression") && SNodeOperations.getContainingLinkDeclaration(targetNode) == SLinkOperations.findLinkDeclaration("jetbrains.mps.query.structure.MqlDotExpression", "left")) {
        // if parent expression is DotExpression and target is operang ("left" part of the expression) 
        // then we should rather transform current target 
        break;
      }

      targetNode = SNodeOperations.cast(parentNode, "jetbrains.mps.query.structure.MqlExpression");
    }
    return targetNode;
  }

  public static SNode parenthesiseAndRotateIfNecessary(@NotNull SNode contextNode) {
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(contextNode), "jetbrains.mps.query.structure.MqlExpression")) {
      int prio = MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(SNodeOperations.getParent(contextNode), "jetbrains.mps.query.structure.MqlExpression"));
      boolean needWrapping = prio >= 0 && prio < MqlExpression_Behavior.call_getPriority_7352592509980890960(contextNode);
      if (!(needWrapping) && prio >= 0 && prio == MqlExpression_Behavior.call_getPriority_7352592509980890960(contextNode)) {
        if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(contextNode), "jetbrains.mps.query.structure.MqlTriplex") && SNodeOperations.getContainingLinkDeclaration(contextNode) != SLinkOperations.findLinkDeclaration("jetbrains.mps.query.structure.MqlTriplex", "elseexpr")) {
          needWrapping = true;
        }
      }
      if (needWrapping) {
        SNode result = SNodeOperations.replaceWithNewChild(contextNode, "jetbrains.mps.query.structure.MqlParentheses");
        SLinkOperations.setTarget(result, "expr", contextNode, true);
        return result;
      } else if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.query.structure.MqlBinaryExpr")) {
        PrecedenceUtil.rotateIfNecessary(SNodeOperations.cast(contextNode, "jetbrains.mps.query.structure.MqlBinaryExpr"));
      }
    }
    return contextNode;
  }

  private static void rotate(SNode expr, SNode child) {
    boolean isRight = SLinkOperations.getTarget(expr, "right", true) == child;
    SNode backsideExpr = (isRight ?
      SLinkOperations.getTarget(child, "left", true) :
      SLinkOperations.getTarget(child, "right", true)
    );
    SNodeOperations.detachNode(child);
    SNodeOperations.replaceWithAnother(expr, child);
    if ((backsideExpr != null)) {
      SNodeOperations.replaceWithAnother(backsideExpr, expr);
    }
    if (isRight) {
      SLinkOperations.setTarget(expr, "right", backsideExpr, true);
    } else {
      SLinkOperations.setTarget(expr, "left", backsideExpr, true);
    }
  }

  private static boolean needsRotate(SNode expr, SNode child) {
    int childPrio = MqlExpression_Behavior.call_getPriority_7352592509980890960(child);
    int opPrio = MqlExpression_Behavior.call_getPriority_7352592509980890960(expr);
    if (childPrio == opPrio) {
      boolean isRight = SLinkOperations.getTarget(expr, "right", true) == child;
      int assoc = MqlBinaryExpr_Behavior.call_getAssociativity_5322644393894740267(expr);
      if (assoc != 0) {
        return assoc == -1 && isRight || assoc == 1 && !(isRight);
      }
    }
    return childPrio > opPrio;
  }

  public static void rotateIfNecessary(SNode expr) {
    rotateParentsIfNecessary(rotateChildrenIfNecessary(expr));
  }

  private static SNode rotateChildrenIfNecessary(SNode node) {
    SNode expr = node;
    boolean checkMore = true;
    while (checkMore) {
      checkMore = false;
      while (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(expr, "left", true), "jetbrains.mps.query.structure.MqlBinaryExpr") && needsRotate(expr, SNodeOperations.cast(SLinkOperations.getTarget(expr, "left", true), "jetbrains.mps.query.structure.MqlBinaryExpr"))) {
        SNode left = SNodeOperations.cast(SLinkOperations.getTarget(expr, "left", true), "jetbrains.mps.query.structure.MqlBinaryExpr");
        rotate(expr, left);
        rotateChildrenIfNecessary(expr);
        expr = left;
      }
      while (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(expr, "right", true), "jetbrains.mps.query.structure.MqlBinaryExpr") && needsRotate(expr, SNodeOperations.cast(SLinkOperations.getTarget(expr, "right", true), "jetbrains.mps.query.structure.MqlBinaryExpr"))) {
        SNode right = SNodeOperations.cast(SLinkOperations.getTarget(expr, "right", true), "jetbrains.mps.query.structure.MqlBinaryExpr");
        rotate(expr, right);
        rotateChildrenIfNecessary(expr);
        expr = right;
        checkMore = true;
      }
    }
    return expr;
  }

  private static void rotateParentsIfNecessary(SNode expr) {
    while (SNodeOperations.isInstanceOf(SNodeOperations.getParent(expr), "jetbrains.mps.query.structure.MqlBinaryExpr")) {
      SNode parent = SNodeOperations.cast(SNodeOperations.getParent(expr), "jetbrains.mps.query.structure.MqlBinaryExpr");
      SNode newtop = rotateChildrenIfNecessary(parent);
      if (newtop == parent) {
        break;
      }
      expr = parent;
    }
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(expr), "jetbrains.mps.query.structure.MqlUnary")) {
      SNode parent = SNodeOperations.cast(SNodeOperations.getParent(expr), "jetbrains.mps.query.structure.MqlUnary");
      SLinkOperations.setTarget(parent, "expr", SLinkOperations.getTarget(expr, "left", true), true);
      SNodeOperations.replaceWithAnother(parent, expr);
      SLinkOperations.setTarget(expr, "left", parent, true);
    }
  }
}
