package jetbrains.mps.core.smodel.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.ide.findusages.view.FindUtils;
import jetbrains.mps.ide.findusages.findalgorithm.finders.ModuleClassReference;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Set;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import java.util.List;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.awt.Rectangle;
import java.awt.Point;
import com.intellij.ui.awt.RelativePoint;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.ide.editor.util.NodeListCellRenderer;
import jetbrains.mps.ide.navigation.NodeNavigatable;
import java.util.ArrayList;
import java.util.Collections;
import javax.swing.ListCellRenderer;
import jetbrains.mps.ide.editor.util.GoToHelper;
import jetbrains.mps.runtime.ModuleClassLoader;
import javax.swing.JList;
import com.intellij.ui.components.JBList;
import com.intellij.openapi.ui.popup.PopupChooserBuilder;
import jetbrains.mps.util.Computable;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.core.smodel.behavior.SConceptQuery_Behavior;
import jetbrains.mps.smodel.presentation.NodePresentationUtil;

public class QueriesGoToUtil {
  public QueriesGoToUtil() {
  }

  public static boolean hasApplicableFinder(SNode node, ModuleReference finderModule, String finderClassName) {
    return FindUtils.getFinderByClass(new ModuleClassReference(finderModule, finderClassName)).isApplicable(node);
  }

  public static void executeFinders(final SNode query, EditorCell anchorCell, Project project, final ModuleReference finderModule, final String finderClassName) {
    final String[] methodName = new String[1];
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        methodName[0] = SPropertyOperations.getString(query, "name");
        assert FindUtils.getFinderByClass(new ModuleClassReference(finderModule, finderClassName)).isApplicable(query);
      }
    });

    final Set<SNodePointer> nodes = SetSequence.fromSet(new HashSet<SNodePointer>());
    ProgressManager.getInstance().run(new Task.Modal(project, "Searching...", true) {
      public void run(@NotNull final ProgressIndicator p) {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            List<SNode> list = FindUtils.executeFinder(new ModuleClassReference(finderModule, finderClassName), query, GlobalScope.getInstance(), new ProgressMonitorAdapter(p));
            SetSequence.fromSet(nodes).addSequence(ListSequence.fromList(list).select(new ISelector<SNode, SNodePointer>() {
              public SNodePointer select(SNode it) {
                return new SNodePointer(it);
              }
            }));
          }
        });
      }
    });

    Rectangle cellBounds = anchorCell.getBounds();
    Point point = new Point(((int) cellBounds.getMinX()), ((int) cellBounds.getMaxY()));
    RelativePoint relPoint = new RelativePoint(anchorCell.getEditor(), point);

    showOverridingQueriesMenu(SetSequence.fromSet(nodes).toListSequence(), relPoint, ProjectHelper.toMPSProject(project), methodName[0]);
  }

  public static void showOverridingQueriesMenu(List<SNodePointer> nodes, RelativePoint point, jetbrains.mps.project.Project project, String methodName) {
    String title = "Choose overriding query of " + methodName + "() to navigate to";
    QueriesGoToUtil.QueryCellRenderer renderer = new QueriesGoToUtil.QueryCellRenderer();
    showMenu(point, project, title, nodes, renderer);
  }

  private static void showMenu(RelativePoint point, jetbrains.mps.project.Project project, String title, List<SNodePointer> nodes, NodeListCellRenderer renderer) {
    if (ListSequence.fromList(nodes).isEmpty()) {
      return;
    }
    List<NodeNavigatable> navigatables = new ArrayList<NodeNavigatable>();
    for (SNodePointer node : nodes) {
      navigatables.add(new NodeNavigatable(project, node));
    }
    Collections.sort(navigatables, renderer.getComparator());
    openTargets(point, navigatables, title, renderer);
  }

  private static void openTargets(RelativePoint p, List<NodeNavigatable> targets, String title, ListCellRenderer listRenderer) {
    assert !(GoToHelper.class.getClassLoader() instanceof ModuleClassLoader) : "if this class is loaded by a reloadable classloader, this will cause memleaks. See MPS-13481";
    if (targets.isEmpty()) {
      return;
    }
    if (targets.size() == 1) {
      targets.get(0).navigate(true);
    } else {
      final JList list = new JBList(targets.toArray());
      list.setCellRenderer(listRenderer);
      new PopupChooserBuilder(list).setTitle(title).setMovable(true).setItemChoosenCallback(new Runnable() {
        public void run() {
          int[] ids = list.getSelectedIndices();
          if (ids == null || ids.length == 0) {
            return;
          }
          Object[] selectedElements = list.getSelectedValues();
          for (Object element : selectedElements) {
            NodeNavigatable selected = (NodeNavigatable) element;
            selected.navigate(true);
          }
        }
      }).createPopup().show(p);
    }
  }

  public static class QueryCellRenderer extends GoToHelper.DefaultNodeNavigationItemCellRenderer {
    public QueryCellRenderer() {
    }

    @Override
    public String getElementText(final NodeNavigatable element) {
      return ModelAccess.instance().runReadAction(new Computable<String>() {
        public String compute() {
          SNode labelNode = getLabelNode(element);
          if (SNodeOperations.isInstanceOf(labelNode, "jetbrains.mps.core.smodel.structure.SConceptQuery")) {
            return SConceptQuery_Behavior.call_getText_270269450479821683(SNodeOperations.cast(labelNode, "jetbrains.mps.core.smodel.structure.SConceptQuery"));
          }
          return labelNode.getPresentation();
        }
      });
    }

    @Override
    protected SNode getContainerNode(NodeNavigatable element) {
      return getLabelNode(element).getParent();
    }

    @Override
    protected String getContainerText(final NodeNavigatable element, String name) {
      return ModelAccess.instance().runReadAction(new Computable<String>() {
        public String compute() {
          SNode containerNode = getContainerNode(element);
          if (SNodeOperations.isInstanceOf(containerNode, "jetbrains.mps.core.structure.structure.SAbstractConcept")) {
            return "in " + SPropertyOperations.getString(SNodeOperations.cast(containerNode, "jetbrains.mps.core.structure.structure.SAbstractConcept"), "name");
          }
          return NodePresentationUtil.descriptionText(containerNode, false);
        }
      });
    }
  }
}
