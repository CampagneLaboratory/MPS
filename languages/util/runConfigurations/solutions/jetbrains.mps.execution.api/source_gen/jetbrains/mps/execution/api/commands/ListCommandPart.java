package jetbrains.mps.execution.api.commands;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.List;
import org.jetbrains.annotations.Nullable;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.ArrayList;
import java.io.File;

public class ListCommandPart extends AbstractCommandPart implements CommandPart {
  protected static Log log = LogFactory.getLog(ListCommandPart.class);

  public ListCommandPart(List<? extends Object> list) {
    this(list, null);
  }

  public ListCommandPart(List<? extends Object> list, @Nullable String separator) {
    if (StringUtils.isEmpty(separator)) {
      addCommands(getCommands(list));
    } else {
      addCommands(IterableUtils.join(Sequence.fromIterable(getCommands(list)), separator));
    }
  }

  private Iterable<String> getCommands(List<? extends Object> list) {
    return ListSequence.fromList(list).<String>translate(new ITranslator2<Object, String>() {
      public Iterable<String> translate(Object it) {
        if (it == null) {
          return ListSequence.fromList(new ArrayList<String>());
        }
        if (it instanceof String) {
          if (StringUtils.isNotEmpty(((String) it))) {
            return ProcessHandlerBuilder.splitCommandInParts((String) it);
          }
        } else if (it instanceof File) {
          String path = ((File) it).getAbsolutePath();
          if (StringUtils.isNotEmpty(path)) {
            return Sequence.<String>singleton(path);
          }
        } else if (it instanceof CommandPart) {
          return ((CommandPart) it).getCommandList();
        } else {
          if (log.isErrorEnabled()) {
            log.error("Unknown type of command part " + it);
          }
        }
        return ListSequence.fromList(new ArrayList<String>());
      }
    });
  }
}
