package jetbrains.mps.execution.lib;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.io.File;
import com.intellij.util.SystemProperties;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.intellij.execution.process.ProcessHandler;
import com.intellij.execution.ExecutionException;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.execution.api.commands.ProcessHandlerBuilder;
import java.io.FileNotFoundException;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.baseLanguage.runConfigurations.runtime.JavaRunParameters;
import jetbrains.mps.debug.api.IDebugger;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.traceInfo.DebugInfo;
import jetbrains.mps.generator.traceInfo.TraceInfoCache;
import jetbrains.mps.traceInfo.UnitPositionInfo;
import jetbrains.mps.traceInfo.DebugInfoRoot;
import jetbrains.mps.traceInfo.TraceablePositionInfo;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.IModule;
import jetbrains.mps.reloading.ClasspathStringCollector;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.util.CollectionUtil;
import java.util.Set;
import jetbrains.mps.reloading.CommonPaths;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.project.ModuleId;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.util.SystemInfo;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.util.FileUtil;
import java.io.PrintWriter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.debug.api.run.IDebuggerConfiguration;
import jetbrains.mps.debug.api.IDebuggerSettings;
import jetbrains.mps.debug.runtime.settings.LocalConnectionSettings;
import jetbrains.mps.debug.api.Debuggers;
import java.util.HashSet;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SNodeId;

public class Java_Command {
  protected static Log log = LogFactory.getLog(Java_Command.class);

  private File myWorkingDirectory = new File(SystemProperties.getUserHome());
  private String myJrePath = Java_Command.getJdkHome();
  private String myProgramParameter;
  private String myVirtualMachineParameter;
  private List<String> myClassPath = ListSequence.fromList(new ArrayList<String>());
  private String myDebuggerSettings;

  public Java_Command() {
  }

  public Java_Command setWorkingDirectory(File workingDirectory) {
    if (workingDirectory != null) {
      myWorkingDirectory = workingDirectory;
    }
    return this;
  }

  public Java_Command setJrePath(String jrePath) {
    if (jrePath != null) {
      myJrePath = jrePath;
    }
    return this;
  }

  public Java_Command setProgramParameter(String programParameter) {
    if (programParameter != null) {
      myProgramParameter = programParameter;
    }
    return this;
  }

  public Java_Command setVirtualMachineParameter(String virtualMachineParameter) {
    if (virtualMachineParameter != null) {
      myVirtualMachineParameter = virtualMachineParameter;
    }
    return this;
  }

  public Java_Command setClassPath(List<String> classPath) {
    if (classPath != null) {
      myClassPath = classPath;
    }
    return this;
  }

  public Java_Command setDebuggerSettings(String debuggerSettings) {
    if (debuggerSettings != null) {
      myDebuggerSettings = debuggerSettings;
    }
    return this;
  }

  public ProcessHandler createProcess(String className) throws ExecutionException {
    String java = Java_Command.getJavaCommand(myJrePath);
    String classPathString = IterableUtils.join(ListSequence.fromList(myClassPath).select(new ISelector<String, String>() {
      public String select(String it) {
        return Java_Command.protect(it);
      }
    }), File.pathSeparator);
    if (StringUtils.isEmpty(className)) {
      throw new ExecutionException("Classname is empty");
    }
    if (check_yvpt_a0a3a0a(myProgramParameter) + classPathString.length() >= Java_Command.getMaxCommandLine()) {
      try {
        String parametersFile = Java_Command.writeToTmpFile(ProcessHandlerBuilder.splitCommandInParts((myProgramParameter == null ?
          "" :
          myProgramParameter
        )));
        String classPathFile = Java_Command.writeToTmpFile(myClassPath);
        String classRunnerClassPath = IterableUtils.join(ListSequence.fromList(Java_Command.getClassRunnerClassPath()).select(new ISelector<String, String>() {
          public String select(String it) {
            return Java_Command.protect(it);
          }
        }), File.pathSeparator);
        return new ProcessHandlerBuilder().append(java).append(myVirtualMachineParameter).append(myDebuggerSettings).appendKey("classpath", classRunnerClassPath).append("jetbrains.mps.execution.lib.startup.ClassRunner").appendKey(("c"), className).appendKey(("p"), classPathFile).appendKey(("f"), parametersFile).build(myWorkingDirectory);
      } catch (FileNotFoundException e) {
        throw new ExecutionException("Could not create temporal file for program parameters.", e);
      }
    } else {
      return new ProcessHandlerBuilder().append(java).append(myVirtualMachineParameter).append(myDebuggerSettings).appendKey("classpath", classPathString).append(className).append(myProgramParameter).build(myWorkingDirectory);
    }
  }

  public ProcessHandler createProcess(SNode node) throws ExecutionException {
    return new Java_Command().setJrePath(myJrePath).setWorkingDirectory(myWorkingDirectory).setProgramParameter(myProgramParameter).setVirtualMachineParameter(myVirtualMachineParameter).setClassPath(Java_Command.getClasspath(node)).setDebuggerSettings(myDebuggerSettings).createProcess(Java_Command.getClassName(node));
  }

  public ProcessHandler createProcess(JavaRunParameters runParameters, SNode node) throws ExecutionException {
    return new Java_Command().setJrePath(check_yvpt_a0a0a0c(runParameters)).setProgramParameter(check_yvpt_a2a0a0c(runParameters)).setVirtualMachineParameter(check_yvpt_a3a0a0c(runParameters)).setWorkingDirectory((check_yvpt_a0a4a0a0c(runParameters) == null ?
      null :
      new File(check_yvpt_a0a0e0a0a2(runParameters))
    )).setDebuggerSettings(myDebuggerSettings).createProcess(node);
  }

  public static IDebugger getDebugger() {
    return getDebuggerConfiguration().getDebugger();
  }

  public static boolean isUnitNode(SNode node) {
    return StringUtils.isNotEmpty(Java_Command.getClassName(node));
  }

  private static String getClassName(final SNode node) {
    final Wrappers._T<String> className = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        SModel model = SNodeOperations.getModel(node);
        DebugInfo debugInfo = TraceInfoCache.getInstance().get(model.getModelDescriptor());
        if (debugInfo == null) {
          if (log.isErrorEnabled()) {
            log.error("No trace.info found for model " + model + ". Check that model is generated.");
          }
          className.value = null;
        } else {
          List<UnitPositionInfo> unitForNode = debugInfo.getUnitsForNode(node.getId());
          if (ListSequence.fromList(unitForNode).isEmpty()) {
            if (log.isErrorEnabled()) {
              log.error("No unitName found for " + node + " in trace.info. Check that model is generated.");
            }
            className.value = null;
          } else if ((int) ListSequence.fromList(unitForNode).count() == 1) {
            className.value = ListSequence.fromList(unitForNode).first().getUnitName();
          } else {
            DebugInfoRoot infoRoot = debugInfo.getRootInfo(SNodeOperations.getContainingRoot(node).getId());
            className.value = null;
            for (final TraceablePositionInfo position : SetSequence.fromSet(infoRoot.getPositions())) {
              if (position.getConceptFqName().equals("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")) {
                if (eq_kk96hj_a0a0a0c0a1a0c0a0a0a0b0c(position.getPropertyString(), ((String) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(new Java_Command.QuotationClass_kk96hj_a0a0a0a0c0a1a0c0a0a1a2().createNode(), "jetbrains.mps.lang.traceable.structure.TraceableConcept"), "virtual_getTraceableProperty_5067982036267369901", new Class[]{SNode.class})))) {
                  UnitPositionInfo unit = ListSequence.fromList(unitForNode).findFirst(new IWhereFilter<UnitPositionInfo>() {
                    public boolean accept(UnitPositionInfo it) {
                      return it.isPositionInside(position.getFileName(), position.getStartLine());
                    }
                  });
                  if (unit != null) {
                    className.value = unit.getUnitName();
                    break;
                  }
                }
              }
            }
          }
        }
      }
    });
    return className.value;
  }

  private static int getMaxCommandLine() {
    // the command line limit on win is 32767 characters 
    // (see http://blogs.msdn.com/b/oldnewthing/archive/2003/12/10/56028.aspx) 
    // we set the limit to 16384 (half as many) just in case 
    return 16384;
  }

  public static List<String> getClasspath(final SNode node) {
    final Wrappers._T<IModule> module = new Wrappers._T<IModule>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        module.value = SNodeOperations.getModel(node).getModelDescriptor().getModule();
      }
    });
    return Java_Command.getClasspath(module.value, true);
  }

  public static List<String> getClasspath(final IModule module, boolean withDependencies) {
    final ClasspathStringCollector visitor = new ClasspathStringCollector();
    module.getClassPathItem().accept(visitor);
    if (withDependencies) {
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          AbstractModule.getDependenciesClasspath(CollectionUtil.set(module), true).accept(visitor);
        }
      });
    }

    Set<String> visited = visitor.getClasspath();
    visited.removeAll(CommonPaths.getJDKPath());
    return ListSequence.fromListWithValues(new ArrayList<String>(), visited);
  }

  private static List<String> getClassRunnerClassPath() {
    final Wrappers._T<IModule> module = new Wrappers._T<IModule>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        module.value = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("5b247b59-8fd0-4475-a767-9e9ff6a9d01c"));
      }
    });

    return Java_Command.getClasspath(module.value, false);
  }

  public static String getJavaCommand(@Nullable String javaHome) throws ExecutionException {
    if (StringUtils.isEmpty(javaHome) || !(new File(javaHome).exists())) {
      javaHome = Java_Command.getJdkHome();
    }
    if (StringUtils.isEmpty(javaHome)) {
      throw new ExecutionException("Could not find valid java home.");
    }
    return Java_Command.protect(Java_Command.getJavaCommandUnprotected(javaHome));
  }

  public static String getJavaCommandUnprotected(String javaHome) {
    String result = javaHome + File.separator + "bin" + File.separator;
    String java = "java";
    if (SystemInfo.isMac) {
      result += java;
    } else
    if (SystemInfo.isWindows) {
      result += java + ".exe";
    } else {
      result += java;
    }
    return result;
  }

  public static List<String> getJavaHomes() {
    String systemJavaHome = SystemProperties.getJavaHome();
    List<String> homes = ListSequence.fromList(new LinkedList<String>());
    String systemJdkHome = systemJavaHome.substring(0, systemJavaHome.length() - "/jre".length());
    if (systemJavaHome.endsWith("jre") && new File(systemJdkHome + File.separator + "bin").exists()) {
      ListSequence.fromList(homes).addElement(systemJdkHome);
    }
    if (StringUtils.isNotEmpty(System.getenv("JAVA_HOME"))) {
      ListSequence.fromList(homes).addElement(System.getenv("JAVA_HOME"));
    }
    ListSequence.fromList(homes).addElement(systemJavaHome);
    return homes;
  }

  public static String getJdkHome() {
    List<String> homes = Java_Command.getJavaHomes();
    for (String javaHome : ListSequence.fromList(homes)) {
      if (new File(Java_Command.getJavaCommandUnprotected(javaHome)).exists()) {
        return javaHome;
      }
    }
    return null;
  }

  public static String protect(String result) {
    if (result.contains(" ")) {
      return "\"" + result + "\"";
    }
    return result;
  }

  private static String writeToTmpFile(Iterable<String> text) throws FileNotFoundException {
    File tmpFile = FileUtil.createTmpFile();
    tmpFile.deleteOnExit();
    PrintWriter writer = new PrintWriter(tmpFile);
    for (String line : Sequence.fromIterable(text)) {
      writer.println(line);
    }
    writer.flush();
    writer.close();
    return tmpFile.getAbsolutePath();
  }

  public static IDebuggerConfiguration getDebuggerConfiguration() {
    return new IDebuggerConfiguration() {
      @Nullable
      public IDebuggerSettings createDebuggerSettings() {
        return new LocalConnectionSettings(true);
      }

      public IDebugger getDebugger() {
        return Debuggers.getInstance().getDebuggerByName("Java");
      }
    };
  }

  private static int check_yvpt_a0a3a0a(String checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.length();
    }
    return 0;
  }

  private static String check_yvpt_a0a0a0c(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getAlternativeJre();
    }
    return null;
  }

  private static String check_yvpt_a2a0a0c(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.programParameters();
    }
    return null;
  }

  private static String check_yvpt_a3a0a0c(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.vmOptions();
    }
    return null;
  }

  private static String check_yvpt_a0a0e0a0a2(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.workingDirectory();
    }
    return null;
  }

  private static String check_yvpt_a0a4a0a0c(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.workingDirectory();
    }
    return null;
  }

  private static boolean eq_kk96hj_a0a0a0c0a1a0c0a0a0a0b0c(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  public static class QuotationClass_kk96hj_a0a0a0a0c0a1a0c0a0a1a2 {
    public QuotationClass_kk96hj_a0a0a0a0c0a1a0c0a0a1a2() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      SNode quotedNode_3 = null;
      SNode quotedNode_4 = null;
      SNode quotedNode_5 = null;
      SNode quotedNode_6 = null;
      SNode quotedNode_7 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_8 = quotedNode_1;
        quotedNode1_8.setProperty("name", "main");
        {
          quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.VoidType", null, GlobalScope.getInstance(), false);
          SNode quotedNode1_9 = quotedNode_2;
          quotedNode_1.addChild("returnType", quotedNode1_9);
        }
        {
          quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PublicVisibility", null, GlobalScope.getInstance(), false);
          SNode quotedNode1_10 = quotedNode_3;
          quotedNode_1.addChild("visibility", quotedNode1_10);
        }
        {
          quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StatementList", null, GlobalScope.getInstance(), false);
          SNode quotedNode1_11 = quotedNode_4;
          quotedNode_1.addChild("body", quotedNode1_11);
        }
        {
          quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ParameterDeclaration", null, GlobalScope.getInstance(), false);
          SNode quotedNode1_12 = quotedNode_5;
          quotedNode1_12.setProperty("name", "args");
          {
            quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ArrayType", null, GlobalScope.getInstance(), false);
            SNode quotedNode1_13 = quotedNode_6;
            {
              quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ClassifierType", null, GlobalScope.getInstance(), false);
              SNode quotedNode1_14 = quotedNode_7;
              quotedNode1_14.addReference(SReference.create("classifier", quotedNode1_14, SModelReference.fromString("f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(java.lang@java_stub)"), SNodeId.fromString("~String")));
              quotedNode_6.addChild("componentType", quotedNode1_14);
            }
            quotedNode_5.addChild("type", quotedNode1_13);
          }
          quotedNode_1.addChild("parameter", quotedNode1_12);
        }
        result = quotedNode1_8;
      }
      return result;
    }
  }
}
