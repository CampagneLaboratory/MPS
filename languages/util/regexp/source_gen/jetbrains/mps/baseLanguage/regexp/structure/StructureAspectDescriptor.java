package jetbrains.mps.baseLanguage.regexp.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.BaseStructureAspectDescriptor;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.impl.ConceptDescriptorBuilder;
import jetbrains.mps.smodel.runtime.StaticScope;
import java.util.Collection;
import java.util.Arrays;
import org.jetbrains.annotations.NotNull;

public class StructureAspectDescriptor extends BaseStructureAspectDescriptor {
  /*package*/ final ConceptDescriptor myConceptAtLeastNTimesRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.AtLeastNTimesRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").properties("n").alias("{n,}", "at least n times").create();
  /*package*/ final ConceptDescriptor myConceptBinaryRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"left", "right"}, new boolean[]{false, false}).abstract_().create();
  /*package*/ final ConceptDescriptor myConceptCharacterSymbolClassPart = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").properties("character").alias("'", "character").create();
  /*package*/ final ConceptDescriptor myConceptDotRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.DotRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").alias(".", "dot regexp (any character)").create();
  /*package*/ final ConceptDescriptor myConceptFindMatchExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.FindMatchExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"inputExpression"}, new boolean[]{false}).alias("=~", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptFindMatchStatement = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.FindMatchStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").children(new String[]{"expr", "body"}, new boolean[]{false, false}).alias("if (expr =~ regex) {", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptForEachMatchStatement = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ForEachMatchStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").children(new String[]{"expr", "body"}, new boolean[]{false, false}).alias("while (expr =~ regex) {", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptFromNToMTimesRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.FromNToMTimesRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").properties("n", "m").alias("{n,m}", "at least n but not more than m times").create();
  /*package*/ final ConceptDescriptor myConceptInlineRegexpExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.InlineRegexpExpression").super_("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression").parents("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression").properties("dotAll", "multiLine", "caseInsensitive").children(new String[]{"regexp"}, new boolean[]{false}).alias("/regexp/", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptIntersectionSymbolClassPart = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.IntersectionSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").children(new String[]{"left", "right"}, new boolean[]{false, false}).alias("&&", "intersection of classes").create();
  /*package*/ final ConceptDescriptor myConceptIntervalSymbolClassPart = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.IntervalSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").properties("start", "end").alias("-", "character range").create();
  /*package*/ final ConceptDescriptor myConceptLazyPlusRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LazyPlusRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("+?", "one or more times, reluctant").create();
  /*package*/ final ConceptDescriptor myConceptLazyQuestionRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LazyQuestionRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("??", "once or not at all, reluctant").create();
  /*package*/ final ConceptDescriptor myConceptLazyStarRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LazyStarRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("*?", "zero or more times, reluctant").create();
  /*package*/ final ConceptDescriptor myConceptLineEndRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LineEndRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").alias("$", "line end").create();
  /*package*/ final ConceptDescriptor myConceptLineStartRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LineStartRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").alias("^", "line start").create();
  /*package*/ final ConceptDescriptor myConceptLiteralReplacement = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LiteralReplacement").super_("jetbrains.mps.baseLanguage.regexp.structure.Replacement").parents("jetbrains.mps.baseLanguage.regexp.structure.Replacement", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").properties("text").create();
  /*package*/ final ConceptDescriptor myConceptLookRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"regexp"}, new boolean[]{false}).abstract_().create();
  /*package*/ final ConceptDescriptor myConceptMatchParensRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchParensRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp", "jetbrains.mps.lang.core.structure.INamedConcept", "jetbrains.mps.baseLanguage.structure.IVariableAssignment", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"regexp"}, new boolean[]{false}).alias("(name:", "matching parens").create();
  /*package*/ final ConceptDescriptor myConceptMatchRegexpExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"inputExpression"}, new boolean[]{false}).alias("matches", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatchRegexpOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.BaseConcept").alias("matches", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatchRegexpStatement = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").children(new String[]{"body", "expr"}, new boolean[]{false, false}).alias("if (expr matches regexp) {", "match with regexp").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatchVariableReference = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("match").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatchVariableReferenceRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").references("match").create();
  /*package*/ final ConceptDescriptor myConceptMatchVariableReferenceReplacement = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceReplacement").super_("jetbrains.mps.baseLanguage.regexp.structure.Replacement").parents("jetbrains.mps.baseLanguage.regexp.structure.Replacement").references("match").create();
  /*package*/ final ConceptDescriptor myConceptNTimesRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NTimesRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").properties("n").alias("{n}", "exactly n times").create();
  /*package*/ final ConceptDescriptor myConceptNegativeLookAheadRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NegativeLookAheadRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?!", "negative look ahead").create();
  /*package*/ final ConceptDescriptor myConceptNegativeLookBehindRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NegativeLookBehindRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?<!", "negative look behind").create();
  /*package*/ final ConceptDescriptor myConceptNegativeSymbolClassRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NegativeSymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").alias("[^", "negative symbol class").create();
  /*package*/ final ConceptDescriptor myConceptOrRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.OrRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").alias("|", "").create();
  /*package*/ final ConceptDescriptor myConceptParensRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ParensRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"expr"}, new boolean[]{false}).alias("(", "parens").create();
  /*package*/ final ConceptDescriptor myConceptPlusRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PlusRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("+", "one or more times").create();
  /*package*/ final ConceptDescriptor myConceptPositiveLookAheadRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PositiveLookAheadRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?=", "").create();
  /*package*/ final ConceptDescriptor myConceptPositiveLookBehindRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PositiveLookBehindRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?<=", "positive look behind").create();
  /*package*/ final ConceptDescriptor myConceptPositiveSymbolClassRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PositiveSymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").alias("[", "positive symbol class").create();
  /*package*/ final ConceptDescriptor myConceptPredefinedSymbolClassDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassDeclaration").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").properties("description").create();
  /*package*/ final ConceptDescriptor myConceptPredefinedSymbolClassRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").references("symbolClass").create();
  /*package*/ final ConceptDescriptor myConceptPredefinedSymbolClassSymbolClassPart = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").references("declaration").create();
  /*package*/ final ConceptDescriptor myConceptPredefinedSymbolClasses = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClasses").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").children(new String[]{"symbolClass"}, new boolean[]{true}).create();
  /*package*/ final ConceptDescriptor myConceptQuestionRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.QuestionRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("?", "once or not at all").create();
  /*package*/ final ConceptDescriptor myConceptRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.Regexp").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").abstract_().create();
  /*package*/ final ConceptDescriptor myConceptRegexpDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclaration").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").properties("description").children(new String[]{"regexp"}, new boolean[]{false}).create();
  /*package*/ final ConceptDescriptor myConceptRegexpDeclarationReferenceRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclarationReferenceRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").references("regexp").create();
  /*package*/ final ConceptDescriptor myConceptRegexpExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").abstract_().staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptRegexpUsingConstruction = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").interface_().children(new String[]{"regexp"}, new boolean[]{false}).create();
  /*package*/ final ConceptDescriptor myConceptRegexps = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.Regexps").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").children(new String[]{"regexp"}, new boolean[]{true}).create();
  /*package*/ final ConceptDescriptor myConceptReplaceBlock = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceBlock").super_("jetbrains.mps.baseLanguage.structure.Closure").parents("jetbrains.mps.baseLanguage.structure.Closure").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptReplaceRegexpOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceRegexpOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation", "jetbrains.mps.lang.core.structure.BaseConcept").properties("dotAll", "multiLine", "caseInsensitive", "globalReplace").children(new String[]{"search", "replacement"}, new boolean[]{false, true}).alias("s/regexp/replacement/", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptReplaceWithRegexpExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"expr", "replaceBlock"}, new boolean[]{false, false}).alias("replace with regexp", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptReplaceWithRegexpOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.BaseConcept").children(new String[]{"replaceBlock"}, new boolean[]{false}).alias("replace with", "replace with regexp").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptReplacement = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.Replacement").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").abstract_().create();
  /*package*/ final ConceptDescriptor myConceptSeqRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SeqRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").alias("seq", "").create();
  /*package*/ final ConceptDescriptor myConceptSplitExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SplitExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"expr"}, new boolean[]{false}).alias("split with", "split with regexp").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptSplitOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SplitOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault", "jetbrains.mps.lang.core.structure.BaseConcept").alias("split with", "split with regexp").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptStarRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.StarRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("*", "zero or more times").create();
  /*package*/ final ConceptDescriptor myConceptStringLiteralRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").properties("text").alias("'", "").create();
  /*package*/ final ConceptDescriptor myConceptSymbolClassPart = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart").abstract_().create();
  /*package*/ final ConceptDescriptor myConceptSymbolClassRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp", "jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart").children(new String[]{"part"}, new boolean[]{true}).abstract_().create();
  /*package*/ final ConceptDescriptor myConceptSymbolClassRegexpAndPart = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart").interface_().create();
  /*package*/ final ConceptDescriptor myConceptUnaryRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"regexp"}, new boolean[]{false}).abstract_().create();
  /*package*/ final ConceptDescriptor myConceptUnicodeCharacterRegexp = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").properties("code").alias("\\uhhhh", "").create();

  @Override
  public Collection<ConceptDescriptor> getDescriptors() {
    return Arrays.asList(myConceptAtLeastNTimesRegexp, myConceptBinaryRegexp, myConceptCharacterSymbolClassPart, myConceptDotRegexp, myConceptFindMatchExpression, myConceptFindMatchStatement, myConceptForEachMatchStatement, myConceptFromNToMTimesRegexp, myConceptInlineRegexpExpression, myConceptIntersectionSymbolClassPart, myConceptIntervalSymbolClassPart, myConceptLazyPlusRegexp, myConceptLazyQuestionRegexp, myConceptLazyStarRegexp, myConceptLineEndRegexp, myConceptLineStartRegexp, myConceptLiteralReplacement, myConceptLookRegexp, myConceptMatchParensRegexp, myConceptMatchRegexpExpression, myConceptMatchRegexpOperation, myConceptMatchRegexpStatement, myConceptMatchVariableReference, myConceptMatchVariableReferenceRegexp, myConceptMatchVariableReferenceReplacement, myConceptNTimesRegexp, myConceptNegativeLookAheadRegexp, myConceptNegativeLookBehindRegexp, myConceptNegativeSymbolClassRegexp, myConceptOrRegexp, myConceptParensRegexp, myConceptPlusRegexp, myConceptPositiveLookAheadRegexp, myConceptPositiveLookBehindRegexp, myConceptPositiveSymbolClassRegexp, myConceptPredefinedSymbolClassDeclaration, myConceptPredefinedSymbolClassRegexp, myConceptPredefinedSymbolClassSymbolClassPart, myConceptPredefinedSymbolClasses, myConceptQuestionRegexp, myConceptRegexp, myConceptRegexpDeclaration, myConceptRegexpDeclarationReferenceRegexp, myConceptRegexpExpression, myConceptRegexpUsingConstruction, myConceptRegexps, myConceptReplaceBlock, myConceptReplaceRegexpOperation, myConceptReplaceWithRegexpExpression, myConceptReplaceWithRegexpOperation, myConceptReplacement, myConceptSeqRegexp, myConceptSplitExpression, myConceptSplitOperation, myConceptStarRegexp, myConceptStringLiteralRegexp, myConceptSymbolClassPart, myConceptSymbolClassRegexp, myConceptSymbolClassRegexpAndPart, myConceptUnaryRegexp, myConceptUnicodeCharacterRegexp);
  }

  @Override
  @NotNull
  public ConceptDescriptor getDescriptor(String conceptFqName) {
    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0mc, conceptFqName)) {
      case 0:
        return myConceptAtLeastNTimesRegexp;
      case 1:
        return myConceptBinaryRegexp;
      case 2:
        return myConceptCharacterSymbolClassPart;
      case 3:
        return myConceptDotRegexp;
      case 4:
        return myConceptFindMatchExpression;
      case 5:
        return myConceptFindMatchStatement;
      case 6:
        return myConceptForEachMatchStatement;
      case 7:
        return myConceptFromNToMTimesRegexp;
      case 8:
        return myConceptInlineRegexpExpression;
      case 9:
        return myConceptIntersectionSymbolClassPart;
      case 10:
        return myConceptIntervalSymbolClassPart;
      case 11:
        return myConceptLazyPlusRegexp;
      case 12:
        return myConceptLazyQuestionRegexp;
      case 13:
        return myConceptLazyStarRegexp;
      case 14:
        return myConceptLineEndRegexp;
      case 15:
        return myConceptLineStartRegexp;
      case 16:
        return myConceptLiteralReplacement;
      case 17:
        return myConceptLookRegexp;
      case 18:
        return myConceptMatchParensRegexp;
      case 19:
        return myConceptMatchRegexpExpression;
      case 20:
        return myConceptMatchRegexpOperation;
      case 21:
        return myConceptMatchRegexpStatement;
      case 22:
        return myConceptMatchVariableReference;
      case 23:
        return myConceptMatchVariableReferenceRegexp;
      case 24:
        return myConceptMatchVariableReferenceReplacement;
      case 25:
        return myConceptNTimesRegexp;
      case 26:
        return myConceptNegativeLookAheadRegexp;
      case 27:
        return myConceptNegativeLookBehindRegexp;
      case 28:
        return myConceptNegativeSymbolClassRegexp;
      case 29:
        return myConceptOrRegexp;
      case 30:
        return myConceptParensRegexp;
      case 31:
        return myConceptPlusRegexp;
      case 32:
        return myConceptPositiveLookAheadRegexp;
      case 33:
        return myConceptPositiveLookBehindRegexp;
      case 34:
        return myConceptPositiveSymbolClassRegexp;
      case 35:
        return myConceptPredefinedSymbolClassDeclaration;
      case 36:
        return myConceptPredefinedSymbolClassRegexp;
      case 37:
        return myConceptPredefinedSymbolClassSymbolClassPart;
      case 38:
        return myConceptPredefinedSymbolClasses;
      case 39:
        return myConceptQuestionRegexp;
      case 40:
        return myConceptRegexp;
      case 41:
        return myConceptRegexpDeclaration;
      case 42:
        return myConceptRegexpDeclarationReferenceRegexp;
      case 43:
        return myConceptRegexpExpression;
      case 44:
        return myConceptRegexpUsingConstruction;
      case 45:
        return myConceptRegexps;
      case 46:
        return myConceptReplaceBlock;
      case 47:
        return myConceptReplaceRegexpOperation;
      case 48:
        return myConceptReplaceWithRegexpExpression;
      case 49:
        return myConceptReplaceWithRegexpOperation;
      case 50:
        return myConceptReplacement;
      case 51:
        return myConceptSeqRegexp;
      case 52:
        return myConceptSplitExpression;
      case 53:
        return myConceptSplitOperation;
      case 54:
        return myConceptStarRegexp;
      case 55:
        return myConceptStringLiteralRegexp;
      case 56:
        return myConceptSymbolClassPart;
      case 57:
        return myConceptSymbolClassRegexp;
      case 58:
        return myConceptSymbolClassRegexpAndPart;
      case 59:
        return myConceptUnaryRegexp;
      case 60:
        return myConceptUnicodeCharacterRegexp;
      default:
        throw new IllegalStateException("Wrong fqName of the concept " + conceptFqName);
    }
  }
  private static String[] stringSwitchCases_1htk8d_a0a0mc = new String[]{"jetbrains.mps.baseLanguage.regexp.structure.AtLeastNTimesRegexp", "jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp", "jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart", "jetbrains.mps.baseLanguage.regexp.structure.DotRegexp", "jetbrains.mps.baseLanguage.regexp.structure.FindMatchExpression", "jetbrains.mps.baseLanguage.regexp.structure.FindMatchStatement", "jetbrains.mps.baseLanguage.regexp.structure.ForEachMatchStatement", "jetbrains.mps.baseLanguage.regexp.structure.FromNToMTimesRegexp", "jetbrains.mps.baseLanguage.regexp.structure.InlineRegexpExpression", "jetbrains.mps.baseLanguage.regexp.structure.IntersectionSymbolClassPart", "jetbrains.mps.baseLanguage.regexp.structure.IntervalSymbolClassPart", "jetbrains.mps.baseLanguage.regexp.structure.LazyPlusRegexp", "jetbrains.mps.baseLanguage.regexp.structure.LazyQuestionRegexp", "jetbrains.mps.baseLanguage.regexp.structure.LazyStarRegexp", "jetbrains.mps.baseLanguage.regexp.structure.LineEndRegexp", "jetbrains.mps.baseLanguage.regexp.structure.LineStartRegexp", "jetbrains.mps.baseLanguage.regexp.structure.LiteralReplacement", "jetbrains.mps.baseLanguage.regexp.structure.LookRegexp", "jetbrains.mps.baseLanguage.regexp.structure.MatchParensRegexp", "jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpExpression", "jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpOperation", "jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpStatement", "jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReference", "jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceRegexp", "jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceReplacement", "jetbrains.mps.baseLanguage.regexp.structure.NTimesRegexp", "jetbrains.mps.baseLanguage.regexp.structure.NegativeLookAheadRegexp", "jetbrains.mps.baseLanguage.regexp.structure.NegativeLookBehindRegexp", "jetbrains.mps.baseLanguage.regexp.structure.NegativeSymbolClassRegexp", "jetbrains.mps.baseLanguage.regexp.structure.OrRegexp", "jetbrains.mps.baseLanguage.regexp.structure.ParensRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PlusRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PositiveLookAheadRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PositiveLookBehindRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PositiveSymbolClassRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassDeclaration", "jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassSymbolClassPart", "jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClasses", "jetbrains.mps.baseLanguage.regexp.structure.QuestionRegexp", "jetbrains.mps.baseLanguage.regexp.structure.Regexp", "jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclaration", "jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclarationReferenceRegexp", "jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.baseLanguage.regexp.structure.Regexps", "jetbrains.mps.baseLanguage.regexp.structure.ReplaceBlock", "jetbrains.mps.baseLanguage.regexp.structure.ReplaceRegexpOperation", "jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpExpression", "jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpOperation", "jetbrains.mps.baseLanguage.regexp.structure.Replacement", "jetbrains.mps.baseLanguage.regexp.structure.SeqRegexp", "jetbrains.mps.baseLanguage.regexp.structure.SplitExpression", "jetbrains.mps.baseLanguage.regexp.structure.SplitOperation", "jetbrains.mps.baseLanguage.regexp.structure.StarRegexp", "jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp", "jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart", "jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp", "jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart", "jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp", "jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp"};
}
