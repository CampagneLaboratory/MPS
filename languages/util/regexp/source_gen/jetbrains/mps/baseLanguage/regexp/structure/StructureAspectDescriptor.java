package jetbrains.mps.baseLanguage.regexp.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.BaseStructureAspectDescriptor;
import java.util.Map;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.smodel.runtime.interpreted.StructureAspectInterpreted;
import org.jetbrains.annotations.NotNull;
import java.util.Arrays;
import jetbrains.mps.smodel.runtime.impl.ConceptDescriptorBuilder;
import jetbrains.mps.smodel.runtime.StaticScope;

public class StructureAspectDescriptor implements BaseStructureAspectDescriptor {
  private final Map<String, ConceptDescriptor> myFqNameToConcept = new HashMap<String, ConceptDescriptor>();

  public StructureAspectDescriptor() {
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.AtLeastNTimesRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.DotRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.FindMatchExpression", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.FindMatchStatement", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.ForEachMatchStatement", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.FromNToMTimesRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.InlineRegexpExpression", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.IntersectionSymbolClassPart", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.IntervalSymbolClassPart", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.LazyPlusRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.LazyQuestionRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.LazyStarRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.LineEndRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.LineStartRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.LiteralReplacement", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.MatchParensRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpExpression", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpOperation", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpStatement", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReference", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceReplacement", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.NTimesRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.NegativeLookAheadRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.NegativeLookBehindRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.NegativeSymbolClassRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.OrRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.ParensRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.PlusRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.PositiveLookAheadRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.PositiveLookBehindRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.PositiveSymbolClassRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassDeclaration", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassSymbolClassPart", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClasses", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.QuestionRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.Regexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclaration", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclarationReferenceRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.Regexps", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.ReplaceBlock", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.ReplaceRegexpOperation", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpExpression", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpOperation", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.Replacement", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.SeqRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.SplitExpression", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.SplitOperation", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.StarRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp", null);
    myFqNameToConcept.put("jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp", null);
  }

  @Override
  public Set<ConceptDescriptor> getDescriptors() {
    for (String fqName : myFqNameToConcept.keySet()) {
      if (myFqNameToConcept.get(fqName) == null) {
        initLazy(fqName);
      }
    }
    return new HashSet<ConceptDescriptor>(myFqNameToConcept.values());
  }

  @Override
  public ConceptDescriptor getDescriptor(String conceptFqName) {
    if (!(myFqNameToConcept.containsKey(conceptFqName))) {
      return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);
    }
    return initLazy(conceptFqName);
  }

  @NotNull
  private ConceptDescriptor initLazy(String conceptFqName) {
    assert myFqNameToConcept.containsKey(conceptFqName);
    ConceptDescriptor conceptDescriptor = myFqNameToConcept.get(conceptFqName);
    if (conceptDescriptor != null) {
      return conceptDescriptor;
    }
    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0d0i, conceptFqName)) {
      case 0:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.AtLeastNTimesRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").properties("n").alias("{n,}", "at least n times").create();
        break;
      case 1:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"left", "right"}, new boolean[]{false, false}).abstract_().create();
        break;
      case 2:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").properties("character").alias("'", "character").create();
        break;
      case 3:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.DotRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").alias(".", "dot regexp (any character)").create();
        break;
      case 4:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.FindMatchExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"inputExpression"}, new boolean[]{false}).alias("=~", "").staticScope(StaticScope.NONE).create();
        break;
      case 5:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.FindMatchStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").children(new String[]{"expr", "body"}, new boolean[]{false, false}).alias("if (expr =~ regex) {", "").staticScope(StaticScope.NONE).create();
        break;
      case 6:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ForEachMatchStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").children(new String[]{"expr", "body"}, new boolean[]{false, false}).alias("while (expr =~ regex) {", "").staticScope(StaticScope.NONE).create();
        break;
      case 7:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.FromNToMTimesRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").properties("n", "m").alias("{n,m}", "at least n but not more than m times").create();
        break;
      case 8:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.InlineRegexpExpression").super_("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression").parents("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression").properties("dotAll", "multiLine", "caseInsensitive").children(new String[]{"regexp"}, new boolean[]{false}).alias("/regexp/", "").staticScope(StaticScope.NONE).create();
        break;
      case 9:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.IntersectionSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").children(new String[]{"left", "right"}, new boolean[]{false, false}).alias("&&", "intersection of classes").create();
        break;
      case 10:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.IntervalSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").properties("start", "end").alias("-", "character range").create();
        break;
      case 11:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LazyPlusRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("+?", "one or more times, reluctant").create();
        break;
      case 12:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LazyQuestionRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("??", "once or not at all, reluctant").create();
        break;
      case 13:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LazyStarRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("*?", "zero or more times, reluctant").create();
        break;
      case 14:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LineEndRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").alias("$", "line end").create();
        break;
      case 15:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LineStartRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").alias("^", "line start").create();
        break;
      case 16:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LiteralReplacement").super_("jetbrains.mps.baseLanguage.regexp.structure.Replacement").parents("jetbrains.mps.baseLanguage.regexp.structure.Replacement", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").properties("text").create();
        break;
      case 17:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"regexp"}, new boolean[]{false}).abstract_().create();
        break;
      case 18:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchParensRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp", "jetbrains.mps.lang.core.structure.INamedConcept", "jetbrains.mps.baseLanguage.structure.IVariableAssignment", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"regexp"}, new boolean[]{false}).alias("(name:", "matching parens").create();
        break;
      case 19:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"inputExpression"}, new boolean[]{false}).alias("matches", "").staticScope(StaticScope.NONE).create();
        break;
      case 20:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.BaseConcept").alias("matches", "").staticScope(StaticScope.NONE).create();
        break;
      case 21:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").children(new String[]{"body", "expr"}, new boolean[]{false, false}).alias("if (expr matches regexp) {", "match with regexp").staticScope(StaticScope.NONE).create();
        break;
      case 22:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("match").staticScope(StaticScope.NONE).create();
        break;
      case 23:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").references("match").create();
        break;
      case 24:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceReplacement").super_("jetbrains.mps.baseLanguage.regexp.structure.Replacement").parents("jetbrains.mps.baseLanguage.regexp.structure.Replacement").references("match").create();
        break;
      case 25:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NTimesRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").properties("n").alias("{n}", "exactly n times").create();
        break;
      case 26:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NegativeLookAheadRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?!", "negative look ahead").create();
        break;
      case 27:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NegativeLookBehindRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?<!", "negative look behind").create();
        break;
      case 28:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NegativeSymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").alias("[^", "negative symbol class").create();
        break;
      case 29:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.OrRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").alias("|", "").create();
        break;
      case 30:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ParensRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"expr"}, new boolean[]{false}).alias("(", "parens").create();
        break;
      case 31:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PlusRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("+", "one or more times").create();
        break;
      case 32:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PositiveLookAheadRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?=", "").create();
        break;
      case 33:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PositiveLookBehindRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?<=", "positive look behind").create();
        break;
      case 34:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PositiveSymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").alias("[", "positive symbol class").create();
        break;
      case 35:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassDeclaration").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").properties("description").create();
        break;
      case 36:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").references("symbolClass").create();
        break;
      case 37:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").references("declaration").create();
        break;
      case 38:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClasses").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").children(new String[]{"symbolClass"}, new boolean[]{true}).create();
        break;
      case 39:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.QuestionRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("?", "once or not at all").create();
        break;
      case 40:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.Regexp").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").abstract_().create();
        break;
      case 41:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclaration").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").properties("description").children(new String[]{"regexp"}, new boolean[]{false}).create();
        break;
      case 42:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclarationReferenceRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").references("regexp").create();
        break;
      case 43:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").abstract_().staticScope(StaticScope.NONE).create();
        break;
      case 44:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").interface_().children(new String[]{"regexp"}, new boolean[]{false}).create();
        break;
      case 45:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.Regexps").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").children(new String[]{"regexp"}, new boolean[]{true}).create();
        break;
      case 46:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceBlock").super_("jetbrains.mps.baseLanguage.structure.Closure").parents("jetbrains.mps.baseLanguage.structure.Closure").staticScope(StaticScope.NONE).create();
        break;
      case 47:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceRegexpOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation", "jetbrains.mps.lang.core.structure.BaseConcept").properties("dotAll", "multiLine", "caseInsensitive", "globalReplace").children(new String[]{"search", "replacement"}, new boolean[]{false, true}).alias("s/regexp/replacement/", "").staticScope(StaticScope.NONE).create();
        break;
      case 48:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"expr", "replaceBlock"}, new boolean[]{false, false}).alias("replace with regexp", "").staticScope(StaticScope.NONE).create();
        break;
      case 49:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.BaseConcept").children(new String[]{"replaceBlock"}, new boolean[]{false}).alias("replace with", "replace with regexp").staticScope(StaticScope.NONE).create();
        break;
      case 50:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.Replacement").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").abstract_().create();
        break;
      case 51:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SeqRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").alias("seq", "").create();
        break;
      case 52:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SplitExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"expr"}, new boolean[]{false}).alias("split with", "split with regexp").staticScope(StaticScope.NONE).create();
        break;
      case 53:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SplitOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault", "jetbrains.mps.lang.core.structure.BaseConcept").alias("split with", "split with regexp").staticScope(StaticScope.NONE).create();
        break;
      case 54:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.StarRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("*", "zero or more times").create();
        break;
      case 55:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").properties("text").alias("'", "").create();
        break;
      case 56:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart").abstract_().create();
        break;
      case 57:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp", "jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart").children(new String[]{"part"}, new boolean[]{true}).abstract_().create();
        break;
      case 58:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart").interface_().create();
        break;
      case 59:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"regexp"}, new boolean[]{false}).abstract_().create();
        break;
      case 60:
        conceptDescriptor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").properties("code").alias("\\uhhhh", "").create();
        break;
      default:
        conceptDescriptor = null;
    }
    assert conceptDescriptor != null;
    myFqNameToConcept.put(conceptFqName, conceptDescriptor);
    return conceptDescriptor;
  }
  private static String[] stringSwitchCases_1htk8d_a0d0i = new String[]{"jetbrains.mps.baseLanguage.regexp.structure.AtLeastNTimesRegexp", "jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp", "jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart", "jetbrains.mps.baseLanguage.regexp.structure.DotRegexp", "jetbrains.mps.baseLanguage.regexp.structure.FindMatchExpression", "jetbrains.mps.baseLanguage.regexp.structure.FindMatchStatement", "jetbrains.mps.baseLanguage.regexp.structure.ForEachMatchStatement", "jetbrains.mps.baseLanguage.regexp.structure.FromNToMTimesRegexp", "jetbrains.mps.baseLanguage.regexp.structure.InlineRegexpExpression", "jetbrains.mps.baseLanguage.regexp.structure.IntersectionSymbolClassPart", "jetbrains.mps.baseLanguage.regexp.structure.IntervalSymbolClassPart", "jetbrains.mps.baseLanguage.regexp.structure.LazyPlusRegexp", "jetbrains.mps.baseLanguage.regexp.structure.LazyQuestionRegexp", "jetbrains.mps.baseLanguage.regexp.structure.LazyStarRegexp", "jetbrains.mps.baseLanguage.regexp.structure.LineEndRegexp", "jetbrains.mps.baseLanguage.regexp.structure.LineStartRegexp", "jetbrains.mps.baseLanguage.regexp.structure.LiteralReplacement", "jetbrains.mps.baseLanguage.regexp.structure.LookRegexp", "jetbrains.mps.baseLanguage.regexp.structure.MatchParensRegexp", "jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpExpression", "jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpOperation", "jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpStatement", "jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReference", "jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceRegexp", "jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceReplacement", "jetbrains.mps.baseLanguage.regexp.structure.NTimesRegexp", "jetbrains.mps.baseLanguage.regexp.structure.NegativeLookAheadRegexp", "jetbrains.mps.baseLanguage.regexp.structure.NegativeLookBehindRegexp", "jetbrains.mps.baseLanguage.regexp.structure.NegativeSymbolClassRegexp", "jetbrains.mps.baseLanguage.regexp.structure.OrRegexp", "jetbrains.mps.baseLanguage.regexp.structure.ParensRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PlusRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PositiveLookAheadRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PositiveLookBehindRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PositiveSymbolClassRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassDeclaration", "jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassRegexp", "jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassSymbolClassPart", "jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClasses", "jetbrains.mps.baseLanguage.regexp.structure.QuestionRegexp", "jetbrains.mps.baseLanguage.regexp.structure.Regexp", "jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclaration", "jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclarationReferenceRegexp", "jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression", "jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction", "jetbrains.mps.baseLanguage.regexp.structure.Regexps", "jetbrains.mps.baseLanguage.regexp.structure.ReplaceBlock", "jetbrains.mps.baseLanguage.regexp.structure.ReplaceRegexpOperation", "jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpExpression", "jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpOperation", "jetbrains.mps.baseLanguage.regexp.structure.Replacement", "jetbrains.mps.baseLanguage.regexp.structure.SeqRegexp", "jetbrains.mps.baseLanguage.regexp.structure.SplitExpression", "jetbrains.mps.baseLanguage.regexp.structure.SplitOperation", "jetbrains.mps.baseLanguage.regexp.structure.StarRegexp", "jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp", "jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart", "jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp", "jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart", "jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp", "jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp"};
}
