package jetbrains.mps.graphLayout.stOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graphLayout.IPointLayouter;
import jetbrains.mps.graphLayout.graphLayout.GraphPointLayout;
import jetbrains.mps.graphLayout.graph.Graph;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.algorithms.ConnectivityComponents;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.graphLayout.util.NodeMap;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.graphLayout.algorithms.BiconnectAugmentation;
import jetbrains.mps.graphLayout.planarization.TreeEmbeddingFinder;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.planarization.ShortestPathEmbeddingFinder;
import jetbrains.mps.graphLayout.planarization.BiconnectedInitialEmbeddingFinder;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.graphLayout.algorithms.GraphOrientation;
import jetbrains.mps.graphLayout.planarGraph.STPlanarGraph;

public class OrthogonalLayouter implements IPointLayouter {
  public OrthogonalLayouter() {
  }

  public GraphPointLayout doLayout(Graph graph) {
    Map<Node, Integer> components = ConnectivityComponents.getComponents(graph);
    int maxComponent = 0;
    for (Node node : ListSequence.<Node>fromList(graph.getNodes())) {
      maxComponent = Math.max(maxComponent, MapSequence.<Node,Integer>fromMap(components).get(node));
    }
    Map<Node, Node> newNodes = new NodeMap<Node>(graph);
    List<Graph> subgraphs = ListSequence.<Graph>fromList(new ArrayList<Graph>());
    for (int i = 0; i <= maxComponent; i++) {
      ListSequence.<Graph>fromList(subgraphs).addElement(new Graph());
    }
    for (Node node : ListSequence.<Node>fromList(graph.getNodes())) {
      Graph subgraph = ListSequence.<Graph>fromList(subgraphs).getElement(MapSequence.<Node,Integer>fromMap(components).get(node));
      MapSequence.<Node,Node>fromMap(newNodes).put(node, subgraph.createNode());
    }
    for (Edge edge : ListSequence.<Edge>fromList(graph.getEdges())) {
      Node source = MapSequence.<Node,Node>fromMap(newNodes).get(edge.getSource());
      Graph subgraph = source.getGraph();
      subgraph.connect(source, MapSequence.<Node,Node>fromMap(newNodes).get(edge.getTarget()));
    }
    /*
      for (Graph subgraph : ListSequence.<Graph>fromList(subgraphs)) {
        findSTLayout(graph);
      }
    */
    return findSTLayout(ListSequence.<Graph>fromList(subgraphs).getElement(0));
  }

  public GraphPointLayout findSTLayout(Graph graph) {
    BiconnectAugmentation.makeBiconnected(graph);
    final int maxIndex = graph.getNumNodes();
    TreeEmbeddingFinder embeddingFinder = new TreeEmbeddingFinder();
    EmbeddedGraph embeddedGraph = new ShortestPathEmbeddingFinder(new BiconnectedInitialEmbeddingFinder()).find(graph);
    List<Node> outerNodes = ListSequence.<Node>fromList(new ArrayList<Node>());
    for (Dart dart : ListSequence.<Dart>fromList(embeddedGraph.getOuterFace().getDarts())) {
      ListSequence.<Node>fromList(outerNodes).addElement(dart.getTarget());
    }
    outerNodes = ListSequence.<Node>fromList(outerNodes).where(new IWhereFilter<Node>() {
      public boolean accept(Node it) {
        return it.getIndex() < maxIndex;
      }
    }).toListSequence();
    Node s = ListSequence.<Node>fromList(outerNodes).getElement(0);
    Node t = ListSequence.<Node>fromList(outerNodes).getElement((ListSequence.<Node>fromList(outerNodes).count()) / 2);
    GraphOrientation.orientST(graph, s, t);
    STPlanarGraph stPlanarGraph = new STPlanarGraph(embeddedGraph, s, t);
    return new OrthogonalFromVisibility().doLayout(stPlanarGraph);
  }
}
