package jetbrains.mps.graphLayout.internal.flowOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graphLayout.GraphLayout;
import jetbrains.mps.graphLayout.graph.Graph;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.intGeom2D.Dimension;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.graphLayout.graphLayout.GraphLayoutFactory;
import java.util.List;
import jetbrains.mps.graphLayout.intGeom2D.Point;
import jetbrains.mps.graphLayout.intGeom2D.Rectangle;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.graphLayout.graph.EdgesHistoryManager;
import jetbrains.mps.graphLayout.algorithms.BiconnectAugmentation;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.planarization.ShortestPathEmbeddingFinder;
import jetbrains.mps.graphLayout.planarization.PQPlanarizationFinder;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.graphLayout.flowOrthogonalLayout.QuasiOrthogonalRepresentation;
import jetbrains.mps.graphLayout.flowOrthogonalLayout.QuasiRepresentationModifier;
import jetbrains.mps.graphLayout.flowOrthogonalLayout.OrthogonalRepresentation;
import jetbrains.mps.graphLayout.intGeom2D.Direction2D;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.graphLayout.intGeom2D.OrthogonalUtil;
import java.util.Iterator;

public class OrthogonalFlowLabelProcessing {
  private static int DEFAULT_UNIT_LENGTH = 20;
  private static int SHOW_INFO = 0;

  private int myUnitLength = OrthogonalFlowLabelProcessing.DEFAULT_UNIT_LENGTH;

  public OrthogonalFlowLabelProcessing() {
  }

  public GraphLayout doLayout(Graph graph, Map<Node, Dimension> nodeSizes, Map<Edge, Dimension> labelSizes) {
    Graph copy = new Graph();
    Map<Node, Node> nodeMap = MapSequence.<Node,Node>fromMap(new HashMap<Node, Node>());
    Map<Edge, Edge> edgeMap = MapSequence.<Edge,Edge>fromMap(new HashMap<Edge, Edge>());
    Map<Node, Dimension> copyNodeSizes = MapSequence.<Node,Dimension>fromMap(new LinkedHashMap<Node, Dimension>(16, (float) 0.75, false));
    Map<Edge, Dimension> copyLabelSizes = MapSequence.<Edge,Dimension>fromMap(new HashMap<Edge, Dimension>());
    for (Node node : ListSequence.<Node>fromList(graph.getNodes())) {
      Node copyNode = copy.createNode();
      MapSequence.<Node,Node>fromMap(nodeMap).put(node, copyNode);
      MapSequence.<Node,Dimension>fromMap(copyNodeSizes).put(copyNode, MapSequence.<Node,Dimension>fromMap(nodeSizes).get(node));
    }
    for (Edge edge : ListSequence.<Edge>fromList(graph.getEdges())) {
      Edge copyEdge = copy.connect(MapSequence.<Node,Node>fromMap(nodeMap).get(edge.getSource()), MapSequence.<Node,Node>fromMap(nodeMap).get(edge.getTarget()));
      MapSequence.<Edge,Edge>fromMap(edgeMap).put(edge, copyEdge);
    }
    for (Edge edge : SetSequence.<Edge>fromSet(MapSequence.fromMap(labelSizes).keySet())) {
      MapSequence.<Edge,Dimension>fromMap(copyLabelSizes).put(MapSequence.<Edge,Edge>fromMap(edgeMap).get(edge), MapSequence.<Edge,Dimension>fromMap(labelSizes).get(edge));
    }
    GraphLayout copyLayout = getLayoutCorruptGraph(copy, copyNodeSizes, copyLabelSizes);
    GraphLayout layout = GraphLayoutFactory.createGraphLayout(graph);
    for (Node node : ListSequence.<Node>fromList(graph.getNodes())) {
      layout.setLayoutFor(node, copyLayout.getNodeLayout(MapSequence.<Node,Node>fromMap(nodeMap).get(node)));
    }
    for (Edge edge : ListSequence.<Edge>fromList(graph.getEdges())) {
      Edge copyEdge = MapSequence.<Edge,Edge>fromMap(edgeMap).get(edge);
      List<Point> copyEdgeLayout = copyLayout.getEdgeLayout(copyEdge);
      // copyEdge can be reverted 
      if (copyEdge.getSource() != MapSequence.<Node,Node>fromMap(nodeMap).get(edge.getSource())) {
        copyEdgeLayout = ListSequence.<Point>fromList(copyEdgeLayout).reversedList();
      }
      layout.setLayoutFor(edge, copyEdgeLayout);
    }
    for (Edge edge : SetSequence.<Edge>fromSet(MapSequence.fromMap(labelSizes).keySet())) {
      layout.setLabelLayout(edge, copyLayout.getLabelLayout(MapSequence.<Edge,Edge>fromMap(edgeMap).get(edge)));
    }
    Rectangle rect = layout.getContainingRectangle();
    layout = layout.shift(20 - rect.x, 20 - rect.y);
    return layout;
  }

  private GraphLayout getLayoutCorruptGraph(Graph graph, Map<Node, Dimension> nodeSizes, Map<Edge, Dimension> initialLabelSizes) {
    Set<Node> initialNodes = SetSequence.<Node>fromSet(new HashSet<Node>());
    SetSequence.fromSet(initialNodes).addSequence(ListSequence.<Node>fromList(graph.getNodes()));
    Set<Edge> initialEdges = SetSequence.<Edge>fromSet(new HashSet<Edge>());
    SetSequence.fromSet(initialEdges).addSequence(ListSequence.<Edge>fromList(graph.getEdges()));
    EdgesHistoryManager historyManager = new EdgesHistoryManager(graph);
    BiconnectAugmentation.smartMakeBiconnected(graph);
    EmbeddedGraph embeddedGraph = new ShortestPathEmbeddingFinder(new PQPlanarizationFinder()).find(graph);
    Map<Edge, List<Edge>> history = MapSequence.<Edge,List<Edge>>fromMap(new HashMap<Edge, List<Edge>>());
    Map<Edge, Edge> labeledEdge = MapSequence.<Edge,Edge>fromMap(new HashMap<Edge, Edge>());
    for (Edge edge : SetSequence.<Edge>fromSet(initialEdges)) {
      MapSequence.<Edge,List<Edge>>fromMap(history).put(edge, historyManager.getHistory(edge));
      MapSequence.<Edge,Edge>fromMap(labeledEdge).put(edge, getLabeledEdge(MapSequence.<Edge,List<Edge>>fromMap(history).get(edge)));
    }
    Map<Edge, Dimension> labelSizes = MapSequence.<Edge,Dimension>fromMap(new HashMap<Edge, Dimension>());
    for (Edge edge : SetSequence.<Edge>fromSet(MapSequence.fromMap(initialLabelSizes).keySet())) {
      MapSequence.<Edge,Dimension>fromMap(labelSizes).put(MapSequence.<Edge,Edge>fromMap(labeledEdge).get(edge), MapSequence.<Edge,Dimension>fromMap(initialLabelSizes).get(edge));
    }
    GraphLayout layout = getlayoutFromEmbeddedGraph(embeddedGraph, nodeSizes, labelSizes, historyManager);
    GraphLayout initialLayout = GraphLayoutFactory.createGraphLayout(graph);
    for (Node node : SetSequence.<Node>fromSet(initialNodes)) {
      initialLayout.setLayoutFor(node, layout.getNodeLayout(node));
    }
    for (Edge edge : SetSequence.<Edge>fromSet(initialEdges)) {
      List<Point> edgeLayout = ListSequence.<Point>fromList(new ArrayList<Point>());
      Node cur = edge.getSource();
      for (Edge historyEdge : ListSequence.<Edge>fromList(MapSequence.<Edge,List<Edge>>fromMap(history).get(edge))) {
        List<Point> historyLayout = layout.getEdgeLayout(historyEdge);
        if (historyEdge.getSource() != cur) {
          historyLayout = ListSequence.<Point>fromList(historyLayout).reversedList();
        }
        ListSequence.<Point>fromList(edgeLayout).addSequence(ListSequence.<Point>fromList(historyLayout));
        cur = historyEdge.getOpposite(cur);
      }
      initialLayout.setLayoutFor(edge, edgeLayout);
    }
    for (Edge edge : SetSequence.<Edge>fromSet(MapSequence.fromMap(initialLabelSizes).keySet())) {
      initialLayout.setLabelLayout(edge, layout.getLabelLayout(MapSequence.<Edge,Edge>fromMap(labeledEdge).get(edge)));
    }
    return initialLayout;
  }

  private Edge getLabeledEdge(List<Edge> edges) {
    return ListSequence.<Edge>fromList(edges).getElement(ListSequence.<Edge>fromList(edges).count() / 2);
  }

  public GraphLayout getlayoutFromEmbeddedGraph(EmbeddedGraph embeddedGraph, Map<Node, Dimension> nodeSizes, Map<Edge, Dimension> labelSizes, EdgesHistoryManager historyManager) {
    if (OrthogonalFlowLabelProcessing.SHOW_INFO > 0) {
      System.out.println("initial graph: " + embeddedGraph);
    }
    Graph graph = embeddedGraph.getGraph();
    List<Edge> oldEdges = ListSequence.<Edge>fromList(new ArrayList<Edge>());
    ListSequence.<Edge>fromList(oldEdges).addSequence(ListSequence.<Edge>fromList(graph.getEdges()));
    List<Node> oldNodes = ListSequence.<Node>fromList(new ArrayList<Node>());
    ListSequence.<Node>fromList(oldNodes).addSequence(SetSequence.<Node>fromSet(MapSequence.fromMap(nodeSizes).keySet()));
    Map<Dart, Integer> bends = MapSequence.<Dart,Integer>fromMap(new HashMap<Dart, Integer>());
    Map<Dart, Integer> angles = MapSequence.<Dart,Integer>fromMap(new HashMap<Dart, Integer>());
    QuasiOrthogonalRepresentation.getRepresentation(embeddedGraph, bends, angles);
    QuasiRepresentationModifier quasiModifier = new QuasiRepresentationModifier(embeddedGraph, bends, angles);
    quasiModifier.reduceToOrthogonalRepresentation();
    if (OrthogonalFlowLabelProcessing.SHOW_INFO > 0) {
      System.out.println("modifications: ");
      for (QuasiRepresentationModifier.Modification modification : ListSequence.<QuasiRepresentationModifier.Modification>fromList(quasiModifier.getModifications())) {
        System.out.println(modification);
      }
    }
    OrthogonalRepresentation.replaceBendsByNodes(embeddedGraph, bends, angles);
    if (OrthogonalFlowLabelProcessing.SHOW_INFO > 0) {
      System.out.println("modified graph: " + embeddedGraph);
    }
    Map<Dart, Direction2D> directions = OrthogonalRepresentation.getDirections(embeddedGraph, angles);

    Map<Edge, Node> labelNodes = MapSequence.<Edge,Node>fromMap(new HashMap<Edge, Node>());
    Map<Node, Dimension> labelNodeSizes = MapSequence.<Node,Dimension>fromMap(new HashMap<Node, Dimension>());
    for (Edge edge : SetSequence.<Edge>fromSet(MapSequence.fromMap(labelSizes).keySet())) {
      Edge labeledEdge = getLabeledEdge(historyManager.getHistory(edge));
      Node node = splitEdge(labeledEdge, embeddedGraph, directions);
      MapSequence.<Edge,Node>fromMap(labelNodes).put(edge, node);
      MapSequence.<Node,Dimension>fromMap(labelNodeSizes).put(node, MapSequence.<Edge,Dimension>fromMap(labelSizes).get(edge));
    }
    Map<Node, Map<Direction2D, Integer>> nodeAndLabelDirectionSizes = getNodeDirectionSizes(nodeSizes);
    Map<Node, Map<Direction2D, Integer>> labelDirectionSizes = getNodeDirectionSizes(labelNodeSizes);
    for (Node node : SetSequence.<Node>fromSet(MapSequence.fromMap(labelDirectionSizes).keySet())) {
      MapSequence.<Node,Map<Direction2D, Integer>>fromMap(nodeAndLabelDirectionSizes).put(node, MapSequence.<Node,Map<Direction2D, Integer>>fromMap(labelDirectionSizes).get(node));
    }
    Map<Node, Dimension> nodeAndLabelSizes = MapSequence.<Node,Dimension>fromMap(new HashMap<Node, Dimension>());
    for (Node node : SetSequence.<Node>fromSet(MapSequence.fromMap(nodeSizes).keySet())) {
      MapSequence.<Node,Dimension>fromMap(nodeAndLabelSizes).put(node, MapSequence.<Node,Dimension>fromMap(nodeSizes).get(node));
    }
    for (Node node : SetSequence.<Node>fromSet(MapSequence.fromMap(labelNodeSizes).keySet())) {
      MapSequence.<Node,Dimension>fromMap(nodeAndLabelSizes).put(node, MapSequence.<Node,Dimension>fromMap(labelNodeSizes).get(node));
    }
    Map<Edge, Integer> initialEdgesShifts = getEdgesShifts(quasiModifier.getModifications(), directions, nodeAndLabelDirectionSizes);
    Map<Edge, Integer> edgeShifts = MapSequence.<Edge,Integer>fromMap(new HashMap<Edge, Integer>());
    for (Edge initialEdge : SetSequence.<Edge>fromSet(MapSequence.fromMap(initialEdgesShifts).keySet())) {
      Edge edge = ListSequence.<Edge>fromList(historyManager.getHistory(initialEdge)).first();
      MapSequence.<Edge,Integer>fromMap(edgeShifts).put(edge, MapSequence.<Edge,Integer>fromMap(initialEdgesShifts).get(initialEdge));
    }
    List<Node> nodesAndLabels = ListSequence.<Node>fromList(new LinkedList<Node>());
    ListSequence.<Node>fromList(nodesAndLabels).addSequence(SetSequence.<Node>fromSet(MapSequence.fromMap(nodeSizes).keySet()));
    ListSequence.<Node>fromList(nodesAndLabels).addSequence(SetSequence.<Node>fromSet(MapSequence.fromMap(labelNodeSizes).keySet()));
    ConstraintsGraphProcessor processor = new ConstraintsGraphProcessor(embeddedGraph, directions);
    processor.setUnitLength(myUnitLength);
    processor.modifyEmbeddedGraph(nodesAndLabels, nodeAndLabelSizes);
    processor.constructGraph();
    Map<Node, Point> coordinates = processor.getCoordinatesInModifiedGraph(initialEdgesShifts, nodeAndLabelDirectionSizes, historyManager);
    GraphLayout graphLayout = GraphLayoutFactory.createGraphLayout(graph);
    for (Node node : ListSequence.<Node>fromList(oldNodes)) {
      Rectangle rect = getRectangle(coordinates, node, nodeAndLabelDirectionSizes, nodeAndLabelSizes);
      graphLayout.setLayoutFor(node, rect);
    }
    for (Edge edge : SetSequence.<Edge>fromSet(MapSequence.fromMap(labelNodes).keySet())) {
      Rectangle rect = getRectangle(coordinates, MapSequence.<Edge,Node>fromMap(labelNodes).get(edge), nodeAndLabelDirectionSizes, nodeAndLabelSizes);
      graphLayout.setLabelLayout(edge, rect);
    }
    for (Edge edge : ListSequence.<Edge>fromList(oldEdges)) {
      Node source = edge.getSource();
      Node target = edge.getTarget();
      List<Edge> history = historyManager.getHistory(edge);
      List<Point> edgeLayout = ListSequence.<Point>fromList(new LinkedList<Point>());
      Node cur = source;
      ListSequence.<Point>fromList(edgeLayout).addElement(new Point(MapSequence.<Node,Point>fromMap(coordinates).get(cur)));
      for (Edge historyEdge : ListSequence.<Edge>fromList(history)) {
        Node next = historyEdge.getOpposite(cur);
        ListSequence.<Point>fromList(edgeLayout).addElement(new Point(MapSequence.<Node,Point>fromMap(coordinates).get(next)));
        cur = next;
      }
      if (ListSequence.<Node>fromList(oldNodes).contains(source)) {
        Direction2D dir = MapSequence.<Dart,Direction2D>fromMap(directions).get(embeddedGraph.getSourceDart(ListSequence.<Edge>fromList(history).first(), source));
        int size = MapSequence.<Direction2D,Integer>fromMap(MapSequence.<Node,Map<Direction2D, Integer>>fromMap(nodeAndLabelDirectionSizes).get(source)).get(dir);
        Point first = ListSequence.<Point>fromList(edgeLayout).removeElementAt(0);
        first.translate(size * dir.dx(), size * dir.dy());
        ListSequence.<Point>fromList(edgeLayout).removeElementAt(0);
        ListSequence.<Point>fromList(edgeLayout).insertElement(0, first);
      }
      if (ListSequence.<Node>fromList(oldNodes).contains(edge.getTarget())) {
        Direction2D dir = MapSequence.<Dart,Direction2D>fromMap(directions).get(embeddedGraph.getSourceDart(ListSequence.<Edge>fromList(history).last(), target));
        int size = MapSequence.<Direction2D,Integer>fromMap(MapSequence.<Node,Map<Direction2D, Integer>>fromMap(nodeAndLabelDirectionSizes).get(target)).get(dir);
        Point last = ListSequence.<Point>fromList(edgeLayout).removeLastElement();
        last.translate(size * dir.dx(), size * dir.dy());
        ListSequence.<Point>fromList(edgeLayout).removeLastElement();
        ListSequence.<Point>fromList(edgeLayout).addElement(last);
      }
      graphLayout.setLayoutFor(edge, edgeLayout);
    }
    for (QuasiRepresentationModifier.Modification modification : ListSequence.<QuasiRepresentationModifier.Modification>fromList(quasiModifier.getModifications())) {
      splitEdges(graphLayout, modification, initialEdgesShifts);
    }
    return graphLayout;
  }

  private Node splitEdge(Edge oldEdge, EmbeddedGraph embeddedGraph, Map<Dart, Direction2D> directions) {
    Node source = oldEdge.getSource();
    Node target = oldEdge.getTarget();
    Dart sourceDart = embeddedGraph.getSourceDart(oldEdge, source);
    Dart targetDart = embeddedGraph.getSourceDart(oldEdge, target);
    List<Edge> edges = ListSequence.<Edge>fromList(new ArrayList<Edge>());
    Node node = embeddedGraph.splitEdge(oldEdge, edges);
    for (Edge edge : ListSequence.<Edge>fromList(edges)) {
      for (Dart dart : ListSequence.<Dart>fromList(embeddedGraph.getDarts(edge))) {
        if (dart.getSource() == source || dart.getTarget() == target) {
          MapSequence.<Dart,Direction2D>fromMap(directions).put(dart, MapSequence.<Dart,Direction2D>fromMap(directions).get(sourceDart));
        } else {
          MapSequence.<Dart,Direction2D>fromMap(directions).put(dart, MapSequence.<Dart,Direction2D>fromMap(directions).get(targetDart));
        }
      }
    }
    return node;
  }

  public GraphLayout getLayoutFromEmbeddedGraph(EmbeddedGraph embeddedGraph, Map<Node, Dimension> nodeSizes, Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes, EdgesHistoryManager historyManager) {
    if (OrthogonalFlowLabelProcessing.SHOW_INFO > 0) {
      System.out.println("initial graph: " + embeddedGraph);
    }
    Graph graph = embeddedGraph.getGraph();
    List<Edge> oldEdges = ListSequence.<Edge>fromList(new ArrayList<Edge>());
    ListSequence.<Edge>fromList(oldEdges).addSequence(ListSequence.<Edge>fromList(graph.getEdges()));
    List<Node> oldNodes = ListSequence.<Node>fromList(new ArrayList<Node>());
    ListSequence.<Node>fromList(oldNodes).addSequence(SetSequence.<Node>fromSet(MapSequence.fromMap(nodeDirectionSizes).keySet()));
    Map<Dart, Integer> bends = MapSequence.<Dart,Integer>fromMap(new HashMap<Dart, Integer>());
    Map<Dart, Integer> angles = MapSequence.<Dart,Integer>fromMap(new HashMap<Dart, Integer>());
    QuasiOrthogonalRepresentation.getRepresentation(embeddedGraph, bends, angles);
    QuasiRepresentationModifier quasiModifier = new QuasiRepresentationModifier(embeddedGraph, bends, angles);
    quasiModifier.reduceToOrthogonalRepresentation();
    if (OrthogonalFlowLabelProcessing.SHOW_INFO > 0) {
      System.out.println("modifications: ");
      for (QuasiRepresentationModifier.Modification modification : ListSequence.<QuasiRepresentationModifier.Modification>fromList(quasiModifier.getModifications())) {
        System.out.println(modification);
      }
    }
    OrthogonalRepresentation.replaceBendsByNodes(embeddedGraph, bends, angles);
    if (OrthogonalFlowLabelProcessing.SHOW_INFO > 0) {
      System.out.println("modified graph: " + embeddedGraph);
    }
    Map<Dart, Direction2D> directions = OrthogonalRepresentation.getDirections(embeddedGraph, angles);
    Map<Edge, Integer> edgesShifts = getEdgesShifts(quasiModifier.getModifications(), directions, nodeDirectionSizes);
    ConstraintsGraphProcessor processor = new ConstraintsGraphProcessor(embeddedGraph, directions);
    processor.setUnitLength(myUnitLength);
    processor.modifyEmbeddedGraph(oldNodes, nodeSizes);
    processor.constructGraph();
    Map<Node, Point> coordinates = processor.getCoordinatesInModifiedGraph(edgesShifts, nodeDirectionSizes, historyManager);
    GraphLayout graphLayout = GraphLayoutFactory.createGraphLayout(graph);
    for (Node node : ListSequence.<Node>fromList(oldNodes)) {
      Rectangle rect = getRectangle(coordinates, node, nodeDirectionSizes, nodeSizes);
      graphLayout.setLayoutFor(node, rect);
    }
    for (Edge edge : ListSequence.<Edge>fromList(oldEdges)) {
      Node source = edge.getSource();
      Node target = edge.getTarget();
      List<Edge> history = historyManager.getHistory(edge);
      List<Point> edgeLayout = ListSequence.<Point>fromList(new LinkedList<Point>());
      Node cur = source;
      ListSequence.<Point>fromList(edgeLayout).addElement(new Point(MapSequence.<Node,Point>fromMap(coordinates).get(cur)));
      for (Edge historyEdge : ListSequence.<Edge>fromList(history)) {
        Node next = historyEdge.getOpposite(cur);
        ListSequence.<Point>fromList(edgeLayout).addElement(new Point(MapSequence.<Node,Point>fromMap(coordinates).get(next)));
        cur = next;
      }
      if (ListSequence.<Node>fromList(oldNodes).contains(source)) {
        Direction2D dir = MapSequence.<Dart,Direction2D>fromMap(directions).get(embeddedGraph.getSourceDart(ListSequence.<Edge>fromList(history).first(), source));
        int size = MapSequence.<Direction2D,Integer>fromMap(MapSequence.<Node,Map<Direction2D, Integer>>fromMap(nodeDirectionSizes).get(source)).get(dir);
        Point first = ListSequence.<Point>fromList(edgeLayout).removeElementAt(0);
        first.translate(size * dir.dx(), size * dir.dy());
        ListSequence.<Point>fromList(edgeLayout).removeElementAt(0);
        ListSequence.<Point>fromList(edgeLayout).insertElement(0, first);
      }
      if (ListSequence.<Node>fromList(oldNodes).contains(edge.getTarget())) {
        Direction2D dir = MapSequence.<Dart,Direction2D>fromMap(directions).get(embeddedGraph.getSourceDart(ListSequence.<Edge>fromList(history).last(), target));
        int size = MapSequence.<Direction2D,Integer>fromMap(MapSequence.<Node,Map<Direction2D, Integer>>fromMap(nodeDirectionSizes).get(target)).get(dir);
        Point last = ListSequence.<Point>fromList(edgeLayout).removeLastElement();
        last.translate(size * dir.dx(), size * dir.dy());
        ListSequence.<Point>fromList(edgeLayout).removeLastElement();
        ListSequence.<Point>fromList(edgeLayout).addElement(last);
      }
      graphLayout.setLayoutFor(edge, edgeLayout);
    }
    for (QuasiRepresentationModifier.Modification modification : ListSequence.<QuasiRepresentationModifier.Modification>fromList(quasiModifier.getModifications())) {
      splitEdges(graphLayout, modification, edgesShifts);
    }
    return graphLayout;
  }

  public GraphLayout processLabels(EmbeddedGraph embeddedGraph, Map<Node, Dimension> nodeSizes, Map<Edge, Dimension> labelSizes, EdgesHistoryManager historyManager) {
    Graph graph = embeddedGraph.getGraph();
    List<Edge> oldEdges = ListSequence.<Edge>fromList(new ArrayList<Edge>());
    ListSequence.<Edge>fromList(oldEdges).addSequence(ListSequence.<Edge>fromList(graph.getEdges()));
    List<Node> oldNodes = ListSequence.<Node>fromList(new ArrayList<Node>());
    ListSequence.<Node>fromList(oldNodes).addSequence(SetSequence.<Node>fromSet(MapSequence.fromMap(nodeSizes).keySet()));
    Map<Edge, Node> labelNodes = MapSequence.<Edge,Node>fromMap(new HashMap<Edge, Node>());
    Map<Edge, List<Edge>> labelEdges = MapSequence.<Edge,List<Edge>>fromMap(new HashMap<Edge, List<Edge>>());
    for (Edge edge : SetSequence.<Edge>fromSet(MapSequence.fromMap(labelSizes).keySet())) {
      List<Edge> newEdges = ListSequence.<Edge>fromList(new ArrayList<Edge>());
      MapSequence.<Edge,Node>fromMap(labelNodes).put(edge, embeddedGraph.splitEdge(edge, newEdges));
      MapSequence.<Edge,List<Edge>>fromMap(labelEdges).put(edge, newEdges);
    }
    Map<Node, Dimension> labelAndNodeSizes = MapSequence.<Node,Dimension>fromMap(new HashMap<Node, Dimension>());
    for (Edge edge : SetSequence.<Edge>fromSet(MapSequence.fromMap(labelSizes).keySet())) {
      MapSequence.<Node,Dimension>fromMap(labelAndNodeSizes).put(MapSequence.<Edge,Node>fromMap(labelNodes).get(edge), MapSequence.<Edge,Dimension>fromMap(labelSizes).get(edge));
    }
    Map<Node, Map<Direction2D, Integer>> labelAndNodeDirectionSizes = getNodeDirectionSizes(labelAndNodeSizes);
    Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes = getNodeDirectionSizes(nodeSizes);
    for (Node node : SetSequence.<Node>fromSet(MapSequence.fromMap(nodeSizes).keySet())) {
      MapSequence.<Node,Dimension>fromMap(labelAndNodeSizes).put(node, MapSequence.<Node,Dimension>fromMap(nodeSizes).get(node));
      MapSequence.<Node,Map<Direction2D, Integer>>fromMap(labelAndNodeDirectionSizes).put(node, MapSequence.<Node,Map<Direction2D, Integer>>fromMap(nodeDirectionSizes).get(node));
    }
    GraphLayout layout = getLayoutFromEmbeddedGraph(embeddedGraph, labelAndNodeSizes, labelAndNodeDirectionSizes, historyManager);
    GraphLayout initialLayout = GraphLayoutFactory.createGraphLayout(graph);
    for (Node node : ListSequence.<Node>fromList(oldNodes)) {
      initialLayout.setLayoutFor(node, layout.getNodeLayout(node));
    }
    for (Edge edge : ListSequence.<Edge>fromList(oldEdges)) {
      initialLayout.setLabelLayout(edge, layout.getNodeLayout(MapSequence.<Edge,Node>fromMap(labelNodes).get(edge)));
    }
    for (Edge edge : ListSequence.<Edge>fromList(oldEdges)) {
      if (MapSequence.fromMap(labelEdges).containsKey(edge)) {
        List<Edge> newEdges = MapSequence.<Edge,List<Edge>>fromMap(labelEdges).get(edge);
        List<Point> edgeLayout = layout.getEdgeLayout(ListSequence.<Edge>fromList(newEdges).getElement(0));
        ListSequence.<Point>fromList(edgeLayout).addSequence(ListSequence.<Point>fromList(layout.getEdgeLayout(ListSequence.<Edge>fromList(newEdges).getElement(1))));
        initialLayout.setLayoutFor(edge, edgeLayout);
      } else {
        initialLayout.setLayoutFor(edge, layout.getEdgeLayout(edge));
      }
    }
    return initialLayout;
  }

  private Rectangle getRectangle(Map<Node, Point> coordinates, Node node, Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes, Map<Node, Dimension> nodeSizes) {
    Point center = MapSequence.<Node,Point>fromMap(coordinates).get(node);
    Map<Direction2D, Integer> sizes = MapSequence.<Node,Map<Direction2D, Integer>>fromMap(nodeDirectionSizes).get(node);
    Dimension nodeSize = MapSequence.<Node,Dimension>fromMap(nodeSizes).get(node);
    return new Rectangle(center.x - MapSequence.<Direction2D,Integer>fromMap(sizes).get(Direction2D.LEFT), center.y - MapSequence.<Direction2D,Integer>fromMap(sizes).get(Direction2D.DOWN), nodeSize.width, nodeSize.height);
  }

  private Map<Node, Map<Direction2D, Integer>> getNodeDirectionSizes(Map<Node, Dimension> nodeSizes) {
    Map<Node, Map<Direction2D, Integer>> nodeDirectionSizes = MapSequence.<Node,Map<Direction2D, Integer>>fromMap(new HashMap<Node, Map<Direction2D, Integer>>());
    for (Node node : SetSequence.<Node>fromSet(MapSequence.fromMap(nodeSizes).keySet())) {
      Map<Direction2D, Integer> directionSizes = MapSequence.<Direction2D,Integer>fromMap(new HashMap<Direction2D, Integer>());
      Dimension size = MapSequence.<Node,Dimension>fromMap(nodeSizes).get(node);
      int horSize = size.height;
      MapSequence.<Direction2D,Integer>fromMap(directionSizes).put(Direction2D.UP, horSize / 2);
      MapSequence.<Direction2D,Integer>fromMap(directionSizes).put(Direction2D.DOWN, horSize - MapSequence.<Direction2D,Integer>fromMap(directionSizes).get(Direction2D.UP));
      int verSize = size.width;
      MapSequence.<Direction2D,Integer>fromMap(directionSizes).put(Direction2D.LEFT, verSize / 2);
      MapSequence.<Direction2D,Integer>fromMap(directionSizes).put(Direction2D.RIGHT, verSize - MapSequence.<Direction2D,Integer>fromMap(directionSizes).get(Direction2D.LEFT));
      MapSequence.<Node,Map<Direction2D, Integer>>fromMap(nodeDirectionSizes).put(node, directionSizes);
    }
    return nodeDirectionSizes;
  }

  private Map<Edge, Integer> getEdgesShifts(List<QuasiRepresentationModifier.Modification> modifications, Map<Dart, Direction2D> directions, Map<Node, Map<Direction2D, Integer>> nodeSizes) {
    Map<Edge, Integer> edgeShifts = MapSequence.<Edge,Integer>fromMap(new HashMap<Edge, Integer>());
    for (QuasiRepresentationModifier.Modification modification : ListSequence.<QuasiRepresentationModifier.Modification>fromList(modifications)) {
      List<Edge> edges = modification.getNewEdges();
      Node node = modification.getSource();
      Direction2D dir = MapSequence.<Dart,Direction2D>fromMap(directions).get(modification.getSourceDart());
      Direction2D shiftDir = dir.turnClockwise(3);
      int nodeLength = MapSequence.<Direction2D,Integer>fromMap(MapSequence.<Node,Map<Direction2D, Integer>>fromMap(nodeSizes).get(node)).get(shiftDir);
      nodeLength = Math.min(nodeLength, myUnitLength);
      int unitShift = nodeLength / ListSequence.<Edge>fromList(edges).count();
      int curShift = 0;
      for (Edge edge : ListSequence.<Edge>fromList(edges)) {
        MapSequence.<Edge,Integer>fromMap(edgeShifts).put(edge, curShift);
        curShift += unitShift;
      }
    }
    return edgeShifts;
  }

  private void splitEdges(GraphLayout layout, QuasiRepresentationModifier.Modification modification, Map<Edge, Integer> edgeShifts) {
    List<Edge> edges = modification.getModifiedEdges();
    Edge firstEdge = ListSequence.<Edge>fromList(edges).first();
    List<Point> path = layout.getEdgeLayout(firstEdge);
    Node node = modification.getSource();
    Direction2D dartsDir;
    if (firstEdge.getSource() == node) {
      dartsDir = OrthogonalUtil.getDirection(ListSequence.<Point>fromList(path).getElement(0), ListSequence.<Point>fromList(path).getElement(1));
    } else {
      int last = ListSequence.<Point>fromList(path).count() - 1;
      dartsDir = OrthogonalUtil.getDirection(ListSequence.<Point>fromList(path).getElement(last), ListSequence.<Point>fromList(path).getElement(last - 1));
    }
    Direction2D shiftDir = dartsDir.turnClockwise(3);
    int dx = shiftDir.dx();
    int dy = shiftDir.dy();
    Iterator<Edge> newEdgeItr = ListSequence.<Edge>fromList(modification.getNewEdges()).iterator();
    for (Edge edge : ListSequence.<Edge>fromList(edges)) {
      layout.removeStraightBends(edge);
      List<Point> edgeLayout = layout.getEdgeLayout(edge);
      List<Point> pointsToShift;
      if (edge.getSource() == node) {
        pointsToShift = ListSequence.<Point>fromListAndArray(new ArrayList<Point>(), ListSequence.<Point>fromList(edgeLayout).getElement(0), ListSequence.<Point>fromList(edgeLayout).getElement(1));
      } else {
        int last = ListSequence.<Point>fromList(edgeLayout).count() - 1;
        pointsToShift = ListSequence.<Point>fromListAndArray(new ArrayList<Point>(), ListSequence.<Point>fromList(edgeLayout).getElement(last), ListSequence.<Point>fromList(edgeLayout).getElement(last - 1));
      }
      Edge newEdge = newEdgeItr.next();
      for (Point point : ListSequence.<Point>fromList(pointsToShift)) {
        point.translate(dx * MapSequence.<Edge,Integer>fromMap(edgeShifts).get(newEdge), dy * MapSequence.<Edge,Integer>fromMap(edgeShifts).get(newEdge));
      }
    }
  }
}
