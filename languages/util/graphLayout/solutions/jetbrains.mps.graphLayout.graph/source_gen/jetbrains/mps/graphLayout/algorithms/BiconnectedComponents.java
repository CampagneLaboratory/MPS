package jetbrains.mps.graphLayout.algorithms;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.util.NodeMap;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;

public class BiconnectedComponents extends Dfs {
  private Map<Node, Node> myLow;
  private Map<Node, Integer> myNum;
  private int myCurNum;

  public BiconnectedComponents() {
  }

  @Override
  public void doDfs(Graph graph) {
    myLow = new NodeMap<Node>(graph);
    myNum = new NodeMap<Integer>(graph);
    init(graph, Edge.Direction.BOTH);
    myCurNum = 0;
    dfs(ListSequence.<Node>fromList(graph.getNodes()).first(), null);
  }

  public void doDfs(Graph graph, Node source, Edge stEdge) {
    myLow = new NodeMap<Node>(graph);
    myNum = new NodeMap<Integer>(graph);
    init(graph, Edge.Direction.BOTH);
    MapSequence.<Node,Integer>fromMap(getDfsState()).put(source, DURING);
    MapSequence.<Node,Node>fromMap(myLow).put(source, source);
    MapSequence.<Node,Integer>fromMap(myNum).put(source, 0);
    myCurNum = 1;
    dfs(stEdge.getOpposite(source), stEdge);
  }

  @Override
  protected void preprocess(Node node, Edge from) {
    MapSequence.<Node,Integer>fromMap(myNum).put(node, myCurNum++);
    MapSequence.<Node,Node>fromMap(myLow).put(node, node);
  }

  @Override
  protected void processEdge(Edge edge, Node source) {
    Node next = edge.getOpposite(source);
    if (MapSequence.<Node,Integer>fromMap(getDfsState()).get(next) == DURING) {
      changeLow(source, next);
    }
  }

  @Override
  protected void postprocess(Node node, Edge from) {
    if (from != null) {
      Node prev = from.getOpposite(node);
      changeLow(prev, MapSequence.<Node,Node>fromMap(myLow).get(node));
    }
  }

  private void changeLow(Node node, Node newLow) {
    Node oldLow = MapSequence.<Node,Node>fromMap(myLow).get(node);
    if (MapSequence.<Node,Integer>fromMap(myNum).get(oldLow) > MapSequence.<Node,Integer>fromMap(myNum).get(newLow)) {
      MapSequence.<Node,Node>fromMap(myLow).put(node, newLow);
    }
  }

  public Map<Node, Node> getLow() {
    return this.myLow;
  }

  public Map<Node, Integer> getNum() {
    return this.myNum;
  }
}
