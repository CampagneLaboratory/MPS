package jetbrains.mps.graphLayout.algorithms;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class MinCostCirculation {
  private static int TEST_MODE = 1;

  public static Map<Edge, Integer> getCirculation(Graph graph, Map<Edge, Integer> low, Map<Edge, Integer> initialCapacity, Map<Edge, Integer> cost) {
    Map<Edge, Integer> capacity = MapSequence.<Edge,Integer>fromMap(new HashMap<Edge, Integer>());
    Node source = graph.createNode();
    Node target = graph.createNode();
    for (Edge edge : ListSequence.<Edge>fromList(graph.getEdges())) {
      MapSequence.<Edge,Integer>fromMap(capacity).put(edge, MapSequence.<Edge,Integer>fromMap(initialCapacity).get(edge) - MapSequence.<Edge,Integer>fromMap(low).get(edge));
    }
    for (Node node : ListSequence.<Node>fromList(graph.getNodes())) {
      if (node == source || node == target) {
        continue;
      }
      int diff = 0;
      for (Edge edge : ListSequence.<Edge>fromList(node.getInEdges())) {
        diff += MapSequence.<Edge,Integer>fromMap(low).get(edge);
      }
      for (Edge edge : ListSequence.<Edge>fromList(node.getOutEdges())) {
        diff -= MapSequence.<Edge,Integer>fromMap(low).get(edge);
      }
      Edge newEdge = null;
      if (diff > 0) {
        newEdge = graph.connect(source, node);
      }
      if (diff < 0) {
        newEdge = graph.connect(node, target);
      }
      if (newEdge != null) {
        MapSequence.<Edge,Integer>fromMap(capacity).put(newEdge, Math.abs(diff));
        MapSequence.<Edge,Integer>fromMap(cost).put(newEdge, 0);
      }
    }
    Map<Edge, Integer> flow;
    if (TEST_MODE > 0) {
      flow = MinCostMaxFlowWithPotentials.getFlow(graph, source, target, capacity, cost);
      /*
        Map<Edge, Integer> anotherFlow = MinCostMaxFlow.getFlow(graph, source, target, capacity, cost);
        int flowCost = 0;
        int anotherFlowCost = 0;
        for (Edge edge : ListSequence.<Edge>fromList(graph.getEdges())) {
          flowCost += MapSequence.<Edge,Integer>fromMap(flow).get(edge) * MapSequence.<Edge,Integer>fromMap(cost).get(edge);
          anotherFlowCost += MapSequence.<Edge,Integer>fromMap(anotherFlow).get(edge) * MapSequence.<Edge,Integer>fromMap(cost).get(edge);
        }
        if (anotherFlowCost != flowCost) {
          throw new RuntimeException("dijkstra result is different than ford-bellman");
        }
      */
    } else {
      flow = MinCostMaxFlow.getFlow(graph, source, target, capacity, cost);
    }
    /*
      for (Edge edge : ListSequence.<Edge>fromList(source.getOutEdges())) {
        if (MapSequence.<Edge,Integer>fromMap(flow).get(edge) != MapSequence.<Edge,Integer>fromMap(capacity).get(edge)) {
          throw new RuntimeException("failed to find circulation");
        }
      }
    */
    for (Edge edge : ListSequence.<Edge>fromList(source.getEdges()).concat(ListSequence.<Edge>fromList(target.getEdges()))) {
      MapSequence.fromMap(flow).removeKey(edge);
    }
    graph.deleteNode(source);
    graph.deleteNode(target);
    for (Edge edge : ListSequence.<Edge>fromList(graph.getEdges())) {
      MapSequence.<Edge,Integer>fromMap(flow).put(edge, MapSequence.<Edge,Integer>fromMap(flow).get(edge) + MapSequence.<Edge,Integer>fromMap(low).get(edge));
    }
    return flow;
  }
}
