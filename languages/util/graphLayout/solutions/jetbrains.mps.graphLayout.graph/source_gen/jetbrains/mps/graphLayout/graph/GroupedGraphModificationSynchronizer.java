package jetbrains.mps.graphLayout.graph;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public class GroupedGraphModificationSynchronizer implements IGraphModificationListener {
  private static int showInfo = 0;

  private Map<Edge, Edge> myEdgeMap;
  private Map<Node, Node> myNodeMap;
  private Graph myGroupedGraph;
  private Graph mySynchronizedGraph;

  public GroupedGraphModificationSynchronizer(Graph groupedGraph, Graph synchronizedGraph, Map<Edge, Edge> edgeMap) {
    myGroupedGraph = groupedGraph;
    mySynchronizedGraph = synchronizedGraph;
    groupedGraph.addListener(this);
    myEdgeMap = edgeMap;
    myNodeMap = MapSequence.<Node,Node>fromMap(new HashMap<Node, Node>());
  }

  public void process(GraphModificationEvent event) {
    switch (event.getType()) {
      case NODE_CREATED:
        Node addedNode = event.getNode();
        Node syncNode;
        if (addedNode.isDummy()) {
          syncNode = mySynchronizedGraph.createDummyNode();
        } else {
          syncNode = mySynchronizedGraph.createNode();
        }
        MapSequence.<Node,Node>fromMap(myNodeMap).put(addedNode, syncNode);
        break;
      case NODE_DETETED:
        Node deletedNode = event.getNode();
        if (MapSequence.fromMap(myNodeMap).containsKey(deletedNode)) {
          mySynchronizedGraph.deleteNode(MapSequence.<Node,Node>fromMap(myNodeMap).get(deletedNode));
        }
        break;
      case EDGE_ADDED:
        Edge addedEdge = event.getEdge();
        Node source = addedEdge.getSource();
        Node target = addedEdge.getTarget();
        if (MapSequence.fromMap(myEdgeMap).containsKey(addedEdge)) {
          mySynchronizedGraph.addEdge(MapSequence.<Edge,Edge>fromMap(myEdgeMap).get(addedEdge));
        } else if (MapSequence.fromMap(myNodeMap).containsKey(source) && MapSequence.fromMap(myNodeMap).containsKey(target)) {
          Node syncSource = MapSequence.<Node,Node>fromMap(myNodeMap).get(source);
          Node syncTarget = MapSequence.<Node,Node>fromMap(myNodeMap).get(target);
          Edge edge = mySynchronizedGraph.connect(syncSource, syncTarget);
          MapSequence.<Edge,Edge>fromMap(myEdgeMap).put(addedEdge, edge);
          if (showInfo > 0) {
            System.out.println("added " + addedEdge + " sync = " + edge);
          }
        }
        break;
      case EDGE_REMOVED:
        Edge removedEdge = event.getEdge();
        if (showInfo > 0) {
          System.out.println("removed " + removedEdge + " sync = ");
        }
        if (MapSequence.fromMap(myEdgeMap).containsKey(removedEdge)) {
          mySynchronizedGraph.removeEdge(MapSequence.<Edge,Edge>fromMap(myEdgeMap).get(removedEdge));
          if (showInfo > 0) {
            System.out.println(MapSequence.<Edge,Edge>fromMap(myEdgeMap).get(removedEdge));
          }
        }
        break;
      case EDGE_REVERTED:
        Edge revertedEdge = event.getEdge();
        if (MapSequence.fromMap(myEdgeMap).containsKey(revertedEdge)) {
          mySynchronizedGraph.revertEdge(MapSequence.<Edge,Edge>fromMap(myEdgeMap).get(revertedEdge));
        }
        break;
      case EDGE_SPLITTED:
        this.processSplitEvent(event);
        break;
      default:
    }
  }

  private void processSplitEvent(GraphModificationEvent event) {
    Edge splittedEdge = event.getEdge();
    if (MapSequence.fromMap(myEdgeMap).containsKey(splittedEdge)) {
      Edge syncEdge = MapSequence.<Edge,Edge>fromMap(myEdgeMap).get(splittedEdge);
      List<Edge> split = event.getSplit();
      List<Edge> syncSplit = ListSequence.<Edge>fromList(new ArrayList<Edge>(ListSequence.<Edge>fromList(split).count()));
      for (Edge splitEdge : ListSequence.<Edge>fromList(split)) {
        if (MapSequence.fromMap(myEdgeMap).containsKey(splitEdge)) {
          ListSequence.<Edge>fromList(syncSplit).addElement(MapSequence.<Edge,Edge>fromMap(myEdgeMap).get(splitEdge));
        } else {
          Node source = splitEdge.getSource();
          Node syncSource;
          if (MapSequence.fromMap(myNodeMap).containsKey(source)) {
            syncSource = MapSequence.<Node,Node>fromMap(myNodeMap).get(source);
          } else {
            syncSource = syncEdge.getSource();
          }
          Node target = splitEdge.getTarget();
          Node syncTarget;
          if (MapSequence.fromMap(myNodeMap).containsKey(target)) {
            syncTarget = MapSequence.<Node,Node>fromMap(myNodeMap).get(target);
          } else {
            syncTarget = syncEdge.getTarget();
          }
          Edge syncSplitEdge = mySynchronizedGraph.connect(syncSource, syncTarget);
          MapSequence.<Edge,Edge>fromMap(myEdgeMap).put(splitEdge, syncSplitEdge);
          ListSequence.<Edge>fromList(syncSplit).addElement(syncSplitEdge);
        }
      }
      if (showInfo > 0) {
        System.out.println("splitted " + splittedEdge + " sync = " + syncEdge);
      }
      mySynchronizedGraph.getModificationProcessor().fire(new GraphModificationEvent(GraphModificationEvent.Type.EDGE_SPLITTED, syncEdge, syncSplit));
    }
  }

  public void disconnect() {
    myGroupedGraph.removeListener(this);
  }
}
