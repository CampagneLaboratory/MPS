package jetbrains.mps.graphLayout.graph;

/*Generated by MPS */

import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;

public class HyperGraph extends Graph {
  private Map<Node, Node> myParent;
  private Map<Node, List<Node>> myChildren;
  private Node myRoot;

  public HyperGraph() {
    super();
    myParent = MapSequence.<Node,Node>fromMap(new HashMap<Node, Node>());
    myChildren = MapSequence.<Node,List<Node>>fromMap(new HashMap<Node, List<Node>>());
    myRoot = new Node(this, -1, false);
    MapSequence.<Node,List<Node>>fromMap(myChildren).put(myRoot, ListSequence.<Node>fromList(new LinkedList<Node>()));
  }

  @Override
  public Graph createNew() {
    return new HyperGraph();
  }

  @Override
  protected Node createNode(boolean isDummy) {
    Node node = super.createNode(isDummy);
    MapSequence.<Node,List<Node>>fromMap(myChildren).put(node, ListSequence.<Node>fromList(new LinkedList<Node>()));
    return node;
  }

  @Override
  public Node createNode() {
    Node node = super.createNode();
    setParent(node, myRoot);
    return node;
  }

  @Override
  public Node createDummyNode() {
    Node node = super.createDummyNode();
    setParent(node, myRoot);
    return node;
  }

  public void createNode(Node parent) {
    // calling an internal superclass method to avoid setting myRoot as 
    // parent of created node 
    Node node = super.createNode();
    setParent(node, parent);
  }

  public void setParent(Node node, Node parent) {
    Node oldParent = MapSequence.<Node,Node>fromMap(myParent).get(node);
    if (oldParent != null) {
      ListSequence.<Node>fromList(MapSequence.<Node,List<Node>>fromMap(myChildren).get(oldParent)).removeElement(node);
    }
    MapSequence.<Node,Node>fromMap(myParent).put(node, parent);
    ListSequence.<Node>fromList(MapSequence.<Node,List<Node>>fromMap(myChildren).get(parent)).addElement(node);
  }

  public void addChild(Node node, Node child) {
    setParent(child, node);
  }

  public Node getRoot() {
    return myRoot;
  }

  public Node getParent(Node node) {
    return MapSequence.<Node,Node>fromMap(myParent).get(node);
  }

  public List<Node> getChildren(Node node) {
    return MapSequence.<Node,List<Node>>fromMap(myChildren).get(node);
  }

  public boolean isNode(Node node) {
    return ListSequence.<Node>fromList(MapSequence.<Node,List<Node>>fromMap(myChildren).get(node)).count() == 0;
  }
}
