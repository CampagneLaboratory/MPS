package layeredLayoutTest;

/*Generated by MPS */

import jetbrains.mps.graphLayout.layeredLayout.NodeLayeredOrder;
import java.util.List;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.graphLayout.graph.Edge;

public class CheckDummyEdgesCrossing {
  public static boolean hasCrosses(NodeLayeredOrder order) {
    for (int layer = 0; layer < order.getNumLayers() - 1; layer++) {
      List<Node> dummyNodes = ListSequence.<Node>fromList(order.getOrder(layer)).where(new IWhereFilter<Node>() {
        public boolean accept(Node it) {
          return it.isDummy();
        }
      }).toListSequence();
      for (int first = 0; first < ListSequence.<Node>fromList(dummyNodes).count(); first++) {
        for (int second = first + 1; second < ListSequence.<Node>fromList(dummyNodes).count(); second++) {
          Node firstTarget = ListSequence.<Edge>fromList(ListSequence.<Node>fromList(dummyNodes).getElement(first).getOutEdges()).getElement(0).getTarget();
          Node secondTarget = ListSequence.<Edge>fromList(ListSequence.<Node>fromList(dummyNodes).getElement(second).getOutEdges()).getElement(0).getTarget();
          if (firstTarget.isDummy() && secondTarget.isDummy()) {
            List<Node> nextLayerOrder = order.getOrder(layer + 1);
            if (ListSequence.<Node>fromList(nextLayerOrder).indexOf(firstTarget) > ListSequence.<Node>fromList(nextLayerOrder).indexOf(secondTarget)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
}
