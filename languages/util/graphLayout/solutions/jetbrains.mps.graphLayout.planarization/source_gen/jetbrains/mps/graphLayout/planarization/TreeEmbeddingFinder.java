package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.graphLayout.graph.Edge;
import java.util.List;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.planarGraph.Face;
import jetbrains.mps.graphLayout.planarGraph.CheckEmbeddedGraph;
import jetbrains.mps.graphLayout.planarGraph.DualGraph;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.graphLayout.algorithms.ShortestPath;
import java.util.Iterator;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.graphLayout.algorithms.Dfs;
import java.util.LinkedHashSet;

public class TreeEmbeddingFinder implements IEmbeddingFinder {
  private Map<Edge, List<Edge>> mySplittedEdges;

  public TreeEmbeddingFinder() {
  }

  public EmbeddedGraph find(Graph graph) {
    mySplittedEdges = MapSequence.<Edge,List<Edge>>fromMap(new HashMap<Edge, List<Edge>>());
    EmbeddedGraph embeddedGraph = new EmbeddedGraph(graph);
    List<Edge> removed = ListSequence.<Edge>fromList(new ArrayList<Edge>());
    Face outerFace = getOuterTreeFace(graph, removed);
    for (Edge edge : ListSequence.<Edge>fromList(removed)) {
      graph.removeEdge(edge);
    }
    embeddedGraph.addFace(outerFace);
    embeddedGraph.setOuterFace(outerFace);
    for (Edge removedEdge : ListSequence.<Edge>fromList(removed)) {
      this.restoreEdge(embeddedGraph, removedEdge);
      CheckEmbeddedGraph.checkEmbeddedGraph(embeddedGraph, false);
    }
    mergeEdges();
    return embeddedGraph;
  }

  private void restoreEdge(EmbeddedGraph embeddedGraph, Edge removedEdge) {
    MapSequence.<Edge,List<Edge>>fromMap(mySplittedEdges).put(removedEdge, ListSequence.<Edge>fromList(new ArrayList<Edge>()));
    Graph graph = embeddedGraph.getGraph();
    DualGraph dualGraph = new DualGraph(embeddedGraph);
    List<Node> newNodes = ListSequence.<Node>fromList(new ArrayList<Node>());
    for (Node node : ListSequence.<Node>fromList(removedEdge.getAdjacentNodes())) {
      Node newNode = dualGraph.createDummyNode();
      for (Edge nodeEdge : ListSequence.<Edge>fromList(node.getEdges(Edge.Direction.BOTH))) {
        for (Face face : ListSequence.<Face>fromList(embeddedGraph.getAdjacentFaces(nodeEdge))) {
          dualGraph.connect(newNode, MapSequence.<Face,Node>fromMap(dualGraph.getNodesMap()).get(face));
        }
      }
      ListSequence.<Node>fromList(newNodes).addElement(newNode);
    }
    List<Edge> path = ShortestPath.getPath(dualGraph, ListSequence.<Node>fromList(newNodes).getElement(0), ListSequence.<Node>fromList(newNodes).getElement(1), Edge.Direction.BOTH);
    List<Node> nodePath = ListSequence.<Node>fromList(new ArrayList<Node>());
    List<Face> facePath = ListSequence.<Face>fromList(new ArrayList<Face>());
    ListSequence.<Node>fromList(nodePath).addElement(ListSequence.<Node>fromList(removedEdge.getAdjacentNodes()).getElement(0));
    Node cur = ListSequence.<Node>fromList(newNodes).getElement(0);
    for (Edge edge : ListSequence.<Edge>fromList(path)) {
      Edge realEdge = MapSequence.<Edge,Edge>fromMap(dualGraph.getEdgesMap()).get(edge);
      if (embeddedGraph.getAdjacentFaces(realEdge) != null) {
        ListSequence.<Node>fromList(nodePath).addElement(split(embeddedGraph, MapSequence.<Edge,Edge>fromMap(dualGraph.getEdgesMap()).get(edge)));
      }
      cur = edge.getOpposite(cur);
      Face curFace = MapSequence.<Node,Face>fromMap(dualGraph.getFacesMap()).get(cur);
      if (curFace != null) {
        ListSequence.<Face>fromList(facePath).addElement(curFace);
      }
    }
    ListSequence.<Node>fromList(nodePath).addElement(ListSequence.<Node>fromList(removedEdge.getAdjacentNodes()).getElement(1));
    for (int i = 0; i < ListSequence.<Node>fromList(nodePath).count() - 1; i++) {
      Edge newEdge = graph.connect(ListSequence.<Node>fromList(nodePath).getElement(i), ListSequence.<Node>fromList(nodePath).getElement(i + 1));
      ListSequence.<Edge>fromList(MapSequence.<Edge,List<Edge>>fromMap(mySplittedEdges).get(removedEdge)).addElement(newEdge);
      splitFace(embeddedGraph, ListSequence.<Face>fromList(facePath).getElement(i), newEdge);
    }
  }

  public void splitFace(EmbeddedGraph embeddedGraph, Face face, Edge newEdge) {
    List<Node> nodes = newEdge.getAdjacentNodes();
    Graph originalGraph = embeddedGraph.getGraph();
    List<Face> newFaces = ListSequence.<Face>fromList(new ArrayList<Face>());
    ListSequence.<Face>fromList(newFaces).addElement(new Face(originalGraph));
    ListSequence.<Face>fromList(newFaces).addElement(new Face(originalGraph));
    Iterator<Dart> dartItr = ListSequence.<Dart>fromList(face.getDarts()).iterator();
    Dart cur;
    do {
      cur = dartItr.next();
    } while (!(ListSequence.<Node>fromList(nodes).contains(cur.getSource())));
    Dart first = cur;
    Node found = cur.getSource();
    Node toFind = ListSequence.<Node>fromList(nodes).getElement(0);
    if (toFind == found) {
      toFind = ListSequence.<Node>fromList(nodes).getElement(1);
    }
    do {
      ListSequence.<Face>fromList(newFaces).getElement(0).addLast(cur);
      cur = dartItr.next();
    } while (cur.getSource() != toFind);
    ListSequence.<Face>fromList(newFaces).getElement(0).addLast(new Dart(newEdge, cur.getSource()));
    ListSequence.<Face>fromList(newFaces).getElement(1).addLast(new Dart(newEdge, first.getSource()));
    ListSequence.<Face>fromList(newFaces).getElement(1).addLast(cur);
    while (dartItr.hasNext()) {
      cur = dartItr.next();
      ListSequence.<Face>fromList(newFaces).getElement(1).addLast(cur);
    }
    dartItr = ListSequence.<Dart>fromList(face.getDarts()).iterator();
    cur = dartItr.next();
    while (cur != first) {
      ListSequence.<Face>fromList(newFaces).getElement(1).addLast(cur);
      cur = dartItr.next();
    }
    embeddedGraph.removeFace(face);
    for (Face newFace : ListSequence.<Face>fromList(newFaces)) {
      embeddedGraph.addFace(newFace);
    }
    if (embeddedGraph.isOuterFace(face)) {
      embeddedGraph.setOuterFace(ListSequence.<Face>fromList(newFaces).getElement(1));
    }
  }

  public Node split(EmbeddedGraph embeddedGraph, Edge edge) {
    Graph originalGraph = embeddedGraph.getGraph();
    Node newNode = originalGraph.createDummyNode();
    originalGraph.removeEdge(edge);
    List<Edge> newEdges = ListSequence.<Edge>fromList(new ArrayList<Edge>());
    ListSequence.<Edge>fromList(newEdges).addElement(originalGraph.connect(edge.getSource(), newNode));
    ListSequence.<Edge>fromList(newEdges).addElement(originalGraph.connect(newNode, edge.getTarget()));
    MapSequence.<Edge,List<Edge>>fromMap(mySplittedEdges).put(edge, newEdges);
    List<Face> facesToProcess = ListSequence.<Face>fromList(new ArrayList<Face>());
    ListSequence.<Face>fromList(facesToProcess).addSequence(ListSequence.<Face>fromList(embeddedGraph.getAdjacentFaces(edge)));
    for (Face face : ListSequence.<Face>fromList(facesToProcess)) {
      List<Dart> darts = face.getDarts();
      int pos = 0;
      while (ListSequence.<Dart>fromList(darts).getElement(pos).getEdge() != edge) {
        pos++;
      }
      Dart dartToReplace = ListSequence.<Dart>fromList(darts).getElement(pos);
      for (Edge newEdge : ListSequence.<Edge>fromList(newEdges)) {
        if (ListSequence.<Node>fromList(newEdge.getAdjacentNodes()).contains(dartToReplace.getSource())) {
          embeddedGraph.setDart(face, pos, new Dart(newEdge, dartToReplace.getSource()));
        }
      }
      for (Edge newEdge : ListSequence.<Edge>fromList(newEdges)) {
        if (ListSequence.<Node>fromList(newEdge.getAdjacentNodes()).contains(dartToReplace.getTarget())) {
          embeddedGraph.insertDart(face, pos + 1, new Dart(newEdge, newNode));
        }
      }
    }
    return newNode;
  }

  private Face getOuterTreeFace(Graph graph, List<Edge> removed) {
    TreeEmbeddingFinder.MyDfs dfs = new TreeEmbeddingFinder.MyDfs();
    dfs.doDfs(graph, Edge.Direction.BOTH);
    ListSequence.<Edge>fromList(removed).clear();
    ListSequence.<Edge>fromList(removed).addSequence(SetSequence.<Edge>fromSet(dfs.getBackEdges()));
    return dfs.getOuterFace();
  }

  private void mergeEdges() {
    Map<Edge, List<Edge>> merged = MapSequence.<Edge,List<Edge>>fromMap(new HashMap<Edge, List<Edge>>());
    Set<Edge> dummyEdges = SetSequence.<Edge>fromSet(new HashSet<Edge>());
    for (Edge edge : SetSequence.<Edge>fromSet(MapSequence.fromMap(mySplittedEdges).keySet())) {
      SetSequence.fromSet(dummyEdges).addSequence(ListSequence.<Edge>fromList(MapSequence.<Edge,List<Edge>>fromMap(mySplittedEdges).get(edge)));
    }
    for (Edge edge : SetSequence.<Edge>fromSet(MapSequence.fromMap(mySplittedEdges).keySet())) {
      if (SetSequence.<Edge>fromSet(dummyEdges).contains(edge)) {
        continue;
      }
      MapSequence.<Edge,List<Edge>>fromMap(merged).put(edge, mergeEdges(edge));
    }
    mySplittedEdges = merged;
  }

  private List<Edge> mergeEdges(Edge splittedEdge) {
    List<Edge> newEdgeList = ListSequence.<Edge>fromList(new ArrayList<Edge>());
    for (Edge edge : ListSequence.<Edge>fromList(MapSequence.<Edge,List<Edge>>fromMap(mySplittedEdges).get(splittedEdge))) {
      if (MapSequence.fromMap(mySplittedEdges).containsKey(edge)) {
        ListSequence.<Edge>fromList(newEdgeList).addSequence(ListSequence.<Edge>fromList(mergeEdges(edge)));
      } else {
        ListSequence.<Edge>fromList(newEdgeList).addElement(edge);
      }
    }
    return newEdgeList;
  }

  public Map<Edge, List<Edge>> getSplittedEdges() {
    return mySplittedEdges;
  }

  private class MyDfs extends Dfs {
    private Set<Edge> myBackEdges;
    private Face myOuterFace;

    public MyDfs() {
    }

    @Override
    protected void processEdge(Edge edge, Node source) {
      if (MapSequence.<Node,Integer>fromMap(getDfsState()).get(edge.getOpposite(source)) == Dfs.BEFORE) {
        myOuterFace.addLast(new Dart(edge, source));
      } else {
        SetSequence.fromSet(myBackEdges).addElement(edge);
      }
    }

    @Override
    protected void postprocess(Node node, Edge from) {
      if (from != null) {
        myOuterFace.addLast(new Dart(from, node));
      }

    }

    @Override
    public void doDfs(Graph graph, Edge.Direction direction) {
      myBackEdges = SetSequence.<Edge>fromSet(new LinkedHashSet<Edge>());
      myOuterFace = new Face(graph);
      super.doDfs(graph, direction);
    }

    public Set<Edge> getBackEdges() {
      return this.myBackEdges;
    }

    public Face getOuterFace() {
      return this.myOuterFace;
    }
  }
}
