package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graph.ClusteredGraph;
import jetbrains.mps.graphLayout.graph.Node;
import java.util.Set;
import java.util.List;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.INode;
import jetbrains.mps.graphLayout.graph.EdgesHistoryManager;
import jetbrains.mps.graphLayout.planarGraph.Face;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.planarGraph.CheckEmbeddedGraph;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.HashMap;
import jetbrains.mps.graphLayout.algorithms.ConnectivityComponents;
import jetbrains.mps.graphLayout.graph.GroupedGraphModificationSynchronizer;
import java.util.HashSet;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class ClusterEmbeddingConstructor {
  private static int debugMode = 0;
  private static int showInfo = 0;
  private static boolean useSlowFaceFinder = true;

  private ClusteredGraph myGraph;
  private Node myCluster;
  private Set<Node> myClusterNodes;
  private List<Edge> myOuterEdgesOrder;
  private Graph mySubclustersGraph;
  private EmbeddedGraph mySubEmbeddedGraph;
  private Map<INode, Node> mySubclustersMap;
  private EdgesHistoryManager myHistoryManager;
  private List<Edge> myClusterBorder;
  private EmbeddedGraph myEmbeddedGraph;
  private Map<Node, Node> myNodeMap;
  private Map<Face, Face> myFaceMap;
  private Map<Node, List<Edge>> myClusterBorderMap = null;

  public ClusterEmbeddingConstructor(ClusteredGraph graph, Node cluster, List<Edge> outerEdgesOrder) {
    myGraph = graph;
    myCluster = cluster;
    myClusterNodes = graph.getNodesInCluster(cluster);
    myOuterEdgesOrder = ListSequence.<Edge>fromList(new LinkedList<Edge>());
    ListSequence.<Edge>fromList(myOuterEdgesOrder).addSequence(ListSequence.<Edge>fromList(outerEdgesOrder));
    myHistoryManager = new EdgesHistoryManager(graph);
    if (showInfo > 0) {
      System.out.println("cluster " + myCluster + " outer edges: " + outerEdgesOrder);
    }
  }

  public EmbeddedGraph constructEmbedding() {
    Iterable<Node> subclusters = myGraph.getSubclusters(myCluster);
    if (Sequence.<Node>fromIterable(subclusters).count() == 0) {
      return new EmbeddedGraph(myGraph);
    }
    Map<Edge, Edge> invEdgeMap = constructSubclusterGraphEmbedding();
    if (showInfo > 0) {
      System.out.println("for cluster " + myCluster + " border is: " + myClusterBorder);
    }
    myEmbeddedGraph = new EmbeddedGraph(myGraph);
    myFaceMap = MapSequence.<Face,Face>fromMap(new LinkedHashMap<Face, Face>(16, (float) 0.75, false));
    for (Face face : ListSequence.<Face>fromList(mySubEmbeddedGraph.getFaces())) {
      Face realFace = new Face(myGraph);
      MapSequence.<Face,Face>fromMap(myFaceMap).put(face, realFace);
      for (Dart dart : ListSequence.<Dart>fromList(face.getDarts())) {
        Edge edge = dart.getEdge();
        Edge realEdge = MapSequence.<Edge,Edge>fromMap(invEdgeMap).get(edge);
        if (realEdge == null) {
          throw new RuntimeException("wrong synchronized embedding");
        }
        Node source = dart.getSource();
        Node realSource;
        if (source == edge.getSource()) {
          realSource = realEdge.getSource();
        } else {
          realSource = realEdge.getTarget();
        }
        realFace.addLast(new Dart(realEdge, realSource));
      }
    }
    for (Node subcluster : Sequence.<Node>fromIterable(subclusters)) {
      findSubclusterEmbedding(subcluster, invEdgeMap);
    }
    for (Face face : SetSequence.<Face>fromSet(MapSequence.fromMap(myFaceMap).keySet())) {
      Face realFace = MapSequence.<Face,Face>fromMap(myFaceMap).get(face);
      myEmbeddedGraph.addFace(realFace);
      if (mySubEmbeddedGraph.isOuterFace(face)) {
        myEmbeddedGraph.setOuterFace(realFace);
      }
    }
    if (myClusterBorderMap != null && ListSequence.<Edge>fromList(myClusterBorder).count() > 0) {
      MapSequence.<Node,List<Edge>>fromMap(myClusterBorderMap).put(myCluster, myClusterBorder);
    }
    return myEmbeddedGraph;
  }

  private void findSubclusterEmbedding(Node subcluster, Map<Edge, Edge> invEdgeMap) {
    Node node = MapSequence.<INode,Node>fromMap(mySubclustersMap).get(subcluster);
    List<Dart> darts = mySubEmbeddedGraph.getOrderedDarts(node);
    List<Edge> subOuterEdgesOrder = ListSequence.<Edge>fromList(new ArrayList<Edge>(ListSequence.<Dart>fromList(darts).count()));
    for (Dart dart : ListSequence.<Dart>fromList(darts)) {
      Edge edge = dart.getEdge();
      Edge realEdge = MapSequence.<Edge,Edge>fromMap(invEdgeMap).get(edge);
      List<Edge> history = myHistoryManager.getHistory(realEdge);
      if (edge.getSource() == node) {
        realEdge = ListSequence.<Edge>fromList(history).first();
      } else {
        realEdge = ListSequence.<Edge>fromList(history).last();
      }
      ListSequence.<Edge>fromList(subOuterEdgesOrder).addElement(realEdge);
    }
    if (showInfo > 0) {
      for (Dart dart : ListSequence.<Dart>fromList(darts)) {
        System.out.println("pr dart " + dart + " -> " + MapSequence.<Edge,Edge>fromMap(invEdgeMap).get(dart.getEdge()));
      }
      System.out.println("pr " + subOuterEdgesOrder);
    }
    ClusterEmbeddingConstructor subProcessor = new ClusterEmbeddingConstructor(myGraph, subcluster, subOuterEdgesOrder);
    subProcessor.setClusterBorderMap(myClusterBorderMap);
    EmbeddedGraph subclusterEmbedding = subProcessor.constructEmbedding();
    CheckEmbeddedGraph.checkEmbeddedGraph(subclusterEmbedding, false);
    if (ListSequence.<Face>fromList(subclusterEmbedding.getFaces()).count() > 0) {
      for (Face face : ListSequence.<Face>fromList(subclusterEmbedding.getFaces())) {
        if (subclusterEmbedding.isOuterFace(face)) {
          continue;
        }
        myEmbeddedGraph.addFace(face);
      }
      if (showInfo > 0) {
        for (Edge edge : ListSequence.<Edge>fromList(subOuterEdgesOrder)) {
          System.out.println("order " + edge + ": " + myHistoryManager.getHistory(edge));
        }
        for (Dart dart : ListSequence.<Dart>fromList(darts)) {
          System.out.println("dart " + dart + " -> " + MapSequence.<Edge,Edge>fromMap(invEdgeMap).get(dart.getEdge()));
        }
      }
      List<Edge> subclusterBorder = subProcessor.getClusterBorder();
      for (int i = 0; i < ListSequence.<Dart>fromList(darts).count(); i++) {
        Edge borderEdge = ListSequence.<Edge>fromList(subclusterBorder).getElement(i);
        Edge outerEdge = ListSequence.<Edge>fromList(subOuterEdgesOrder).getElement(i);
        int next = i + 1;
        if (next == ListSequence.<Dart>fromList(darts).count()) {
          next = 0;
        }
        final Edge nextOuterEdge = ListSequence.<Edge>fromList(subOuterEdgesOrder).getElement(next);
        Face face = MapSequence.<Face,Face>fromMap(myFaceMap).get(mySubEmbeddedGraph.getFace(ListSequence.<Dart>fromList(darts).getElement(i)));
        List<Dart> faceDarts = face.getDarts();
        List<Dart> nextOuterFaceDarts = ListSequence.<Dart>fromList(faceDarts).where(new IWhereFilter<Dart>() {
          public boolean accept(Dart dart) {
            return dart.getEdge() == nextOuterEdge;
          }
        }).toListSequence();
        final Node outerNode = getOuterNode(nextOuterEdge, subcluster);
        Dart nextOuterEdgeDart = ListSequence.<Dart>fromList(nextOuterFaceDarts).findFirst(new IWhereFilter<Dart>() {
          public boolean accept(Dart it) {
            return it.getSource() == outerNode;
          }
        });
        if (nextOuterEdgeDart == null) {
          throw new RuntimeException("error during merging subcluster's embeddings");
        }
        face.makeStartsWith(nextOuterEdgeDart);
        ListSequence.<Dart>fromList(faceDarts).removeElementAt(0);
        ListSequence.<Dart>fromList(faceDarts).removeElementAt(0);
        Edge curOuterEdge = getOuterEdgeAfterModifications(subcluster, outerEdge);
        Edge curNextOuterEdge = getOuterEdgeAfterModifications(subcluster, nextOuterEdge);
        ListSequence.<Dart>fromList(faceDarts).insertElement(0, new Dart(curOuterEdge, borderEdge.getSource()));
        ListSequence.<Dart>fromList(faceDarts).insertElement(0, new Dart(borderEdge, borderEdge.getTarget()));
        ListSequence.<Dart>fromList(faceDarts).insertElement(0, new Dart(curNextOuterEdge, curNextOuterEdge.getOpposite(borderEdge.getTarget())));
      }
    }
  }

  private Edge getOuterEdgeAfterModifications(Node subcluster, Edge outerEdge) {
    final Node outerNode = this.getOuterNode(outerEdge, subcluster);
    return ListSequence.<Edge>fromList(myHistoryManager.getHistory(outerEdge)).findFirst(new IWhereFilter<Edge>() {
      public boolean accept(Edge edge) {
        return ListSequence.<Node>fromList(edge.getAdjacentNodes()).contains(outerNode);
      }
    });
  }

  private Node getOuterNode(Edge outerEdge, final Node subcluster) {
    return ListSequence.<Node>fromList(outerEdge.getAdjacentNodes()).findFirst(new IWhereFilter<Node>() {
      public boolean accept(Node node) {
        return MapSequence.<Node,Node>fromMap(myNodeMap).get(node) != MapSequence.<INode,Node>fromMap(mySubclustersMap).get(subcluster);
      }
    });
  }

  private Map<Edge, Edge> constructSubclusterGraphEmbedding() {
    // Creating a subcluster graph, where each subcluster is represented by a single node, 
    // and finding embedding for it. 
    mySubclustersGraph = new Graph();
    Map<Node, Node> nodeMap = MapSequence.<Node,Node>fromMap(new HashMap<Node, Node>());
    myNodeMap = nodeMap;
    mySubclustersMap = MapSequence.<INode,Node>fromMap(new HashMap<INode, Node>());
    List<Node> subclusters = myGraph.getSubclusters(myCluster);
    for (Node subcluster : ListSequence.<Node>fromList(subclusters)) {
      Node clusterNode = mySubclustersGraph.createNode();
      for (Node node : myGraph.getNodesInCluster(subcluster)) {
        MapSequence.<Node,Node>fromMap(nodeMap).put(node, clusterNode);
      }
      MapSequence.<INode,Node>fromMap(mySubclustersMap).put(subcluster, clusterNode);
    }
    Map<Edge, Edge> invEdgeMap = MapSequence.<Edge,Edge>fromMap(new HashMap<Edge, Edge>());
    for (Node source : SetSequence.<Node>fromSet(myClusterNodes)) {
      for (Edge edge : source.getOutEdges()) {
        Node target = edge.getTarget();
        if (SetSequence.<Node>fromSet(myClusterNodes).contains(target) && MapSequence.<Node,Node>fromMap(nodeMap).get(source) != MapSequence.<Node,Node>fromMap(nodeMap).get(target)) {
          Edge newEdge = mySubclustersGraph.connect(MapSequence.<Node,Node>fromMap(nodeMap).get(source), MapSequence.<Node,Node>fromMap(nodeMap).get(target));
          MapSequence.<Edge,Edge>fromMap(invEdgeMap).put(newEdge, edge);
        }
      }
    }
    if (showInfo > 0) {
      System.out.println("i subgraph " + myCluster + ": " + mySubclustersGraph.getEdges());
    }
    Set<Edge> connectingEdges = ConnectivityComponents.makeConnected(mySubclustersGraph);
    if (showInfo > 0) {
      System.out.println("c subgraph " + myCluster + ": " + mySubclustersGraph.getEdges());
    }
    for (Edge edge : SetSequence.<Edge>fromSet(connectingEdges)) {
      Node source = this.getRealNode(edge.getSource(), nodeMap);
      Node target = getRealNode(edge.getTarget(), nodeMap);
      Edge realEdge = myGraph.connect(source, target);
      MapSequence.<Edge,Edge>fromMap(invEdgeMap).put(edge, realEdge);
    }
    GroupedGraphModificationSynchronizer synchronizer = new GroupedGraphModificationSynchronizer(mySubclustersGraph, myGraph, invEdgeMap);
    mySubEmbeddedGraph = EmbeddingFinderFactory.getFinder().find(mySubclustersGraph);
    if (showInfo > 0) {
      System.out.println("e subgraph " + myCluster + ": " + mySubclustersGraph.getEdges());
    }
    synchronizer.disconnect();

    if (ListSequence.<Edge>fromList(myOuterEdgesOrder).count() > 0) {
      // Creating a special structure for processing outer edges. Syncronizer should be turned off 
      // due to this structure has no corresponding in initial graph. 
      int numShifts = 0;
      while (getSubcluster(ListSequence.<Edge>fromList(myOuterEdgesOrder).first()) == getSubcluster(ListSequence.<Edge>fromList(myOuterEdgesOrder).last()) && numShifts < ListSequence.<Edge>fromList(myOuterEdgesOrder).count()) {
        ListSequence.<Edge>fromList(myOuterEdgesOrder).insertElement(0, ListSequence.<Edge>fromList(myOuterEdgesOrder).removeLastElement());
        numShifts++;
      }
      List<Edge> subClusterBorder = ListSequence.<Edge>fromList(new ArrayList<Edge>(ListSequence.<Edge>fromList(myOuterEdgesOrder).count()));
      myClusterBorder = ListSequence.<Edge>fromList(new ArrayList<Edge>(ListSequence.<Edge>fromList(myOuterEdgesOrder).count()));
      List<Edge> subOuterEdges = ListSequence.<Edge>fromList(new ArrayList<Edge>(ListSequence.<Edge>fromList(myOuterEdgesOrder).count()));
      List<Node> realBorderNodes = ListSequence.<Node>fromList(new ArrayList<Node>(ListSequence.<Edge>fromList(myOuterEdgesOrder).count()));
      List<Node> subBorderNodes = ListSequence.<Node>fromList(new ArrayList<Node>(ListSequence.<Edge>fromList(myOuterEdgesOrder).count()));
      for (Edge outerEdge : ListSequence.<Edge>fromList(myOuterEdgesOrder)) {
        final Node realClusterNode = getClusterNode(outerEdge);
        boolean isSource = realClusterNode == outerEdge.getSource();
        List<Edge> realSplit = myGraph.splitEdge(outerEdge);
        ListSequence.<Node>fromList(realBorderNodes).addElement(ListSequence.<Edge>fromList(realSplit).getElement(0).getTarget());
        Node subBorderNode = mySubclustersGraph.createNode();
        ListSequence.<Node>fromList(subBorderNodes).addElement(subBorderNode);
        Edge subOuterEdge;
        if (isSource) {
          subOuterEdge = mySubclustersGraph.connect(MapSequence.<Node,Node>fromMap(nodeMap).get(realClusterNode), subBorderNode);
        } else {
          subOuterEdge = mySubclustersGraph.connect(subBorderNode, MapSequence.<Node,Node>fromMap(nodeMap).get(realClusterNode));
        }
        Edge realOuterEdge = ListSequence.<Edge>fromList(realSplit).findFirst(new IWhereFilter<Edge>() {
          public boolean accept(Edge it) {
            return ListSequence.<Node>fromList(it.getAdjacentNodes()).contains(realClusterNode);
          }
        });
        MapSequence.<Edge,Edge>fromMap(invEdgeMap).put(subOuterEdge, realOuterEdge);
        ListSequence.<Edge>fromList(subOuterEdges).addElement(subOuterEdge);
      }
      Face outerFace = new Face(mySubclustersGraph);
      for (int i = 0; i < ListSequence.<Edge>fromList(myOuterEdgesOrder).count(); i++) {
        int next = i + 1;
        if (next == ListSequence.<Edge>fromList(myOuterEdgesOrder).count()) {
          next = 0;
        }
        Edge realBorderEdge = myGraph.connect(ListSequence.<Node>fromList(realBorderNodes).getElement(i), ListSequence.<Node>fromList(realBorderNodes).getElement(next));
        ListSequence.<Edge>fromList(myClusterBorder).addElement(realBorderEdge);
        Edge subBorderEdge = mySubclustersGraph.connect(ListSequence.<Node>fromList(subBorderNodes).getElement(i), ListSequence.<Node>fromList(subBorderNodes).getElement(next));
        ListSequence.<Edge>fromList(subClusterBorder).addElement(subBorderEdge);
        MapSequence.<Edge,Edge>fromMap(invEdgeMap).put(subBorderEdge, realBorderEdge);
        outerFace.addFirst(new Dart(subBorderEdge, ListSequence.<Node>fromList(subBorderNodes).getElement(next)));
      }
      // make myClusterBorder in correspondence with initial outer edges 
      for (int i = 0; i < numShifts; i++) {
        ListSequence.<Edge>fromList(myClusterBorder).addElement(ListSequence.<Edge>fromList(myClusterBorder).removeElementAt(0));
      }

      // Including this construction into subclusters graph embedding as an outer face. 
      Set<Edge> addedEdges = SetSequence.<Edge>fromSet(new HashSet<Edge>());
      if (useSlowFaceFinder) {
        addedEdges = createOuterFaceWithFaceSelection(subBorderNodes, subOuterEdges, subClusterBorder);
      } else {
        Edge bridge = this.createOuterFace(subBorderNodes, subOuterEdges, subClusterBorder);
        SetSequence.fromSet(addedEdges).addElement(bridge);
      }
      mySubEmbeddedGraph.addFace(outerFace);
      mySubEmbeddedGraph.setOuterFace(outerFace);
      if (debugMode > 0) {
        CheckEmbeddedGraph.checkEmbeddedGraph(mySubEmbeddedGraph, false);
      }
      // Processing outer edges. 
      synchronizer = new GroupedGraphModificationSynchronizer(mySubclustersGraph, myGraph, invEdgeMap);
      for (Edge edge : ListSequence.<Edge>fromList(subOuterEdges)) {
        if (SetSequence.<Edge>fromSet(addedEdges).contains(edge)) {
          continue;
        }
        mySubclustersGraph.removeEdge(edge);
        ShortestPathEmbeddingFinder.restoreEdge(mySubEmbeddedGraph, edge, true);
      }
      synchronizer.disconnect();
    }
    return invEdgeMap;
  }

  private Set<Edge> createOuterFaceWithFaceSelection(List<Node> subBorderNodes, List<Edge> subOuterEdges, List<Edge> subClusterBorder) {
    // there is only one subcluster of myCluster 
    if (mySubEmbeddedGraph.isEmpty()) {
      Node node = ListSequence.<Node>fromList(mySubclustersGraph.getNodes()).first();
      Edge prev = ListSequence.<Edge>fromList(subOuterEdges).last();
      Edge borderEdge = ListSequence.<Edge>fromList(subClusterBorder).last();
      Iterator<Edge> borderEdgeItr = ListSequence.<Edge>fromList(subClusterBorder).iterator();
      for (Edge edge : ListSequence.<Edge>fromList(subOuterEdges)) {
        Face face = new Face(mySubclustersGraph);
        face.addLast(new Dart(borderEdge, borderEdge.getSource()));
        face.addLast(new Dart(edge, edge.getOpposite(node)));
        face.addLast(new Dart(prev, node));
        mySubEmbeddedGraph.addFace(face);
        prev = edge;
        borderEdge = borderEdgeItr.next();
      }
      Set<Edge> addedEdges = SetSequence.<Edge>fromSet(new HashSet<Edge>());
      SetSequence.fromSet(addedEdges).addSequence(ListSequence.<Edge>fromList(subOuterEdges));
      return addedEdges;
    }
    Tuples._2<Face, List<Tuples._2<Integer, Integer>>> bestFaceInfo = findBestFace();
    Face bestFace = bestFaceInfo._0();
    mySubEmbeddedGraph.removeFace(bestFace);
    List<Tuples._2<Integer, Integer>> positions = bestFaceInfo._1();
    List<Dart> darts = ListSequence.<Dart>fromList(bestFace.getDarts()).reversedList();
    positions = shiftLists(positions, darts, subBorderNodes, subOuterEdges, subClusterBorder);
    checkPos(positions);
    ClusterEmbeddingConstructor.ListParser<Dart> dartParser = new ClusterEmbeddingConstructor.ListParser(darts);
    ClusterEmbeddingConstructor.ListParser<Edge> edgeParser = new ClusterEmbeddingConstructor.ListParser(subClusterBorder);
    Tuples._2<Integer, Integer> prev = MultiTuple.<Integer,Integer>from(-1, -1);
    Set<Edge> addedEdges = SetSequence.<Edge>fromSet(new HashSet<Edge>());
    for (Tuples._2<Integer, Integer> pos : ListSequence.<Tuples._2<Integer, Integer>>fromList(positions)) {
      if ((int) prev._0() == -1) {
        prev = pos;
        continue;
      }
      List<Dart> curDarts = dartParser.getNext((int) pos._1());
      List<Edge> curEdges = edgeParser.getNext((int) pos._0());
      this.addFace(subOuterEdges, prev, subBorderNodes, curEdges, pos, curDarts, addedEdges);
      prev = pos;
    }
    // add last face 
    List<Dart> curDarts = dartParser.getEnd();
    List<Edge> curEdges = edgeParser.getEnd();
    Tuples._2<Integer, Integer> pos = ListSequence.<Tuples._2<Integer, Integer>>fromList(positions).first();
    addFace(subOuterEdges, prev, subBorderNodes, curEdges, pos, curDarts, addedEdges);
    return addedEdges;
  }

  private void addFace(List<Edge> subOuterEdges, Tuples._2<Integer, Integer> prev, List<Node> subBorderNodes, List<Edge> curEdges, Tuples._2<Integer, Integer> pos, List<Dart> curDarts, Set<Edge> addedEdges) {
    Face face = new Face(mySubclustersGraph);
    Edge prevEdge = ListSequence.<Edge>fromList(subOuterEdges).getElement((int) prev._0());
    face.addLast(new Dart(prevEdge, prevEdge.getOpposite(ListSequence.<Node>fromList(subBorderNodes).getElement((int) prev._0()))));
    for (Edge edge : ListSequence.<Edge>fromList(curEdges)) {
      face.addLast(new Dart(edge, edge.getSource()));
    }
    face.addLast(new Dart(ListSequence.<Edge>fromList(subOuterEdges).getElement((int) pos._0()), ListSequence.<Node>fromList(subBorderNodes).getElement((int) pos._0())));
    for (Dart dart : ListSequence.<Dart>fromList(curDarts).reversedList()) {
      face.addLast(dart);
    }
    mySubEmbeddedGraph.addFace(face);
    SetSequence.fromSet(addedEdges).addElement(ListSequence.<Edge>fromList(subOuterEdges).getElement((int) pos._0()));
  }

  public void checkPos(List<Tuples._2<Integer, Integer>> pos) {
    int last0 = Integer.MIN_VALUE;
    int last1 = Integer.MIN_VALUE;
    for (Tuples._2<Integer, Integer> p : ListSequence.<Tuples._2<Integer, Integer>>fromList(pos)) {
      if ((int) p._0() <= last0) {
        throw new RuntimeException("fail");
      }
      if ((int) p._1() < last1) {
        throw new RuntimeException("fail");
      }
      last0 = (int) p._0();
      last1 = (int) p._1();
    }
  }

  private List<Tuples._2<Integer, Integer>> shiftLists(List<Tuples._2<Integer, Integer>> pos, List<Dart> darts, List<Node> borderNodes, List<Edge> outerEdges, List<Edge> borderEdges) {
    Tuples._2<Integer, Integer> first = ListSequence.<Tuples._2<Integer, Integer>>fromList(pos).first();
    int firstBorderPos = (int) first._0();
    for (int i = 0; i < firstBorderPos; i++) {
      ListSequence.<Node>fromList(borderNodes).addElement(ListSequence.<Node>fromList(borderNodes).removeElementAt(0));
      ListSequence.<Edge>fromList(outerEdges).addElement(ListSequence.<Edge>fromList(outerEdges).removeElementAt(0));
      ListSequence.<Edge>fromList(borderEdges).addElement(ListSequence.<Edge>fromList(borderEdges).removeElementAt(0));
    }
    int firstDartPos = (int) first._1();
    for (int i = 0; i < firstDartPos; i++) {
      ListSequence.<Dart>fromList(darts).addElement(ListSequence.<Dart>fromList(darts).removeElementAt(0));
    }
    List<Tuples._2<Integer, Integer>> newPos = ListSequence.<Tuples._2<Integer, Integer>>fromList(new ArrayList<Tuples._2<Integer, Integer>>(ListSequence.<Tuples._2<Integer, Integer>>fromList(pos).count()));
    for (Tuples._2<Integer, Integer> p : ListSequence.<Tuples._2<Integer, Integer>>fromList(pos)) {
      int p0 = (int) p._0() - firstBorderPos;
      int p1 = (int) p._1() - firstDartPos;
      if (p1 < 0) {
        p1 += ListSequence.<Dart>fromList(darts).count();
      }
      ListSequence.<Tuples._2<Integer, Integer>>fromList(newPos).addElement(MultiTuple.<Integer,Integer>from(p0, p1));
    }
    return newPos;
  }

  private Tuples._2<Face, List<Tuples._2<Integer, Integer>>> findBestFace() {
    Face bestFace = null;
    List<Tuples._2<Integer, Integer>> pos = ListSequence.<Tuples._2<Integer, Integer>>fromList(new ArrayList<Tuples._2<Integer, Integer>>());
    List<Object> outerOrder = ListSequence.<Object>fromList(new LinkedList<Object>());
    for (Edge outerEdge : ListSequence.<Edge>fromList(myOuterEdgesOrder)) {
      ListSequence.<Object>fromList(outerOrder).addElement(getSubcluster(outerEdge));
    }
    for (Face face : ListSequence.<Face>fromList(mySubEmbeddedGraph.getFaces())) {
      List<Object> faceOrder = ListSequence.<Object>fromList(new LinkedList<Object>());
      List<Dart> darts = face.getDarts();
      // outer edge has counterclockwise darts order 
      for (Dart dart : ListSequence.<Dart>fromList(darts).reversedList()) {
        ListSequence.<Object>fromList(faceOrder).addElement(dart.getTarget());
      }
      List<Tuples._2<Integer, Integer>> facePos = SubsequenceFinder.getCyclicSubsequence(outerOrder, faceOrder);
      if (ListSequence.<Tuples._2<Integer, Integer>>fromList(facePos).count() > ListSequence.<Tuples._2<Integer, Integer>>fromList(pos).count()) {
        pos = facePos;
        bestFace = face;
      }
    }
    return MultiTuple.<Face,List<Tuples._2<Integer, Integer>>>from(bestFace, pos);
  }

  private Edge createOuterFace(List<Node> subBorderNodes, List<Edge> subOuterEdges, List<Edge> subClusterBorder) {
    Node borderFirstNode = ListSequence.<Node>fromList(subBorderNodes).first();
    Edge bridge = ListSequence.<Edge>fromList(subOuterEdges).first();
    Node clusterFirstNode = bridge.getOpposite(borderFirstNode);
    Face clusterOuterFace = mySubEmbeddedGraph.findContainingFace(ListSequence.<Node>fromListAndArray(new ArrayList<Node>(), clusterFirstNode));
    clusterOuterFace.makeEndsWith(clusterFirstNode);
    Face ringFace = new Face(mySubclustersGraph);
    ringFace.addLast(new Dart(bridge, clusterFirstNode));
    for (Edge edge : ListSequence.<Edge>fromList(subClusterBorder)) {
      ringFace.addLast(new Dart(edge, edge.getSource()));
    }
    ringFace.addLast(new Dart(bridge, borderFirstNode));
    for (Dart dart : ListSequence.<Dart>fromList(clusterOuterFace.getDarts())) {
      ringFace.addLast(dart);
    }
    mySubEmbeddedGraph.removeFace(clusterOuterFace);
    mySubEmbeddedGraph.addFace(ringFace);
    return bridge;
  }

  private Node getRealNode(final Node subNode, final Map<Node, Node> nodeMap) {
    return SetSequence.<Node>fromSet(myClusterNodes).findFirst(new IWhereFilter<Node>() {
      public boolean accept(Node it) {
        return MapSequence.<Node,Node>fromMap(nodeMap).get(it) == subNode;
      }
    });
  }

  private Node getClusterNode(Edge edge) {
    boolean isSource = SetSequence.<Node>fromSet(myClusterNodes).contains(edge.getSource());
    boolean isTarget = SetSequence.<Node>fromSet(myClusterNodes).contains(edge.getTarget());
    if (isSource == isTarget) {
      throw new RuntimeException("" + edge + " is not outer for cluster " + myCluster);
    }
    if (isSource) {
      return edge.getSource();
    } else {
      return edge.getTarget();
    }
  }

  private Node getSubcluster(Edge outerEdge) {
    for (Node node : ListSequence.<Node>fromList(outerEdge.getAdjacentNodes())) {
      Node subcluster = MapSequence.<Node,Node>fromMap(myNodeMap).get(node);
      if (subcluster != null) {
        return subcluster;
      }
    }
    return null;
  }

  public List<Edge> getClusterBorder() {
    return myClusterBorder;
  }

  public void setClusterBorderMap(Map<Node, List<Edge>> clusterBorderMap) {
    myClusterBorderMap = clusterBorderMap;
  }

  public class ListParser<T> {
    private Iterator<T> myItr;
    private int myPos;

    public ListParser(List<T> list) {
      myItr = ListSequence.<T>fromList(list).iterator();
      myPos = 0;
    }

    public List<T> getNext(int nextPos) {
      List<T> part = ListSequence.<T>fromList(new LinkedList<T>());
      while (myPos != nextPos) {
        ListSequence.<T>fromList(part).addElement(myItr.next());
        myPos++;
      }
      return part;
    }

    public List<T> getEnd() {
      List<T> part = ListSequence.<T>fromList(new LinkedList<T>());
      while (myItr.hasNext()) {
        ListSequence.<T>fromList(part).addElement(myItr.next());
        myPos++;
      }
      return part;
    }
  }
}
