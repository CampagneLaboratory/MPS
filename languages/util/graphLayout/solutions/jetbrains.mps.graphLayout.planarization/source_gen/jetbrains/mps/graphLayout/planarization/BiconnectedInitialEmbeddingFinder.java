package jetbrains.mps.graphLayout.planarization;

/*Generated by MPS */

import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.graph.Graph;
import java.util.Set;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.graphLayout.graph.Edge;
import java.util.List;
import jetbrains.mps.graphLayout.algorithms.ShortestPath;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.planarGraph.Face;
import jetbrains.mps.graphLayout.planarGraph.DualGraph;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.graphLayout.graph.GraphModificationEvent;

public class BiconnectedInitialEmbeddingFinder implements IEmbeddingFinder {
  private static int SHOW_LOG = 0;

  public BiconnectedInitialEmbeddingFinder() {
  }

  public EmbeddedGraph find(Graph graph) {
    EmbeddedGraph embeddedGraph = new EmbeddedGraph(graph);
    this.findCycle(embeddedGraph);
    Set<Node> toBeAdded = SetSequence.<Node>fromSet(new HashSet<Node>());
    SetSequence.fromSet(toBeAdded).addSequence(ListSequence.<Node>fromList(graph.getNodes()));
    for (Dart dart : ListSequence.<Dart>fromList(embeddedGraph.getOuterFace().getDarts())) {
      SetSequence.fromSet(toBeAdded).removeElement(dart.getSource());
    }
    while (SetSequence.<Node>fromSet(toBeAdded).count() > 0) {
      for (Edge edge : ListSequence.<Edge>fromList(graph.getEdges())) {
        for (Node node : ListSequence.<Node>fromList(edge.getAdjacentNodes())) {
          Node opNode = edge.getOpposite(node);
          if (!(SetSequence.<Node>fromSet(toBeAdded).contains(node)) && SetSequence.<Node>fromSet(toBeAdded).contains(opNode)) {
            addPath(embeddedGraph, node, opNode, toBeAdded);
          }
        }
      }
    }
    return embeddedGraph;
  }

  private void addPath(EmbeddedGraph embeddedGraph, final Node start, final Node toAdd, Set<Node> toBeAdded) {
    if (SHOW_LOG > 0) {
      System.out.println("before: \n" + embeddedGraph);
    }
    Set<Edge> removed = SetSequence.<Edge>fromSet(new HashSet<Edge>());
    for (Edge edge : ListSequence.<Edge>fromList(start.getEdges())) {
      if (SetSequence.<Node>fromSet(toBeAdded).contains(edge.getOpposite(start))) {
        SetSequence.fromSet(removed).addElement(edge);
      }
    }
    for (Edge edge : SetSequence.<Edge>fromSet(removed)) {
      embeddedGraph.getGraph().removeEdge(edge);
    }
    List<Edge> path = ShortestPath.getPath(embeddedGraph.getGraph(), toAdd, start, Edge.Direction.BOTH);
    int endIndex = 0;
    Node cur = toAdd;
    while (SetSequence.<Node>fromSet(toBeAdded).contains(cur)) {
      cur = ListSequence.<Edge>fromList(path).getElement(endIndex).getOpposite(cur);
      endIndex++;
    }
    path = ListSequence.<Edge>fromList(path).subListSequence(0, endIndex);
    for (Edge edge : SetSequence.<Edge>fromSet(removed)) {
      embeddedGraph.getGraph().addEdge(edge);
    }
    ListSequence.<Edge>fromList(path).insertElement(0, ListSequence.<Edge>fromList(SetSequence.<Edge>fromSet(removed).where(new IWhereFilter<Edge>() {
      public boolean accept(Edge it) {
        return it.getOpposite(start) == toAdd;
      }
    }).toListSequence()).getElement(0));
    for (Edge edge : ListSequence.<Edge>fromList(path)) {
      for (Node node : ListSequence.<Node>fromList(edge.getAdjacentNodes())) {
        SetSequence.fromSet(toBeAdded).removeElement(node);
      }
    }
    if (SHOW_LOG > 0) {
      System.out.println("find path: " + path);
    }
    connect(embeddedGraph, path, start, cur);
  }

  private void findCycle(EmbeddedGraph embeddedGraph) {
    Set<Node> visited = SetSequence.<Node>fromSet(new HashSet<Node>());
    List<Dart> darts = ListSequence.<Dart>fromList(new ArrayList<Dart>());
    Graph graph = embeddedGraph.getGraph();
    Node cur = graph.getNode(0);
    Edge prevEdge = null;
    while (!(SetSequence.<Node>fromSet(visited).contains(cur))) {
      SetSequence.fromSet(visited).addElement(cur);
      Edge next = ListSequence.<Edge>fromList(cur.getEdges()).getElement(0);
      if (next == prevEdge) {
        next = ListSequence.<Edge>fromList(cur.getEdges()).getElement(1);
      }
      ListSequence.<Dart>fromList(darts).addElement(new Dart(next, cur));
      cur = next.getOpposite(cur);
      prevEdge = next;
    }
    List<Dart> path = ListSequence.<Dart>fromList(new ArrayList<Dart>());
    boolean inCycle = false;
    for (Dart dart : ListSequence.<Dart>fromList(darts)) {
      if (dart.getSource() == cur) {
        inCycle = true;
      }
      if (inCycle) {
        ListSequence.<Dart>fromList(path).addElement(dart);
      }
    }
    Face innerFace = new Face(graph);
    for (Dart dart : ListSequence.<Dart>fromList(path)) {
      innerFace.addLast(dart);
    }
    Face outerFace = new Face(graph);
    for (Dart dart : ListSequence.<Dart>fromList(path).reversedList()) {
      outerFace.addLast(new Dart(dart.getEdge(), dart.getTarget()));
    }
    embeddedGraph.addFace(innerFace);
    embeddedGraph.addFace(outerFace);
    embeddedGraph.setOuterFace(outerFace);
  }

  public void connect(EmbeddedGraph embeddedGraph, List<Edge> path, Node start, Node end) {
    Graph graph = embeddedGraph.getGraph();
    DualGraph dualGraph = new DualGraph(embeddedGraph);
    Node dualStart = dualGraph.addRealNode(start);
    Node dualEnd = dualGraph.addRealNode(end);
    List<Edge> dualPath = ShortestPath.getPath(dualGraph, dualStart, dualEnd, Edge.Direction.BOTH);
    List<Node> nodePath = ListSequence.<Node>fromList(new ArrayList<Node>());
    List<Face> facePath = ListSequence.<Face>fromList(new ArrayList<Face>());
    ListSequence.<Node>fromList(nodePath).addElement(start);
    Node cur = dualStart;
    for (Edge edge : ListSequence.<Edge>fromList(dualPath)) {
      Edge realEdge = MapSequence.<Edge,Edge>fromMap(dualGraph.getEdgesMap()).get(edge);
      if (embeddedGraph.getAdjacentFaces(realEdge) != null) {
        ListSequence.<Node>fromList(nodePath).addElement(embeddedGraph.splitEdge(MapSequence.<Edge,Edge>fromMap(dualGraph.getEdgesMap()).get(edge)));
      }
      cur = edge.getOpposite(cur);
      Face curFace = MapSequence.<Node,Face>fromMap(dualGraph.getFacesMap()).get(cur);
      if (curFace != null) {
        ListSequence.<Face>fromList(facePath).addElement(curFace);
      }
    }
    ListSequence.<Node>fromList(nodePath).addElement(end);
    Edge deletedEdge = null;
    List<Edge> newEdges = ListSequence.<Edge>fromList(new ArrayList<Edge>());
    for (int i = 0; i < ListSequence.<Node>fromList(nodePath).count() - 1; i++) {
      Node curStart = ListSequence.<Node>fromList(nodePath).getElement(i);
      Node curEnd = ListSequence.<Node>fromList(nodePath).getElement(i + 1);
      List<Edge> tempPath = ListSequence.<Edge>fromList(new ArrayList<Edge>());
      if (i == 0) {
        if (end == ListSequence.<Node>fromList(nodePath).getElement(i + 1)) {
          ListSequence.<Edge>fromList(tempPath).addSequence(ListSequence.<Edge>fromList(path));
        } else {
          Edge lastEdge = ListSequence.<Edge>fromList(path).removeLastElement();
          graph.removeEdge(lastEdge);
          deletedEdge = lastEdge;
          ListSequence.<Edge>fromList(tempPath).addSequence(ListSequence.<Edge>fromList(path));
          Edge newEdge;
          newEdge = graph.connect(lastEdge.getOpposite(end), curEnd);
          ListSequence.<Edge>fromList(newEdges).addElement(newEdge);
          ListSequence.<Edge>fromList(tempPath).addElement(newEdge);
        }
      } else {
        Edge newEdge;
        newEdge = graph.connect(curStart, curEnd);
        ListSequence.<Edge>fromList(newEdges).addElement(newEdge);
        ListSequence.<Edge>fromList(tempPath).addElement(newEdge);
      }
      embeddedGraph.splitFace(ListSequence.<Face>fromList(facePath).getElement(i), tempPath, curStart, curEnd);
      if (deletedEdge != null) {
        GraphModificationEvent splitEvent = new GraphModificationEvent(GraphModificationEvent.Type.EDGE_SPLITTED, deletedEdge, newEdges);
        graph.getModificationProcessor().fire(splitEvent);
      }
    }
  }
}
