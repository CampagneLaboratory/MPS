package jetbrains.mps.graphLayout.planarGraph;

/*Generated by MPS */

import java.util.List;
import java.util.Map;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.LinkedHashMap;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;

public class EmbeddedGraph {
  private List<Face> myFaces;
  private Map<Edge, List<Face>> myAdjacentFacesMap;
  private Map<Dart, Face> myDartsToFacesMap;
  private Map<Edge, List<Dart>> myEdgeDarts;
  private Graph myGraph;
  private Face myOuterFace;

  public EmbeddedGraph(Graph graph) {
    myFaces = ListSequence.<Face>fromList(new ArrayList<Face>());
    myAdjacentFacesMap = MapSequence.<Edge,List<Face>>fromMap(new HashMap<Edge, List<Face>>());
    myDartsToFacesMap = MapSequence.<Dart,Face>fromMap(new HashMap<Dart, Face>());
    myEdgeDarts = MapSequence.<Edge,List<Dart>>fromMap(new LinkedHashMap<Edge, List<Dart>>(16, (float) 0.75, false));
    myGraph = graph;
  }

  public Face findContainingFace(List<Node> nodes) {
    Face containingFace = null;
    for (Face face : ListSequence.<Face>fromList(getFaces())) {
      if (face.contains(nodes)) {
        if (isOuterFace(face)) {
          containingFace = face;
        } else {
          return face;
        }
      }
    }
    return containingFace;
  }

  public Face getFaceToTheRight(Edge edge) {
    List<Dart> darts = getDarts(edge);
    for (Dart dart : ListSequence.<Dart>fromList(darts)) {
      if (dart.getSource() == edge.getTarget()) {
        return getFace(dart);
      }
    }
    return null;
  }

  public Face getFaceToTheLeft(Edge edge) {
    List<Dart> darts = getDarts(edge);
    for (Dart dart : ListSequence.<Dart>fromList(darts)) {
      if (dart.getSource() == edge.getSource()) {
        return getFace(dart);
      }
    }
    return null;
  }

  public Dart getSourceDart(Edge edge, final Node source) {
    return ListSequence.<Dart>fromList(getDarts(edge)).findFirst(new IWhereFilter<Dart>() {
      public boolean accept(Dart dart) {
        return dart.getSource() == source;
      }
    });
  }

  public Node splitEdge(Edge edge) {
    return splitEdge(edge, ListSequence.<Edge>fromList(new ArrayList<Edge>()));
  }

  public Node splitEdge(final Edge edge, List<Edge> newEdges) {
    Graph originalGraph = this.getGraph();
    List<Edge> split = originalGraph.splitEdge(edge);
    ListSequence.<Edge>fromList(newEdges).addSequence(ListSequence.<Edge>fromList(split));
    Node newNode = ListSequence.<Edge>fromList(split).getElement(0).getTarget();
    List<Face> facesToProcess = ListSequence.<Face>fromList(new ArrayList<Face>());
    ListSequence.<Face>fromList(facesToProcess).addSequence(ListSequence.<Face>fromList(getAdjacentFaces(edge)));
    List<Edge> addOrder = null;
    for (Face face : ListSequence.<Face>fromList(facesToProcess)) {
      List<Dart> darts = face.getDarts();
      int numDartsToRemove = ListSequence.<Dart>fromList(darts).where(new IWhereFilter<Dart>() {
        public boolean accept(Dart it) {
          return it.getEdge() == edge;
        }
      }).count();
      // addOrder is added here to process case of a loop 
      for (int dartNum = 0; dartNum < numDartsToRemove; dartNum++) {
        int pos = 0;
        while (ListSequence.<Dart>fromList(darts).getElement(pos).getEdge() != edge) {
          pos++;
        }
        Dart dartToReplace = ListSequence.<Dart>fromList(darts).getElement(pos);
        if (addOrder == null) {
          addOrder = newEdges;
          if (dartToReplace.getSource() != edge.getSource()) {
            addOrder = ListSequence.<Edge>fromList(newEdges).reversedList();
          }
        } else {
          addOrder = ListSequence.<Edge>fromList(addOrder).reversedList();
        }
        setDart(face, pos, new Dart(ListSequence.<Edge>fromList(addOrder).getElement(0), dartToReplace.getSource()));
        insertDart(face, pos + 1, new Dart(ListSequence.<Edge>fromList(addOrder).getElement(1), newNode));
        /*
          for (Edge newEdge : ListSequence.<Edge>fromList(newEdges)) {
            if (ListSequence.<Node>fromList(newEdge.getAdjacentNodes()).contains(dartToReplace.getSource())) {
              this.setDart(face, pos, new Dart(newEdge, dartToReplace.getSource()));
            }
          }
          for (Edge newEdge : ListSequence.<Edge>fromList(newEdges)) {
            if (ListSequence.<Node>fromList(newEdge.getAdjacentNodes()).contains(dartToReplace.getTarget())) {
              this.insertDart(face, pos + 1, new Dart(newEdge, newNode));
            }
          }
        */

      }
    }
    return newNode;
  }

  public List<Face> splitFace(Face face, List<Edge> path, Node start, Node end) {
    Graph originalGraph = this.getGraph();
    Face faceSToE = new Face(originalGraph);
    Face faceEToS = new Face(originalGraph);
    List<Dart> darts = face.getDarts();
    int posStart = -1;
    int posEnd = -1;
    for (int i = 0; i < ListSequence.<Dart>fromList(darts).count(); i++) {
      Dart cur = ListSequence.<Dart>fromList(darts).getElement(i);
      if (cur.getSource() == start) {
        posStart = i;
      }
      if (cur.getSource() == end) {
        posEnd = i;
      }
    }
    Face succ;
    Face split;
    int begSucc;
    int endSucc;
    if (posEnd > posStart) {
      succ = faceEToS;
      split = faceSToE;
      begSucc = posStart;
      endSucc = posEnd;
    } else {
      succ = faceSToE;
      split = faceEToS;
      begSucc = posEnd;
      endSucc = posStart;
    }
    for (int i = begSucc; i < endSucc; i++) {
      succ.addLast(ListSequence.<Dart>fromList(darts).getElement(i));
    }
    for (int i = endSucc; i < ListSequence.<Dart>fromList(darts).count(); i++) {
      split.addLast(ListSequence.<Dart>fromList(darts).getElement(i));
    }
    for (int i = 0; i < begSucc; i++) {
      split.addLast(ListSequence.<Dart>fromList(darts).getElement(i));
    }
    Node cur = start;
    for (Edge edge : ListSequence.<Edge>fromList(path)) {
      faceSToE.addLast(new Dart(edge, cur));
      cur = edge.getOpposite(cur);
    }
    cur = end;
    for (Edge edge : ListSequence.<Edge>fromList(path).reversedList()) {
      faceEToS.addLast(new Dart(edge, cur));
      cur = edge.getOpposite(cur);
    }
    this.removeFace(face);
    addFace(faceEToS);
    addFace(faceSToE);
    if (this.isOuterFace(face)) {
      this.setOuterFace(split);
    }
    return ListSequence.<Face>fromListAndArray(new ArrayList<Face>(), faceSToE, faceEToS);
  }

  public Face makeLoop(Face face, List<Edge> loop, Node node) {
    face.makeEndsWith(node);
    for (Edge edge : ListSequence.<Edge>fromList(loop)) {
      addLastDart(face, new Dart(edge, edge.getSource()));
    }
    Face newFace = new Face(getGraph());
    for (Edge edge : ListSequence.<Edge>fromList(loop)) {
      newFace.addFirst(new Dart(edge, edge.getTarget()));
    }
    addFace(newFace);
    return newFace;
  }

  public void addFace(Face face) {
    ListSequence.<Face>fromList(myFaces).addElement(face);
    for (Dart dart : ListSequence.<Dart>fromList(face.getDarts())) {
      adjustDart(dart, face);
    }
  }

  private void adjustDart(Dart dart, Face face) {
    MapSequence.<Dart,Face>fromMap(myDartsToFacesMap).put(dart, face);
    Edge edge = dart.getEdge();
    if (!(MapSequence.fromMap(myEdgeDarts).containsKey(edge))) {
      MapSequence.<Edge,List<Dart>>fromMap(myEdgeDarts).put(edge, ListSequence.<Dart>fromList(new ArrayList<Dart>()));
    }
    ListSequence.<Dart>fromList(MapSequence.<Edge,List<Dart>>fromMap(myEdgeDarts).get(edge)).addElement(dart);
  }

  public void removeFace(Face face) {
    ListSequence.<Face>fromList(myFaces).removeElement(face);
    for (Dart dart : ListSequence.<Dart>fromList(face.getDarts())) {
      unadjustDart(dart);
    }
  }

  private void unadjustDart(Dart dart) {
    MapSequence.fromMap(myDartsToFacesMap).removeKey(dart);
    Edge edge = dart.getEdge();
    ListSequence.<Dart>fromList(MapSequence.<Edge,List<Dart>>fromMap(myEdgeDarts).get(edge)).removeElement(dart);
    if (ListSequence.<Dart>fromList(MapSequence.<Edge,List<Dart>>fromMap(myEdgeDarts).get(edge)).count() == 0) {
      MapSequence.fromMap(myEdgeDarts).removeKey(edge);
    }
  }

  public void setDart(Face face, int pos, Dart dart) {
    Dart oldDart = ListSequence.<Dart>fromList(face.getDarts()).getElement(pos);
    unadjustDart(oldDart);
    ListSequence.<Dart>fromList(face.getDarts()).setElement(pos, dart);
    adjustDart(dart, face);
  }

  public void removeDart(Face face, Dart dart) {
    unadjustDart(dart);
    ListSequence.<Dart>fromList(face.getDarts()).removeElement(dart);
  }

  public void insertDart(Face face, int pos, Dart dart) {
    ListSequence.<Dart>fromList(face.getDarts()).insertElement(pos, dart);
    adjustDart(dart, face);
  }

  public void addFirstDart(Face face, Dart dart) {
    insertDart(face, 0, dart);
  }

  public void addLastDart(Face face, Dart dart) {
    insertDart(face, ListSequence.<Dart>fromList(face.getDarts()).count(), dart);
  }

  public List<Face> getFaces() {
    return this.myFaces;
  }

  public List<Face> getAdjacentFaces(Edge edge) {
    List<Face> faces = ListSequence.<Face>fromList(new ArrayList<Face>());
    ListSequence.<Face>fromList(faces).addSequence(ListSequence.<Dart>fromList(getDarts(edge)).<Face>select(new ISelector<Dart, Face>() {
      public Face select(Dart dart) {
        return getFace(dart);
      }
    }));
    if (ListSequence.<Face>fromList(faces).count() == 0) {
      return null;
    }
    return faces;
  }

  public Set<Edge> getEdges() {
    return MapSequence.fromMap(myEdgeDarts).keySet();
  }

  public List<Dart> getDarts(Edge edge) {
    return MapSequence.<Edge,List<Dart>>fromMap(myEdgeDarts).get(edge);
  }

  public Dart getOpposite(final Dart dart) {
    return ListSequence.<Dart>fromList(getDarts(dart.getEdge())).findFirst(new IWhereFilter<Dart>() {
      public boolean accept(Dart it) {
        return it != dart;
      }
    });
  }

  public Face getFace(Dart dart) {
    return MapSequence.<Dart,Face>fromMap(myDartsToFacesMap).get(dart);
  }

  public List<Dart> getDartWithSource(final Node node) {
    List<Dart> darts = ListSequence.<Dart>fromList(new ArrayList<Dart>());
    for (Edge edge : ListSequence.<Edge>fromList(node.getEdges())) {
      List<Dart> edgeDarts = getDarts(edge);
      if (edgeDarts != null) {
        ListSequence.<Dart>fromList(darts).addElement(ListSequence.<Dart>fromList(edgeDarts).findFirst(new IWhereFilter<Dart>() {
          public boolean accept(Dart dart) {
            return dart.getSource() == node;
          }
        }));
      }
    }
    return darts;
  }

  public Dart getNextSourceDart(Dart dart) {
    Face face = getFace(dart);
    Dart next = null;
    // here is a hack!!! in the bad case node is cutpoint of graph and condition below stands for many darts 
    int num = 0;
    for (Dart sourceDart : ListSequence.<Dart>fromList(getDartWithSource(dart.getSource()))) {
      if (getFace(getOpposite(sourceDart)) == face) {
        next = sourceDart;
        num++;
      }
    }
    if (num > 1) {
      // bad case :( 
      face.makeStartsWith(dart);
      next = getOpposite(ListSequence.<Dart>fromList(face.getDarts()).last());
    }
    return next;
  }

  public List<Dart> getOrderedDarts(Node node) {
    List<Dart> darts = getDartWithSource(node);
    List<Dart> sortedDarts = ListSequence.<Dart>fromList(new LinkedList<Dart>());
    Dart curDart = ListSequence.<Dart>fromList(darts).first();
    while (ListSequence.<Dart>fromList(sortedDarts).count() != ListSequence.<Dart>fromList(darts).count()) {
      ListSequence.<Dart>fromList(sortedDarts).addElement(curDart);
      curDart = getNextSourceDart(curDart);
    }
    return sortedDarts;
  }

  public Graph getGraph() {
    return this.myGraph;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    for (Face face : ListSequence.<Face>fromList(myFaces)) {
      builder.append(face + "\n");
    }
    builder.append("outer face has num: " + ListSequence.<Face>fromList(myFaces).indexOf(myOuterFace));
    return builder.toString();
  }

  public Face getOuterFace() {
    return this.myOuterFace;
  }

  public void setOuterFace(Face outerFace) {
    this.myOuterFace = outerFace;
  }

  public boolean isOuterFace(Face face) {
    return face == myOuterFace;
  }

  public void removeEdge(Edge edge) {
    List<Dart> edgeDarts = getDarts(edge);
    Dart first = ListSequence.<Dart>fromList(edgeDarts).first();
    Face face = getFace(first);
    face.makeStartsWith(first);
    removeDart(face, first);
    Dart last = ListSequence.<Dart>fromList(edgeDarts).last();
    Face toRemove = getFace(last);
    if (isOuterFace(toRemove)) {
      setOuterFace(face);
    }
    removeFace(toRemove);
    List<Dart> darts = toRemove.makeStartsWith(last);
    for (Dart dart : ListSequence.<Dart>fromList(darts)) {
      if (dart == last) {
        continue;
      }
      addLastDart(face, dart);
    }
  }

  public boolean isEmpty() {
    return ListSequence.<Face>fromList(getFaces()).count() == 0;
  }
}
