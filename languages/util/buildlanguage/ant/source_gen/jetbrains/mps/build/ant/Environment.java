package jetbrains.mps.build.ant;

/*Generated by MPS */

import jetbrains.mps.build.ant.util.SetLibraryContributor;
import jetbrains.mps.project.PathMacrosProvider;
import jetbrains.mps.logging.ILoggingHandler;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Logger;
import jetbrains.mps.MPSCore;
import jetbrains.mps.generator.GenerationSettingsProvider;
import jetbrains.mps.generator.DefaultModifiableGenerationSettings;
import jetbrains.mps.project.PathMacros;
import jetbrains.mps.library.LibraryInitializer;
import javax.swing.SwingUtilities;
import jetbrains.mps.project.Project;
import java.io.File;
import jetbrains.mps.util.FileUtil;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.build.ant.util.PathUtil;
import jetbrains.mps.build.ant.util.MapPathMacrosProvider;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.build.ant.util.PathManager;
import jetbrains.mps.smodel.ModelAccess;
import org.apache.log4j.Level;

public class Environment {
  private WhatToDo myWhatToDo;
  private SetLibraryContributor myLibraryContibutor;
  private PathMacrosProvider myMacroProvider;
  private ILoggingHandler myMessageHandler;

  public Environment() {
  }

  public void init(WhatToDo whatToDo, ILoggingHandler lh) {
    this.myWhatToDo = whatToDo;
    this.myMessageHandler = lh;
  }

  public void setup() {
    BasicConfigurator.configure(new ConsoleAppender());
    Logger.getRootLogger().setLevel(getLog4jLevel());
    jetbrains.mps.logging.Logger.addLoggingHandler(myMessageHandler);
    MpsPlatform.init();
    MPSCore.getInstance().setTestMode();
    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());
    try {
      configureMPS(false);
    } catch (Exception ex) {
      throw new RuntimeException(ex);
    }
    setMacro();
    loadLibraries();
  }

  public void dispose() {
    if (myMacroProvider != null) {
      PathMacros.getInstance().removeMacrosProvider(myMacroProvider);
      this.myMacroProvider = null;
    }
    if (myLibraryContibutor != null) {
      LibraryInitializer.getInstance().removeContributor(myLibraryContibutor);
      this.myLibraryContibutor = null;
    }
    for (int i = 0; i < 3; i++) {
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
          }
        });
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    MpsPlatform.dispose();
    jetbrains.mps.logging.Logger.removeLoggingHandler(myMessageHandler);
  }

  public Project createDummyProject() {
    File projectFile = FileUtil.createTmpFile();
    FileMPSProject project = new FileMPSProject(projectFile);
    project.init(new FileMPSProject.ProjectDescriptor(null));
    projectFile.deleteOnExit();
    return project;
  }

  public Project loadProject(File projectFile) {
    FileMPSProject project = new FileMPSProject(projectFile);
    project.init(new FileMPSProject.ProjectDescriptor(projectFile));
    return project;
  }

  protected void setMacro() {
    Map<String, String> macro = myWhatToDo.getMacro();
    Map<String, String> realMacros = new HashMap<String, String>();
    for (String macroName : macro.keySet()) {
      String canonicalPath = PathUtil.getCanonicalPath(macro.get(macroName));
      File file = new File(canonicalPath);
      if (file.exists() && file.isDirectory()) {
        realMacros.put(macroName, canonicalPath);
      }
    }
    if (myMacroProvider == null) {
      this.myMacroProvider = new MapPathMacrosProvider(realMacros);
      PathMacros.getInstance().addMacrosProvider(myMacroProvider);
    }
  }

  protected void loadLibraries() {
    if (myLibraryContibutor == null) {
      Set<String> libraryPaths = new HashSet<String>();
      libraryPaths.addAll(PathManager.getBootstrapPaths());
      libraryPaths.add(PathManager.getLanguagesPath());
      for (String libName : myWhatToDo.getLibraries().keySet()) {
        libraryPaths.add(myWhatToDo.getLibraries().get(libName).getAbsolutePath());
      }
      this.myLibraryContibutor = new SetLibraryContributor(libraryPaths);
      LibraryInitializer.getInstance().addContributor(myLibraryContibutor);
    }
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        LibraryInitializer.getInstance().update();
      }
    });
  }

  protected void configureMPS(boolean loadIdeaPlugins) {
    String mpsInternal = System.getProperty("mps.internal");
    System.setProperty("idea.is.internal", (mpsInternal == null ?
      "false" :
      mpsInternal
    ));
    System.setProperty("idea.no.jre.check", "true");
    if (!(loadIdeaPlugins)) {
      System.setProperty("idea.load.plugins", "false");
    }
    System.setProperty("idea.platform.prefix", "Idea");
    StringBuffer pluginPath = new StringBuffer();
    File pluginDir = new File(PathManager.getPreinstalledPluginsPath());
    for (File pluginFolder : pluginDir.listFiles()) {
      if (pluginPath.length() > 0) {
        pluginPath.append(File.pathSeparator);
      }
      pluginPath.append(pluginFolder.getPath());
    }
    System.setProperty("plugin.path", pluginPath.toString());
  }

  private Level getLog4jLevel() {
    //  still warn, info only for messages from this task 
    //  now we have info 
    switch (myWhatToDo.getLogLevel()) {
      case org.apache.tools.ant.Project.MSG_ERR:
        return Level.ERROR;
      case org.apache.tools.ant.Project.MSG_WARN:
        return Level.WARN;
      case org.apache.tools.ant.Project.MSG_INFO:
        return Level.WARN;
      case org.apache.tools.ant.Project.MSG_VERBOSE:
        return Level.INFO;
      case org.apache.tools.ant.Project.MSG_DEBUG:
        return Level.DEBUG;
      default:
        return null;
    }
  }
}
