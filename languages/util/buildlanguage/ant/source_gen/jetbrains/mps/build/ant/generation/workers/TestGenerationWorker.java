package jetbrains.mps.build.ant.generation.workers;

/*Generated by MPS */

import jetbrains.mps.build.ant.MpsWorker;
import jetbrains.mps.build.ant.IBuildServerMessageFormat;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.build.ant.WhatToDo;
import java.io.File;
import java.io.IOException;
import jetbrains.mps.project.Project;
import jetbrains.mps.build.ant.generation.GenerateTask;
import jetbrains.mps.ide.generator.GenerationSettings;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.make.script.IScriptController;
import jetbrains.mps.make.script.IConfigMonitor;
import jetbrains.mps.make.script.IJobMonitor;
import jetbrains.mps.make.script.IProgress;
import jetbrains.mps.make.script.IFeedback;
import jetbrains.mps.make.script.IPropertiesPool;
import jetbrains.mps.make.facet.ITarget;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.vfs.IFile;
import java.util.Set;
import jetbrains.mps.build.ant.generation.unittest.UnitTestListener;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.script.ScriptBuilder;
import jetbrains.mps.make.facet.IFacet;
import java.util.concurrent.ExecutionException;
import java.util.List;
import jetbrains.mps.project.MPSExtentions;
import java.lang.reflect.Method;
import jetbrains.mps.project.MPSProject;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.project.StandaloneMPSProject;
import jetbrains.mps.project.structure.project.testconfigurations.BaseTestConfiguration;
import jetbrains.mps.project.structure.project.testconfigurations.IllegalGeneratorConfigurationException;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.resources.ModelsToResources;
import jetbrains.mps.build.ant.generation.TestGenerationOnTeamcity;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.build.ant.TeamCityMessageFormat;
import jetbrains.mps.build.ant.generation.ConsoleMessageFormat;
import org.apache.tools.ant.BuildException;
import jetbrains.mps.messages.IMessageHandler;
import jetbrains.mps.messages.IMessage;
import jetbrains.mps.build.ant.generation.unittest.UnitTestAdapter;
import jetbrains.mps.build.ant.generation.unittest.ITestReporter;
import jetbrains.mps.build.ant.generation.unittest.XmlTestReporter;
import jetbrains.mps.build.ant.generation.unittest.ConsoleTestReporter;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;

public class TestGenerationWorker extends MpsWorker {
  private final TestGenerationWorker.MyMessageHandler myMessageHandler = new TestGenerationWorker.MyMessageHandler();
  private boolean myTestFailed = false;
  private IBuildServerMessageFormat myBuildServerMessageFormat;
  private Map<String, String> path2tmp = MapSequence.fromMap(new HashMap<String, String>());
  private String tmpPath;
  private TestGenerationWorker.MyReporter myReporter = new TestGenerationWorker.MyReporter();

  public TestGenerationWorker(WhatToDo whatToDo, MpsWorker.AntLogger logger) {
    super(whatToDo, logger);
    myBuildServerMessageFormat = getBuildServerMessageFormat();
    File tmpDir;
    try {
      tmpDir = File.createTempFile("gentest_", "tmp");
      tmpDir.delete();
      tmpDir.mkdir();
    } catch (IOException ex) {
      throw new RuntimeException(ex);
    }
    this.tmpPath = tmpDir.getAbsolutePath();
  }

  @Override
  protected void executeTask(final Project project, MpsWorker.ObjectsToProcess go) {
    setGenerationProperties();
    if (go.hasAnythingToGenerate()) {
      generate(project, go);
    }
  }

  private void setGenerationProperties() {
    boolean strictMode = Boolean.parseBoolean(myWhatToDo.getProperty(GenerateTask.STRICT_MODE));
    GenerationSettings.getInstance().setStrictMode(strictMode);
    if (strictMode) {
      boolean parallelMode = Boolean.parseBoolean(myWhatToDo.getProperty(GenerateTask.PARALLEL_MODE));
      GenerationSettings.getInstance().setParallelGenerator(parallelMode);
      if (parallelMode) {
        GenerationSettings.getInstance().setNumberOfParallelThreads(8);
      }
      info("Generating in strict mode, parallel generation = " + ((parallelMode ?
        "on" :
        "off"
      )));
    }
  }

  private void generate(final Project project, final MpsWorker.ObjectsToProcess go) {
    StringBuffer s = new StringBuffer("Generating:");
    for (Project p : go.getProjects()) {
      s.append("\n    ");
      s.append(p);
    }
    for (IModule m : go.getModules()) {
      s.append("\n    ");
      s.append(m);
    }
    for (SModelDescriptor m : go.getModels()) {
      s.append("\n    ");
      s.append(m);
    }
    info(s.toString());

    final _FunctionTypes._void_P1_E0<? super String> startTestFormat = new _FunctionTypes._void_P1_E0<String>() {
      public void invoke(String msg) {
        myReporter.testStarted(StringUtils.trim(msg));
      }
    };
    final _FunctionTypes._void_P1_E0<? super String> finishTestFormat = new _FunctionTypes._void_P1_E0<String>() {
      public void invoke(String msg) {
        myReporter.testFinished(StringUtils.trim(msg));
      }
    };
    final int[] count = new int[]{1};

    final IScriptController ctl = new IScriptController.Stub(new IConfigMonitor.Stub(), new IJobMonitor.Stub(new IProgress.Stub() {
      @Override
      public void beginWork(String name, int estimate, int ofTotal) {
        reportIfStartsWith("Generating ", name, startTestFormat);
      }

      @Override
      public void finishWork(String name) {
        reportIfStartsWith("Generating ", name, finishTestFormat);
      }

      @Override
      public void advanceWork(String name, int done, String comment) {
        if (comment != null) {
          _FunctionTypes._void_P1_E0<? super String> format = startTestFormat;
          if (done > 1) {
            format = finishTestFormat;
          }
          reportIfStartsWith("Diffing ", name + " " + comment, format);
        }
      }
    }) {
      @Override
      public void reportFeedback(IFeedback fdbk) {
        if (fdbk.getSeverity() == IFeedback.Severity.ERROR) {
          String test = myReporter.getCurrentTestName();
          if (test == null) {
            test = "unknown";
          }
          Throwable thr = fdbk.getException();
          String msg = fdbk.getMessage();
          String details = (thr == null ?
            "(no details)" :
            String.valueOf(MpsWorker.extractStackTrace(thr))
          );
          int eol = msg.indexOf("\n");
          if (eol >= 0) {
            details = msg.substring(eol + 1) + "\n" + details;
            msg = msg.substring(0, eol);
          }
          myReporter.testFailed(test, msg, details);
        }
      }
    }) {
      @Override
      public void setup(IPropertiesPool ppool, Iterable<ITarget> toExecute, Iterable<? extends IResource> input) {
        super.setup(ppool, toExecute, input);
        Tuples._1<_FunctionTypes._return_P1_E0<? extends IFile, ? super String>> makeparams = (Tuples._1<_FunctionTypes._return_P1_E0<? extends IFile, ? super String>>) ppool.properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"), Object.class);
        makeparams._0(new _FunctionTypes._return_P1_E0<IFile, String>() {
          public IFile invoke(String path) {
            return tmpFile(path);
          }
        });

        Tuples._1<Boolean> tparams = (Tuples._1<Boolean>) ppool.properties(new ITarget.Name("jetbrains.mps.lang.core.TextGen.textGen"), Object.class);
        if (tparams != null) {
          tparams._0(false);
        }

        Tuples._2<_FunctionTypes._return_P1_E0<? extends String, ? super IFile>, Set<File>> dparams = (Tuples._2<_FunctionTypes._return_P1_E0<? extends String, ? super IFile>, Set<File>>) ppool.properties(new ITarget.Name("jetbrains.mps.build.gentest.Diff.diff"), Object.class);
        if (dparams != null && isShowDiff()) {
          dparams._0(new _FunctionTypes._return_P1_E0<String, IFile>() {
            public String invoke(IFile f) {
              return pathOfTmpFile(f);
            }
          });
          dparams._1(myWhatToDo.getExcludedFromDiffFiles());
        }

        if (isInvokeTestsSet()) {
          Tuples._1<UnitTestListener> testParams = (Tuples._1<UnitTestListener>) ppool.properties(new ITarget.Name("jetbrains.mps.build.gentest.Test.runTests"), Object.class);
          testParams._0(new TestGenerationWorker.MyUnitTestAdapter());
        }
        myReporter.finishRun();
        myReporter.startRun("Module cluster " + String.valueOf(count[0]++));
      }
    };
    final Wrappers._T<IResult> result = new Wrappers._T<IResult>();
    ModelAccess.instance().flushEventQueue();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        IOperationContext context = new ProjectOperationContext(project);
        try {
          BuildMakeService bms = new BuildMakeService();
          MakeSession ms = new MakeSession(context, myMessageHandler, true) {
            @Override
            public IScript toScript(ScriptBuilder scriptBuilder) {
              if (isInvokeTestsSet()) {
                scriptBuilder.withFacetName(new IFacet.Name("jetbrains.mps.build.gentest.Test"));
              }
              if (isShowDiff()) {
                scriptBuilder.withFacetName(new IFacet.Name("jetbrains.mps.build.gentest.Diff"));
              }
              return scriptBuilder.toScript();
            }
          };
          result.value = bms.make(ms, collectResources(context, go.getProjects(), go.getModules(), go.getModels()), null, ctl).get();
        } catch (InterruptedException ignore) {
        } catch (ExecutionException ignore) {
        }
      }
    });
    ModelAccess.instance().flushEventQueue();
  }

  private void reportIfStartsWith(String prefix, String work, _FunctionTypes._void_P1_E0<? super String> format) {
    if (work != null && work.startsWith(prefix)) {
      format.invoke(work.substring(prefix.length()) + ".Test." + StringUtils.trim(prefix));
    }
  }

  public void work() {
    setupEnvironment();
    myReporter.init();
    //  for each project 
    Map<File, List<String>> mpsProjects = myWhatToDo.getMPSProjectFiles();
    for (File file : mpsProjects.keySet()) {
      if (!(file.getName().endsWith(MPSExtentions.DOT_MPS_PROJECT))) {
        continue;
      }
      Project p;
      try {
        Class<?> cls = Class.forName("jetbrains.mps.TestMain");
        Method meth = cls.getMethod("loadProject", File.class);
        p = (MPSProject) meth.invoke(null, file);
      } catch (Exception ex) {
        throw new RuntimeException(ex);
      }
      info("Loaded project " + p);
      executeTask(p, new MpsWorker.ObjectsToProcess(Collections.singleton(p), new HashSet<IModule>(), new HashSet<SModelDescriptor>()));
      disposeProject(p);
      dispose();
    }

    // the rest -- using dummy project 
    LinkedHashSet<IModule> modules = new LinkedHashSet<IModule>();
    LinkedHashSet<SModelDescriptor> models = new LinkedHashSet<SModelDescriptor>();
    collectFromModuleFiles(modules);
    collectFromModelFiles(models);
    MpsWorker.ObjectsToProcess go = new MpsWorker.ObjectsToProcess(Collections.EMPTY_SET, modules, models);
    if (go.hasAnythingToGenerate()) {
      Project project = createDummyProject();
      executeTask(project, go);
    } else {
      error("Could not find anything to generate.");
      myTestFailed = true;
    }

    myReporter.finishRun();
    cleanUp();
    dispose();
    showStatistic();
  }

  private void cleanUp() {
    for (Queue<File> dirs = QueueSequence.fromQueueAndArray(new LinkedList<File>(), new File(tmpPath)); QueueSequence.fromQueue(dirs).isNotEmpty();) {
      File dir = QueueSequence.fromQueue(dirs).removeFirstElement();
      dir.deleteOnExit();
      for (File f : dir.listFiles()) {
        if (f.isDirectory()) {
          QueueSequence.fromQueue(dirs).addLastElement(f);
        } else {
          f.deleteOnExit();
        }
      }
    }
    this.tmpPath = null;
    MapSequence.fromMap(path2tmp).clear();
  }

  private Iterable<IResource> collectResources(IOperationContext context, final Iterable<Project> projects, Iterable<IModule> modules, final Iterable<SModelDescriptor> models) {
    final Wrappers._T<Iterable<IModule>> _modules = new Wrappers._T<Iterable<IModule>>(modules);
    final Wrappers._T<Iterable<SModelDescriptor>> result = new Wrappers._T<Iterable<SModelDescriptor>>(null);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        for (Project prj : projects) {
          if (isWholeProject(prj)) {
            _modules.value = Sequence.fromIterable(_modules.value).concat(ListSequence.fromList(prj.getModules()));
          } else
          if (!(((StandaloneMPSProject) prj).getProjectDescriptor().getTestConfigurations().isEmpty())) {
            for (BaseTestConfiguration tconf : ((StandaloneMPSProject) prj).getProjectDescriptor().getTestConfigurations()) {
              try {
                result.value = Sequence.fromIterable(result.value).concat(ListSequence.fromList(tconf.getGenParams(prj, true).getModelDescriptors()));
              } catch (IllegalGeneratorConfigurationException e) {
                log("Error while reading configuration of project " + prj.getName(), e);
              }
            }
          } else {
            warning("No test configurations for project " + prj.getName());
          }
        }
        result.value = Sequence.fromIterable(result.value).concat(Sequence.fromIterable(_modules.value).translate(new ITranslator2<IModule, SModelDescriptor>() {
          public Iterable<SModelDescriptor> translate(IModule m) {
            return m.getOwnModelDescriptors();
          }
        }));
        result.value = Sequence.fromIterable(result.value).concat(Sequence.fromIterable(_modules.value).where(new IWhereFilter<IModule>() {
          public boolean accept(IModule it) {
            return it instanceof Language;
          }
        }).translate(new ITranslator2<IModule, IModule>() {
          public Iterable<IModule> translate(IModule it) {
            return Collections.<IModule>unmodifiableList(((Language) it).getGenerators());
          }
        }).translate(new ITranslator2<IModule, SModelDescriptor>() {
          public Iterable<SModelDescriptor> translate(IModule gen) {
            return gen.getOwnModelDescriptors();
          }
        }));
        result.value = Sequence.fromIterable(result.value).concat(Sequence.fromIterable(models));
      }
    });
    return new ModelsToResources(context, Sequence.fromIterable(result.value).where(new IWhereFilter<SModelDescriptor>() {
      public boolean accept(SModelDescriptor smd) {
        return smd.isGeneratable();
      }
    })).resources(false);
  }

  private boolean isWholeProject(Project prj) {
    return Sequence.fromIterable(((Iterable<String>) myWhatToDo.getMPSProjectFiles().get(prj.getProjectFile()))).contains(TestGenerationOnTeamcity.WHOLE_PROJECT);
  }

  private IFile tmpFile(String path) {
    if (MapSequence.fromMap(path2tmp).containsKey(path)) {
      return FileSystem.getInstance().getFileByPath(MapSequence.fromMap(path2tmp).get(path));
    }
    int idx = path.indexOf("/");
    if (idx > 0) {
      throw new IllegalArgumentException("not an absolute path '" + path + "'");
    }
    idx = (idx < 0 ?
      path.indexOf(File.separator) :
      idx
    );
    if (idx > "C:\\".length() && path.indexOf(":") < 0) {
      throw new IllegalArgumentException("not an absolute path '" + path + "'");
    }
    String tmp = tmpPath + "/" + ((idx != 0 ?
      path.replace(":", "_w_") :
      path.substring(1)
    ));
    MapSequence.fromMap(path2tmp).put(path, tmp);
    return FileSystem.getInstance().getFileByPath(tmp);
  }

  private String pathOfTmpFile(IFile file) {
    String p = file.getPath();
    if (!(p.startsWith(tmpPath))) {
      throw new IllegalArgumentException("unknown tmp path '" + file.getParent() + "'");
    }
    p = p.substring(tmpPath.length() + 1);
    if (p.contains("_w_")) {
      return FileSystem.getInstance().getFileByPath(p.replace("_w_", ":")).getPath();
    }
    String prefix = (File.separatorChar == '/' ?
      "/" :
      "\\\\"
    );
    return FileSystem.getInstance().getFileByPath(prefix + p).getPath();
  }

  public IBuildServerMessageFormat getBuildServerMessageFormat() {
    if (isRunningOnTeamCity()) {
      return new TeamCityMessageFormat();
    } else {
      return new ConsoleMessageFormat();
    }
  }

  private boolean isRunningOnTeamCity() {
    return myWhatToDo.getProperty("teamcity.version") != null;
  }

  private String[] getPerfomanceReportDestinations() {
    String reportType = myWhatToDo.getProperty(TestGenerationOnTeamcity.GENERATE_PERFORMANCE_REPORT);
    if (reportType == null || reportType.isEmpty()) {
      return new String[]{};
    }
    String[] reports = reportType.split(",+");
    return reports;
  }

  private boolean isSaveGeneratedFilesOnDisk() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(TestGenerationOnTeamcity.SAVE_ON_DISK));
  }

  private boolean isInvokeTestsSet() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(TestGenerationOnTeamcity.INVOKE_TESTS)) && isCompileSet();
  }

  private boolean isCompileSet() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(GenerateTask.COMPILE));
  }

  private boolean isShowDiff() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(TestGenerationOnTeamcity.SHOW_DIFF));
  }

  @Override
  protected void showStatistic() {
    if (myTestFailed && myWhatToDo.getFailOnError()) {
      throw new BuildException("Tests Failed");
    }
  }

  public static void main(String[] args) {
    TestGenerationWorker generator = new TestGenerationWorker(WhatToDo.fromDumpInFile(new File(args[0])), new MpsWorker.SystemOutLogger());
    generator.workFromMain();
  }

  private class MyMessageHandler implements IMessageHandler {
    public MyMessageHandler() {
    }

    public void handle(IMessage msg) {
      switch (msg.getKind()) {
        case ERROR:
          TestGenerationWorker.this.error(msg.getText());
          myReporter.errorLine("[ERROR] " + msg.getText());
          break;
        case WARNING:
          TestGenerationWorker.this.warning(msg.getText());
          myReporter.outputLine("[WARNING]" + msg.getText());
          break;
        case INFORMATION:
          TestGenerationWorker.this.verbose(msg.getText());
          myReporter.outputLine("[INFO]" + msg.getText());
          break;
        default:
      }
    }

    public void clear() {
    }
  }

  private class MyUnitTestAdapter extends UnitTestAdapter {
    private MyUnitTestAdapter() {
    }

    @Override
    public void testStarted(String testName) {
      myReporter.testStarted(testName);
    }

    @Override
    public void testFailed(String test, String message, String details) {
      myReporter.testFailed(test, message, details);
      myTestFailed = true;
    }

    @Override
    public void testFinished(String testName) {
      myReporter.testFinished(testName);
    }

    @Override
    public void logMessage(String message) {
      if (message != null && !(message.isEmpty())) {
        info(message);
        myReporter.outputLine(message);
      }
    }

    @Override
    public void logError(String errorMessage) {
      if (errorMessage != null && !(errorMessage.isEmpty())) {
        error(errorMessage);
        myReporter.errorLine(errorMessage);
      }
    }
  }

  private class MyReporter {
    private ITestReporter testReporter;
    private String currentTestName;
    private File gentestdir;

    private MyReporter() {
    }

    private void init() {
      if (gentestdir != null) {
        return;
      }
      if (isRunningOnTeamCity()) {
        String wd = myWhatToDo.getProperty("mps.gentest.reportsDir");
        wd = (wd == null ?
          System.getProperty("user.dir") :
          wd
        );
        gentestdir = new File(wd, ".gentest");
        if (!(gentestdir.exists())) {
          if (!(gentestdir.mkdirs())) {
            File tmpDir;
            try {
              tmpDir = File.createTempFile("gentest", "reports");
              tmpDir.delete();
              tmpDir.mkdir();
            } catch (IOException ex) {
              throw new RuntimeException(ex);
            }
            gentestdir = tmpDir;
          }
        } else if (gentestdir.isDirectory()) {
          for (File f : gentestdir.listFiles()) {
            f.delete();
          }
        }
      }
    }

    private String getCurrentTestName() {
      return currentTestName;
    }

    private void startRun(String name) {
      this.testReporter = (isRunningOnTeamCity() ?
        new XmlTestReporter(name) :
        new ConsoleTestReporter()
      );
    }

    private void finishRun() {
      if (testReporter == null) {
        return;
      }
      if (currentTestName != null) {
        testReporter.testFinished(currentTestName);
      }
      testReporter.runFinished();
      if (isRunningOnTeamCity()) {
        BufferedOutputStream os = null;
        try {
          File reportFile = File.createTempFile("gentest_report-", ".xml", gentestdir);
          os = new BufferedOutputStream(new FileOutputStream(reportFile));
          ((XmlTestReporter) testReporter).dump(os);
          System.out.println("##teamcity[importData type='junit' path='" + reportFile.getAbsolutePath() + "']");
        } catch (IOException ex) {
        } finally {
          if (os != null) {
            try {
              os.close();
            } catch (IOException ignore) {
            }
          }
        }
      }
      this.testReporter = null;
    }

    private void testStarted(String testname) {
      if (currentTestName != null) {
        testReporter.testFinished(currentTestName);
      }
      this.currentTestName = testname;
      testReporter.testStarted(testname);
    }

    private void testFinished(String testname) {
      testReporter.testFinished(testname);
      this.currentTestName = null;
    }

    private void testFailed(String testname, String msg, String longmsg) {
      testReporter.testFailed(testname, msg, longmsg);
    }

    private void outputLine(String out) {
      if (currentTestName != null) {
        testReporter.testOutputLine(currentTestName, out);
      } else {
        testReporter.outputLine(out);
      }
    }

    private void errorLine(String err) {
      if (currentTestName != null) {
        testReporter.testErrorLine(currentTestName, err);
      } else {
        testReporter.errorLine(err);
      }
    }
  }
}
