package jetbrains.mps.build.ant.generation.workers;

/*Generated by MPS */

import jetbrains.mps.build.ant.MpsWorker;
import jetbrains.mps.build.ant.IBuildServerMessageFormat;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.build.ant.WhatToDo;
import java.io.File;
import java.io.IOException;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.build.ant.generation.GenerateTask;
import jetbrains.mps.ide.generator.GenerationSettings;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.make.script.IScriptController;
import jetbrains.mps.make.script.IConfigMonitor;
import jetbrains.mps.make.script.IJobMonitor;
import jetbrains.mps.make.script.IProgress;
import jetbrains.mps.make.script.IFeedback;
import jetbrains.mps.make.script.IPropertiesPool;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.make.facet.ITarget;
import java.util.Set;
import jetbrains.mps.build.ant.generation.unittest.UnitTestListener;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.script.ScriptBuilder;
import jetbrains.mps.make.facet.IFacet;
import java.util.concurrent.ExecutionException;
import java.util.List;
import jetbrains.mps.project.MPSExtentions;
import java.lang.reflect.Method;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.project.structure.project.testconfigurations.BaseTestConfiguration;
import jetbrains.mps.project.structure.project.testconfigurations.IllegalGeneratorConfigurationException;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.resources.ModelsToResources;
import jetbrains.mps.build.ant.generation.TestGenerationOnTeamcity;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.build.ant.TeamCityMessageFormat;
import jetbrains.mps.build.ant.generation.ConsoleMessageFormat;
import org.apache.tools.ant.BuildException;
import jetbrains.mps.messages.IMessageHandler;
import java.util.ArrayList;
import jetbrains.mps.messages.IMessage;
import jetbrains.mps.build.ant.generation.unittest.UnitTestAdapter;

public class TestGenerationWorker extends MpsWorker {
  private final TestGenerationWorker.MyMessageHandler myMessageHandler = new TestGenerationWorker.MyMessageHandler();
  private boolean myTestFailed = false;
  private IBuildServerMessageFormat myBuildServerMessageFormat;
  private Map<String, String> path2tmp = MapSequence.fromMap(new HashMap<String, String>());
  private String tmpPath;

  public TestGenerationWorker(WhatToDo whatToDo, MpsWorker.AntLogger logger) {
    super(whatToDo, logger);
    myBuildServerMessageFormat = getBuildServerMessageFormat();
    File tmpDir;
    try {
      tmpDir = File.createTempFile("gentest_", "tmp");
      tmpDir.delete();
      tmpDir.mkdir();
    } catch (IOException ex) {
      throw new RuntimeException(ex);
    }
    this.tmpPath = tmpDir.getAbsolutePath();
  }

  protected void executeTask(final MPSProject project, MpsWorker.ObjectsToProcess go) {
    setGenerationProperties();
    if (go.hasAnythingToGenerate()) {
      generate(project, go);
    }
  }

  private void setGenerationProperties() {
    if (myWhatToDo.getProperty(GenerateTask.PER_ROOT_GENERATION) != null) {
      boolean perRootGeneration = Boolean.parseBoolean(myWhatToDo.getProperty(GenerateTask.PER_ROOT_GENERATION));
      GenerationSettings.getInstance().setParallelGenerator(perRootGeneration);
      GenerationSettings.getInstance().setStrictMode(perRootGeneration);
      if (perRootGeneration) {
        GenerationSettings.getInstance().setNumberOfParallelThreads(8);
      }
      info("Per-root generation set to " + perRootGeneration);
    }
  }

  private void generate(final MPSProject project, final MpsWorker.ObjectsToProcess go) {
    StringBuffer s = new StringBuffer("Generating:");
    for (MPSProject p : go.getProjects()) {
      s.append("\n    ");
      s.append(p);
    }
    for (IModule m : go.getModules()) {
      s.append("\n    ");
      s.append(m);
    }
    for (SModelDescriptor m : go.getModels()) {
      s.append("\n    ");
      s.append(m);
    }
    info(s.toString());

    final String[] currentTestName = new String[1];
    final _FunctionTypes._void_P1_E0<? super String> startTestFormat = new _FunctionTypes._void_P1_E0<String>() {
      public void invoke(String msg) {
        currentTestName[0] = myBuildServerMessageFormat.escapeBuildMessage(new StringBuffer(msg)).toString();
        System.out.println(myBuildServerMessageFormat.formatTestStart(currentTestName[0]));
      }
    };
    final _FunctionTypes._void_P1_E0<? super String> finishTestFormat = new _FunctionTypes._void_P1_E0<String>() {
      public void invoke(String msg) {
        System.out.println(myBuildServerMessageFormat.formatTestFinish(myBuildServerMessageFormat.escapeBuildMessage(new StringBuffer(msg)).toString()));
        currentTestName[0] = null;
      }
    };

    final IScriptController ctl = new IScriptController.Stub(new IConfigMonitor.Stub(), new IJobMonitor.Stub(new IProgress.Stub() {
      @Override
      public void beginWork(String name, int estimate, int ofTotal) {
        reportIfStartsWith("Generating ", name, startTestFormat);
      }

      @Override
      public void finishWork(String name) {
        reportIfStartsWith("Generating ", name, finishTestFormat);
      }

      @Override
      public void advanceWork(String name, int done, String comment) {
        if (comment != null) {
          _FunctionTypes._void_P1_E0<? super String> format = startTestFormat;
          if (done > 1) {
            format = finishTestFormat;
          }
          reportIfStartsWith("Diffing", name + " " + comment, format);
        }
      }
    }) {
      @Override
      public void reportFeedback(IFeedback fdbk) {
        if (fdbk.getSeverity() == IFeedback.Severity.ERROR) {
          String test = currentTestName[0];
          if (test == null) {
            test = "unknown";
          }
          System.out.println(myBuildServerMessageFormat.formatTestFailure(test, fdbk.getMessage(), myBuildServerMessageFormat.escapeBuildMessage(new StringBuffer(String.valueOf(fdbk.getException())))));
        }
      }
    }) {
      @Override
      public void setup(IPropertiesPool ppool) {
        Tuples._1<_FunctionTypes._return_P1_E0<? extends IFile, ? super String>> makeparams = (Tuples._1<_FunctionTypes._return_P1_E0<? extends IFile, ? super String>>) ppool.properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"), Object.class);
        makeparams._0(new _FunctionTypes._return_P1_E0<IFile, String>() {
          public IFile invoke(String path) {
            return tmpFile(path);
          }
        });

        Tuples._1<Boolean> tparams = (Tuples._1<Boolean>) ppool.properties(new ITarget.Name("jetbrains.mps.lang.core.TextGen.textGen"), Object.class);
        if (tparams != null) {
          tparams._0(false);
        }

        Tuples._2<_FunctionTypes._return_P1_E0<? extends String, ? super IFile>, Set<File>> dparams = (Tuples._2<_FunctionTypes._return_P1_E0<? extends String, ? super IFile>, Set<File>>) ppool.properties(new ITarget.Name("jetbrains.mps.build.gentest.Diff.diff"), Object.class);
        if (dparams != null && isShowDiff()) {
          dparams._0(new _FunctionTypes._return_P1_E0<String, IFile>() {
            public String invoke(IFile f) {
              return pathOfTmpFile(f);
            }
          });
          dparams._1(myWhatToDo.getExcludedFromDiffFiles());
        }

        if (isInvokeTestsSet()) {
          Tuples._1<UnitTestListener> testParams = (Tuples._1<UnitTestListener>) ppool.properties(new ITarget.Name("jetbrains.mps.build.gentest.Test.runTests"), Object.class);
          testParams._0(new TestGenerationWorker.MyUnitTestAdapter());
        }
      }
    };
    final Wrappers._T<IResult> result = new Wrappers._T<IResult>();
    ModelAccess.instance().flushEventQueue();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        IOperationContext context = ProjectOperationContext.get(project.getProject());
        try {
          BuildMakeService bms = new BuildMakeService();
          MakeSession ms = new MakeSession(context, myMessageHandler, true) {
            @Override
            public IScript toScript(ScriptBuilder scriptBuilder) {
              if (isInvokeTestsSet()) {
                scriptBuilder.withFacetName(new IFacet.Name("jetbrains.mps.build.gentest.Test"));
              }
              if (isShowDiff()) {
                scriptBuilder.withFacetName(new IFacet.Name("jetbrains.mps.build.gentest.Diff"));
              }
              return scriptBuilder.toScript();
            }
          };
          result.value = bms.make(ms, collectResources(context, go.getProjects(), go.getModules(), go.getModels()), null, ctl).get();
        } catch (InterruptedException ignore) {
        } catch (ExecutionException ignore) {
        }
      }
    });
    ModelAccess.instance().flushEventQueue();
  }

  private void reportIfStartsWith(String prefix, String work, _FunctionTypes._void_P1_E0<? super String> format) {
    if (work != null && work.startsWith(prefix)) {
      format.invoke(work);
    }
  }

  public void work() {
    setupEnvironment();
    //  for each project 
    Map<File, List<String>> mpsProjects = myWhatToDo.getMPSProjectFiles();
    for (File file : mpsProjects.keySet()) {
      if (!(file.getName().endsWith(MPSExtentions.DOT_MPS_PROJECT))) {
        continue;
      }
      MPSProject p;
      try {
        Class<?> cls = Class.forName("jetbrains.mps.TestMain");
        Method meth = cls.getMethod("loadProject", File.class);
        p = (MPSProject) meth.invoke(null, file);
      } catch (Exception ex) {
        throw new RuntimeException(ex);
      }
      info("Loaded project " + p);
      executeTask(p, new MpsWorker.ObjectsToProcess(Collections.singleton(p), new HashSet<IModule>(), new HashSet<SModelDescriptor>()));
      disposeProject(p);
      dispose();
    }

    // the rest -- using dummy project 
    LinkedHashSet<IModule> modules = new LinkedHashSet<IModule>();
    LinkedHashSet<SModelDescriptor> models = new LinkedHashSet<SModelDescriptor>();
    collectFromModuleFiles(modules);
    collectFromModelFiles(models);
    MpsWorker.ObjectsToProcess go = new MpsWorker.ObjectsToProcess(Collections.EMPTY_SET, modules, models);
    if (go.hasAnythingToGenerate()) {
      MPSProject project = createDummyProject();
      executeTask(project, go);
    } else {
      // <node> 
      // <node> 
    }

    cleanUp();
    dispose();
    showStatistic();
  }

  private void cleanUp() {
    for (Queue<File> dirs = QueueSequence.fromQueueAndArray(new LinkedList<File>(), new File(tmpPath)); QueueSequence.fromQueue(dirs).isNotEmpty();) {
      File dir = QueueSequence.fromQueue(dirs).removeFirstElement();
      dir.deleteOnExit();
      for (File f : dir.listFiles()) {
        if (f.isDirectory()) {
          QueueSequence.fromQueue(dirs).addLastElement(f);
        } else {
          f.deleteOnExit();
        }
      }
    }
    this.tmpPath = null;
    MapSequence.fromMap(path2tmp).clear();
  }

  private Iterable<IResource> collectResources(IOperationContext context, final Iterable<MPSProject> projects, Iterable<IModule> modules, final Iterable<SModelDescriptor> models) {
    final Wrappers._T<Iterable<IModule>> _modules = new Wrappers._T<Iterable<IModule>>(modules);
    final Wrappers._T<Iterable<SModelDescriptor>> result = new Wrappers._T<Iterable<SModelDescriptor>>(null);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        for (MPSProject prj : projects) {
          if (isWholeProject(prj)) {
            _modules.value = Sequence.fromIterable(_modules.value).concat(ListSequence.fromList(prj.getModules()));
          } else
          if (!(prj.getProjectDescriptor().getTestConfigurations().isEmpty())) {
            for (BaseTestConfiguration tconf : prj.getProjectDescriptor().getTestConfigurations()) {
              try {
                result.value = Sequence.fromIterable(result.value).concat(ListSequence.fromList(tconf.getGenParams(prj.getProject(), true).getModelDescriptors()));
              } catch (IllegalGeneratorConfigurationException e) {
                log("Error while reading configuration of project " + prj.getProject().getName(), e);
              }
            }
          } else {
            warning("No test configurations for project " + prj.getProjectDescriptor().getName());
          }
        }
        result.value = Sequence.fromIterable(result.value).concat(Sequence.fromIterable(_modules.value).translate(new ITranslator2<IModule, SModelDescriptor>() {
          public Iterable<SModelDescriptor> translate(IModule m) {
            return m.getOwnModelDescriptors();
          }
        }));
        result.value = Sequence.fromIterable(result.value).concat(Sequence.fromIterable(_modules.value).where(new IWhereFilter<IModule>() {
          public boolean accept(IModule it) {
            return it instanceof Language;
          }
        }).translate(new ITranslator2<IModule, IModule>() {
          public Iterable<IModule> translate(IModule it) {
            return Collections.<IModule>unmodifiableList(((Language) it).getGenerators());
          }
        }).translate(new ITranslator2<IModule, SModelDescriptor>() {
          public Iterable<SModelDescriptor> translate(IModule gen) {
            return gen.getOwnModelDescriptors();
          }
        }));
        result.value = Sequence.fromIterable(result.value).concat(Sequence.fromIterable(models));
      }
    });
    return new ModelsToResources(context, Sequence.fromIterable(result.value).where(new IWhereFilter<SModelDescriptor>() {
      public boolean accept(SModelDescriptor smd) {
        return smd.isGeneratable();
      }
    })).resources(false);
  }

  private boolean isWholeProject(MPSProject prj) {
    return Sequence.fromIterable(((Iterable<String>) myWhatToDo.getMPSProjectFiles().get(prj.getProjectFile()))).contains(TestGenerationOnTeamcity.WHOLE_PROJECT);
  }

  private IFile tmpFile(String path) {
    if (MapSequence.fromMap(path2tmp).containsKey(path)) {
      return FileSystem.getInstance().getFileByPath(MapSequence.fromMap(path2tmp).get(path));
    }
    int idx = path.indexOf("/");
    if (idx > 0) {
      throw new IllegalArgumentException("not an absolute path '" + path + "'");
    }
    idx = (idx < 0 ?
      path.indexOf(File.separator) :
      idx
    );
    if (idx > "C:\\".length() && path.indexOf(":") < 0) {
      throw new IllegalArgumentException("not an absolute path '" + path + "'");
    }
    String tmp = tmpPath + "/" + ((idx != 0 ?
      path.replace(":", "_w_") :
      path.substring(1)
    ));
    MapSequence.fromMap(path2tmp).put(path, tmp);
    return FileSystem.getInstance().getFileByPath(tmp);
  }

  private String pathOfTmpFile(IFile file) {
    String p = file.getPath();
    if (!(p.startsWith(tmpPath))) {
      throw new IllegalArgumentException("unknown tmp path '" + file.getParent() + "'");
    }
    p = p.substring(tmpPath.length() + 1);
    if (p.contains("_w_")) {
      return FileSystem.getInstance().getFileByPath(p.replace("_w_", ":")).getPath();
    }
    String prefix = (File.separatorChar == '/' ?
      "/" :
      "\\\\"
    );
    return FileSystem.getInstance().getFileByPath(prefix + p).getPath();
  }

  public IBuildServerMessageFormat getBuildServerMessageFormat() {
    if (isRunningOnTeamCity()) {
      return new TeamCityMessageFormat();
    } else {
      return new ConsoleMessageFormat();
    }
  }

  private boolean isRunningOnTeamCity() {
    return myWhatToDo.getProperty("teamcity.version") != null;
  }

  private String[] getPerfomanceReportDestinations() {
    String reportType = myWhatToDo.getProperty(TestGenerationOnTeamcity.GENERATE_PERFORMANCE_REPORT);
    if (reportType == null || reportType.isEmpty()) {
      return new String[]{};
    }
    String[] reports = reportType.split(",+");
    return reports;
  }

  private boolean isSaveGeneratedFilesOnDisk() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(TestGenerationOnTeamcity.SAVE_ON_DISK));
  }

  private boolean isInvokeTestsSet() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(TestGenerationOnTeamcity.INVOKE_TESTS)) && isCompileSet();
  }

  private boolean isCompileSet() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(GenerateTask.COMPILE));
  }

  private boolean isShowDiff() {
    return Boolean.parseBoolean(myWhatToDo.getProperty(TestGenerationOnTeamcity.SHOW_DIFF));
  }

  @Override
  protected void showStatistic() {
    if (myTestFailed && myWhatToDo.getFailOnError()) {
      throw new BuildException("Tests Failed");
    }
  }

  public static void main(String[] args) {
    TestGenerationWorker generator = new TestGenerationWorker(WhatToDo.fromDumpInFile(new File(args[0])), new MpsWorker.SystemOutLogger());
    generator.workFromMain();
  }

  private class MyMessageHandler implements IMessageHandler {
    private final List<String> myGenerationErrors = ListSequence.fromList(new ArrayList<String>());
    private final List<String> myGenerationWarnings = ListSequence.fromList(new ArrayList<String>());

    public MyMessageHandler() {
    }

    public void handle(IMessage msg) {
      switch (msg.getKind()) {
        case ERROR:
          TestGenerationWorker.this.error(msg.getText());
          if (msg.getException() != null) {
            myGenerationErrors.add(MpsWorker.extractStackTrace(msg.getException()).toString());
          } else {
            myGenerationErrors.add(msg.getText());
          }
          break;
        case WARNING:
          TestGenerationWorker.this.warning(msg.getText());
          myGenerationWarnings.add(msg.getText());
          break;
        case INFORMATION:
          TestGenerationWorker.this.verbose(msg.getText());
          break;
        default:
      }
    }

    public List<String> getGenerationErrors() {
      return myGenerationErrors;
    }

    public List<String> getGenerationWarnings() {
      return myGenerationWarnings;
    }

    public void clean() {
      myGenerationErrors.clear();
      myGenerationWarnings.clear();
    }

    public void clear() {
    }
  }

  private class MyUnitTestAdapter extends UnitTestAdapter {
    private MyUnitTestAdapter() {
    }

    @Override
    public void testStarted(String testName) {
      System.out.println(myBuildServerMessageFormat.formatTestStart(myBuildServerMessageFormat.escapeBuildMessage(testName)));
    }

    @Override
    public void testFailed(String test, String message, String details) {
      System.out.println(myBuildServerMessageFormat.formatTestFailure(myBuildServerMessageFormat.escapeBuildMessage(test), myBuildServerMessageFormat.escapeBuildMessage(message), myBuildServerMessageFormat.escapeBuildMessage(details)));
      myTestFailed = true;
    }

    @Override
    public void testFinished(String testName) {
      System.out.println(myBuildServerMessageFormat.formatTestFinish(myBuildServerMessageFormat.escapeBuildMessage(testName)));
    }

    @Override
    public void logMessage(String message) {
      if (message != null && !(message.isEmpty())) {
        info(message);
      }
    }

    @Override
    public void logError(String errorMessage) {
      if (errorMessage != null && !(errorMessage.isEmpty())) {
        error(errorMessage);
      }
    }
  }
}
