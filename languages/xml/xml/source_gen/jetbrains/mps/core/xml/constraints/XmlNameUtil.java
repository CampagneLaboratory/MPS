package jetbrains.mps.core.xml.constraints;

/*Generated by MPS */


public class XmlNameUtil {
  public XmlNameUtil() {
  }

  /**
   * Extensible Markup Language (XML) 1.0 (Fifth Edition): 2.3 Common Syntactic Constructs
   * Token "Name"
   * 
   * @param s string to test
   */
  public static boolean isName(String s) {
    int len = s.length();
    if (len == 0 || !(isNameStartChar(s.codePointAt(0)))) {
      return false;
    }
    for (int i = 1; i < len; i++) {
      if (!(isNameChar(s.codePointAt(i)))) {
        return false;
      }
    }
    return true;
  }

  /**
   * Extensible Markup Language (XML) 1.0 (Fifth Edition): 2.3 Common Syntactic Constructs
   * Token "NameStartChar"
   * 
   * @param c character to test
   */
  public static boolean isNameStartChar(int c) {
    if (c < 0xC0) {
      // ":" | [A-Z] | "_" | [a-z] 
      return c == ':' || c == '_' || c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z';
    } else if (c < 0x300) {
      // [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] 
      return c != 0xD7 && c != 0xF7;
    } else if (c < 0x2000) {
      // [#x370-#x37D] | [#x37F-#x1FFF] 
      return c >= 0x370 && c != 0x37e;
    } else if (c < 0xE000) {
      // [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] 
      return c >= 0x200c && c <= 0x200d || c >= 0x2070 && c <= 0x218f || c >= 0x2c00 && c <= 0x2fef || c >= 0x3001 && c <= 0xd7ff;
    } else {
      // [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF] 
      return c >= 0xf900 && c <= 0xfdcf || c >= 0xfdf0 && c <= 0xfffd || c >= 0x10000 && c <= 0xeffff;
    }
  }

  /**
   * Extensible Markup Language (XML) 1.0 (Fifth Edition): 2.3 Common Syntactic Constructs
   * Token "NameChar"
   * 
   * @param c character to test
   */
  public static boolean isNameChar(int c) {
    if (c < 0x100) {
      // "-" | "." | [0-9] | #xB7 
      if (c == '.' || c == '-' || c >= '0' && c <= '9' || c == 0xb7) {
        return true;
      }
    } else {
      // [#x0300-#x036F] | [#x203F-#x2040] 
      if (c >= 0x300 && c <= 0x36f || c >= 0x203f && c <= 0x2040) {
        return true;
      }
    }
    return isNameStartChar(c);
  }

  /**
   * Extensible Markup Language (XML) 1.0 (Fifth Edition): 2.6 Processing Instructions
   * Token "PITarget"
   * 
   * @param target target name to check
   */
  public static boolean isPITarget(String target) {
    if (target.length() == 3 && "xml".equals(target.toLowerCase())) {
      return false;
    }
    return isName(target);
  }

  /**
   * Extensible Markup Language (XML) 1.0 (Fifth Edition): 2.2 Characters
   * Token "Char": any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.
   * 
   * @param c character to test
   */
  public static boolean isXmlChar(int c) {
    if (c < 0xe000) {
      // #x9 | #xA | #xD | [#x20-#xD7FF] 
      return c == 0x9 || c == 0xa || c == 0xd || c >= 0x20 && c <= 0xd7ff;
    } else {
      // [#xE000-#xFFFD] | [#x10000-#x10FFFF] 
      return c <= 0xfffd || c >= 0x10000 && c <= 0x10FFFF;
    }
  }

  /**
   * Checks if all characters in a string are xml chars.
   */
  public static boolean isXmlString(String s) {
    for (int i = 0; i < s.length(); i++) {
      if (!(isXmlChar(s.codePointAt(i)))) {
        return false;
      }
    }
    return true;
  }

  /**
   * Extensible Markup Language (XML) 1.0 (Fifth Edition): 2.4 Character Data and Markup
   * Token "CharData"
   */
  public static boolean isCharData(String s) {
    // CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*) 
    if (s.indexOf('<') >= 0 || s.indexOf('&') >= 0 || s.contains("]]>")) {
      return false;
    }
    return isXmlString(s);
  }

  /**
   * Extensible Markup Language (XML) 1.0 (Fifth Edition): 2.5 Comments
   * Token "Comment": ((Char - '-') | ('-' (Char - '-')))*
   * 
   * @param text string to test
   */
  public static boolean isCommentText(String text) {
    int len = text.length();
    for (int i = 0; i < len; i++) {
      int c = text.codePointAt(i);
      if (c == '-') {
        if (i + 1 >= len || text.codePointAt(i + 1) == '-') {
          return false;
        }
      }
      if (!(isXmlChar(c))) {
        return false;
      }
    }
    return true;
  }

  /**
   * Checks if string is a valid CDATA content
   */
  public static boolean isCDATA(String content) {
    return !(content.contains("]]>")) && isXmlString(content);
  }

  public static boolean isAttValue(String text) {
    for (int i = 0; i < text.length(); i++) {
      int c = text.codePointAt(i);
      if (c == '&' || c == '"' || c == '<') {
        return false;
      }
    }
    return isXmlString(text);
  }

  /**
   * Well-formedness constraint: Entity Declared.
   * need not declare any of the following entities: amp, lt, gt, apos, quot.
   */
  public static String[] getDefaultEntities() {
    return new String[]{"amp", "gt", "lt", "apos", "quot"};
  }

  public static boolean isValidCharRef(String charRef) {
    int charCode = 0;
    if (charRef.startsWith("x")) {
      // '&#x' [0-9a-fA-F]+ 
      if (charRef.length() > 8 || charRef.length() < 2) {
        return false;
      }
      for (int i = 1; i < charRef.length(); i++) {
        int c = charRef.codePointAt(i);
        if (c >= '0' && c <= '9') {
          c = c - '0';
        } else if (c >= 'A' && c <= 'F') {
          c = c - 'A' + 10;
        } else if (c >= 'a' && c <= 'f') {
          c = c - 'a' + 10;
        } else {
          return false;
        }
        charCode = (charCode << 4) + c;
      }
    } else {
      // '&#' [0-9]+ 
      if (charRef.length() > 9 || charRef.length() < 1) {
        return false;
      }
      for (int i = 0; i < charRef.length(); i++) {
        int c = charRef.codePointAt(i);
        if (c >= '0' && c <= '9') {
          c = c - '0';
        } else {
          return false;
        }
        charCode = charCode * 10 + c;
      }
    }
    return isXmlChar(charCode);
  }
}
