package jetbrains.mps.baseLanguage.closures.helper;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.baseLanguage.closures.behavior.FunctionType_Behavior;
import java.util.Iterator;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;

public class ClosureLiteralUtil {
  public static boolean hasYieldStatement(SNode cl) {
    for (SNode desc : SNodeOperations.getDescendants(cl, "jetbrains.mps.baseLanguage.closures.structure.YieldStatement", false, new String[]{})) {
      if (cl == SNodeOperations.getAncestorWhereConceptInList(desc, new String[]{"jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral", "jetbrains.mps.baseLanguage.structure.IStatementListContainer", "jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock"}, false, false)) {
        return true;
      }
    }
    return false;
  }

  public static List<SNode> collectNonFinalVariableDeclarations(SNode cl) {
    List<SNode> vrefs = ListSequence.fromList(new ArrayList<SNode>());
    for (SNode desc : SNodeOperations.getDescendants(cl, null, false, new String[]{})) {
      if (SNodeOperations.isInstanceOf(desc, "jetbrains.mps.baseLanguage.structure.VariableReference") && cl == SNodeOperations.getAncestor(desc, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral", false, false)) {
        SNode vd = SLinkOperations.getTarget(SNodeOperations.cast(desc, "jetbrains.mps.baseLanguage.structure.VariableReference"), "variableDeclaration", false);
        if (cl != SNodeOperations.getAncestor(vd, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral", false, false)) {
          if (!(SPropertyOperations.getBoolean(vd, "isFinal")) && (SNodeOperations.isInstanceOf(vd, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration") || SNodeOperations.isInstanceOf(vd, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration"))) {
            ListSequence.fromList(vrefs).addElement(SLinkOperations.getTarget(SNodeOperations.cast(desc, "jetbrains.mps.baseLanguage.structure.VariableReference"), "variableDeclaration", false));
          }
        }
      }
    }
    return vrefs;
  }

  public static SNode fillParams(SNode targetIfaceErase, SNode funType) {
    TypeMatcher matcher = new TypeMatcher();
    SNode meth = Sequence.fromIterable(Classifier_Behavior.call_methods_5292274854859311639(SLinkOperations.getTarget(targetIfaceErase, "classifier", false))).first();
    if ((meth == null)) {
      return null;
    }
    if ((SLinkOperations.getTarget(meth, "returnType", true) != null) && !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(meth, "returnType", true), "jetbrains.mps.baseLanguage.structure.VoidType"))) {
      matcher.matchReturnType(SLinkOperations.getTarget(meth, "returnType", true), FunctionType_Behavior.call_getNormalizedReturnType_1213877405252(funType));
    }
    {
      Iterator<SNode> funParamIt = ListSequence.fromList(FunctionType_Behavior.call_getNormalizedParameterTypes_1213877405276(funType)).iterator();
      Iterator<SNode> methParamIt = ListSequence.fromList(SLinkOperations.getTargets(meth, "parameter", true)).iterator();
      while (funParamIt.hasNext() && methParamIt.hasNext()) {
        matcher.matchType(SLinkOperations.getTarget(methParamIt.next(), "type", true), funParamIt.next());
      }
    }

    Map<SNode, SNode> map = matcher.getMap();
    SNode result = SNodeOperations.copyNode(targetIfaceErase);
    if (map != null) {
      Iterator<SNode> targetTypeVarIt = ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(targetIfaceErase, "classifier", false), "typeVariableDeclaration", true)).iterator();
      while (targetTypeVarIt.hasNext()) {
        ListSequence.fromList(SLinkOperations.getTargets(result, "parameter", true)).addElement(SNodeOperations.cast(MapSequence.fromMap(map).get(targetTypeVarIt.next()), "jetbrains.mps.baseLanguage.structure.Type"));
      }
    }
    return result;
  }
}
