package jetbrains.mps.baseLanguage.closures.helper;

/*Generated by MPS */

import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.closures.behavior.FunctionType_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.typesystem.runtime.HUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;
import java.util.List;

public class AdaptableClassifierTarget {
  private TemplateQueryContext genContext;

  public AdaptableClassifierTarget(TemplateQueryContext genContext) {
    this.genContext = genContext;
  }

  public String getTargetName(SNode target) {
    SNode adaptable = (SNode) Values.ADAPTABLE.get(genContext, target);
    String aname = SPropertyOperations.getString(adaptable, "name");
    int aldidx = aname.lastIndexOf(".");
    aname = (aldidx >= 0 ?
      aname.substring(aldidx + 1) :
      aname
    );
    String tname = SPropertyOperations.getString(target, "name");
    int tldidx = tname.lastIndexOf(".");
    tname = (tldidx >= 0 ?
      tname.substring(tldidx + 1) :
      tname
    );
    return aname + "_to_" + tname + "_adapter";
  }

  public SNode getTarget(SNode expr) {
    SNode ntype = FunctionType_Behavior.call_getDeclarationRuntimeType_1230319610063(SNodeOperations.as(TypeChecker.getInstance().getTypeOf(expr), "jetbrains.mps.baseLanguage.closures.structure.FunctionType"));
    ntype = (ntype == null ?
      TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(expr), HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.ClassifierType"), true) :
      ntype
    );
    assert ntype != null;
    final String trgFQname = (String) Values.PREP_DATA.get(genContext, expr);
    SNode target = ListSequence.fromList(getTargets(SLinkOperations.getTarget(ntype, "classifier", false))).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode cr) {
        return trgFQname.equals(INamedConcept_Behavior.call_getFqName_1213877404258(cr));
      }
    });
    assert Values.ADAPTABLE.get(genContext, target) != null;
    return target;
  }

  public List<SNode> getTargets(SNode adaptable) {
    return (List<SNode>) genContext.getStepObject(Keys.NEEDS_ADAPTER.compose(INamedConcept_Behavior.call_getFqName_1213877404258(adaptable)));
  }

  public List<SNode> getAllAdaptable() {
    return (List<SNode>) genContext.getStepObject(Keys.ALL_NEEDS_ADAPTED);
  }

  public boolean hasAdaptable() {
    return ListSequence.fromList(getAllAdaptable()).isNotEmpty();
  }
}
