package jetbrains.mps.baseLanguage.closures.helper;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.baseLanguage.closures.behavior.FunctionType_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.constraints.ClassifierTypeUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.generator.template.ITemplateGenerator;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.typesystem.runtime.HUtil;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.baseLanguage.closures.util.Constants;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SNodeId;

public class FunctionTypeUtil {
  public static String getRuntimeSignature(SNode ft) {
    return FunctionType_Behavior.call_getRuntimeSignature_1213877404927(ft);
  }

  public static SNode getResultType(SNode functionTypeOrClassifier) {
    if (SNodeOperations.isInstanceOf(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
      return null;
    }
    if (SNodeOperations.isInstanceOf(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.closures.structure.FunctionType")) {
      return FunctionType_Behavior.call_getResultType_1230475757059(SNodeOperations.cast(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.closures.structure.FunctionType"));
    } else if (SNodeOperations.isInstanceOf(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
      SNode meth = FunctionTypeUtil.getFunctionMethod(functionTypeOrClassifier);
      return ClassifierTypeUtil.resolveType(SLinkOperations.getTarget(meth, "returnType", true), SNodeOperations.cast(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.structure.ClassifierType"));
    } else {
      throw new IllegalArgumentException("Invalid argument: " + functionTypeOrClassifier);
    }
  }

  public static List<SNode> getParameterTypes(SNode functionTypeOrClassifier) {
    if (SNodeOperations.isInstanceOf(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
      return null;
    }
    if (SNodeOperations.isInstanceOf(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.closures.structure.FunctionType")) {
      return SLinkOperations.getTargets(SNodeOperations.cast(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.closures.structure.FunctionType"), "parameterType", true);
    } else if (SNodeOperations.isInstanceOf(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
      SNode meth = FunctionTypeUtil.getFunctionMethod(functionTypeOrClassifier);
      List<SNode> res = new ArrayList<SNode>();
      for (SNode pd : ListSequence.fromList(SLinkOperations.getTargets(meth, "parameter", true))) {
        ListSequence.fromList(res).addElement(ClassifierTypeUtil.resolveType(SLinkOperations.getTarget(pd, "type", true), SNodeOperations.cast(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.structure.ClassifierType")));
      }
      return res;
    } else {
      throw new IllegalArgumentException("Invalid argument: " + functionTypeOrClassifier);
    }
  }

  public static List<SNode> normalizeThrowsTypes(List<SNode> ttypes) {
    List<SNode> result = new ArrayList<SNode>();
    List<SNode> visited = new ArrayList<SNode>();
with_throws:
    for (SNode tt : ttypes) {
      SNode clstt = SNodeOperations.as(tt, "jetbrains.mps.baseLanguage.structure.ClassifierType");
      if (clstt != null) {
        if (!(Classifier_Behavior.call_isDescendant_7165541881557222913(SLinkOperations.getTarget(clstt, "classifier", false), SLinkOperations.getTarget(new FunctionTypeUtil.QuotationClass_2t0coq_a0b0a0a1a2a3().createNode(), "classifier", false)))) {
          for (int i = 0; i < ListSequence.fromList(visited).count(); ++i) {
            SNode restt = ListSequence.fromList(visited).getElement(i);
            if (Classifier_Behavior.call_isDescendant_7165541881557222913(SLinkOperations.getTarget(restt, "classifier", false), SLinkOperations.getTarget(clstt, "classifier", false))) {
              ListSequence.fromList(visited).setElement(i, clstt);
              continue with_throws;
            }
          }
          ListSequence.fromList(visited).addElement(clstt);
        }
      } else {
        ListSequence.fromList(result).addElement(tt);
      }
    }
    ListSequence.fromList(result).addSequence(ListSequence.fromList(visited));
    return result;
  }

  private static SNode getFunctionMethod(SNode functionTypeOrClassifier) {
    return ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(SNodeOperations.cast(functionTypeOrClassifier, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", false), "method", true)).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode m) {
        return !("equals".equals(SPropertyOperations.getString(m, "name"))) && SPropertyOperations.getBoolean(m, "isAbstract");
      }
    });
  }

  public static String getAdapterName(SNode adaptable, SNode target) {
    String aname = SPropertyOperations.getString(adaptable, "name");
    int aldidx = aname.lastIndexOf(".");
    aname = (aldidx >= 0 ?
      aname.substring(aldidx + 1) :
      aname
    );
    String tname = SPropertyOperations.getString(target, "name");
    int tldidx = tname.lastIndexOf(".");
    tname = (tldidx >= 0 ?
      tname.substring(tldidx + 1) :
      tname
    );
    return aname + "_to_" + tname + "_adapter";
  }

  public static SNode getAdaptableTarget(TemplateQueryContext genContext, SNode expr, ITemplateGenerator generator) {
    SNode ntype = FunctionType_Behavior.call_getDeclarationRuntimeType_1230319610063(SNodeOperations.as(TypeChecker.getInstance().getTypeOf(expr), "jetbrains.mps.baseLanguage.closures.structure.FunctionType"));
    ntype = (ntype == null ?
      TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(expr), HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.ClassifierType"), true) :
      ntype
    );
    assert ntype != null;
    List<SNode> targets = FunctionTypeUtil.getAdaptableClassifierTargets(SLinkOperations.getTarget(SNodeOperations.as(ntype, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", false), generator);
    String trgFQname = (String) Values.PREP_DATA.get(genContext, expr);
    SNode trg = null;
    for (SNode ct : targets) {
      if (trgFQname.equals(INamedConcept_Behavior.call_getFqName_1213877404258(ct))) {
        trg = ct;
        break;
      }
    }
    return trg;
  }

  public static SNode unmeet(SNode possiblyMeet) {
    SNode tmp = possiblyMeet;
with_meet:
    while (SNodeOperations.isInstanceOf(tmp, "jetbrains.mps.lang.typesystem.structure.MeetType")) {
      for (SNode arg : SLinkOperations.getTargets(SNodeOperations.cast(tmp, "jetbrains.mps.lang.typesystem.structure.MeetType"), "argument", true)) {
        if (!(SNodeOperations.isInstanceOf(arg, "jetbrains.mps.baseLanguage.structure.VoidType"))) {
          tmp = arg;
          continue with_meet;
        }
      }
      return new FunctionTypeUtil.QuotationClass_2t0coq_a0b0b0h().createNode();
    }
    if (SNodeOperations.isInstanceOf(tmp, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
      List<SNode> params = SLinkOperations.getTargets(SNodeOperations.cast(tmp, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "parameter", true);
      for (SNode p : params) {
        SNode up = unmeet(p);
        if (up != p) {
          SNodeOperations.replaceWithAnother(p, up);
        }
      }
    }
    return tmp;
  }

  public static SNode unbound(SNode maybeBound) {
    SNode res = null;
    List<SNode> q = ListSequence.fromListAndArray(new LinkedList<SNode>(), SNodeOperations.copyNode(maybeBound));
    while (!(ListSequence.fromList(q).isEmpty())) {
      SNode n = ListSequence.fromList(q).removeElementAt(0);
      if (SNodeOperations.isInstanceOf(n, "jetbrains.mps.baseLanguage.structure.UpperBoundType")) {
        n = SNodeOperations.replaceWithAnother(n, SLinkOperations.getTarget(SNodeOperations.cast(n, "jetbrains.mps.baseLanguage.structure.UpperBoundType"), "bound", true));
      }
      if (SNodeOperations.isInstanceOf(n, "jetbrains.mps.baseLanguage.structure.LowerBoundType")) {
        n = SNodeOperations.replaceWithAnother(n, SLinkOperations.getTarget(SNodeOperations.cast(n, "jetbrains.mps.baseLanguage.structure.LowerBoundType"), "bound", true));
      }
      if ((n != null)) {
        ListSequence.fromList(q).addSequence(ListSequence.fromList(SNodeOperations.getChildren(n)));
      }
      if ((res == null)) {
        res = n;
      }
      break;
    }
    return res;
  }

  public static SNode unmeetRecursively(SNode nodeWithMeetDescendants) {
    for (SNode dsc : SNodeOperations.getDescendants(nodeWithMeetDescendants, null, false, new String[]{})) {
      if (SNodeOperations.isInstanceOf(dsc, "jetbrains.mps.lang.typesystem.structure.MeetType")) {
        SNodeOperations.replaceWithAnother(dsc, SNodeOperations.copyNode(unmeet(dsc)));
      }
    }
    return nodeWithMeetDescendants;
  }

  public static void prepAdaptations(TemplateQueryContext genContext, SNode ltype, SNode rexpr) {
    SNode lCType = (SNodeOperations.isInstanceOf(ltype, "jetbrains.mps.baseLanguage.structure.ClassifierType") ?
      SNodeOperations.cast(ltype, "jetbrains.mps.baseLanguage.structure.ClassifierType") :
      null
    );
    SNode lFType = (SNodeOperations.isInstanceOf(ltype, "jetbrains.mps.baseLanguage.closures.structure.FunctionType") ?
      SNodeOperations.cast(ltype, "jetbrains.mps.baseLanguage.closures.structure.FunctionType") :
      null
    );
    if ((lFType == null) && (lCType == null)) {
      return;
    }
    /*
      if ((lCType != null) && !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(lCType, "classifier", false), "jetbrains.mps.baseLanguage.structure.Interface"))) {
        return;
      }
    */
    if (Constants.ONLY_CLOSURE_LITERAL_AS_FUNCTION_TYPE) {
      //  TEMP HACK: proceed only if the "right" expression is a ClosureLiteral, balk otherwise 
      //  This may cause unexpected results, so please disable in case of difficulties generating some code 
      if (!(SNodeOperations.isInstanceOf(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral"))) {
        return;
      }
    }
    SNode rtype = TypeChecker.getInstance().getTypeOf(rexpr);
    SNode rFType = (SNodeOperations.isInstanceOf(rtype, "jetbrains.mps.baseLanguage.closures.structure.FunctionType") ?
      SNodeOperations.cast(rtype, "jetbrains.mps.baseLanguage.closures.structure.FunctionType") :
      null
    );
    SNode rCType = (SNodeOperations.isInstanceOf(rtype, "jetbrains.mps.baseLanguage.structure.ClassifierType") ?
      SNodeOperations.cast(rtype, "jetbrains.mps.baseLanguage.structure.ClassifierType") :
      null
    );

    if ((lCType != null) && (rFType != null)) {
      if (SNodeOperations.isInstanceOf(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral") && (!(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(TypeChecker.getInstance().getRuntimeSupport().coerce_(lCType, HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.closures.structure.FunctionType"), true), "resultType", true), "jetbrains.mps.baseLanguage.structure.VoidType")) || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(rFType, "resultType", true), "jetbrains.mps.baseLanguage.structure.VoidType") || ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(SNodeOperations.cast(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral"), "body", true), "jetbrains.mps.baseLanguage.structure.ReturnStatement", false, new String[]{})).all(new IWhereFilter<SNode>() {
        public boolean accept(SNode rs) {
          return (SLinkOperations.getTarget(rs, "expression", true) == null);
        }
      }))) {
        // <node> 
        new ClosureLiteralTarget(genContext).setTarget(SNodeOperations.cast(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral"), lCType);
      } else {
        FunctionTypeUtil.addAdaptableClassifierTypeTarget(genContext, FunctionType_Behavior.call_getDeclarationRuntimeType_1230319610063(rFType), lCType);
        Values.PREP_DATA.set(genContext, rexpr, INamedConcept_Behavior.call_getFqName_1213877404258(SLinkOperations.getTarget(lCType, "classifier", false)));
      }
    } else
    if ((lFType != null) && (rCType != null)) {
      FunctionTypeUtil.addAdaptableClassifierTypeTarget(genContext, rCType, FunctionType_Behavior.call_getDeclarationRuntimeType_1230319610063(lFType));
      Values.PREP_DATA.set(genContext, rexpr, INamedConcept_Behavior.call_getFqName_1213877404258(SLinkOperations.getTarget(FunctionType_Behavior.call_getDeclarationRuntimeType_1230319610063(lFType), "classifier", false)));
    } else
    if ((lFType != null) && (rFType != null)) {
      AdapterClassTypeBuilder builder = new AdapterClassTypeBuilder(genContext);

      if (SNodeOperations.isInstanceOf(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral") && builder.hasAdapterClass(SNodeOperations.cast(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral"))) {
        SNode adapterClassType = builder.buildAdapterClassType(SNodeOperations.cast(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral"), lFType);
        // <node> 
        new ClosureLiteralTarget(genContext).setTarget(SNodeOperations.cast(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral"), adapterClassType);

      } else if (SNodeOperations.isInstanceOf(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral") && (!(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(lFType, "resultType", true), "jetbrains.mps.baseLanguage.structure.VoidType")) || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(rFType, "resultType", true), "jetbrains.mps.baseLanguage.structure.VoidType") || ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(SNodeOperations.cast(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral"), "body", true), "jetbrains.mps.baseLanguage.structure.ReturnStatement", false, new String[]{})).all(new IWhereFilter<SNode>() {
        public boolean accept(SNode rs) {
          return (SLinkOperations.getTarget(rs, "expression", true) == null);
        }
      }))) {
        // <node> 
        new ClosureLiteralTarget(genContext).setTarget(SNodeOperations.cast(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral"), FunctionType_Behavior.call_getDeclarationRuntimeType_811905832257074290(lFType, rFType));

      } else if (SNodeOperations.isInstanceOf(rexpr, "jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral") || ListSequence.fromList(FunctionType_Behavior.call_getNormalizedThrowsTypes_3448422702164385781(lFType)).count() != ListSequence.fromList(FunctionType_Behavior.call_getNormalizedThrowsTypes_3448422702164385781(rFType)).count()) {
        FunctionTypeUtil.addAdaptableClassifierTypeTarget(genContext, FunctionType_Behavior.call_getDeclarationRuntimeType_1230319610063(rFType), FunctionType_Behavior.call_getDeclarationRuntimeType_1230319610063(lFType));
        Values.PREP_DATA.set(genContext, rexpr, INamedConcept_Behavior.call_getFqName_1213877404258(SLinkOperations.getTarget(FunctionType_Behavior.call_getDeclarationRuntimeType_1230319610063(lFType), "classifier", false)));
      }
    }
  }

  public static void addAdaptableClassifierTypeTarget(TemplateQueryContext genContext, SNode adaptable, SNode target) {
    List<SNode> allAdaptable = getAllAdaptableClassifiers(genContext);
    if (allAdaptable == null) {
      allAdaptable = ListSequence.fromList(new ArrayList<SNode>());
      genContext.putStepObject(Keys.ALL_NEEDS_ADAPTED, allAdaptable);
    }
    if (!(ListSequence.fromList(allAdaptable).contains(SLinkOperations.getTarget(adaptable, "classifier", false)))) {
      ListSequence.fromList(allAdaptable).addElement(SLinkOperations.getTarget(adaptable, "classifier", false));
    }
    List<SNode> trgList = (List<SNode>) genContext.getStepObject(Keys.NEEDS_ADAPTER.compose(INamedConcept_Behavior.call_getFqName_1213877404258(SLinkOperations.getTarget(adaptable, "classifier", false))));
    if (trgList == null) {
      trgList = ListSequence.fromList(new ArrayList<SNode>());
      genContext.putStepObject(Keys.NEEDS_ADAPTER.compose(INamedConcept_Behavior.call_getFqName_1213877404258(SLinkOperations.getTarget(adaptable, "classifier", false))), trgList);
    }
    boolean hasOneAlready = false;
    for (SNode ct : trgList) {
      if (INamedConcept_Behavior.call_getFqName_1213877404258(SLinkOperations.getTarget(target, "classifier", false)).equals(INamedConcept_Behavior.call_getFqName_1213877404258(ct))) {
        hasOneAlready = true;
        break;
      }
    }
    if (!(hasOneAlready)) {
      ListSequence.fromList(trgList).addElement(SLinkOperations.getTarget(target, "classifier", false));
      Values.ADAPTABLE.set(genContext, SLinkOperations.getTarget(target, "classifier", false), SLinkOperations.getTarget(adaptable, "classifier", false));
    }
  }

  public static List<SNode> getAllAdaptableClassifiers(TemplateQueryContext genContext) {
    return (List<SNode>) genContext.getStepObject(Keys.ALL_NEEDS_ADAPTED);
  }

  public static List<SNode> getAdaptableClassifierTargets(SNode adaptable, ITemplateGenerator generator) {
    return (List<SNode>) generator.getGeneratorSessionContext().getStepObject(Keys.NEEDS_ADAPTER.compose(INamedConcept_Behavior.call_getFqName_1213877404258(adaptable)));
  }

  public static Map<SNode, SNode> mapAdaptableTargetTVDs(SNode adaptable, SNode target) {
    Map<SNode, SNode> resMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    SNode adMethod = ListSequence.fromList(SLinkOperations.getTargets(adaptable, "method", true)).getElement(0);
    SNode trgMethod = ListSequence.fromList(SLinkOperations.getTargets(target, "method", true)).getElement(0);
    doMapTVDS(resMap, SLinkOperations.getTarget(adMethod, "returnType", true), SLinkOperations.getTarget(trgMethod, "returnType", true));
    {
      SNode adParm;
      SNode trgParm;
      Iterator<SNode> adParm_iterator = ListSequence.fromList(SLinkOperations.getTargets(adMethod, "parameter", true)).iterator();
      Iterator<SNode> trgParm_iterator = ListSequence.fromList(SLinkOperations.getTargets(trgMethod, "parameter", true)).iterator();
      while (true) {
        if (!(adParm_iterator.hasNext())) {
          break;
        }
        if (!(trgParm_iterator.hasNext())) {
          break;
        }
        adParm = adParm_iterator.next();
        trgParm = trgParm_iterator.next();
        doMapTVDS(resMap, SLinkOperations.getTarget(adParm, "type", true), SLinkOperations.getTarget(trgParm, "type", true));
      }
    }
    return resMap;
  }

  private static void doMapTVDS(Map<SNode, SNode> theMap, SNode adType, SNode trgType) {
    SNode adTVD = SLinkOperations.getTarget(SNodeOperations.as(adType, "jetbrains.mps.baseLanguage.structure.TypeVariableReference"), "typeVariableDeclaration", false);
    SNode trgTVD = SLinkOperations.getTarget(SNodeOperations.as(trgType, "jetbrains.mps.baseLanguage.structure.TypeVariableReference"), "typeVariableDeclaration", false);
    if ((adTVD != null) && (trgTVD != null)) {
      MapSequence.fromMap(theMap).put(adTVD, trgTVD);
    }
  }

  public static class QuotationClass_2t0coq_a0b0a0a1a2a3 {
    public QuotationClass_2t0coq_a0b0a0a1a2a3() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ClassifierType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        quotedNode1_2.addReference(SReference.create("classifier", quotedNode1_2, SModelReference.fromString("f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(java.lang@java_stub)"), SNodeId.fromString("~RuntimeException")));
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_2t0coq_a0b0b0h {
    public QuotationClass_2t0coq_a0b0b0h() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.VoidType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }
}
