package jetbrains.mps.baseLanguage.closures.helper;

/*Generated by MPS */

import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.List;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.baseLanguage.closures.behavior.FunctionType_Behavior;
import jetbrains.mps.util.JavaNameUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.lang.core.behavior.BaseConcept_Behavior;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.baseLanguage.closures.constraints.ClassifierTypeUtil;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.HashMap;

public class ClosureLiteralTarget {
  private TemplateQueryContext genContext;

  public ClosureLiteralTarget(TemplateQueryContext genContext) {
    this.genContext = genContext;
  }

  public void setTarget(SNode literal, SNode targetIface) {
    SNode targetIfaceErase = SConceptOperations.createNewNode(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(targetIface)), null);
    SLinkOperations.setTarget(targetIfaceErase, "classifier", SLinkOperations.getTarget(targetIface, "classifier", false), false);
    matchTypeParameters(literal, targetIfaceErase, SLinkOperations.getTargets(targetIface, "parameter", true));
    Values.LITERAL.set(genContext, targetIfaceErase, literal);
    Values.LITERAL_TARGET.set(genContext, literal, targetIfaceErase);
  }

  private void matchTypeParameters(SNode literal, SNode targetIfaceErase, List<SNode> reifiedTargetIfaceTypeParams) {
    SNode meth = getFunctionMethod(literal, targetIfaceErase);
    SNode funType = SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(literal), "jetbrains.mps.baseLanguage.closures.structure.FunctionType");
    ClosureLiteralTarget.TypeMatcher matcher = new ClosureLiteralTarget.TypeMatcher();

    if ((SLinkOperations.getTarget(meth, "returnType", true) != null) && !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(meth, "returnType", true), "jetbrains.mps.baseLanguage.structure.VoidType"))) {
      matcher.matchReturnType(SLinkOperations.getTarget(meth, "returnType", true), FunctionType_Behavior.call_getNormalizedReturnType_1213877405252(funType));
      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(meth, "returnType", true), "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
        // TODO: refactor this code 
        SNode absRetCT = SNodeOperations.copyNode(SNodeOperations.cast(SLinkOperations.getTarget(meth, "returnType", true), "jetbrains.mps.baseLanguage.structure.ClassifierType"));
        SNode ftResCT = FunctionTypeUtil.unmeet(FunctionType_Behavior.call_getNormalizedReturnType_1213877405252(funType));
        String adapterName = JavaNameUtil.shortName(SPropertyOperations.getString(SLinkOperations.getTarget(absRetCT, "classifier", false), "name")) + JavaNameUtil.shortName(SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.as(FunctionTypeUtil.unbound(ftResCT), "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", false), "name")) + "Adapter";
        for (SNode cls : SModelOperations.getNodes(SNodeOperations.getModel(SLinkOperations.getTarget(absRetCT, "classifier", false)), "jetbrains.mps.baseLanguage.structure.Classifier")) {
          if (adapterName.equals(JavaNameUtil.shortName(SPropertyOperations.getString(cls, "name")))) {
            SNode newRetCT = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierType", null);
            SLinkOperations.setTarget(newRetCT, "classifier", cls, false);
            Values.RETURN_TYPE.set(genContext, targetIfaceErase, newRetCT);
            break;
          }
        }
      }
    }

    {
      Iterator<SNode> funParamIt = ListSequence.fromList(FunctionType_Behavior.call_getNormalizedParameterTypes_1213877405276(funType)).iterator();
      Iterator<SNode> methParamIt = ListSequence.fromList(SLinkOperations.getTargets(meth, "parameter", true)).iterator();
      while (funParamIt.hasNext() && methParamIt.hasNext()) {
        matcher.matchType(SLinkOperations.getTarget(methParamIt.next(), "type", true), funParamIt.next());
      }
      if (funParamIt.hasNext() || methParamIt.hasNext()) {
        genContext.showErrorMessage(literal, "Closure parameters count doesn't match method '" + SPropertyOperations.getString(meth, "name") + "' in " + JavaNameUtil.fqClassName(SLinkOperations.getTarget(targetIfaceErase, "classifier", false), SPropertyOperations.getString(SLinkOperations.getTarget(targetIfaceErase, "classifier", false), "name")));
      }
    }

    {
      // TODO: rewrite throws types matching algorithm 
      List<SNode> normFunThrowsTypes = FunctionType_Behavior.call_getNormalizedThrowsTypes_3448422702164385781(funType);
      Iterator<SNode> funThrIt = ListSequence.fromList(normFunThrowsTypes).sort(new ISelector<SNode, Comparable<?>>() {
        public Comparable<?> select(SNode t) {
          String key = Classifier_Behavior.call_getNestedName_8540045600162184125(SLinkOperations.getTarget(SNodeOperations.as(t, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", false));
          return (key != null ?
            key :
            BaseConcept_Behavior.call_getPresentation_1213877396640(t)
          );
        }
      }, true).iterator();
      Iterator<SNode> methThrIt = ListSequence.fromList(FunctionTypeUtil.normalizeThrowsTypes(SLinkOperations.getTargets(meth, "throwsItem", true))).iterator();

      while (funThrIt.hasNext() && methThrIt.hasNext()) {
        matcher.matchType(methThrIt.next(), funThrIt.next());
      }
      if (funThrIt.hasNext() || methThrIt.hasNext()) {
        genContext.showWarningMessage(literal, "Closure generic throws types count doesn't match method '" + SPropertyOperations.getString(meth, "name") + "' in " + JavaNameUtil.fqClassName(SLinkOperations.getTarget(targetIfaceErase, "classifier", false), SPropertyOperations.getString(SLinkOperations.getTarget(targetIfaceErase, "classifier", false), "name")));
      }
    }

    Values.TYPE_MAP.set(genContext, targetIfaceErase, matcher.getMap());

    // Copy reified target ClassifierType parameters to the erasure target ClassifierType 
    Map<SNode, SNode> map = matcher.getMap();
    if (map != null) {
      Iterator<SNode> reifiedTypeIt = ListSequence.fromList(reifiedTargetIfaceTypeParams).iterator();
      Iterator<SNode> targetTypeVarIt = ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(targetIfaceErase, "classifier", false), "typeVariableDeclaration", true)).iterator();
      while (reifiedTypeIt.hasNext() && targetTypeVarIt.hasNext()) {
        SNode typeVar = targetTypeVarIt.next();
        SNode rtp = reifiedTypeIt.next();
        SNode substituteType = (MapSequence.fromMap(map).containsKey(typeVar) ?
          SNodeOperations.copyNode(MapSequence.fromMap(map).get(typeVar)) :
          SNodeOperations.copyNode(rtp)
        );
        // TODO: we need a better way to handle wildcards in the substitutes 
        // Any (completely) reified type has precedence over calculated function type's parameter 
        // Example: String s = { => null; } must use String, not Object as the return value 
        if (!(hasTypeVariable(rtp)) && !(TypeChecker.getInstance().getSubtypingManager().isSubtype(substituteType, rtp))) {
          substituteType = ClassifierTypeUtil.getTypeCoercedToClassifierType(SNodeOperations.copyNode(rtp));
        }
        List<SNode> queue = ListSequence.fromListAndArray(new LinkedList<SNode>(), ListSequence.fromList(SLinkOperations.getTargets(targetIfaceErase, "parameter", true)).addElement(substituteType));
with_queue:
        while (!(ListSequence.fromList(queue).isEmpty())) {
          SNode n = ListSequence.fromList(queue).removeElementAt(0);
          if ((n != null)) {
            if (SNodeOperations.isInstanceOf(n, "jetbrains.mps.baseLanguage.structure.UpperBoundType")) {
              n = SNodeOperations.replaceWithAnother(n, SLinkOperations.getTarget(SNodeOperations.cast(n, "jetbrains.mps.baseLanguage.structure.UpperBoundType"), "bound", true));
            } else if (SNodeOperations.isInstanceOf(n, "jetbrains.mps.baseLanguage.structure.LowerBoundType")) {
              n = SNodeOperations.replaceWithAnother(n, SLinkOperations.getTarget(SNodeOperations.cast(n, "jetbrains.mps.baseLanguage.structure.LowerBoundType"), "bound", true));
            } else {
              continue with_queue;
            }
            ListSequence.fromList(queue).addElement(n);
            ListSequence.fromList(queue).addSequence(ListSequence.fromList(SNodeOperations.getChildren(n)));
          }
        }
      }
      if (reifiedTypeIt.hasNext() || targetTypeVarIt.hasNext()) {
        genContext.showWarningMessage(literal, "Reified type parameters count doesn't match method declaration '" + SPropertyOperations.getString(meth, "name") + "' in " + JavaNameUtil.fqClassName(SLinkOperations.getTarget(targetIfaceErase, "classifier", false), SPropertyOperations.getString(SLinkOperations.getTarget(targetIfaceErase, "classifier", false), "name")));
      }
    }
  }

  private boolean hasTypeVariable(SNode type) {
    return ListSequence.fromList(SNodeOperations.getDescendants(type, "jetbrains.mps.baseLanguage.structure.TypeVariableReference", true, new String[]{})).isNotEmpty();
  }

  private SNode getFunctionMethod(SNode literal, SNode targetIface) {
    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());
    for (SNode mth : SLinkOperations.getTargets(SLinkOperations.getTarget(targetIface, "classifier", false), "method", true)) {
      if (!("equals".equals(SPropertyOperations.getString(mth, "name"))) && SPropertyOperations.getBoolean(mth, "isAbstract")) {
        ListSequence.fromList(result).addElement(mth);
      }
    }
    if (ListSequence.fromList(result).count() > 1) {
      genContext.showWarningMessage(literal, "The adaptation target interface has more than one method");
    }
    return ListSequence.fromList(result).first();
  }

  private static class TypeMatcher {
    private Map<SNode, SNode> typeMap;

    public TypeMatcher() {
    }

    public Map<SNode, SNode> getMap() {
      return typeMap;
    }

    public void matchType(SNode absType, SNode realType) {
      SNode matched = null;
      if (SNodeOperations.isInstanceOf(realType, "jetbrains.mps.lang.typesystem.structure.MeetType")) {
        matched = whichTypeMatching(SLinkOperations.getTargets(SNodeOperations.cast(realType, "jetbrains.mps.lang.typesystem.structure.MeetType"), "argument", true), absType);
      } else if (isTypeMatching(absType, realType)) {
        matched = realType;
      }
      if ((matched != null)) {
        if (SNodeOperations.isInstanceOf(absType, "jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
          mapTypeVar(SNodeOperations.cast(absType, "jetbrains.mps.baseLanguage.structure.TypeVariableReference"), matched);
        } else {
          int idx = 0;
          List<SNode> mptypes = SLinkOperations.getTargets(SNodeOperations.as(absType, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "parameter", true);
          List<SNode> rptypes = SLinkOperations.getTargets(SNodeOperations.as(matched, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "parameter", true);
          for (int i = 0; i < ListSequence.fromList(mptypes).count() && i < ListSequence.fromList(rptypes).count(); i++) {
            matchType(ListSequence.fromList(mptypes).getElement(i), ListSequence.fromList(rptypes).getElement(i));
          }
        }
      }
    }

    public void matchReturnType(SNode absType, SNode realType) {
      Set<String> visited = SetSequence.fromSet(new HashSet<String>());
      List<SNode> queue = new ArrayList<SNode>();
      if (SNodeOperations.isInstanceOf(realType, "jetbrains.mps.lang.typesystem.structure.MeetType")) {
        for (SNode arg : SLinkOperations.getTargets(SNodeOperations.cast(realType, "jetbrains.mps.lang.typesystem.structure.MeetType"), "argument", true)) {
          ListSequence.fromList(queue).addElement(arg);
        }
      } else {
        ListSequence.fromList(queue).addElement(realType);
      }
      while (!(ListSequence.fromList(queue).isEmpty())) {
        SNode candidate = ListSequence.fromList(queue).removeElementAt(0);
        if (!(SetSequence.fromSet(visited).contains(BaseConcept_Behavior.call_getPresentation_1213877396640(candidate)))) {
          if (isTypeMatching(absType, candidate)) {
            matchType(absType, candidate);
            return;
          }
          SetSequence.fromSet(visited).addElement(BaseConcept_Behavior.call_getPresentation_1213877396640(candidate));
          for (SNode superType : TypeChecker.getInstance().getSubtypingManager().collectImmediateSupertypes(candidate)) {
            ListSequence.fromList(queue).addElement(superType);
          }
        }
      }
    }

    private void mapTypeVar(SNode typeVar, SNode tvr) {
      MapSequence.fromMap(getOrCreateMap()).put(SLinkOperations.getTarget(typeVar, "typeVariableDeclaration", false), FunctionTypeUtil.unbound(SNodeOperations.copyNode(tvr)));
    }

    private Map<SNode, SNode> getOrCreateMap() {
      if (typeMap == null) {
        typeMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      }
      return typeMap;
    }

    private SNode whichTypeMatching(List<SNode> leftList, SNode right) {
      for (SNode left : leftList) {
        if (isTypeMatching(left, right)) {
          return left;
        }
      }
      return null;
    }

    private boolean isTypeMatching(SNode left, SNode right) {
      if (SNodeOperations.isInstanceOf(left, "jetbrains.mps.baseLanguage.structure.VoidType") || SNodeOperations.isInstanceOf(right, "jetbrains.mps.baseLanguage.structure.VoidType")) {
        return false;
      }
      if (SNodeOperations.isInstanceOf(right, "jetbrains.mps.baseLanguage.structure.TypeVariableReference") || SNodeOperations.isInstanceOf(left, "jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
        return true;
      }
      if (SNodeOperations.isInstanceOf(left, "jetbrains.mps.baseLanguage.structure.ClassifierType") && SNodeOperations.isInstanceOf(right, "jetbrains.mps.baseLanguageInternal.structure.InternalClassifierType")) {
        return true;
      }
      if (SNodeOperations.getConceptDeclaration(left) == SNodeOperations.getConceptDeclaration(right)) {
        if (!(SNodeOperations.isInstanceOf(left, "jetbrains.mps.baseLanguage.structure.ClassifierType"))) {
          return true;
        }
        return SLinkOperations.getTarget(SNodeOperations.cast(left, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", false) == SLinkOperations.getTarget(SNodeOperations.cast(right, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", false) && (int) ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(left, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "parameter", true)).count() == (int) ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(right, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "parameter", true)).count();
      }
      return false;
    }
  }
}
