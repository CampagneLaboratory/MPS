package jetbrains.mps.baseLanguage.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.ArrayList;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import org.jetbrains.mps.openapi.language.SConceptRepository;
import jetbrains.mps.util.NameUtil;

public class ParenthesisUtil {
  public ParenthesisUtil() {
  }



  public static SNode createUnmatchedLeftParenthesis(@NotNull SNode leftExpression) {
    return createUnmatchedParenthesis(leftExpression, false);
  }



  public static SNode createUnmatchedRightParenthesis(@NotNull SNode rightExpression) {
    return createUnmatchedParenthesis(rightExpression, true);
  }



  private static SNode createUnmatchedParenthesis(@NotNull SNode myExpression, final boolean completingByRightParen) {
    List<SNode> myParentPath = parentPath(myExpression, completingByRightParen);
    SNode topExp = ListSequence.fromList(myParentPath).last();
    List<SNode> otherParentedNodes = ListSequence.fromList(SNodeOperations.getDescendants(topExp, "jetbrains.mps.baseLanguage.structure.Expression", true, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (completingByRightParen && (AttributeOperations.getAttribute(it, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteLeftParen")) != null)) || (!(completingByRightParen) && (AttributeOperations.getAttribute(it, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteRightParen")) != null));
      }
    }).toListSequence();

    if (!(completingByRightParen)) {
      otherParentedNodes = ListSequence.fromList(otherParentedNodes).reversedList();
    }

    int index = ListSequence.fromList(otherParentedNodes).count() - 1;
    SNode otherExpression = null;
    final Wrappers._T<List<SNode>> otherParentPath = new Wrappers._T<List<SNode>>(null);
    SNode firstCommon = null;

    // Find a matching parenthesis 
    while (index >= 0) {
      otherExpression = ListSequence.fromList(otherParentedNodes).getElement(index);
      otherParentPath.value = parentPath(otherExpression, !(completingByRightParen));
      if (ListSequence.fromList(myParentPath).contains(ListSequence.fromList(otherParentPath.value).last()) || ListSequence.fromList(otherParentPath.value).contains(ListSequence.fromList(myParentPath).last())) {
        if (eq_a65dpo_a0a0c0m0g(otherExpression, myExpression)) {
          // they are both the same node 
          ParenthesisUtil.clearIncompleteParens(otherExpression, completingByRightParen);
          SNode parens = SNodeFactoryOperations.replaceWithNewChild(otherExpression, "jetbrains.mps.baseLanguage.structure.ParenthesizedExpression");
          SLinkOperations.setTarget(parens, "expression", otherExpression, true);
          return parens;
        }

        firstCommon = ListSequence.fromList(myParentPath).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return ListSequence.fromList(otherParentPath.value).contains(it);
          }
        });
        assert firstCommon != null;

        if ((eq_a65dpo_a0a0a5a2a21a6_0(firstCommon, otherExpression) || eq_a65dpo_a0a0a5a2a21a6(firstCommon, myExpression)) && SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.DotExpression")) {
          // one of the parenthesised nodes is the common ancestor 
          ParenthesisUtil.clearIncompleteParens(otherExpression, completingByRightParen);
          SNode parens = SNodeFactoryOperations.replaceWithNewChild(firstCommon, "jetbrains.mps.baseLanguage.structure.ParenthesizedExpression");
          SLinkOperations.setTarget(parens, "expression", firstCommon, true);
          return parens;
        }


        if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
          // Does left parented node come from the left and right parented node from the right? 
          SNode commonBin = SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
          if ((completingByRightParen && ListSequence.fromList(SNodeOperations.getAncestors(otherExpression, null, true)).contains(SLinkOperations.getTarget(commonBin, "leftExpression", true)) && ListSequence.fromList(SNodeOperations.getAncestors(myExpression, null, true)).contains(SLinkOperations.getTarget(commonBin, "rightExpression", true))) || !(completingByRightParen) && ListSequence.fromList(SNodeOperations.getAncestors(myExpression, null, true)).contains(SLinkOperations.getTarget(commonBin, "leftExpression", true)) && ListSequence.fromList(SNodeOperations.getAncestors(otherExpression, null, true)).contains(SLinkOperations.getTarget(commonBin, "rightExpression", true))) {
            break;
          }
        } else if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression")) {
          // In case of a ternary operator expression being the first common predecessor 
          SNode commonTern = SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression");
          if ((completingByRightParen && ListSequence.fromList(SNodeOperations.getAncestors(otherExpression, null, true)).contains(SLinkOperations.getTarget(commonTern, "condition", true)) && ListSequence.fromList(SNodeOperations.getAncestors(myExpression, null, true)).contains(SLinkOperations.getTarget(commonTern, "ifFalse", true))) || !(completingByRightParen) && ListSequence.fromList(SNodeOperations.getAncestors(myExpression, null, true)).contains(SLinkOperations.getTarget(commonTern, "condition", true)) && ListSequence.fromList(SNodeOperations.getAncestors(otherExpression, null, true)).contains(SLinkOperations.getTarget(commonTern, "ifFalse", true))) {
            break;
          }
        } else if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.CastExpression")) {
          SNode commonCast = SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.CastExpression");
          if ((completingByRightParen && ListSequence.fromList(SNodeOperations.getAncestors(myExpression, null, true)).contains(SLinkOperations.getTarget(commonCast, "expression", true))) || (!(completingByRightParen) && ListSequence.fromList(SNodeOperations.getAncestors(otherExpression, null, true)).contains(SLinkOperations.getTarget(commonCast, "expression", true)))) {
            break;
          }
        }
      }
      index--;
    }
    if (index == -1) {
      // no common ancestor with any of the candidate parens or swapped left-right -> can't parenthesise 
      if (completingByRightParen) {
        AttributeOperations.setAttribute(myExpression, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteRightParen"), SNodeFactoryOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IncompleteRightParen", null));
      } else {
        AttributeOperations.setAttribute(myExpression, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteLeftParen"), SNodeFactoryOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IncompleteLeftParen", null));
      }
      return myExpression;
    }

    clearIncompleteParens(otherExpression, completingByRightParen);

    SNode leftExpression = (completingByRightParen ? otherExpression : myExpression);
    SNode rightExpression = (completingByRightParen ? myExpression : otherExpression);

    if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
      return ParenthesisUtil.handleBinaryOperation(leftExpression, firstCommon, rightExpression);
    } else if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.CastExpression")) {
      return ParenthesisUtil.handleCastExpression(firstCommon, rightExpression);
    } else {
      return ParenthesisUtil.handleTernaryOperator(firstCommon, leftExpression, rightExpression);
    }
  }



  private static SNode handleTernaryOperator(SNode firstCommon, SNode leftExpression, SNode rightExpression) {
    assert SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression");
    SNode ternaryExpr = SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression");
    SNode leftTurn = findLeftTurn(leftExpression, ternaryExpr);
    SNode rightTurn = findRightTurn(rightExpression, ternaryExpr);
    return ParenthesisUtil.rebalance(leftTurn, firstCommon, rightTurn);
  }



  private static SNode handleCastExpression(SNode firstCommon, SNode rightExpression) {
    SNode castExpr = SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.CastExpression");
    SNode leftTurn = null;
    SNode rightTurn = findRightTurn(rightExpression, castExpr);
    return ParenthesisUtil.rebalance(leftTurn, firstCommon, rightTurn);
  }



  private static SNode handleBinaryOperation(SNode leftExpression, SNode firstCommon, SNode rightExpression) {
    SNode leftTurn = findLeftTurn(leftExpression, firstCommon);
    SNode rightTurn = findRightTurn(rightExpression, firstCommon);
    return ParenthesisUtil.rebalance(leftTurn, firstCommon, rightTurn);
  }





  /**
   * Create a ParenthesisedExpression and hook it properly into the model
   * 
   * @param leftTurn The node that should be put outside and to the left from the new parens
   * @param rightTurn The node that should be put outside and to the right from the new parens
   * @param firstCommon The common ancestor expression of both parentheses
   */
  private static SNode rebalance(SNode leftTurn, SNode firstCommon, SNode rightTurn) {

    // Accumulate expressions between the leftTurn and firstCommon to include inside the parens. 
    // These would be the nodes into which we come from the left child. 
    SNode leftAccumulator = null;
    // Accumulate expressions between the rightTurn and firstCommon to include inside the parens. 
    // These would be the nodes into which we come from the right child. 
    SNode rightAccumulator = null;
    if (leftTurn != null && neq_a65dpo_a0a7a61(leftTurn, firstCommon)) {
      // Accumulate nodes on the path from the left paren 
      leftAccumulator = SLinkOperations.getTarget(leftTurn, "rightExpression", true);
      SNodeOperations.detachNode(leftAccumulator);
      SNode current = SNodeOperations.cast(SNodeOperations.getParent(leftTurn), "jetbrains.mps.baseLanguage.structure.Expression");
      SNode previous = leftTurn;
      while (neq_a65dpo_a0f0h0q(current, firstCommon)) {
        if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation") && eq_a65dpo_a0a0a5a7a61(SLinkOperations.getTarget(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", true), previous)) {
          SNodeOperations.replaceWithAnother(current, previous);
          SLinkOperations.setTarget(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", leftAccumulator, true);
          leftAccumulator = current;
        } else {
          previous = current;
        }
        current = SNodeOperations.cast(SNodeOperations.getParent(previous), "jetbrains.mps.baseLanguage.structure.Expression");
      }
    } else {
      // Nothing to accumulate 
      if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.CastExpression")) {
        leftAccumulator = firstCommon;
      }
      if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression")) {
        leftAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression"), "condition", true);
        SNodeOperations.detachNode(leftAccumulator);
      }
      if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
        leftAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", true);
        SNodeOperations.detachNode(leftAccumulator);
      }
    }

    if (rightTurn != null && neq_a65dpo_a0a9a61(rightTurn, firstCommon)) {
      // Accumulate nodes on the path from the right paren 
      rightAccumulator = SLinkOperations.getTarget(rightTurn, "leftExpression", true);
      SNodeOperations.detachNode(rightAccumulator);
      SNode current = SNodeOperations.cast(SNodeOperations.getParent(rightTurn), "jetbrains.mps.baseLanguage.structure.Expression");
      SNode previous = rightTurn;
      while (neq_a65dpo_a0a5a9a61(current, firstCommon) && !(SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression") || SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.CastExpression"))) {
        if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation") && eq_a65dpo_a0a0a5a9a61(SLinkOperations.getTarget(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", true), previous)) {
          SNodeOperations.replaceWithAnother(current, previous);
          SLinkOperations.setTarget(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", rightAccumulator, true);
          rightAccumulator = current;
        } else {
          previous = current;
        }
        current = SNodeOperations.cast(SNodeOperations.getParent(previous), "jetbrains.mps.baseLanguage.structure.Expression");
      }

    } else {
      // Nothing to accumulate 
      if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.CastExpression")) {
        rightAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.CastExpression"), "expression", true);
      }
      if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression")) {
        rightAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression"), "ifFalse", true);
      }
      if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
        rightAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", true);
      }
      SNodeOperations.detachNode(rightAccumulator);
    }

    assert leftAccumulator != null;
    assert rightAccumulator != null;
    SNode parens = SNodeFactoryOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
    if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
      ParenthesisUtil.hookInBinaryOperation(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), rightTurn, leftTurn, parens, rightAccumulator, leftAccumulator);
    } else if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.CastExpression")) {
      ParenthesisUtil.hookInCastExpression(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.CastExpression"), rightTurn, parens, rightAccumulator);

    } else if (SNodeOperations.isInstanceOf(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression")) {
      ParenthesisUtil.hookInTernaryOperator(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression"), rightTurn, leftTurn, parens, rightAccumulator, leftAccumulator);
    } else {
      assert false;
    }
    SLinkOperations.setTarget(parens, "expression", firstCommon, true);
    return parens;
  }




  private static void hookInBinaryOperation(SNode firstCommon, SNode rightTurn, SNode leftTurn, SNode parens, SNode rightAccumulator, SNode leftAccumulator) {

    if (leftTurn == rightTurn) {
      SNodeOperations.replaceWithAnother(firstCommon, parens);
      SLinkOperations.setTarget(firstCommon, "leftExpression", leftAccumulator, true);
      SLinkOperations.setTarget(firstCommon, "rightExpression", rightAccumulator, true);
      SLinkOperations.setTarget(parens, "expression", firstCommon, true);
      return;
    }

    SNode leftSide = SLinkOperations.getTarget(firstCommon, "leftExpression", true);
    SNode rightSide = SLinkOperations.getTarget(firstCommon, "rightExpression", true);
    assert leftSide != null || rightSide != null;
    SNode head = (rightSide != null ? rightSide : leftSide);
    SNodeOperations.replaceWithAnother(firstCommon, head);
    SLinkOperations.setTarget(parens, "expression", firstCommon, true);
    SLinkOperations.setTarget(firstCommon, "leftExpression", leftAccumulator, true);
    SLinkOperations.setTarget(firstCommon, "rightExpression", rightAccumulator, true);
    SNode subtree;
    if (leftSide != null) {
      subtree = leftSide;
      SLinkOperations.setTarget(leftTurn, "rightExpression", parens, true);
    } else {
      subtree = parens;
    }
    if (rightSide != null) {
      SLinkOperations.setTarget(rightTurn, "leftExpression", subtree, true);
    }
  }



  private static void hookInCastExpression(SNode firstCommon, SNode rightTurn, SNode parens, SNode rightAccumulator) {
    if (rightTurn != null) {
      SNodeOperations.replaceWithAnother(firstCommon, rightTurn);
      SLinkOperations.setTarget(rightTurn, "leftExpression", parens, true);
    } else {
      SNodeOperations.replaceWithAnother(firstCommon, parens);
    }
    SLinkOperations.setTarget(parens, "expression", firstCommon, true);
    SLinkOperations.setTarget(firstCommon, "expression", rightAccumulator, true);
  }



  private static void hookInTernaryOperator(SNode firstCommon, SNode rightTurn, SNode leftTurn, SNode parens, SNode rightAccumulator, SNode leftAccumulator) {

    SNode bottomMostTernary = ParenthesisUtil.findBottomMostTernary(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression"));
    if (rightTurn != null) {
      SNodeOperations.replaceWithAnother(firstCommon, SLinkOperations.getTarget(bottomMostTernary, "ifFalse", true));
      if (leftTurn != null) {
        SLinkOperations.setTarget(rightTurn, "leftExpression", SLinkOperations.getTarget(firstCommon, "condition", true), true);
        SLinkOperations.setTarget(leftTurn, "rightExpression", parens, true);
      } else {
        SLinkOperations.setTarget(rightTurn, "leftExpression", parens, true);
      }
    } else {
      if (leftTurn != null) {
        SNodeOperations.replaceWithAnother(firstCommon, SLinkOperations.getTarget(firstCommon, "condition", true));
        SLinkOperations.setTarget(leftTurn, "rightExpression", parens, true);
      } else {
        SNodeOperations.replaceWithAnother(firstCommon, parens);
      }
    }
    SLinkOperations.setTarget(bottomMostTernary, "ifFalse", rightAccumulator, true);
    SLinkOperations.setTarget(firstCommon, "condition", leftAccumulator, true);
  }



  /**
   * Ternary expressions can be nested in one anothers ifFalse child. Find the right-most one.
   */
  private static SNode findBottomMostTernary(SNode bottomMostTernary) {
    while (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(bottomMostTernary, "ifFalse", true), "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression")) {
      bottomMostTernary = SNodeOperations.cast(SLinkOperations.getTarget(bottomMostTernary, "ifFalse", true), "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression");
    }
    return bottomMostTernary;
  }




  /**
   * Remove the found matching paren annotation from its node
   */
  private static void clearIncompleteParens(SNode otherExpression, boolean completingByRightParen) {
    if (completingByRightParen) {
      AttributeOperations.setAttribute(otherExpression, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteLeftParen"), null);
    } else {
      AttributeOperations.setAttribute(otherExpression, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteRightParen"), null);
    }
  }




  /**
   * Climb up the ancestor expressions and return the first binary operation, in which we come from the right sub-tree.
   * 
   * @param stopNode Never climb beyond this node
   */
  private static SNode findLeftTurn(SNode leaf, SNode stopNode) {
    return findTurn(leaf, stopNode, true);
  }



  /**
   * Climb up the ancestor expressions and return the first binary operation, in which we come from the left sub-tree.
   * 
   * @param stopNode Never climb beyond this node
   */
  private static SNode findRightTurn(SNode leaf, SNode stopNode) {
    return findTurn(leaf, stopNode, false);
  }



  private static SNode findTurn(SNode leaf, SNode stopNode, boolean leftTurn) {
    SNode currentNode = SNodeOperations.getParent(leaf);
    SNode previous = leaf;
    while (neq_a65dpo_a0c0jb(previous, stopNode)) {
      if (SNodeOperations.isInstanceOf(currentNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
        final SNode currentBinaryExpr = SNodeOperations.cast(currentNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
        if (leftTurn && eq_a65dpo_a0a1a0a2a53(SLinkOperations.getTarget(currentBinaryExpr, "rightExpression", true), previous)) {
          return currentBinaryExpr;
        }
        if (!(leftTurn) && eq_a65dpo_a0a2a0a2a53(SLinkOperations.getTarget(currentBinaryExpr, "leftExpression", true), previous)) {
          return currentBinaryExpr;
        }
      }
      previous = currentNode;
      currentNode = SNodeOperations.getParent(currentNode);
    }
    return (SNodeOperations.isInstanceOf(stopNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation") ? SNodeOperations.cast(stopNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation") : null);
  }




  /**
   * Find all the ancestor expressions of leaf that could be wrapped in parens.
   * Stops when the parent current expression could no longer be parenthesised.
   */
  private static List<SNode> parentPath(SNode leaf, boolean rightParen) {
    List<SNode> path = new ArrayList<SNode>();
    ListSequence.fromList(path).addElement(leaf);

    for (SNode currentNode = SNodeOperations.getParent(leaf); SNodeOperations.isInstanceOf(currentNode, "jetbrains.mps.baseLanguage.structure.Expression"); currentNode = SNodeOperations.getParent(currentNode)) {
      ListSequence.fromList(path).addElement(SNodeOperations.cast(currentNode, "jetbrains.mps.baseLanguage.structure.Expression"));

      // Notes: 
      // binary operation cannot be a parent of ternary operator expression, parens around ternary are required 

      if (SNodeOperations.isInstanceOf(currentNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
        continue;
      }
      if (SNodeOperations.isInstanceOf(currentNode, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression") && !(ListSequence.fromList(SNodeOperations.getAncestors(leaf, null, false)).contains(SLinkOperations.getTarget(SNodeOperations.cast(currentNode, "jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression"), "ifTrue", true)))) {
        continue;
      }
      if (SNodeOperations.isInstanceOf(currentNode, "jetbrains.mps.baseLanguage.structure.CastExpression") && rightParen && isTheRightMostExpression(SLinkOperations.getTarget(SNodeOperations.cast(currentNode, "jetbrains.mps.baseLanguage.structure.CastExpression"), "expression", true), leaf)) {
        continue;
      } else if (SNodeOperations.isInstanceOf(currentNode, "jetbrains.mps.baseLanguage.structure.DotExpression") && !(rightParen)) {
        continue;
      } else {
        break;
      }
    }
    return path;
  }




  /**
   * Strictly following binary operations, is the leaf the right-most leaf under the root?
   * Useful to detect right parens added behind an expression inside e.g. a CastExpression
   */
  private static boolean isTheRightMostExpression(final SNode root, final SNode leaf) {
    if (!(SNodeOperations.isInstanceOf(root, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return eq_a65dpo_a0a0a0pb(root, leaf);
    }
    SNode binOp = SNodeOperations.cast(root, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
    return isTheRightMostExpression(SLinkOperations.getTarget(binOp, "rightExpression", true), leaf);
  }



  public static void checkOperationWRTPriority(SNode binOp) {
    checkOperationChildWRTPriority(binOp, false);
    checkOperationChildWRTPriority(binOp, true);
    checkOpeartionParentWRTPriority(binOp);
  }

  private static void checkOperationChildWRTPriority(SNode node, boolean isRight) {
    SNode sideExpr = (isRight ? SLinkOperations.getTarget(node, "rightExpression", true) : SLinkOperations.getTarget(node, "leftExpression", true));
    if (SNodeOperations.isInstanceOf(sideExpr, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
      SNode sideChild = SNodeOperations.cast(sideExpr, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
      if (isBadPriority(sideChild, node, isRight)) {
        ParenthesisUtil.rotateTree(sideChild, node, isRight);
        checkOperationWRTPriority(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"));
      }
    }
  }

  private static void checkOpeartionParentWRTPriority(SNode node) {
    if (SNodeOperations.getParent(node) == null) {
      return;
    }
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
      SNode parent = SNodeOperations.cast(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.BinaryOperation");
      boolean isRight = false;
      if (SLinkOperations.getTarget(parent, "rightExpression", true) == node) {
        isRight = true;
      } else if (SLinkOperations.getTarget(parent, "leftExpression", true) == node) {
        isRight = false;
      }
      if (ParenthesisUtil.isBadPriority(node, parent, isRight)) {
        ParenthesisUtil.rotateTree(node, parent, isRight);
        checkOpeartionParentWRTPriority(node);
      }
    }
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.AbstractUnaryNumberOperation")) {
      SNode parent = SNodeOperations.cast(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.AbstractUnaryNumberOperation");
      SLinkOperations.setTarget(parent, "expression", SLinkOperations.getTarget(node, "leftExpression", true), true);
      SNodeOperations.replaceWithAnother(parent, node);
      SLinkOperations.setTarget(node, "leftExpression", parent, true);
    }
  }

  public static SNode getBinOp(SNode expr, boolean toRight) {
    SNode parent = SNodeOperations.getParent(expr);
    if (!(SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return null;
    }
    SNode parentOp = SNodeOperations.cast(parent, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
    boolean right = toRight && SLinkOperations.getTarget(parentOp, "leftExpression", true) == expr;
    boolean left = !(toRight) && SLinkOperations.getTarget(parentOp, "rightExpression", true) == expr;
    if (right || left) {
      return parentOp;
    }
    return getBinOp(parentOp, toRight);
  }

  public static void rotateTree(SNode child, SNode op, boolean isRight) {
    SNode backsideExpr = (isRight ? SLinkOperations.getTarget(child, "leftExpression", true) : SLinkOperations.getTarget(child, "rightExpression", true));
    SNodeOperations.detachNode(child);
    SNodeOperations.replaceWithAnother(op, child);
    SNodeOperations.replaceWithAnother(backsideExpr, op);
    if (isRight) {
      SLinkOperations.setTarget(op, "rightExpression", backsideExpr, true);
    } else {
      SLinkOperations.setTarget(op, "leftExpression", backsideExpr, true);
    }
  }

  public static boolean isBadPriority(SNode child, SNode parent, boolean isRight) {
    return BehaviorReflection.invokeVirtualStatic(Integer.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(child))), "virtual_getPriority_1262430001741497858", new Object[]{}) < BehaviorReflection.invokeVirtualStatic(Integer.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(parent))), "virtual_getPriority_1262430001741497858", new Object[]{}) || (isRight && ((int) BehaviorReflection.invokeVirtualStatic(Integer.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(child))), "virtual_getPriority_1262430001741497858", new Object[]{})) == ((int) BehaviorReflection.invokeVirtualStatic(Integer.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(parent))), "virtual_getPriority_1262430001741497858", new Object[]{})));
  }

  private static boolean eq_a65dpo_a0a0c0m0g(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0a0a5a2a21a6(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0a0a5a2a21a6_0(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean neq_a65dpo_a0a7a61(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean eq_a65dpo_a0a0a5a7a61(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean neq_a65dpo_a0f0h0q(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean eq_a65dpo_a0a0a5a9a61(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean neq_a65dpo_a0a5a9a61(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean neq_a65dpo_a0a9a61(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean eq_a65dpo_a0a1a0a2a53(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0a2a0a2a53(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean neq_a65dpo_a0c0jb(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean eq_a65dpo_a0a0a0pb(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
