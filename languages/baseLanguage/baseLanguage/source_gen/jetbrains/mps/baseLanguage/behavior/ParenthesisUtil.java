package jetbrains.mps.baseLanguage.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.ArrayList;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import org.jetbrains.mps.openapi.language.SConceptRepository;
import jetbrains.mps.util.NameUtil;

public class ParenthesisUtil {
  public ParenthesisUtil() {
  }

  public static SNode createParenthesis(@NotNull SNode expression, boolean opening) {
    // todo remove the method 
    SNode current = expression;
    SNode prev = expression;
    while (current != null && !(SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      prev = current;
      if (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(current), "jetbrains.mps.baseLanguage.structure.Expression"))) {
        break;
      }
      current = SNodeOperations.cast(SNodeOperations.getParent(current), "jetbrains.mps.baseLanguage.structure.Expression");
    }
    current = prev;
    // searching for binary operation 
    SNode binOp = getBinOp(current, opening);
    // special cases 
    if (binOp == null) {
      SNode parExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
      SNodeOperations.replaceWithAnother(current, parExpr);
      SLinkOperations.setTarget(parExpr, "expression", current, true);
      return parExpr;
    }
    boolean left = opening && SLinkOperations.getTarget(binOp, "leftExpression", true) == current;
    boolean right = !(opening) && SLinkOperations.getTarget(binOp, "rightExpression", true) == current;
    if (left || right) {
      SNode parExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(binOp), "jetbrains.mps.baseLanguage.structure.ParenthesizedExpression")) {
        SNodeOperations.replaceWithAnother(current, parExpr);
        SLinkOperations.setTarget(parExpr, "expression", current, true);
      } else {
        SNodeOperations.replaceWithAnother(binOp, parExpr);
        SLinkOperations.setTarget(parExpr, "expression", binOp, true);
      }
      return parExpr;
    }
    // rotate 
    SNode subtree = (opening ? SLinkOperations.getTarget(binOp, "leftExpression", true) : SLinkOperations.getTarget(binOp, "rightExpression", true));
    SNode parExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
    SNodeOperations.replaceWithAnother(current, parExpr);
    SNodeOperations.replaceWithAnother(subtree, current);
    SNodeOperations.replaceWithAnother(binOp, subtree);
    SLinkOperations.setTarget(parExpr, "expression", binOp, true);
    return parExpr;
  }



  public static SNode createParenthesisNewLeft(@NotNull SNode expression) {
    AttributeOperations.setAttribute(expression, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteLeftParen"), SNodeFactoryOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IncompleteLeftParen", null));
    return expression;
  }

  public static SNode createParenthesisNewRight(@NotNull SNode rightExpression) {
    List<SNode> rightParentPath = parentPath(rightExpression);
    SNode topExp = ListSequence.fromList(rightParentPath).last();
    List<SNode> leftParentedNodes = ListSequence.fromList(SNodeOperations.getDescendants(topExp, "jetbrains.mps.baseLanguage.structure.Expression", false, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (AttributeOperations.getAttribute(it, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteLeftParen")) != null);
      }
    }).toListSequence();


    int index = ListSequence.fromList(leftParentedNodes).count() - 1;
    SNode leftExpression = null;
    final Wrappers._T<List<SNode>> leftParentPath = new Wrappers._T<List<SNode>>(null);
    SNode firstCommon = null;

    while (index >= 0) {
      leftExpression = ListSequence.fromList(leftParentedNodes).getElement(index);
      leftParentPath.value = parentPath(leftExpression);

      if (eq_a65dpo_a0d0k0e(ListSequence.fromList(leftParentPath.value).last(), topExp)) {
        if (eq_a65dpo_a0a0d0k0e(leftExpression, rightExpression)) {
          // the have a comon ancestor 
          AttributeOperations.setAttribute(leftExpression, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteLeftParen"), null);
          SNode parens = SNodeFactoryOperations.replaceWithNewChild(leftExpression, "jetbrains.mps.baseLanguage.structure.ParenthesizedExpression");
          SLinkOperations.setTarget(parens, "expression", leftExpression, true);
          return parens;
        }

        firstCommon = ListSequence.fromList(rightParentPath).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return ListSequence.fromList(leftParentPath.value).contains(it);
          }
        });
        assert firstCommon != null;
        if (eq_a65dpo_a0a4a3a01a4_0(firstCommon, leftExpression) || eq_a65dpo_a0a4a3a01a4(firstCommon, rightExpression)) {
          // one of the parenthesised nodes is the common ancestor 
          AttributeOperations.setAttribute(leftExpression, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteLeftParen"), null);
          SNode parens = SNodeFactoryOperations.replaceWithNewChild(firstCommon, "jetbrains.mps.baseLanguage.structure.ParenthesizedExpression");
          SLinkOperations.setTarget(parens, "expression", firstCommon, true);
          return parens;
        }

        SNode leftPredecesor = ListSequence.fromList(leftParentPath.value).getElement(ListSequence.fromList(leftParentPath.value).indexOf(firstCommon) - 1);
        SNode rightPredecesor = ListSequence.fromList(rightParentPath).getElement(ListSequence.fromList(rightParentPath).indexOf(firstCommon) - 1);
        // Does left parented node come from the left and right parented node from the right? 
        if (eq_a65dpo_a0a9a3a01a4_0(SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", true), leftPredecesor) && eq_a65dpo_a0a9a3a01a4(SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", true), rightPredecesor)) {
          break;
        }
      }
      index--;
    }

    if (index == -1 || (leftParentPath.value != null && neq_a65dpo_a0a0a21a4(ListSequence.fromList(leftParentPath.value).last(), topExp))) {
      // no common ancestor or swapped left-right -> can't parenthesise 
      AttributeOperations.setAttribute(rightExpression, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteRightParen"), SNodeFactoryOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IncompleteRightParen", null));
      return rightExpression;
    }

    AttributeOperations.setAttribute(leftExpression, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.IncompleteLeftParen"), null);

    SNode leftTurn = findLeftTurn(leftExpression, SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"));
    SNode rightTurn = findRightTurn(rightExpression, SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"));
    if (eq_a65dpo_a0s0e(leftTurn, rightTurn)) {
      assert eq_a65dpo_a0a0s0e(leftTurn, firstCommon);
      SNode parens = SNodeFactoryOperations.replaceWithNewChild(leftTurn, "jetbrains.mps.baseLanguage.structure.ParenthesizedExpression");
      SLinkOperations.setTarget(parens, "expression", leftTurn, true);
      return parens;
    }

    SNode leftAccumulator;
    SNode rightAccumulator;
    if (neq_a65dpo_a0w0e(leftTurn, firstCommon)) {
      leftAccumulator = SLinkOperations.getTarget(leftTurn, "rightExpression", true);
      SNodeOperations.detachNode(leftAccumulator);
      SNode current = SNodeOperations.cast(SNodeOperations.getParent(leftTurn), "jetbrains.mps.baseLanguage.structure.Expression");
      SNode previous = leftTurn;
      while (neq_a65dpo_a0e0w0e(current, firstCommon)) {
        if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation") && eq_a65dpo_a0a0a4a22a4(SLinkOperations.getTarget(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", true), previous)) {
          SNodeOperations.replaceWithAnother(current, previous);
          SLinkOperations.setTarget(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", leftAccumulator, true);
          leftAccumulator = current;
        } else {
          previous = current;
        }
        current = SNodeOperations.cast(SNodeOperations.getParent(previous), "jetbrains.mps.baseLanguage.structure.Expression");
      }
    } else {
      leftAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", true);
      SNodeOperations.detachNode(leftAccumulator);
    }

    if (neq_a65dpo_a0y0e(rightTurn, firstCommon)) {
      rightAccumulator = SLinkOperations.getTarget(rightTurn, "leftExpression", true);
      SNodeOperations.detachNode(rightAccumulator);
      SNode current = SNodeOperations.cast(SNodeOperations.getParent(rightTurn), "jetbrains.mps.baseLanguage.structure.Expression");
      SNode previous = rightTurn;
      while (neq_a65dpo_a0e0y0e(current, firstCommon)) {
        if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation") && eq_a65dpo_a0a0a4a42a4(SLinkOperations.getTarget(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", true), previous)) {
          SNodeOperations.replaceWithAnother(current, previous);
          SLinkOperations.setTarget(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", rightAccumulator, true);
          rightAccumulator = current;
        } else {
          previous = current;
        }
        current = SNodeOperations.cast(SNodeOperations.getParent(previous), "jetbrains.mps.baseLanguage.structure.Expression");
      }
    } else {
      rightAccumulator = SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", true);
      SNodeOperations.detachNode(rightAccumulator);
    }

    SNode parens = SNodeFactoryOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
    if ((SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", true) != null)) {
      SNodeOperations.replaceWithAnother(firstCommon, SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", true));
      if ((SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", true) != null)) {
        SLinkOperations.setTarget(rightTurn, "leftExpression", SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", true), true);
        SLinkOperations.setTarget(leftTurn, "rightExpression", parens, true);
      } else {
        SLinkOperations.setTarget(rightTurn, "leftExpression", parens, true);
      }
    } else {
      SNodeOperations.replaceWithAnother(firstCommon, SLinkOperations.getTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", true));
      SLinkOperations.setTarget(leftTurn, "rightExpression", parens, true);
    }

    SLinkOperations.setTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", rightAccumulator, true);
    SLinkOperations.setTarget(SNodeOperations.cast(firstCommon, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", leftAccumulator, true);
    SLinkOperations.setTarget(parens, "expression", firstCommon, true);
    return rightExpression;
  }



  private static SNode findLeftTurn(SNode leaf, SNode stopNode) {
    return findTurn(leaf, stopNode, true);
  }



  private static SNode findRightTurn(SNode leaf, SNode stopNode) {
    return findTurn(leaf, stopNode, false);
  }



  private static SNode findTurn(SNode leaf, SNode stopNode, boolean leftTurn) {
    SNode currentNode = SNodeOperations.getParent(leaf);
    SNode previous = leaf;
    while (neq_a65dpo_a0c0k(previous, stopNode)) {
      if (SNodeOperations.isInstanceOf(currentNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
        if (leftTurn && eq_a65dpo_a0a0a0a2a01(SLinkOperations.getTarget(SNodeOperations.cast(currentNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "rightExpression", true), previous)) {
          return SNodeOperations.cast(currentNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
        }
        if (!(leftTurn) && eq_a65dpo_a0a1a0a2a01(SLinkOperations.getTarget(SNodeOperations.cast(currentNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation"), "leftExpression", true), previous)) {
          return SNodeOperations.cast(currentNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
        }
      }
      previous = currentNode;
      currentNode = SNodeOperations.getParent(currentNode);
    }
    return stopNode;
  }



  private static List<SNode> parentPath(SNode leaf) {
    SNode currentNode = SNodeOperations.getParent(leaf);
    List<SNode> path = new ArrayList<SNode>();
    ListSequence.fromList(path).addElement(leaf);
    while ((SNodeOperations.isInstanceOf(currentNode, "jetbrains.mps.baseLanguage.structure.Expression"))) {
      ListSequence.fromList(path).addElement(SNodeOperations.cast(currentNode, "jetbrains.mps.baseLanguage.structure.Expression"));
      currentNode = SNodeOperations.getParent(currentNode);
      if (!(SNodeOperations.isInstanceOf(currentNode, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
        break;
      }
    }
    return path;
  }



  public static void checkOperationWRTPriority(SNode binOp) {
    checkOperationChildWRTPriority(binOp, false);
    checkOperationChildWRTPriority(binOp, true);
    checkOpeartionParentWRTPriority(binOp);
  }

  private static void checkOperationChildWRTPriority(SNode node, boolean isRight) {
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return;
    }
    SNode binOp = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
    SNode sideExpr = (isRight ? SLinkOperations.getTarget(binOp, "rightExpression", true) : SLinkOperations.getTarget(binOp, "leftExpression", true));
    if (SNodeOperations.isInstanceOf(sideExpr, "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
      SNode sideChild = SNodeOperations.cast(sideExpr, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
      if (isBadPriority(sideChild, binOp, isRight)) {
        ParenthesisUtil.rotateTree(sideChild, binOp, isRight);
        checkOperationWRTPriority(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BinaryOperation"));
      }
    }
  }

  private static void checkOpeartionParentWRTPriority(SNode node) {
    if (SNodeOperations.getParent(node) == null) {
      return;
    }
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.BinaryOperation")) {
      SNode parent = SNodeOperations.cast(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.BinaryOperation");
      boolean isRight = false;
      if (SLinkOperations.getTarget(parent, "rightExpression", true) == node) {
        isRight = true;
      } else if (SLinkOperations.getTarget(parent, "leftExpression", true) == node) {
        isRight = false;
      }
      if (ParenthesisUtil.isBadPriority(node, parent, isRight)) {
        ParenthesisUtil.rotateTree(node, parent, isRight);
        checkOpeartionParentWRTPriority(node);
      }
    }
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.AbstractUnaryNumberOperation")) {
      SNode parent = SNodeOperations.cast(SNodeOperations.getParent(node), "jetbrains.mps.baseLanguage.structure.AbstractUnaryNumberOperation");
      SLinkOperations.setTarget(parent, "expression", SLinkOperations.getTarget(node, "leftExpression", true), true);
      SNodeOperations.replaceWithAnother(parent, node);
      SLinkOperations.setTarget(node, "leftExpression", parent, true);
    }
  }

  public static SNode getBinOp(SNode expr, boolean toRight) {
    SNode parent = SNodeOperations.getParent(expr);
    if (!(SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.BinaryOperation"))) {
      return null;
    }
    SNode parentOp = SNodeOperations.cast(parent, "jetbrains.mps.baseLanguage.structure.BinaryOperation");
    boolean right = toRight && SLinkOperations.getTarget(parentOp, "leftExpression", true) == expr;
    boolean left = !(toRight) && SLinkOperations.getTarget(parentOp, "rightExpression", true) == expr;
    if (right || left) {
      return parentOp;
    }
    return getBinOp(parentOp, toRight);
  }

  public static void rotateTree(SNode child, SNode op, boolean isRight) {
    SNode backsideExpr = (isRight ? SLinkOperations.getTarget(child, "leftExpression", true) : SLinkOperations.getTarget(child, "rightExpression", true));
    SNodeOperations.detachNode(child);
    SNodeOperations.replaceWithAnother(op, child);
    SNodeOperations.replaceWithAnother(backsideExpr, op);
    if (isRight) {
      SLinkOperations.setTarget(op, "rightExpression", backsideExpr, true);
    } else {
      SLinkOperations.setTarget(op, "leftExpression", backsideExpr, true);
    }
  }

  public static boolean isBadPriority(SNode child, SNode parent, boolean isRight) {
    return BehaviorReflection.invokeVirtualStatic(Integer.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(child))), "virtual_getPriority_1262430001741497858", new Object[]{}) < BehaviorReflection.invokeVirtualStatic(Integer.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(parent))), "virtual_getPriority_1262430001741497858", new Object[]{}) || (isRight && ((int) BehaviorReflection.invokeVirtualStatic(Integer.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(child))), "virtual_getPriority_1262430001741497858", new Object[]{})) == ((int) BehaviorReflection.invokeVirtualStatic(Integer.TYPE, SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(parent))), "virtual_getPriority_1262430001741497858", new Object[]{})));
  }

  private static boolean eq_a65dpo_a0a0d0k0e(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0a4a3a01a4(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0a4a3a01a4_0(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0a9a3a01a4(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0a9a3a01a4_0(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0d0k0e(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean neq_a65dpo_a0a0a21a4(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean eq_a65dpo_a0a0s0e(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0s0e(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0a0a4a22a4(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean neq_a65dpo_a0e0w0e(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean neq_a65dpo_a0w0e(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean eq_a65dpo_a0a0a4a42a4(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean neq_a65dpo_a0e0y0e(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean neq_a65dpo_a0y0e(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean eq_a65dpo_a0a0a0a2a01(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean eq_a65dpo_a0a1a0a2a01(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }

  private static boolean neq_a65dpo_a0c0k(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }
}
