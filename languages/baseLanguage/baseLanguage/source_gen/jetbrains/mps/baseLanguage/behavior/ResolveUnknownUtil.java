package jetbrains.mps.baseLanguage.behavior;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.search.MethodResolveUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.baseLanguage.scopes.ClassifiersScope;
import java.util.List;

public class ResolveUnknownUtil {
  private static Logger LOG = LogManager.getLogger(ResolveUnknownUtil.class);

  public ResolveUnknownUtil() {
  }

  public static _FunctionTypes._return_P0_E0<? extends SNode> resolveQualNameRef(SNode x) {
    final SNode result = ResolveUnknownUtil.resolveTokens(x);

    if ((result == null)) {
      return null;
    }
    if (SNodeOperations.isInstanceOf(result, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      // change to something real as default, e.g. static field access expression without the field 
      return new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          SNode fieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldReference", null);
          SLinkOperations.setTarget(fieldRef, "classifier", SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.Classifier"), false);
          return fieldRef;
        };;
;      };
    }

    if (SNodeOperations.isInstanceOf(result, "jetbrains.mps.baseLanguage.structure.Expression")) {
      return new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          return result;
        };;
;      };
    }

    return null;
  };;
;
  public static _FunctionTypes._return_P0_E0<? extends SNode> resolveConsCall(final SNode x) {
    SNode enclosingClass = SNodeOperations.getAncestor(x, "jetbrains.mps.baseLanguage.structure.ClassConcept", false, false);
    if ((enclosingClass == null)) {
      return null;
    }
    final SNode foundCons = ResolveUnknownUtil.findConstructor(enclosingClass, SLinkOperations.getTargets(x, "actualArgument", true));
    if ((foundCons == null)) {
      return null;
    }

    // success 
    return new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNode result = (SPropertyOperations.getBoolean(x, "isSuper") ? SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SuperConstructorInvocation", null) : SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ThisConstructorInvocation", null));
        reattachMethodArguments(x, result);
        SLinkOperations.setTarget(result, "baseMethodDeclaration", foundCons, false);
        return result;
      };;
;    };
  };;
;
  public static _FunctionTypes._return_P0_E0<? extends SNode> resolveLocalCall(final SNode x) {
    final Wrappers._T<SNode> call = new Wrappers._T<SNode>(null);

    Scope methodsScope = Scope.getScope(SNodeOperations.getParent(x), x, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.MethodDeclaration"));

    if (methodsScope == null) {
      return null;
    }

    SNode node = methodsScope.resolve(x, SPropertyOperations.getString(x, "callee"));
    if ((node == null)) {
      return null;
    }

    if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")) {
      SNode decl = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration");
      SNode scall = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodCall", null);
      SLinkOperations.setTarget(scall, "baseMethodDeclaration", decl, false);
      call.value = scall;

    } else if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
      SNode decl = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration");
      SNode icall = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LocalMethodCall", null);
      SLinkOperations.setTarget(icall, "baseMethodDeclaration", decl, false);
      call.value = icall;
    }

    if ((call.value == null)) {
      return null;
    }

    return new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        reattachMethodArguments(x, call.value);
        return call.value;
      };;
;    };
  };;
;
  public static _FunctionTypes._return_P0_E0<? extends SNode> resolveNew(final SNode x) {
    final SNode typ = findClass(x, SPropertyOperations.getString(x, "className"));
    if ((typ == null)) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(typ, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
      return null;
    }

    return new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {

        SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
        SNode creator;

        Tuples._2<SNode, Boolean> resolveResult = MethodResolveUtil.resolveMethod(x, "");
        SNode ctor = (resolveResult == null ? null : SNodeOperations.as(resolveResult._0(), "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration"));

        if ((ctor == null)) {

          // we can't use default constructor in this case 
          if (ListSequence.fromList(SLinkOperations.getTargets(x, "actualArgument", true)).isNotEmpty()) {
            return null;
          }

          SNode defaultConsCreator = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DefaultClassCreator", null);
          SLinkOperations.setTarget(defaultConsCreator, "classifier", typ, false);
          for (SNode arg : ListSequence.fromList(SLinkOperations.getTargets(x, "typeArgument", true))) {
            SNodeOperations.detachNode(arg);
            ListSequence.fromList(SLinkOperations.getTargets(defaultConsCreator, "typeParameter", true)).addElement(arg);
          }

          creator = defaultConsCreator;

        } else {

          SNode classCreator = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassCreator", null);

          reattachMethodArguments(x, classCreator);
          for (SNode arg : ListSequence.fromList(SLinkOperations.getTargets(x, "typeArgument", true))) {
            SNodeOperations.detachNode(arg);
            ListSequence.fromList(SLinkOperations.getTargets(classCreator, "typeParameter", true)).addElement(arg);
          }

          SLinkOperations.setTarget(classCreator, "baseMethodDeclaration", ctor, false);
          creator = classCreator;
        }

        SLinkOperations.setTarget(result, "creator", creator, true);
        return result;
      };;
;    };
  };;
;
  public static _FunctionTypes._return_P0_E0<? extends SNode> resolveDotCall(final SNode x) {
    final SNode operand = ResolveUnknownUtil.resolveTokens(x);

    final String className = null;

    if ((operand == null)) {
      return null;
    }

    if (SNodeOperations.isInstanceOf(operand, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      final SNode target = ((operand == null) ? null : SNodeOperations.cast(operand, "jetbrains.mps.baseLanguage.structure.Classifier"));

      if ((target != null) && !(SNodeOperations.isInstanceOf(target, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
        return null;
      }

      return new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          SNode call = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodCall", null);
          if ((target != null)) {
            SLinkOperations.setTarget(call, "classConcept", SNodeOperations.cast(target, "jetbrains.mps.baseLanguage.structure.ClassConcept"), false);
          } else {
            call.setReference(new DynamicReference("classConcept", call, null, className).getRole(), new DynamicReference("classConcept", call, null, className));
          }
          SReference sref = new DynamicReference("baseMethodDeclaration", call, null, SPropertyOperations.getString(x, "callee"));
          call.setReference(sref.getRole(), sref);
          reattachMethodArguments(x, call);
          reattachTypeArguments(x, call);
          return call;
        };;
;      };

    } else if (SNodeOperations.isInstanceOf(operand, "jetbrains.mps.baseLanguage.structure.Expression")) {
      // operand is some other expression. it's supposed to be an instance method call then 

      return new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          SNode dotExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DotExpression", null);
          SLinkOperations.setTarget(dotExpr, "operand", SNodeOperations.cast(operand, "jetbrains.mps.baseLanguage.structure.Expression"), true);

          SNode call = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation", null);
          SLinkOperations.setTarget(dotExpr, "operation", call, true);

          SReference sref = new DynamicReference("baseMethodDeclaration", call, null, SPropertyOperations.getString(x, "callee"));
          call.setReference(sref.getRole(), sref);

          reattachMethodArguments(x, call);
          reattachTypeArguments(x, call);
          return dotExpr;
        };;
;      };

    } else {
      return null;

    }

  };;
;
  public static SNode resolveTokens(SNode x) {
    // returns either node<Expression> with a normal baseLanguage expression 
    // or node<Classifier> if all tokens form a name class 
    // returns null if could not resolve 

    String[] tokens = SPropertyOperations.getString(x, "tokens").split("\\.");

    SNode operand = null;
    int tokPos = 0;

    SNode mbVarRef = ResolveUnknownUtil.tryFirstTokenAsVarRef(x);

    if ((mbVarRef != null)) {
      // it's a variable 
      operand = mbVarRef;
      tokPos = 1;

    } else {
      // it must be a class 
      Tuples._2<SNode, Integer> classAndPos = ResolveUnknownUtil.tryFindClass(x);
      if (classAndPos == null) {
        return null;
      }

      SNode cls = classAndPos._0();
      tokPos = (int) classAndPos._1();

      if (tokPos == tokens.length) {
        // no tokens left, all of them form a class name 
        // done 
        return cls;

      } else {
        // there is at least one token that must represent a static field (or enum constant) 

        final String memberName = tokens[tokPos];
        SNode mbEnumConst = null;

        if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
          mbEnumConst = ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.EnumClass"), "enumConstant", true)).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return memberName.equals(SPropertyOperations.getString(it, "name"));
            };;
;          }).first();
        }

        if (mbEnumConst != null) {
          SNode enumRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumConstantReference", null);
          SLinkOperations.setTarget(enumRef, "enumClass", SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.EnumClass"), false);
          SLinkOperations.setTarget(enumRef, "enumConstantDeclaration", mbEnumConst, false);
          operand = enumRef;

        } else {
          SNode statFieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldReference", null);
          SLinkOperations.setTarget(statFieldRef, "classifier", cls, false);
          SReference fieldRef;
          fieldRef = new DynamicReference("variableDeclaration", statFieldRef, null, memberName);
          statFieldRef.setReference(fieldRef.getRole(), fieldRef);
          operand = statFieldRef;
        }
        // +1 is here because static field takes one extra token 
        tokPos = tokPos + 1;
      }
    }

    if ((operand == null)) {
      return null;
    }

    // success. now the structure is determined, only need to put dynamic references to nodes 
    while (tokPos < tokens.length) {
      SNode dotExpr = ResolveUnknownUtil.makeFieldDotExpression(operand, tokens[tokPos]);
      operand = dotExpr;
      tokPos++;
    }

    return operand;
  };;
;
  public static SNode makeFieldDotExpression(SNode holder, String fieldName) {
    SNode dotExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DotExpression", null);
    SLinkOperations.setTarget(dotExpr, "operand", holder, true);
    SNode fieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldReferenceOperation", null);
    SLinkOperations.setTarget(dotExpr, "operation", fieldRef, true);
    SReference sref = new DynamicReference("fieldDeclaration", fieldRef, null, fieldName);
    fieldRef.setReference(sref.getRole(), sref);
    return dotExpr;
  };;
;
  public static SNode tryFirstTokenAsVarRef(SNode x) {
    Scope scope = Scope.getScope(SNodeOperations.getParent(x), x, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.VariableDeclaration"));
    if (scope == null) {
      // TODO make it more informative 
      // <node> 
      return null;
    }

    String name = Tokens_Behavior.call_firstToken_1296023605441710627(x);

    if (Sequence.fromIterable(scope.getAvailableElements(name)).isNotEmpty()) {
      // it's a variable 

      SNode varRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.VariableReference", null);
      SReference sref = new DynamicReference("variableDeclaration", varRef, null, name);
      varRef.setReference(sref.getRole(), sref);

      return varRef;
    } else {
      return null;
    }
  };;
;
  public static Tuples._2<SNode, Integer> tryFindClass(SNode x) {
    StringBuilder sb = new StringBuilder();
    String[] tokens = SPropertyOperations.getString(x, "tokens").split("\\.");

    int[] dotPositions = new int[tokens.length];
    int lastDot = -1;
    int k = 0;

    for (String tok : tokens) {
      sb.append(tok);
      sb.append('.');
      dotPositions[k] = lastDot + tok.length() + 1;
      lastDot = dotPositions[k];
      k++;
    }

    // TODO maybe should return a list of possible s along with their token count 
    // so that the client can choose the right one itself 

    // try the longest name first, the shortest last 
    for (int p = dotPositions.length - 1; p >= 0; p--) {
      String className = sb.substring(0, dotPositions[p]);
      SNode cls = findClass(x, className);
      if ((cls != null)) {

        return MultiTuple.<SNode,Integer>from(cls, p + 1);
      }
    }

    return null;
  };;
;
  public static SNode findClass(SNode from, String className) {
    SNode res = null;

    SNode contextClas = SNodeOperations.getAncestor(from, "jetbrains.mps.baseLanguage.structure.Classifier", true, false);
    ClassifiersScope scope = new ClassifiersScope(SNodeOperations.getModel(from), contextClas, "jetbrains.mps.baseLanguage.structure.Classifier", true);

    SNode claz = scope.resolve(from, className);
    if ((claz == null)) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(claz, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
      return null;
    }

    return SNodeOperations.cast(claz, "jetbrains.mps.baseLanguage.structure.Classifier");
  };;
;
  public static SNode findConstructor(SNode claz, List<SNode> args) {
    SNode result;
    Iterable<SNode> conss = ClassConcept_Behavior.call_constructors_5292274854859503373(claz);
    if (Sequence.fromIterable(conss).isEmpty()) {
      result = null;
    } else if (Sequence.fromIterable(conss).count() == 1) {
      result = Sequence.fromIterable(conss).first();
    } else {
      final int argCount = ListSequence.fromList(args).count();
      Iterable<SNode> subset = Sequence.fromIterable(conss).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return ListSequence.fromList(SLinkOperations.getTargets(it, "parameter", true)).count() == argCount;
        };;
;      });
      result = Sequence.fromIterable(subset).first();
    }
    return result;
  };;
;
  public static void reattachMethodArguments(SNode from, SNode to) {
    for (SNode arg : ListSequence.fromList(SLinkOperations.getTargets(from, "actualArgument", true))) {
      ListSequence.fromList(SLinkOperations.getTargets(to, "actualArgument", true)).addElement(SNodeOperations.copyNode(arg));
    }
  };;
;
  public static void reattachTypeArguments(SNode from, SNode to) {
    for (SNode arg : ListSequence.fromList(SLinkOperations.getTargets(from, "typeArgument", true))) {
      ListSequence.fromList(SLinkOperations.getTargets(to, "typeArgument", true)).addElement(SNodeOperations.copyNode(arg));
    }
  };;
;

;;;  protected static Logger LOG_180675533 = LogManager.getLogger(ResolveUnknownUtil.class);
}
