package jetbrains.mps.baseLanguage.behavior;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.baseLanguage.scopes.ClassifiersScope;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.SModelRepository;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class ResolveUnknownUtil {
  private static Logger LOG = Logger.getLogger(ResolveUnknownUtil.class);

  public ResolveUnknownUtil() {
  }

  public static _FunctionTypes._return_P0_E0<? extends SNode> resolveQualNameRef(SNode x) {
    final SNode result = ResolveUnknownUtil.resolveTokens(x);

    if ((result == null)) {
      return null;
    }
    if (SNodeOperations.isInstanceOf(result, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      // change to something real as default, e.g. static field access expression without the field 
      return new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          SNode fieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldReference", null);
          SLinkOperations.setTarget(fieldRef, "classifier", SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.Classifier"), false);
          return fieldRef;
        }
      };
    }

    if (SNodeOperations.isInstanceOf(result, "jetbrains.mps.baseLanguage.structure.Expression")) {
      return new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          return result;
        }
      };
    }

    return null;
  }

  public static _FunctionTypes._return_P0_E0<? extends SNode> resolveConsCall(final SNode x) {
    SNode enclosingClass = SNodeOperations.getAncestor(x, "jetbrains.mps.baseLanguage.structure.ClassConcept", false, false);
    if ((enclosingClass == null)) {
      return null;
    }
    final SNode foundCons = ResolveUnknownUtil.findConstructor(enclosingClass, SLinkOperations.getTargets(x, "actualArgument", true));
    if ((foundCons == null)) {
      return null;
    }

    // success 
    return new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNode result = (SPropertyOperations.getBoolean(x, "isSuper") ?
          SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SuperConstructorInvocation", null) :
          SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ThisConstructorInvocation", null)
        );
        reattachMethodArguments(x, result);
        SLinkOperations.setTarget(result, "baseMethodDeclaration", foundCons, false);
        return result;
      }
    };
  }

  public static _FunctionTypes._return_P0_E0<? extends SNode> resolveLocalCall(final SNode x) {
    final Wrappers._T<SNode> call = new Wrappers._T<SNode>(null);

    Scope staticMethodsScope = Scope.getScope(SNodeOperations.getParent(x), x, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"));
    Scope instMethodsScope = Scope.getScope(SNodeOperations.getParent(x), x, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"));

    Iterable<SNode> staticMethods = staticMethodsScope.getAvailableElements(SPropertyOperations.getString(x, "callee"));
    Iterable<SNode> instMethods = instMethodsScope.getAvailableElements(SPropertyOperations.getString(x, "callee"));

    if (Sequence.fromIterable(staticMethods).isNotEmpty()) {
      SNode decl = SNodeOperations.cast(Sequence.fromIterable(staticMethods).iterator().next(), "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration");
      SNode scall = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodCall", null);
      SLinkOperations.setTarget(scall, "baseMethodDeclaration", decl, false);
      call.value = scall;

    } else if (Sequence.fromIterable(instMethods).isNotEmpty()) {
      SNode decl = null;
      if (Sequence.fromIterable(instMethods).isNotEmpty()) {
        decl = SNodeOperations.cast(Sequence.fromIterable(instMethods).iterator().next(), "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration");
      }
      SNode icall = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LocalInstanceMethodCall", null);
      SLinkOperations.setTarget(icall, "baseMethodDeclaration", decl, false);
      call.value = icall;
    }

    if ((call.value == null)) {
      return null;
    }

    return new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        reattachMethodArguments(x, call.value);
        return call.value;
      }
    };
  }

  public static _FunctionTypes._return_P0_E0<? extends SNode> resolveNew(final SNode x) {
    SNode typ = findClass(x, SPropertyOperations.getString(x, "className"));
    if ((typ == null)) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(typ, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
      return null;
    }

    final SNode cons = ResolveUnknownUtil.findConstructor(SNodeOperations.cast(typ, "jetbrains.mps.baseLanguage.structure.ClassConcept"), SLinkOperations.getTargets(x, "actualArgument", true));
    if ((cons == null)) {
      return null;
    }

    return new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
        SNode create = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassCreator", null);

        reattachMethodArguments(x, create);
        for (SNode arg : ListSequence.fromList(SLinkOperations.getTargets(x, "typeArgument", true))) {
          SNodeOperations.detachNode(arg);
          ListSequence.fromList(SLinkOperations.getTargets(create, "typeParameter", true)).addElement(arg);
        }

        SLinkOperations.setTarget(create, "baseMethodDeclaration", cons, false);
        SLinkOperations.setTarget(result, "creator", create, true);
        return result;
      }
    };
  }

  public static _FunctionTypes._return_P0_E0<? extends SNode> resolveDotCall(final SNode x) {
    final SNode operand = ResolveUnknownUtil.resolveTokens(x);
    if ((operand == null)) {
      return null;
    }

    if (SNodeOperations.isInstanceOf(operand, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      final SNode target = SNodeOperations.cast(operand, "jetbrains.mps.baseLanguage.structure.Classifier");

      if (!(SNodeOperations.isInstanceOf(target, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
        return null;
      }

      return new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          SNode call = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodCall", null);
          SLinkOperations.setTarget(call, "classConcept", SNodeOperations.cast(target, "jetbrains.mps.baseLanguage.structure.ClassConcept"), false);
          SReference sref = new DynamicReference("staticMethodDeclaration", call, null, SPropertyOperations.getString(x, "callee"));
          call.addReference(sref);
          reattachMethodArguments(x, call);
          return call;
        }
      };

    } else if (SNodeOperations.isInstanceOf(operand, "jetbrains.mps.baseLanguage.structure.Expression")) {
      // operand is some other expression. it's supposed to an instance method call then 

      return new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          SNode dotExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DotExpression", null);
          SLinkOperations.setTarget(dotExpr, "operand", SNodeOperations.cast(operand, "jetbrains.mps.baseLanguage.structure.Expression"), true);

          SNode call = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation", null);
          SLinkOperations.setTarget(dotExpr, "operation", call, true);

          SReference sref = new DynamicReference("instanceMethodDeclaration", call, null, SPropertyOperations.getString(x, "callee"));
          call.addReference(sref);

          reattachMethodArguments(x, call);
          return dotExpr;
        }
      };

    } else {
      return null;
    }

  }

  public static SNode resolveTokens(SNode x) {
    // returns either node<Expression> with a normal baseLanguage expression 
    // or node<Classifier> if all tokens form a name class 
    // returns null if could not resolve 

    SNode operand = null;
    int tokPos = 0;

    SNode mbVarRef = ResolveUnknownUtil.tryFirstTokenAsVarRef(x);

    if ((mbVarRef != null)) {
      // it's a variable 
      operand = mbVarRef;
      tokPos = 1;

      System.err.println("DEBUG: normal dot expr");

    } else {
      // it must be a class 
      Tuples._2<SNode, Integer> classAndPos = ResolveUnknownUtil.tryFindClass(x);
      if (classAndPos == null) {
        return null;
      }

      SNode cls = classAndPos._0();
      tokPos = (int) classAndPos._1();

      if (tokPos == (int) ListSequence.fromList(SLinkOperations.getTargets(x, "token", true)).count()) {
        // no tokens left, all of them form a class name 
        // done 
        return cls;

      } else {
        // there is at least one token that must represent a static field 

        SNode statFieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldReference", null);
        SLinkOperations.setTarget(statFieldRef, "classifier", cls, false);

        SReference fieldRef = new DynamicReference("staticFieldDeclaration", statFieldRef, null, SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(x, "token", true)).getElement(tokPos), "value"));
        statFieldRef.addReference(fieldRef);

        operand = statFieldRef;
        // +1 is here because static field takes one extra token 
        tokPos = tokPos + 1;
      }
    }

    if ((operand == null)) {
      return null;
    }

    // success. now the structure is determined, only need to put dynamic references to nodes 
    while (tokPos < ListSequence.fromList(SLinkOperations.getTargets(x, "token", true)).count()) {
      SNode dotExpr = ResolveUnknownUtil.makeFieldDotExpression(operand, SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(x, "token", true)).getElement(tokPos), "value"));
      operand = dotExpr;
      tokPos++;
    }

    return operand;
  }

  public static SNode makeFieldDotExpression(SNode holder, String fieldName) {
    SNode dotExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DotExpression", null);
    SLinkOperations.setTarget(dotExpr, "operand", holder, true);
    SNode fieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldReferenceOperation", null);
    SLinkOperations.setTarget(dotExpr, "operation", fieldRef, true);
    SReference sref = new DynamicReference("fieldDeclaration", fieldRef, null, fieldName);
    fieldRef.addReference(sref);
    return dotExpr;
  }

  public static SNode tryFirstTokenAsVarRef(SNode x) {
    Scope scope = Scope.getScope(SNodeOperations.getParent(x), x, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.VariableDeclaration"));
    if (scope == null) {
      // TODO make it more informative 
      // <node> 
      return null;
    }

    String name = SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(x, "token", true)).first(), "value");

    if (Sequence.fromIterable(scope.getAvailableElements(name)).isNotEmpty()) {
      // it's a variable 

      System.err.println("First token is a variable: " + name + " " + SPropertyOperations.getString(SNodeOperations.getConceptDeclaration(Sequence.fromIterable(scope.getAvailableElements(name)).first()), "name"));

      SNode varRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.VariableReference", null);
      SReference sref = new DynamicReference("variableDeclaration", varRef, null, name);
      varRef.addReference(sref);

      return varRef;
    } else {
      return null;
    }
  }

  public static Tuples._2<SNode, Integer> tryFindClass(SNode x) {
    StringBuilder sb = new StringBuilder();

    int[] dotPositions = new int[ListSequence.fromList(SLinkOperations.getTargets(x, "token", true)).count()];
    int lastDot = -1;
    int k = 0;

    for (SNode tok : ListSequence.fromList(SLinkOperations.getTargets(x, "token", true))) {
      sb.append(SPropertyOperations.getString(tok, "value"));
      sb.append('.');
      dotPositions[k] = lastDot + SPropertyOperations.getString(tok, "value").length() + 1;
      lastDot = dotPositions[k];
      k++;
    }

    // TODO maybe should return a list of possible classifiers along with their token count 
    // so that the client can choose the right one itself 

    // try the longest name first, the shortest last 
    for (int p = dotPositions.length - 1; p >= 0; p--) {
      String className = sb.substring(0, dotPositions[p]);
      SNode cls = findClass(x, className);
      if ((cls != null)) {

        return MultiTuple.<SNode,Integer>from(cls, p + 1);
      }
    }

    return null;
  }

  public static SNode findClass(SNode from, String className) {
    SNode res = null;

    ClassifiersScope scope = new ClassifiersScope(SNodeOperations.getModel(from), new GlobalScope(MPSModuleRepository.getInstance(), SModelRepository.getInstance()), className);

    SNode claz = scope.resolve(from, className);
    if ((claz == null)) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(claz, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
      return null;
    }

    return SNodeOperations.cast(claz, "jetbrains.mps.baseLanguage.structure.Classifier");
  }

  public static SNode findConstructor(SNode claz, List<SNode> args) {
    SNode result;
    Iterable<SNode> conss = SLinkOperations.getTargets(claz, "constructor", true);
    if (Sequence.fromIterable(conss).isEmpty()) {
      result = null;
    } else if ((int) Sequence.fromIterable(conss).count() == 1) {
      result = Sequence.fromIterable(conss).first();
    } else {
      final int argCount = ListSequence.fromList(args).count();
      Iterable<SNode> subset = Sequence.fromIterable(conss).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return (int) ListSequence.fromList(SLinkOperations.getTargets(it, "parameter", true)).count() == argCount;
        }
      });
      result = Sequence.fromIterable(subset).first();
    }
    return result;
  }

  private static void reattachMethodArguments(SNode from, SNode to) {
    for (SNode arg : ListSequence.fromList(SLinkOperations.getTargets(from, "actualArgument", true))) {
      SNodeOperations.detachNode(arg);
      ListSequence.fromList(SLinkOperations.getTargets(to, "actualArgument", true)).addElement(arg);
    }
  }
}
