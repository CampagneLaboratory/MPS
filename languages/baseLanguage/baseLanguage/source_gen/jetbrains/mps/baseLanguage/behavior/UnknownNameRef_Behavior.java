package jetbrains.mps.baseLanguage.behavior;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class UnknownNameRef_Behavior {
  public static void init(SNode thisNode) {
  }

  public static SNode virtual_evaluateSubst_8136348407761606764(SNode thisNode) {
    SNode result = UnknownNameRef_Behavior.call_resolveTokens_4018023047319628331(thisNode);

    if ((result == null)) {
      return null;
    } else if (SNodeOperations.isInstanceOf(result, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      // change to something real as default, e.g. static field access expression without the field 
      SNode fieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldReference", null);
      SLinkOperations.setTarget(fieldRef, "classifier", SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.Classifier"), false);
      result = fieldRef;

      // <node> 
      return result;

    } else if (SNodeOperations.isInstanceOf(result, "jetbrains.mps.baseLanguage.structure.Expression")) {
      // success 
      return result;
    } else {
      // something unexpected 
      // TODO maybe signal an error without quick fix 
      return null;
    }
  }

  public static SNode call_resolveTokens_4018023047319628331(SNode thisNode) {
    // returns either node<Expression> with a normal baseLanguage expression 
    // or node<Classifier> if all tokens form a name class 
    // returns null if could not resolve 

    SNode operand = null;
    int tokPos = 0;

    SNode mbVarRef = UnknownNameRef_Behavior.call_tryFirstTokenAsVarRef_4018023047319628132(thisNode);

    if ((mbVarRef != null)) {
      // it's a variable 
      operand = mbVarRef;
      tokPos = 1;

      System.err.println("DEBUG: normal dot expr");

    } else {
      // it must be a class 
      Tuples._2<SNode, Integer> classAndPos = UnknownNameRef_Behavior.call_tryFindClass_2621000434129553484(thisNode);
      if (classAndPos == null) {
        return null;
      }

      SNode cls = classAndPos._0();
      tokPos = (int) classAndPos._1();

      if (tokPos == (int) ListSequence.fromList(SLinkOperations.getTargets(thisNode, "token", true)).count()) {
        // no tokens left, all of them form a class name 
        // done 
        return cls;

      } else {
        // there is at least one token that must represent a static field 

        SNode statFieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldReference", null);
        SLinkOperations.setTarget(statFieldRef, "classifier", cls, false);

        SReference fieldRef = new DynamicReference("staticFieldDeclaration", statFieldRef, null, SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(thisNode, "token", true)).getElement(tokPos), "value"));
        statFieldRef.addReference(fieldRef);

        operand = statFieldRef;
        // +1 is here because static field takes one extra token 
        tokPos = tokPos + 1;
        System.err.println("DEBUG: no variable elements in scope");
      }
    }

    if ((operand == null)) {
      return null;
    }

    // success. now the structure is determined, only need to put dynamic references to nodes 
    while (tokPos < ListSequence.fromList(SLinkOperations.getTargets(thisNode, "token", true)).count()) {
      SNode dotExpr = UnknownNameRef_Behavior.makeFieldDotExpression_8473865358220213520(operand, SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(thisNode, "token", true)).getElement(tokPos), "value"));
      operand = dotExpr;
      tokPos++;
    }

    return operand;
  }

  public static SNode call_tryFirstTokenAsVarRef_4018023047319628132(SNode thisNode) {

    Scope scope = Scope.getScope(SNodeOperations.getParent(thisNode), thisNode, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.VariableDeclaration"));
    if (scope == null) {
      System.err.println("DEBUG: sccope is null");
      return null;
    }

    String name = SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(thisNode, "token", true)).first(), "value");

    if (Sequence.fromIterable(scope.getAvailableElements(name)).isNotEmpty()) {
      System.err.println("DEBUG: token = " + name);
      // it's a variable 
      SNode varRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.VariableReference", null);
      SReference sref = new DynamicReference("variableDeclaration", varRef, null, name);
      varRef.addReference(sref);

      return varRef;
    } else {
      return null;
    }
  }

  public static Tuples._2<SNode, Integer> call_tryFindClass_2621000434129553484(SNode thisNode) {
    StringBuilder sb = new StringBuilder();

    int[] dotPositions = new int[ListSequence.fromList(SLinkOperations.getTargets(thisNode, "token", true)).count()];
    int lastDot = -1;
    int k = 0;

    for (SNode tok : ListSequence.fromList(SLinkOperations.getTargets(thisNode, "token", true))) {
      sb.append(SPropertyOperations.getString(tok, "value"));
      sb.append('.');
      dotPositions[k] = lastDot + SPropertyOperations.getString(tok, "value").length() + 1;
      lastDot = dotPositions[k];
      k++;
    }

    // TODO maybe should return a list of possible classifiers along with their token count 
    // so that the client can choose the right one itself 

    // try the longest name first, the shortest last 
    for (int p = dotPositions.length - 1; p >= 0; p--) {
      String className = sb.substring(0, dotPositions[p]);
      SNode cls = UnknownNew_Behavior.findClass_4175350419479594579(thisNode, className);
      if ((cls != null)) {

        return MultiTuple.<SNode,Integer>from(cls, p + 1);
      }
    }

    return null;
  }

  public static SNode makeFieldDotExpression_8473865358220213520(SNode holder, String fieldName) {
    SNode dotExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DotExpression", null);
    SLinkOperations.setTarget(dotExpr, "operand", holder, true);
    SNode fieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldReferenceOperation", null);
    SLinkOperations.setTarget(dotExpr, "operation", fieldRef, true);
    SReference sref = new DynamicReference("fieldDeclaration", fieldRef, null, fieldName);
    fieldRef.addReference(sref);
    return dotExpr;
  }
}
