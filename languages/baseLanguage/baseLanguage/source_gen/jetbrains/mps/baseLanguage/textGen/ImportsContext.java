package jetbrains.mps.baseLanguage.textGen;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.textGen.TextGenBuffer;
import java.util.Set;
import java.util.Map;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples._2;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.HashMap;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;
import jetbrains.mps.util.JavaNameUtil;
import jetbrains.mps.textGen.TextGenManager;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.util.InternUtil;
import java.util.Collections;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public class ImportsContext {
  private static String USER_OBJECT_KEY = "CLASS_IMPORTS_CONTEXT";
  private static Logger LOG = Logger.getLogger(ImportsContext.class);

  private final TextGenBuffer buffer;
  private final String packageName;
  private final Set<String> packageSimpleNames;
  private final Set<String> classifiersInRoot;
  private final Map<String, String> bindings;
  private Map<_2<SNode, String>, Map<String, String>> contextClassifiersCache;

  private ImportsContext(TextGenBuffer buffer, SNode rootNode) {
    this.buffer = buffer;
    this.packageName = SNodeOperations.getModel(rootNode).getSModelReference().getLongName();

    contextClassifiersCache = new HashMap<_2<SNode, String>, Map<String, String>>();

    // init nested class bindings 
    bindings = new HashMap<String, String>();

    // init package simple names 
    packageSimpleNames = new HashSet<String>();
    for (SNode classifier : SModelOperations.getRoots(SNodeOperations.getModel(rootNode), "jetbrains.mps.baseLanguage.structure.Classifier")) {
      packageSimpleNames.add(SPropertyOperations.getString(classifier, "name"));
    }

    // init classifiers in root 
    classifiersInRoot = new HashSet<String>();
    for (SNode classifier : SNodeOperations.getModel(rootNode).getFastNodeFinder().getNodes("jetbrains.mps.baseLanguage.structure.Classifier", true)) {
      if (SNodeOperations.getContainingRoot(classifier) == rootNode) {
        classifiersInRoot.add(INamedConcept_Behavior.call_getFqName_1213877404258(SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.Classifier")));
      }
    }
  }

  public ImportsContext.ClassifierRefText getClassRefText(String packageName, String fqName, SNode contextNode) {
    String simpleName = JavaNameUtil.shortName(fqName);
    Map<String, String> nestedClassifiersBinding = getContextClassifiers(contextNode);

    // 0) nested classifier in same root 
    // todo: maybe after 1) ? 
    if (classifiersInRoot.contains(fqName)) {
      return new ImportsContext.ClassifierRefText(nestedName(packageName, fqName), false);
    }

    // 1) check nested classes context 
    if (nestedClassifiersBinding.containsKey(simpleName)) {
      if (fqName.equals(nestedClassifiersBinding.get(simpleName))) {
        return new ImportsContext.ClassifierRefText(simpleName, false);
      } else {
        return new ImportsContext.ClassifierRefText(fqName, false);
      }
    }

    // 2) check current binding 
    if (bindings.containsKey(simpleName)) {
      if (fqName.equals(bindings.get(simpleName))) {
        return new ImportsContext.ClassifierRefText(simpleName, false);
      } else {
        return new ImportsContext.ClassifierRefText(fqName, false);
      }
    }

    // 3) add binding, add explicit import or not? 
    bindings.put(simpleName, fqName);
    addDependency(packageName, fqName);

    if (packageName.equals(this.packageName)) {
      // same package: generate without explicit import in case of root classifier 
      boolean isRootClassifier = (packageName.length() + simpleName.length() + 1) == fqName.length();
      return new ImportsContext.ClassifierRefText(simpleName, !(isRootClassifier));
    }
    if (packageName.equals("java.lang")) {
      // java.lang model: generate without explicit import if context package doesn't contains same simple name 
      return new ImportsContext.ClassifierRefText(simpleName, packageSimpleNames.contains(simpleName));
    }
    // in other cases: generate explicit import 
    return new ImportsContext.ClassifierRefText(simpleName, true);
  }

  private void addDependency(String packageName, String fqName) {
    // using only root classifiers as dependencies 
    String nestedName = nestedName(packageName, fqName);
    int dotIndex = nestedName.indexOf(".");
    String dependencyFqName;
    if (dotIndex == -1) {
      dependencyFqName = fqName;
    } else {
      dependencyFqName = packageName + "." + nestedName.substring(0, dotIndex);
    }

    Set<String> dependencies = (Set<String>) buffer.getUserObject(TextGenManager.DEPENDENCY);
    if (dependencies == null) {
      dependencies = SetSequence.fromSet(new HashSet<String>());
      buffer.putUserObject(TextGenManager.DEPENDENCY, dependencies);
    }
    dependencies.add(InternUtil.intern(dependencyFqName));
  }

  private Map<String, String> getContextClassifiers(SNode contextNode) {
    // only AnonymousClass has Classifier as reference 
    // todo: make it clearer 
    if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
      contextNode = SNodeOperations.getParent(contextNode);
    }
    if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      LOG.warning("contextNode is classifier in getContextClassifiers: " + contextNode);
      return Collections.emptyMap();
    }

    // find first classifier in path 
    String sourceChildRole = null;
    while ((contextNode != null) && !(SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
      sourceChildRole = contextNode.getRole();
      contextNode = SNodeOperations.getParent(contextNode);
    }

    if ((contextNode == null)) {
      // todo: impossible? 
      return Collections.emptyMap();
    }

    _2<SNode, String> cacheKey = MultiTuple.<SNode,String>from(SNodeOperations.cast(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier"), sourceChildRole);
    if (contextClassifiersCache.containsKey((Object) cacheKey)) {
      return contextClassifiersCache.get((Object) cacheKey);
    }

    Map<String, String> result = getContextClassifiersInternal(SNodeOperations.cast(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier"), sourceChildRole);
    contextClassifiersCache.put(cacheKey, result);

    return result;
  }

  public static ImportsContext getInstance(TextGenBuffer buffer) {
    ImportsContext instance = (ImportsContext) buffer.getUserObject(USER_OBJECT_KEY);
    if (instance == null) {
      SNode rootNode = (SNode) buffer.getUserObject(TextGenManager.ROOT_NODE);
      if ((rootNode == null) || !(SNodeOperations.isInstanceOf(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
        throw new IllegalStateException();
      }
      instance = new ImportsContext(buffer, SNodeOperations.cast(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier"));
      buffer.putUserObject(USER_OBJECT_KEY, instance);
    }
    return instance;
  }

  private static void addClassifierToBindingMap(Map<String, String> bindings, SNode classifier) {
    String simpleName = SPropertyOperations.getString(classifier, "name");
    String fqName = INamedConcept_Behavior.call_getFqName_1213877404258(classifier);

    if (!(bindings.containsKey(simpleName))) {
      bindings.put(simpleName, fqName);
    }
  }

  private static String nestedName(String packageName, String fqName) {
    return fqName.substring(packageName.length() + 1);
  }

  private static Map<String, String> getContextClassifiersInternal(SNode contextNode, String sourceChildRole) {
    Map<String, String> bindings = new HashMap<String, String>();

    SNode current = contextNode;
    while ((current != null)) {
      if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.Classifier")) {
        boolean processNestedClassifiers = false;
        if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.AnonymousClass") || SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
          processNestedClassifiers = true;
        } else if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.Interface")) {
          processNestedClassifiers = !("extendedInterface".equals(sourceChildRole));
        } else if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
          processNestedClassifiers = !("superclass".equals(sourceChildRole) || "implementedInterface".equals(sourceChildRole));
        } else {
          LOG.warning("Illegal classifier node in bl textgen: " + current);
        }

        // todo: is it true? had a bug with it. Look like nested classifier has more priority then class with same name 
        addClassifierToBindingMap(bindings, SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.Classifier"));
        if (processNestedClassifiers) {
          // todo: classifiers with same names in different supertypes? 
          for (SNode superClassifier : Classifier_Behavior.call_getAllExtendedClassifiers_2907982978864985482(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
            for (SNode nestedClassifier : SLinkOperations.getTargets(superClassifier, "staticInnerClassifiers", true)) {
              addClassifierToBindingMap(bindings, nestedClassifier);
            }
          }
        }
      }

      // todo: specialized links? 
      // should not be a problem: superclass/extendedInterface/implementedInterface not specialized 
      sourceChildRole = current.getRole();
      current = SNodeOperations.getParent(current);
    }

    return bindings;
  }

  public class ClassifierRefText {
    public String refText;
    public boolean shouldBeImported;

    public ClassifierRefText(String refText, boolean shouldBeImported) {
      this.refText = refText;
      this.shouldBeImported = shouldBeImported;
    }
  }
}
