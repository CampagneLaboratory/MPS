package jetbrains.mps.baseLanguage.textGen;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.textGen.TextGenBuffer;
import java.util.Set;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.HashMap;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.util.JavaNameUtil;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.textGen.TextGenManager;
import jetbrains.mps.util.InternUtil;
import java.util.Collections;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;

public class ImportsContext {
  private static String USER_OBJECT_KEY = "CLASS_IMPORTS_CONTEXT";
  private static Logger LOG = Logger.getLogger(ImportsContext.class);

  private final TextGenBuffer buffer;
  private final String packageName;
  private final Set<String> packageSimpleNames;
  private final Map<String, String> bindings;

  private ImportsContext(TextGenBuffer buffer, SNode rootNode) {
    this.buffer = buffer;
    this.packageName = SNodeOperations.getModel(rootNode).getSModelReference().getLongName();

    // init nested class bindings 
    bindings = new HashMap<String, String>();

    // init package simple names 
    packageSimpleNames = new HashSet<String>();
    for (SNode classifier : SModelOperations.getRoots(SNodeOperations.getModel(rootNode), "jetbrains.mps.baseLanguage.structure.Classifier")) {
      SetSequence.fromSet(packageSimpleNames).addElement(SPropertyOperations.getString(classifier, "name"));
    }
  }

  public ClassifierRefText getClassRefText(String packageName, String fqName, SNode contextNode) {
    String simpleName = JavaNameUtil.shortName(fqName);
    Map<String, String> nestedClassifiersBinding = getContextClassifiers(contextNode);

    // 0) nested classifier in same root 
    // todo 

    // 1) check nested classes context 
    if (MapSequence.fromMap(nestedClassifiersBinding).containsKey(simpleName)) {
      if (fqName.equals(MapSequence.fromMap(nestedClassifiersBinding).get(simpleName))) {
        return new ClassifierRefText(simpleName, false);
      } else {
        return new ClassifierRefText(fqName, false);
      }
    }

    // 2) check current binding 
    if (MapSequence.fromMap(bindings).containsKey(simpleName)) {
      if (fqName.equals(MapSequence.fromMap(bindings).get(simpleName))) {
        return new ClassifierRefText(simpleName, false);
      } else {
        return new ClassifierRefText(fqName, false);
      }
    }

    // 3) add binding, add explicit import or not? 
    MapSequence.fromMap(bindings).put(simpleName, fqName);
    addDependency(packageName, fqName);

    if (packageName.equals(this.packageName)) {
      // same package: generate without explicit import in case of root classifier 
      boolean isRootClassifier = (packageName.length() + simpleName.length() + 1) == fqName.length();
      return new ClassifierRefText(simpleName, !(isRootClassifier));
    }
    if (packageName.equals("java.lang")) {
      // java.lang model: generate without explicit import if context package doesn't contains same simple name 
      return new ClassifierRefText(simpleName, SetSequence.fromSet(packageSimpleNames).contains(simpleName));
    }
    // in other cases: generate explicit import 
    return new ClassifierRefText(simpleName, true);
  }

  private void addDependency(String packageName, String fqName) {
    // using only root classifiers as dependencies 
    String nestedName = fqName.substring(packageName.length() + 1);
    int dotIndex = nestedName.indexOf(".");
    String dependencyFqName;
    if (dotIndex == -1) {
      dependencyFqName = fqName;
    } else {
      dependencyFqName = packageName + "." + nestedName.substring(0, dotIndex);
    }

    Set<String> dependencies = (Set<String>) buffer.getUserObject(TextGenManager.DEPENDENCY);
    if (dependencies == null) {
      dependencies = SetSequence.fromSet(new HashSet<String>());
      buffer.putUserObject(TextGenManager.DEPENDENCY, dependencies);
    }
    SetSequence.fromSet(dependencies).addElement(InternUtil.intern(dependencyFqName));
  }

  private Map<String, String> getContextClassifiers(SNode contextNode) {
    // only AnonymousClass has Classifier as reference 
    // todo: make it clearer 
    if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
      contextNode = SNodeOperations.getParent(contextNode);
    }
    if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      LOG.warning("contextNode is classifier in getContextClassifiers: " + contextNode);
      return Collections.emptyMap();
    }

    Map<String, String> bindings = MapSequence.fromMap(new HashMap<String, String>());
    SNode child = null;

    while ((contextNode != null)) {
      if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier")) {
        boolean processNestedClassifiers = false;
        if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.AnonymousClass") || SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
          processNestedClassifiers = true;
        } else if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.Interface")) {
          processNestedClassifiers = !(SNodeOperations.hasRole(child, "jetbrains.mps.baseLanguage.structure.Interface", "extendedInterface"));
        } else if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
          processNestedClassifiers = !(SNodeOperations.hasRole(child, "jetbrains.mps.baseLanguage.structure.ClassConcept", "implementedInterface") || SNodeOperations.hasRole(child, "jetbrains.mps.baseLanguage.structure.ClassConcept", "superclass"));
        } else {
          LOG.warning("Illegal classifier node in bl textgen: " + contextNode);
        }

        addClassifierToBindingMap(bindings, SNodeOperations.cast(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier"));
        if (processNestedClassifiers) {
          // todo: classifiers with same names in different supertypes? 
          for (SNode superClassifier : Classifier_Behavior.call_getAllExtendedClassifiers_2907982978864985482(SNodeOperations.cast(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
            for (SNode nestedClassifier : SLinkOperations.getTargets(superClassifier, "staticInnerClassifiers", true)) {
              addClassifierToBindingMap(bindings, nestedClassifier);
            }
          }
        }
      }

      child = contextNode;
      contextNode = SNodeOperations.getParent(contextNode);
    }

    return bindings;
  }

  public static ImportsContext getInstance(TextGenBuffer buffer) {
    ImportsContext instance = (ImportsContext) buffer.getUserObject(USER_OBJECT_KEY);
    if (instance == null) {
      SNode rootNode = (SNode) buffer.getUserObject(TextGenManager.ROOT_NODE);
      if ((rootNode == null) || !(SNodeOperations.isInstanceOf(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
        throw new IllegalStateException();
      }
      instance = new ImportsContext(buffer, SNodeOperations.cast(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier"));
      buffer.putUserObject(USER_OBJECT_KEY, instance);
    }
    return instance;
  }

  private static void addClassifierToBindingMap(Map<String, String> bindings, SNode classifier) {
    String simpleName = SPropertyOperations.getString(classifier, "name");
    String fqName = INamedConcept_Behavior.call_getFqName_1213877404258(classifier);

    if (!(MapSequence.fromMap(bindings).containsKey(simpleName))) {
      MapSequence.fromMap(bindings).put(simpleName, fqName);
    }
  }

  public class ClassifierRefText {
    public String refText;
    public boolean shouldBeImported;

    public ClassifierRefText(String refText, boolean shouldBeImported) {
      this.refText = refText;
      this.shouldBeImported = shouldBeImported;
    }
  }
}
