package jetbrains.mps.baseLanguage.textGen;

/*Generated by MPS */

import jetbrains.mps.textGen.TextGenBuffer;
import java.util.Set;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.HashMap;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.util.JavaNameUtil;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.textGen.TextGenManager;
import jetbrains.mps.util.InternUtil;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;

public class ImportsContext {
  private static String USER_OBJECT_KEY = "CLASS_IMPORTS_CONTEXT";

  private final TextGenBuffer buffer;
  private final String packageName;
  private final Set<String> packageSimpleNames;
  private final Map<String, String> simpleNameToFqName;

  private ImportsContext(TextGenBuffer buffer, SNode rootNode) {
    this.buffer = buffer;
    this.packageName = SNodeOperations.getModel(rootNode).getSModelReference().getLongName();

    // init nested class bindings 
    simpleNameToFqName = new HashMap<String, String>();
    bindNestedClassifiers(rootNode, simpleNameToFqName);

    // init package simple names 
    packageSimpleNames = new HashSet<String>();
    for (SNode classifier : SModelOperations.getRoots(SNodeOperations.getModel(rootNode), "jetbrains.mps.baseLanguage.structure.Classifier")) {
      SetSequence.fromSet(packageSimpleNames).addElement(SPropertyOperations.getString(classifier, "name"));
    }
  }

  public ClassifierRefText getClassRefText(String packageName, String fqName, SNode contextNode) {
    String simpleName = JavaNameUtil.shortName(fqName);
    if (MapSequence.fromMap(simpleNameToFqName).containsKey(simpleName)) {
      if (fqName.equals(MapSequence.fromMap(simpleNameToFqName).get(simpleName))) {
        return new ClassifierRefText(simpleName, false);
      } else {
        return new ClassifierRefText(fqName, false);
      }
    } else {
      addDependency(packageName, fqName);
      return new ClassifierRefText(simpleName, isExplicitImport(packageName, fqName));
    }
  }

  private void addDependency(String packageName, String fqName) {
    // using only root classifiers as dependencies 
    String nestedName = fqName.substring(packageName.length() + 1);
    int dotIndex = nestedName.indexOf(".");
    String dependencyFqName;
    if (dotIndex == -1) {
      dependencyFqName = fqName;
    } else {
      dependencyFqName = packageName + "." + nestedName.substring(0, dotIndex);
    }

    Set<String> dependencies = (Set<String>) buffer.getUserObject(TextGenManager.DEPENDENCY);
    if (dependencies == null) {
      dependencies = SetSequence.fromSet(new HashSet<String>());
      buffer.putUserObject(TextGenManager.DEPENDENCY, dependencies);
    }
    SetSequence.fromSet(dependencies).addElement(InternUtil.intern(dependencyFqName));
  }

  private boolean isExplicitImport(String packageName, String fqName) {
    // return true if classifier should be explicitly imported or false in other case 
    String simpleName = JavaNameUtil.shortName(fqName);

    // first: checking  

    MapSequence.fromMap(simpleNameToFqName).put(simpleName, fqName);

    if (packageName.equals(this.packageName)) {
      // same package: generate without explicit import in case of root classifier 
      boolean isRootClassifier = (packageName.length() + simpleName.length() + 1) == fqName.length();
      return !(isRootClassifier);
    }
    if (packageName.equals("java.lang")) {
      // java.lang model: generate without explicit import if context package doesn't contains same simple name 
      return SetSequence.fromSet(packageSimpleNames).contains(simpleName);
    }
    // in other cases: generate explicit import 
    return true;
  }

  private static void bindNestedClassifiers(SNode rootNode, Map<String, String> binding) {
    Set<SNode> classifiersInRoot = new HashSet<SNode>();
    collectClassifiers(rootNode, classifiersInRoot);

    // add null binding for all possible classifiers 
    for (SNode classifier : classifiersInRoot) {
      for (SNode extendedClassifier : Classifier_Behavior.call_getAllExtendedClassifiers_2907982978864985482(classifier)) {
        for (SNode nestedClassifier : SLinkOperations.getTargets(extendedClassifier, "staticInnerClassifiers", true)) {
          MapSequence.fromMap(binding).put(SPropertyOperations.getString(nestedClassifier, "name"), null);
        }
      }
    }
    // add bindings for inherited nested classifiers in root 
    Set<String> repeatedNames = new HashSet<String>();
    for (SNode extendedClassifier : Classifier_Behavior.call_getAllExtendedClassifiers_2907982978864985482(rootNode)) {
      for (SNode nestedClassifier : SLinkOperations.getTargets(extendedClassifier, "staticInnerClassifiers", true)) {
        if (MapSequence.fromMap(binding).get(SPropertyOperations.getString(nestedClassifier, "name")) == null) {
          MapSequence.fromMap(binding).put(SPropertyOperations.getString(nestedClassifier, "name"), INamedConcept_Behavior.call_getFqName_1213877404258(nestedClassifier));
        } else {
          SetSequence.fromSet(repeatedNames).addElement(SPropertyOperations.getString(nestedClassifier, "name"));
        }
      }
    }
    // add null binding for repeated nested classifier names 
    for (String repeatedName : repeatedNames) {
      MapSequence.fromMap(binding).put(repeatedName, null);
    }
    // add binding for root 
    MapSequence.fromMap(binding).put(SPropertyOperations.getString(rootNode, "name"), INamedConcept_Behavior.call_getFqName_1213877404258(rootNode));
  }

  private static void collectClassifiers(SNode rootNode, Set<SNode> classifiers) {
    // todo: use fast node finder? as in ClassifiersScope 
    if (SNodeOperations.isInstanceOf(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      SetSequence.fromSet(classifiers).addElement(SNodeOperations.cast(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier"));
    }
    for (SNode child : SNodeOperations.getChildren(rootNode)) {
      collectClassifiers(child, classifiers);
    }
  }

  public static ImportsContext getInstance(TextGenBuffer buffer) {
    ImportsContext instance = (ImportsContext) buffer.getUserObject(USER_OBJECT_KEY);
    if (instance == null) {
      SNode rootNode = (SNode) buffer.getUserObject(TextGenManager.ROOT_NODE);
      if ((rootNode == null) || !(SNodeOperations.isInstanceOf(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
        throw new IllegalStateException();
      }
      instance = new ImportsContext(buffer, SNodeOperations.cast(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier"));
      buffer.putUserObject(USER_OBJECT_KEY, instance);
    }
    return instance;
  }

  public class ClassifierRefText {
    public String refText;
    public boolean shouldBeImported;

    public ClassifierRefText(String refText, boolean shouldBeImported) {
      this.refText = refText;
      this.shouldBeImported = shouldBeImported;
    }
  }
}
