package jetbrains.mps.baseLanguage.textGen;

/*Generated by MPS */

import java.util.Set;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.HashMap;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.util.JavaNameUtil;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;
import jetbrains.mps.textGen.TextGenBuffer;
import jetbrains.mps.textGen.TextGenManager;

public class ImportsContext {
  private static String USER_OBJECT_KEY = "CLASS_IMPORTS_CONTEXT";

  private final String packageName;
  private final Set<String> packageSimpleNames;
  private final Map<String, String> simpleNameToFqName;

  private ImportsContext(SNode rootNode) {
    this.packageName = SNodeOperations.getModel(rootNode).getSModelReference().getLongName();

    // init nested class bindings 
    simpleNameToFqName = new HashMap<String, String>();
    bindNestedClassifiers(rootNode, simpleNameToFqName);

    // init package simple names 
    packageSimpleNames = new HashSet<String>();
    for (SNode classifier : SModelOperations.getRoots(SNodeOperations.getModel(rootNode), "jetbrains.mps.baseLanguage.structure.Classifier")) {
      SetSequence.fromSet(packageSimpleNames).addElement(SPropertyOperations.getString(classifier, "name"));
    }
  }

  public boolean containsBinding(String simpleName) {
    return MapSequence.fromMap(simpleNameToFqName).containsKey(simpleName);
  }

  public String getBinding(String simpleName) {
    return MapSequence.fromMap(simpleNameToFqName).get(simpleName);
  }

  public boolean addBinding(String packageName, String fqName) {
    // return true if classifier should be explicitly imported or false in other case 
    String simpleName = JavaNameUtil.shortName(fqName);
    if (containsBinding(simpleName)) {
      throw new IllegalStateException("Binding already added");
    }
    MapSequence.fromMap(simpleNameToFqName).put(simpleName, fqName);
    if (packageName.equals(this.packageName)) {
      // same package: generate without explicit import 
      return false;
    }
    if (packageName.equals("java.lang")) {
      // java.lang model: generate without explicit import if context package doesn't contains same simple name 
      return SetSequence.fromSet(packageSimpleNames).contains(simpleName);
    }
    // in other cases: generate explicit import 
    return true;
  }

  private static void bindNestedClassifiers(SNode rootNode, Map<String, String> binding) {
    Set<SNode> classifiersInRoot = new HashSet<SNode>();
    collectClassifiers(rootNode, classifiersInRoot);

    // add null binding for all possible classifiers 
    for (SNode classifier : classifiersInRoot) {
      for (SNode extendedClassifier : Classifier_Behavior.call_getAllExtendedClassifiers_2907982978864985482(classifier)) {
        for (SNode nestedClassifier : SLinkOperations.getTargets(extendedClassifier, "staticInnerClassifiers", true)) {
          MapSequence.fromMap(binding).put(SPropertyOperations.getString(nestedClassifier, "name"), null);
        }
      }
    }
    // add bindings for inherited nested classifiers in root 
    Set<String> repeatedNames = new HashSet<String>();
    for (SNode extendedClassifier : Classifier_Behavior.call_getAllExtendedClassifiers_2907982978864985482(rootNode)) {
      for (SNode nestedClassifier : SLinkOperations.getTargets(extendedClassifier, "staticInnerClassifiers", true)) {
        if (MapSequence.fromMap(binding).get(SPropertyOperations.getString(nestedClassifier, "name")) == null) {
          MapSequence.fromMap(binding).put(SPropertyOperations.getString(nestedClassifier, "name"), INamedConcept_Behavior.call_getFqName_1213877404258(nestedClassifier));
        } else {
          SetSequence.fromSet(repeatedNames).addElement(SPropertyOperations.getString(nestedClassifier, "name"));
        }
      }
    }
    // add null binding for repeated nested classifier names 
    for (String repeatedName : repeatedNames) {
      MapSequence.fromMap(binding).put(repeatedName, null);
    }
    // add binding for root 
    MapSequence.fromMap(binding).put(SPropertyOperations.getString(rootNode, "name"), INamedConcept_Behavior.call_getFqName_1213877404258(rootNode));
  }

  private static void collectClassifiers(SNode rootNode, Set<SNode> classifiers) {
    // todo: use fast node finder? as in ClassifiersScope 
    if (SNodeOperations.isInstanceOf(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      SetSequence.fromSet(classifiers).addElement(SNodeOperations.cast(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier"));
    }
    for (SNode child : SNodeOperations.getChildren(rootNode)) {
      collectClassifiers(child, classifiers);
    }
  }

  public static ImportsContext getInstance(TextGenBuffer buffer) {
    ImportsContext instance = (ImportsContext) buffer.getUserObject(USER_OBJECT_KEY);
    if (instance == null) {
      SNode rootNode = (SNode) buffer.getUserObject(TextGenManager.ROOT_NODE);
      if ((rootNode == null) || !(SNodeOperations.isInstanceOf(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
        throw new IllegalStateException();
      }
      instance = new ImportsContext(SNodeOperations.cast(rootNode, "jetbrains.mps.baseLanguage.structure.Classifier"));
      buffer.putUserObject(USER_OBJECT_KEY, instance);
    }
    return instance;
  }
}
