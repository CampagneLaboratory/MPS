package jetbrains.mps.baseLanguage.textGen;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.textGen.SNodeTextGen;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.textGen.TextGenManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.core.behavior.IDeprecatable_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.textGen.TextGenBuffer;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.util.JavaNameUtil;
import java.util.HashSet;
import jetbrains.mps.util.InternUtil;

public abstract class BaseLanguageTextGen {
  private static Logger LOG = Logger.getLogger(BaseLanguageTextGen.class);

  public static void typeParameters(List<SNode> types, final SNodeTextGen textGen) {
    if (ListSequence.fromList(types).isNotEmpty()) {
      textGen.append("<");
      if (ListSequence.fromList(types).isNotEmpty()) {
        for (SNode item : types) {
          TextGenManager.instance().appendNodeText(textGen.getContext(), textGen.getBuffer(), item, textGen.getSNode());
          if (item != ListSequence.fromList(types).last()) {
            textGen.append(", ");
          }
        }
      }
      textGen.append(">");
    }
  }

  public static void arguments(SNode methodCall, final SNodeTextGen textGen) {
    textGen.append("(");
    if (ListSequence.fromList(SLinkOperations.getTargets(methodCall, "actualArgument", true)).isNotEmpty()) {
      for (SNode item : SLinkOperations.getTargets(methodCall, "actualArgument", true)) {
        TextGenManager.instance().appendNodeText(textGen.getContext(), textGen.getBuffer(), item, textGen.getSNode());
        if (item != ListSequence.fromList(SLinkOperations.getTargets(methodCall, "actualArgument", true)).last()) {
          textGen.append(", ");
        }
      }
    }
    textGen.append(")");
  }

  public static void newLine(boolean need, final SNodeTextGen textGen) {
    if (need) {
      textGen.appendNewLine();
    }
  }

  public static void annotations(SNode annotable, final SNodeTextGen textGen) {
    if (ListSequence.fromList(SLinkOperations.getTargets(annotable, "annotation", true)).isNotEmpty()) {
      for (SNode item : SLinkOperations.getTargets(annotable, "annotation", true)) {
        TextGenManager.instance().appendNodeText(textGen.getContext(), textGen.getBuffer(), item, textGen.getSNode());
      }
    }
    if (SNodeOperations.isInstanceOf(annotable, "jetbrains.mps.lang.core.structure.IDeprecatable") && IDeprecatable_Behavior.call_isDeprecated_1224609060727(SNodeOperations.cast(annotable, "jetbrains.mps.lang.core.structure.IDeprecatable"))) {
      boolean containsDeprecated = false;
      for (SNode annotationInstance : SLinkOperations.getTargets(annotable, "annotation", true)) {
        if (SLinkOperations.getTarget(annotationInstance, "annotation", false) == SNodeOperations.getNode("f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)", "~Deprecated")) {
          containsDeprecated = true;
          break;
        }
      }
      if (!(containsDeprecated)) {
        SNode deprecated = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationInstance", null);
        SLinkOperations.setTarget(deprecated, "annotation", SNodeOperations.getNode("f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)", "~Deprecated"), false);
        TextGenManager.instance().appendNodeText(textGen.getContext(), textGen.getBuffer(), deprecated, textGen.getSNode());
      }
    }
  }

  public static void visibility(SNode v, final SNodeTextGen textGen) {
    if ((v == null)) {
      textGen.append("/*package*/ ");
    } else {
      TextGenManager.instance().appendNodeText(textGen.getContext(), textGen.getBuffer(), v, textGen.getSNode());
    }
  }

  public static void visibilityWithIndent(SNode v, final SNodeTextGen textGen) {
    textGen.indentBuffer();
    BaseLanguageTextGen.visibility(v, textGen);
  }

  public static void importRefPart(SReference ref, final SNodeTextGen textGen) {
    if (ref == null) {
      return;
    }
    Tuples._2<String, String> packageAndShortName = BaseLanguageTextGen.getPackageAndShortName(ref, textGen);
    if (packageAndShortName == null) {
      LOG.warning("null package and short name");
      return;
    }
    BaseLanguageTextGen.appendClsName(packageAndShortName._0(), packageAndShortName._1(), false, textGen);
  }

  public static void internalClassifierName(SNode node, final SNodeTextGen textGen) {
    if ((node == null)) {
      textGen.append("???");
      textGen.foundError("classifier is null");
      return;
    }
    BaseLanguageTextGen.appendClsName(BaseLanguageTextGen.getPackageName(node, textGen), SPropertyOperations.getString(node, "nestedName"), true, textGen);
  }

  public static void internalClassName(String pack, String className, final SNodeTextGen textGen) {
    BaseLanguageTextGen.appendClsName(pack, className, true, textGen);
  }

  public static void extendedInterface(SNode interface1, final SNodeTextGen textGen) {
    Set<String> dependencies = (Set<String>) BaseLanguageTextGen.getUserObjects(TextGenManager.EXTENDS, textGen);
    SetSequence.fromSet(dependencies).addElement(NameUtil.nodeFQName(interface1));
  }

  public static void implementedInterface(SNode classConcept, final SNodeTextGen textGen) {
    for (SNode classifierType : SLinkOperations.getTargets(classConcept, "implementedInterface", true)) {
      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(classifierType, "classifier", false), "jetbrains.mps.baseLanguage.structure.Interface")) {
        BaseLanguageTextGen.extendedInterface(SNodeOperations.cast(SLinkOperations.getTarget(classifierType, "classifier", false), "jetbrains.mps.baseLanguage.structure.Interface"), textGen);
      }
    }
  }

  public static void extendedClasses(SNode classConcept, final SNodeTextGen textGen) {
    Set<String> dependencies = (Set<String>) BaseLanguageTextGen.getUserObjects(TextGenManager.EXTENDS, textGen);
    SetSequence.fromSet(dependencies).addElement(NameUtil.nodeFQName(classConcept));
  }

  public static void variableDeclaration(SNode node, final SNodeTextGen textGen) {
    if (SPropertyOperations.getBoolean(node, "isFinal")) {
      textGen.append("final ");
    }
    TextGenManager.instance().appendNodeText(textGen.getContext(), textGen.getBuffer(), SLinkOperations.getTarget(node, "type", true), textGen.getSNode());
    textGen.append(" ");
    textGen.append(SPropertyOperations.getString(node, "name"));
    if ((SLinkOperations.getTarget(node, "initializer", true) != null)) {
      textGen.append(" = ");
      TextGenManager.instance().appendNodeText(textGen.getContext(), textGen.getBuffer(), SLinkOperations.getTarget(node, "initializer", true), textGen.getSNode());
    }
  }

  public static void fileHeader(SNode cls, final SNodeTextGen textGen) {
    Set<String> names = (Set<String>) BaseLanguageTextGen.getUserObjects(TextGenManager.IMPORT, textGen);
    String newImport = BaseLanguageTextGen.getPackageName(cls, textGen) + "." + SPropertyOperations.getString(cls, "name");
    SetSequence.fromSet(names).addElement(newImport);
    if (cls.isRoot()) {
      for (SNode nestedClassifier : SNodeOperations.getDescendants(cls, "jetbrains.mps.baseLanguage.structure.Classifier", false, new String[]{})) {
        SetSequence.fromSet(names).addElement(BaseLanguageTextGen.getPackageName(nestedClassifier, textGen) + "." + SPropertyOperations.getString(nestedClassifier, "name"));
      }
      int wasPart = textGen.getBuffer().selectPart(TextGenBuffer.TOP);
      textGen.append("package " + BaseLanguageTextGen.getPackageName(cls, textGen) + ";");
      textGen.appendNewLine();
      textGen.appendNewLine();
      textGen.append("/*Generated by MPS */");
      textGen.appendNewLine();
      textGen.getBuffer().selectPart(wasPart);
    }
    if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface") && ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.Interface"), "extendedInterface", true)).isNotEmpty()) {
      for (SNode interface1 : SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.Interface"), "extendedInterface", true)) {
        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(interface1, "classifier", false), "jetbrains.mps.baseLanguage.structure.Interface")) {
          BaseLanguageTextGen.extendedInterface(SNodeOperations.cast(SLinkOperations.getTarget(interface1, "classifier", false), "jetbrains.mps.baseLanguage.structure.Interface"), textGen);
        } else {
          textGen.foundError("Collection of extended interfaces can't be contains other Classifier Types except Interface");
        }
      }
    } else if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      BaseLanguageTextGen.implementedInterface(cls, textGen);
      BaseLanguageTextGen.extendedClasses(SLinkOperations.getTarget(SLinkOperations.getTarget(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "superclass", true), "classifier", false), textGen);
    }
  }

  public static void methodCall(SNode methodCall, final SNodeTextGen textGen) {
    BaseLanguageTextGen.methodTypeArguments(methodCall, textGen);
    textGen.append(textGen.getReferentPresentation(SNodeOperations.getReference(methodCall, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.IMethodCall", "baseMethodDeclaration")), false));
    BaseLanguageTextGen.arguments(methodCall, textGen);
  }

  public static void methodTypeArguments(SNode methodCall, final SNodeTextGen textGen) {
    if (ListSequence.fromList(SLinkOperations.getTargets(methodCall, "typeArgument", true)).isNotEmpty()) {
      textGen.append("<");
      if (ListSequence.fromList(SLinkOperations.getTargets(methodCall, "typeArgument", true)).isNotEmpty()) {
        for (SNode item : SLinkOperations.getTargets(methodCall, "typeArgument", true)) {
          TextGenManager.instance().appendNodeText(textGen.getContext(), textGen.getBuffer(), item, textGen.getSNode());
          if (item != ListSequence.fromList(SLinkOperations.getTargets(methodCall, "typeArgument", true)).last()) {
            textGen.append(",");
          }
        }
      }
      textGen.append(">");
    }
  }

  public static void blClassifierRef(SReference classifierRef, final SNodeTextGen textGen) {
    if (classifierRef == null) {
      textGen.foundError("null classifier ref");
      return;
    }
    Tuples._2<String, String> packageAndShortName = BaseLanguageTextGen.getPackageAndShortName(classifierRef, textGen);
    if (packageAndShortName == null) {
      LOG.warning("null package and short name");
      return;
    }
    String packageName = packageAndShortName._0();
    String shortName = packageAndShortName._1();
    BaseLanguageTextGen.appendClsName(packageAndShortName._0(), packageAndShortName._1(), false, textGen);
    StringTextGen.compilableString((BaseLanguageTextGen.isNeedLongName(shortName, packageName, textGen) ?
      (packageName + '.' + shortName) :
      shortName
    ), textGen);
  }

  protected static Tuples._2<String, String> getPackageAndShortName(SReference classifierRef, final SNodeTextGen textGen) {
    SReference reference = classifierRef;
    if (reference == null) {
      textGen.foundError("null reference");
      return null;
    }
    String shortName = "";
    String packageName = "";
    if (reference instanceof DynamicReference) {
      shortName = reference.getResolveInfo();
      // hack, todo: remove! 
      if (shortName.startsWith("[")) {
        return MultiTuple.<String,String>from(shortName.substring(1, shortName.lastIndexOf("]")).trim(), shortName.substring(shortName.lastIndexOf("]") + 1).trim());
      } else {
        // todo: remove! 
        final SModelReference modelReference = reference.getTargetSModelReference();
        if (modelReference != null) {
          packageName = modelReference.getLongName();
          LOG.warning("generating classifier reference with target model reference " + modelReference + " @ " + classifierRef);
        } else {
          int lastDot = shortName.lastIndexOf('.');
          if (lastDot >= 0) {
            packageName = shortName.substring(0, lastDot);
            shortName = shortName.substring(lastDot + 1).replace('$', '.');
          } else {
            SModelReference sModelReference = classifierRef.getSourceNode().getModel().getSModelReference();
            packageName = (sModelReference != null ?
              sModelReference.getLongName() :
              ""
            );
          }
        }
        return MultiTuple.<String,String>from(packageName, shortName);
      }
    } else {
      SNode targetNode = reference.getTargetNodeSilently();
      if (targetNode == null) {
        textGen.foundError();
        return null;
      }
      return MultiTuple.<String,String>from(targetNode.getModel().getSModelReference().getLongName(), (SNodeOperations.isInstanceOf(targetNode, "jetbrains.mps.baseLanguage.structure.Classifier") ?
        SPropertyOperations.getString(SNodeOperations.cast(targetNode, "jetbrains.mps.baseLanguage.structure.Classifier"), "nestedName") :
        targetNode.getResolveInfo()
      ));
    }
  }

  protected static boolean isNeedLongName(String shortName, String packageName, final SNodeTextGen textGen) {
    if (shortName == null || packageName == null || packageName.isEmpty()) {
      return false;
    }
    Set<String> importedNames = BaseLanguageTextGen.getUserObjects(TextGenManager.IMPORT, textGen);
    for (String importedName : importedNames) {
      if (JavaNameUtil.shortName(importedName).equals(shortName) && !(JavaNameUtil.packageName(importedName).equals(packageName))) {
        return true;
      }
    }
    return false;
  }

  protected static Set<String> getUserObjects(String type, final SNodeTextGen textGen) {
    Set<String> names = (Set<String>) textGen.getBuffer().getUserObject(type);
    if (names == null) {
      names = SetSequence.fromSet(new HashSet<String>());
      textGen.getBuffer().putUserObject(type, names);
    }
    return names;
  }

  protected static void addDependency(String name, final SNodeTextGen textGen) {
    Set<String> dependencies = (Set<String>) BaseLanguageTextGen.getUserObjects(TextGenManager.DEPENDENCY, textGen);
    SetSequence.fromSet(dependencies).addElement(name);
  }

  protected static void addDependency(SNode node, final SNodeTextGen textGen) {
    BaseLanguageTextGen.addDependency(InternUtil.intern(NameUtil.nodeFQName(node)), textGen);
  }

  protected static String getPackageName(SNode cls, final SNodeTextGen textGen) {
    return cls.getModel().getSModelReference().getLongName();
  }

  protected static void appendClsName(String packageName, String className, boolean isInternal, final SNodeTextGen textGen) {
    if (className == null) {
      textGen.foundError("class name is NULL");
      textGen.append("???");
      return;
    }
    if (packageName.contains("@") || className.contains("@")) {
      textGen.foundError("class name not contain '@'");
    }
    String importedFqName;
    String importedLongFqName;
    String importedShortName = className.split("\\.")[0];
    if (packageName.length() > 0) {
      importedFqName = packageName + "." + importedShortName;
      importedLongFqName = packageName + "." + className;
    } else {
      importedFqName = importedShortName;
      importedLongFqName = className;
    }
    Set<String> importedNames = BaseLanguageTextGen.getUserObjects(TextGenManager.IMPORT, textGen);
    if (SetSequence.fromSet(importedNames).contains(importedLongFqName)) {
      if (isInternal) {
        textGen.append(className);
      }
      return;
    }
    for (String importedName : importedNames) {
      if (className.equals(JavaNameUtil.shortName(importedName))) {
        if (isInternal) {
          String fqName;
          if (packageName.length() > 0) {
            fqName = packageName + "." + className;
          } else {
            fqName = className;
          }
          textGen.append(fqName);
        }
        return;
      }
    }
    SetSequence.fromSet(importedNames).addElement(importedLongFqName);
    BaseLanguageTextGen.addDependency(InternUtil.intern(importedFqName), textGen);
    Set<String> addedImports = BaseLanguageTextGen.getUserObjects(TextGenManager.ADDED_IMPORT, textGen);
    if (!(packageName.equals("java.lang") || packageName.equals(textGen.getBuffer().getUserObject(TextGenManager.PACKAGE_NAME)) || SetSequence.fromSet(addedImports).contains(importedFqName))) {
      int currPartId = textGen.getBuffer().selectPart(TextGenBuffer.TOP);
      textGen.appendNewLine();
      textGen.append("import " + importedFqName + ";");
      textGen.getBuffer().selectPart(currPartId);
      SetSequence.fromSet(addedImports).addElement(importedFqName);
    }
    if (isInternal) {
      textGen.append(className);
    }
  }
}
