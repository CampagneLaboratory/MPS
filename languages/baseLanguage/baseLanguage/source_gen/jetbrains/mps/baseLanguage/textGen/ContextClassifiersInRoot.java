package jetbrains.mps.baseLanguage.textGen;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.smodel.SNode;
import java.util.Map;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Collections;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public class ContextClassifiersInRoot {
  private static Logger LOG = Logger.getLogger(ContextClassifiersInRoot.class);

  private SimpleCache<Tuples._2<SNode, String>, Map<String, String>> contextClassifiersCache;

  public ContextClassifiersInRoot(SNode rootNode) {
    contextClassifiersCache = new SimpleCache<Tuples._2<SNode, String>, Map<String, String>>() {
      protected Map<String, String> innerGet(Tuples._2<SNode, String> key) {
        return getContextClassifiersInternal(key._0(), key._1());
      }
    };
  }

  public Map<String, String> getContextClassifiers(SNode contextNode) {
    // only AnonymousClass has Classifier as reference 
    // todo: make it clearer 
    if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
      contextNode = SNodeOperations.getParent(contextNode);
    }
    if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      LOG.warning("contextNode is classifier in getContextClassifiers: " + contextNode);
      return Collections.emptyMap();
    }

    // find first classifier in path 
    String sourceChildRole = null;
    while ((contextNode != null) && !(SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
      sourceChildRole = contextNode.getRole();
      contextNode = SNodeOperations.getParent(contextNode);
    }

    if ((contextNode == null)) {
      // todo: impossible? 
      return Collections.emptyMap();
    }

    return contextClassifiersCache.get(MultiTuple.<SNode,String>from(SNodeOperations.cast(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier"), sourceChildRole));
  }

  private static void addClassifierToBindingMap(Map<String, String> bindings, SNode classifier) {
    String simpleName = SPropertyOperations.getString(classifier, "name");
    String fqName = INamedConcept_Behavior.call_getFqName_1213877404258(classifier);

    if (!(bindings.containsKey(simpleName))) {
      bindings.put(simpleName, fqName);
    }
  }

  private static Map<String, String> getContextClassifiersInternal(SNode contextNode, String sourceChildRole) {
    Map<String, String> bindings = new HashMap<String, String>();

    SNode current = contextNode;
    while ((current != null)) {
      if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.Classifier")) {
        boolean processNestedClassifiers = false;
        if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.AnonymousClass") || SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
          processNestedClassifiers = true;
        } else if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.Interface")) {
          processNestedClassifiers = !("extendedInterface".equals(sourceChildRole));
        } else if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
          processNestedClassifiers = !("superclass".equals(sourceChildRole) || "implementedInterface".equals(sourceChildRole));
        } else {
          LOG.warning("Illegal classifier node in bl textgen: " + current);
        }

        // todo: is it true? had a bug with it. Look like nested classifier has more priority then class with same name 
        addClassifierToBindingMap(bindings, SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.Classifier"));
        if (processNestedClassifiers) {
          // todo: classifiers with same names in different supertypes? 
          for (SNode superClassifier : Classifier_Behavior.call_getAllExtendedClassifiers_2907982978864985482(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
            for (SNode nestedClassifier : SLinkOperations.getTargets(superClassifier, "staticInnerClassifiers", true)) {
              addClassifierToBindingMap(bindings, nestedClassifier);
            }
          }
        }
      }

      // todo: specialized links? 
      // should not be a problem: superclass/extendedInterface/implementedInterface not specialized 
      sourceChildRole = current.getRole();
      current = SNodeOperations.getParent(current);
    }

    return bindings;
  }
}
