package jetbrains.mps.baseLanguage.textGen;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Collections;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.logging.Logger;

public class ContextClassifiersInRoot {
  private SimpleCache<Tuples._2<SNode, String>, Map<String, String>> contextClassifiersCache;
  private SimpleCache<SNode, Map<String, String>> nestedClassifiersCache;

  public ContextClassifiersInRoot(SNode rootNode) {
    contextClassifiersCache = new SimpleCache<Tuples._2<SNode, String>, Map<String, String>>() {
      protected Map<String, String> innerGet(Tuples._2<SNode, String> key) {
        return getContextClassifiers(key._0(), key._1());
      }
    };
    nestedClassifiersCache = new SimpleCache<SNode, Map<String, String>>() {
      protected Map<String, String> innerGet(SNode key) {
        return getNestedClassifiers(key);
      }
    };
  }

  public Map<String, String> getContextClassifiers(SNode contextNode) {
    // only AnonymousClass has Classifier as reference 
    // todo: make it clearer 
    if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.IAnonymousClass")) {
      contextNode = SNodeOperations.getParent(contextNode);
    }
    if (SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      LOG.warning("contextNode is classifier in getContextClassifiers: " + contextNode);
      return Collections.emptyMap();
    }

    // find first classifier in path 
    String sourceChildRole = null;
    while ((contextNode != null) && !(SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
      sourceChildRole = contextNode.getRoleInParent();
      contextNode = SNodeOperations.getParent(contextNode);
    }

    if ((contextNode == null)) {
      // todo: impossible? 
      return Collections.emptyMap();
    }

    return contextClassifiersCache.get(MultiTuple.<SNode,String>from(SNodeOperations.cast(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier"), sourceChildRole));
  }

  private Map<String, String> getContextClassifiers(SNode contextNode, String sourceChildRole) {
    Map<String, String> bindings = new HashMap<String, String>();

    SNode current = contextNode;
    while ((current != null)) {
      if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.Classifier")) {
        boolean processNestedClassifiers = false;
        if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.AnonymousClass") || SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
          processNestedClassifiers = true;
        } else if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.Interface")) {
          processNestedClassifiers = !("extendedInterface".equals(sourceChildRole));
        } else if (SNodeOperations.isInstanceOf(current, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
          processNestedClassifiers = !("superclass".equals(sourceChildRole) || "implementedInterface".equals(sourceChildRole));
        } else {
          LOG.warning("Illegal classifier node in bl textgen: " + current);
        }

        // todo: is it true? had a bug with it. Look like nested classifier has more priority then class with same name 
        addClassifierToBindingMap(bindings, SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.Classifier"));
        if (processNestedClassifiers) {
          for (Map.Entry<String, String> simpleToFqName : nestedClassifiersCache.get(SNodeOperations.cast(current, "jetbrains.mps.baseLanguage.structure.Classifier")).entrySet()) {
            if (!(bindings.containsKey(simpleToFqName.getKey()))) {
              bindings.put(simpleToFqName.getKey(), simpleToFqName.getValue());
            }
          }
        }
      }

      // todo: specialized links? 
      // should not be a problem: superclass/extendedInterface/implementedInterface not specialized 
      sourceChildRole = current.getRoleInParent();
      current = SNodeOperations.getParent(current);
    }

    return bindings;
  }

  private static Map<String, String> getNestedClassifiers(SNode classifier) {
    // returns map from simpleName to fqName 
    Map<String, String> nestedClassifiers = new HashMap<String, String>();

    // todo: classifiers with same names in different supertypes? 
    for (SNode superClassifier : Classifier_Behavior.call_getAllExtendedClassifiers_2907982978864985482(SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
      for (SNode nestedClassifier : Classifier_Behavior.call_nestedClassifiers_5292274854859193142(superClassifier)) {
        addClassifierToBindingMap(nestedClassifiers, nestedClassifier);
      }
    }

    return nestedClassifiers;
  }

  private static void addClassifierToBindingMap(Map<String, String> bindings, SNode classifier) {
    String simpleName = SPropertyOperations.getString(classifier, "name");
    String fqName = BehaviorReflection.invokeVirtual(String.class, classifier, "virtual_getFqName_1213877404258", new Object[]{});

    if (!(bindings.containsKey(simpleName))) {
      bindings.put(simpleName, fqName);
    }
  }

  private static Logger LOG = Logger.getLogger(ContextClassifiersInRoot.class);
}
