package jetbrains.mps.baseLanguage.textGen;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.text.rt.TextGenContext;
import jetbrains.mps.text.impl.TextGenSupport;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.textGen.SNodeTextGen;

public abstract class BaseClassConceptTextGen {
  public static void membersWithBrackets(SNode classifier, boolean newLineOnEmptyMembers, final TextGenContext ctx) {
    final TextGenSupport tgs = new TextGenSupport(ctx);
    if (Sequence.fromIterable(Classifier_Behavior.call_members_1465982738252129704(classifier)).isNotEmpty() || newLineOnEmptyMembers) {
      tgs.append("{");
      tgs.newLine();
      ctx.getBuffer().area().increaseIndent();
      BaseClassConceptTextGen.members(classifier, ctx);
      ctx.getBuffer().area().decreaseIndent();
      tgs.indent();
      tgs.append("}");
    } else {
      tgs.append("{}");
    }
  }
  public static void members(SNode classifier, final TextGenContext ctx) {
    final TextGenSupport tgs = new TextGenSupport(ctx);
    // just for first element 
    boolean isWrappedElementBefore = true;
    SNode lastMember = Sequence.fromIterable(Classifier_Behavior.call_members_1465982738252129704(classifier)).last();
    for (SNode member : Classifier_Behavior.call_members_1465982738252129704(classifier)) {
      if (SNodeOperations.isInstanceOf(member, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, "jetbrains.mps.baseLanguage.structure.ClassifierMember"))) {
        boolean needsLineBefore = BehaviorReflection.invokeVirtual(Boolean.TYPE, SNodeOperations.cast(member, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, "jetbrains.mps.baseLanguage.structure.ClassifierMember")), "virtual_needsEmptyLineBefore_641490355014296733", new Object[]{});
        boolean needsLineAfter = BehaviorReflection.invokeVirtual(Boolean.TYPE, SNodeOperations.cast(member, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, "jetbrains.mps.baseLanguage.structure.ClassifierMember")), "virtual_needsEmptyLineAfter_641490355014298838", new Object[]{});
        BaseLanguageTextGen.newLine(needsLineBefore && !(isWrappedElementBefore), ctx);
        tgs.appendNode(member);
        BaseLanguageTextGen.newLine(needsLineAfter && !((lastMember == member)), ctx);
        isWrappedElementBefore = needsLineAfter;
      } else {
        tgs.appendNode(member);
        isWrappedElementBefore = false;
      }
    }
    if ((SLinkOperations.getTarget(SNodeOperations.as(classifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x110ca5f7c5aL, "staticInitializer")) != null)) {
      tgs.indent();
      tgs.append("static {");
      ctx.getBuffer().area().increaseIndent();
      tgs.appendNode(SLinkOperations.getTarget(SNodeOperations.cast(classifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x110ca5f7c5aL, "staticInitializer")));
      tgs.newLine();
      ctx.getBuffer().area().decreaseIndent();
      tgs.indent();
      tgs.append("}");
      tgs.newLine();
    }
  }
  public static void body(SNode concept, final TextGenContext ctx) {
    final TextGenSupport tgs = new TextGenSupport(ctx);
    BaseClassConceptTextGen.members(concept, ctx);
  }
  public static void innerClassifiers(SNode concept, final TextGenContext ctx) {
    final TextGenSupport tgs = new TextGenSupport(ctx);
    SNode last = Sequence.fromIterable(Classifier_Behavior.call_nestedClassifiers_5292274854859193142(concept)).last();
    for (SNode classifier : Classifier_Behavior.call_nestedClassifiers_5292274854859193142(concept)) {
      tgs.appendNode(classifier);
      if (!(classifier.equals(last))) {
        tgs.newLine();
      }
    }
  }
  public static void collection(Iterable<SNode> nodes, final TextGenContext ctx) {
    final TextGenSupport tgs = new TextGenSupport(ctx);
    for (SNode item : nodes) {
      tgs.appendNode(item);
    }
    tgs.newLine();
  }
  public static void membersWithBrackets(SNode classifier, boolean newLineOnEmptyMembers, SNodeTextGen ctx) {
    // method left for compile-time compatibility for generated textgen code (MPS 3.2). 
    // MPS compiles modules on start-up. If client keeps generated source code AND if an old TextGen  
    // references utility operations of MPS-supplied TextGen, existing sources won't compile without 
    // this method present. 
  }
  public static void members(SNode classifier, SNodeTextGen ctx) {
    // method left for compile-time compatibility for generated textgen code (MPS 3.2). 
    // MPS compiles modules on start-up. If client keeps generated source code AND if an old TextGen  
    // references utility operations of MPS-supplied TextGen, existing sources won't compile without 
    // this method present. 
  }
  public static void body(SNode concept, SNodeTextGen ctx) {
    // method left for compile-time compatibility for generated textgen code (MPS 3.2). 
    // MPS compiles modules on start-up. If client keeps generated source code AND if an old TextGen  
    // references utility operations of MPS-supplied TextGen, existing sources won't compile without 
    // this method present. 
  }
  public static void innerClassifiers(SNode concept, SNodeTextGen ctx) {
    // method left for compile-time compatibility for generated textgen code (MPS 3.2). 
    // MPS compiles modules on start-up. If client keeps generated source code AND if an old TextGen  
    // references utility operations of MPS-supplied TextGen, existing sources won't compile without 
    // this method present. 
  }
  public static void collection(Iterable<SNode> nodes, SNodeTextGen ctx) {
    // method left for compile-time compatibility for generated textgen code (MPS 3.2). 
    // MPS compiles modules on start-up. If client keeps generated source code AND if an old TextGen  
    // references utility operations of MPS-supplied TextGen, existing sources won't compile without 
    // this method present. 
  }
}
