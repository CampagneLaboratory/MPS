package jetbrains.mps.baseLanguage.dataFlow;

/*Generated by MPS */

import java.util.Map;
import java.util.List;
import jetbrains.mps.analyzers.runtime.framework.DataFlowConstructor;
import java.util.HashMap;
import java.util.LinkedList;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import jetbrains.mps.lang.dataFlow.framework.DataFlowAnalyzer;
import jetbrains.mps.lang.dataFlow.framework.Program;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.lang.dataFlow.framework.DataFlowAspectDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.HashSet;

public class NullableAnalyzerRules {
  private static NullableAnalyzerRules instance;
  private Map<String, List<DataFlowConstructor>> myApplicableMap = new HashMap<String, List<DataFlowConstructor>>();
  private List<jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor> myConceptRules = new LinkedList<jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor>();
  private Map<SNode, Set<jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor>> myConceptRulesCache = new HashMap<SNode, Set<jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor>>();
  private DataFlowAnalyzer myAnalyzer;
  public NullableAnalyzerRules(DataFlowAnalyzer analyzer) {
    myAnalyzer = analyzer;
    // <node> 
    // <node> 
    // <node> 
    // <node> 
    // <node> 
    // <node> 
    // <node> 
    // <node> 
    // <node> 
    // <node> 
    // <node> 
    // <node> 

  }
  public void apply(SNode nodeToApply, Program program) {
    for (SLanguage language : CollectionSequence.fromCollection(((SModelInternal) nodeToApply.getModel()).importedLanguageIds())) {
      LanguageRuntime languageRuntime = LanguageRegistry.getInstance().getLanguage(language.getQualifiedName());
      for (jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor rule : CollectionSequence.fromCollection(languageRuntime.getAspect(DataFlowAspectDescriptor.class).getConstructors(myAnalyzer.getClass()))) {
        myConceptRules.add(rule);
      }
    }
    for (SNode descendant : SNodeOperations.getNodeDescendants(((SNode) nodeToApply), null, false, new SAbstractConcept[]{})) {
      String key = descendant.getConcept().getQualifiedName();
      if (myApplicableMap.containsKey(key)) {
        for (DataFlowConstructor rule : myApplicableMap.get(key)) {
          if (rule.isApplicable(descendant)) {
            rule.performActions(program, descendant);
          }
        }
      }
      for (jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor rule : getRules(descendant)) {
        rule.performActions(program, descendant);
      }
    }
  }
  private Set<jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor> getRules(SNode node) {
    SNode concept = SNodeOperations.getConceptDeclaration(node);
    Set<jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor> cachedResult = myConceptRulesCache.get(concept);
    if (cachedResult != null) {
      return cachedResult;
    }
    Set<jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor> result = new HashSet<jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor>();
    for (jetbrains.mps.lang.dataFlow.framework.DataFlowConstructor rule : myConceptRules) {
      if (rule.isApplicable(node)) {
        result.add(rule);
      }
    }
    myConceptRulesCache.put(concept, result);
    return result;
  }
  public static NullableAnalyzerRules getInstance(DataFlowAnalyzer analyzer) {
    if (instance == null) {
      instance = new NullableAnalyzerRules(analyzer);
    }
    return instance;
  }
}
