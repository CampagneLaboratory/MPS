package jetbrains.mps.baseLanguage.util.plugin.refactorings;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.dataFlow.framework.Program;
import jetbrains.mps.lang.dataFlow.framework.AnalysisResult;
import jetbrains.mps.lang.dataFlow.framework.VarSet;
import java.util.Set;
import jetbrains.mps.lang.dataFlow.framework.instructions.WriteInstruction;
import jetbrains.mps.lang.dataFlow.DataFlowManager;
import jetbrains.mps.lang.dataFlow.framework.analyzers.ReachabilityAnalyzer;
import jetbrains.mps.lang.dataFlow.framework.analyzers.LivenessAnalyzer;
import jetbrains.mps.lang.dataFlow.framework.analyzers.ReachingDefinitionsAnalyzer;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.UUID;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.LinkedHashSet;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.lang.pattern.util.MatchingUtil;
import jetbrains.mps.lang.dataFlow.framework.instructions.EndInstruction;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.typesystem.runtime.HUtil;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.lang.dataFlow.framework.instructions.ReadInstruction;

public class ExtractMethodRefactoringAnalyzer {
  private List<SNode> myPartToExtract;
  private Program myProgram;
  private List<SNode> myInternalExitPoints;
  private AnalysisResult<Boolean> myReachability;
  private AnalysisResult<VarSet> myLiveVariables;
  private AnalysisResult<Set<WriteInstruction>> myReachingDefinitions;
  private IExtractMethodRefactoringProcessor myProcessor;
  private boolean shouldBeStatic;
  private boolean canBeStatic;
  private boolean shouldChooseOuterContainer;
  public ExtractMethodRefactoringAnalyzer(List<SNode> nodes) {
    this.myPartToExtract = nodes;
    this.findExtractMethodRefactoringProcessor();
    this.myProgram = DataFlowManager.getInstance().buildProgramFor(this.myProcessor.getContainerMethod());
    this.myReachability = this.myProgram.analyze(new ReachabilityAnalyzer());
    this.myInternalExitPoints = this.calculateInternalExitPoints();
    this.myLiveVariables = this.myProgram.analyze(new LivenessAnalyzer());
    this.myReachingDefinitions = this.myProgram.analyze(new ReachingDefinitionsAnalyzer());
    this.shouldBeStatic = this.findIfShouldBeStatic();
    this.canBeStatic = this.findIfCanBeStatic();
  }
  /*package*/ boolean hasExitPoints() {
    return ListSequence.fromList(this.myInternalExitPoints).isNotEmpty();
  }
  private boolean isInside(SNode node) {
    SNode current = node;
    while (current != null) {
      if (ListSequence.fromList(this.myPartToExtract).contains(current)) {
        return true;
      }
      current = SNodeOperations.getParent(current);
    }
    return false;
  }
  public boolean shouldBeStatic() {
    return shouldBeStatic;
  }
  public boolean canBeStatic() {
    return canBeStatic;
  }
  public boolean shouldChooseOuterContainer() {
    return shouldChooseOuterContainer;
  }
  private boolean findIfShouldBeStatic() {
    if (shouldChooseOuterContainer) {
      return true;
    }
    SNode containerMethod = this.myProcessor.getContainerMethod();
    if (SNodeOperations.isInstanceOf(containerMethod, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1081236700938l, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"))) {
      return true;
    }
    if (SNodeOperations.isInstanceOf(containerMethod, MetaAdapterFactory.getConcept(new UUID(-5808042798135555774l, -8657779246725685839l), 1225194472830l, "jetbrains.mps.lang.behavior.structure.ConceptMethodDeclaration")) && (SPropertyOperations.getBoolean(SNodeOperations.cast(containerMethod, MetaAdapterFactory.getConcept(new UUID(-5808042798135555774l, -8657779246725685839l), 1225194472830l, "jetbrains.mps.lang.behavior.structure.ConceptMethodDeclaration")), MetaAdapterFactory.getProperty(new UUID(-5808042798135555774l, -8657779246725685839l), 1225194472830l, 5864038008284099149l, "isStatic"))) && !(SPropertyOperations.getBoolean(SNodeOperations.cast(containerMethod, MetaAdapterFactory.getConcept(new UUID(-5808042798135555774l, -8657779246725685839l), 1225194472830l, "jetbrains.mps.lang.behavior.structure.ConceptMethodDeclaration")), MetaAdapterFactory.getProperty(new UUID(-5808042798135555774l, -8657779246725685839l), 1225194472830l, 1225194472832l, "isVirtual")))) {
      return true;
    }
    return false;
  }
  private boolean findIfCanBeStatic() {
    for (SNode node : ListSequence.fromList(this.myPartToExtract)) {
      if (ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, "jetbrains.mps.baseLanguage.structure.VariableReference"), false, new SAbstractConcept[]{})).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, "jetbrains.mps.baseLanguage.structure.VariableReference")), MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068498886296l, 1068581517664l, "variableDeclaration")), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468200l, "jetbrains.mps.baseLanguage.structure.FieldDeclaration"));
        }
      }).toListSequence().isNotEmpty() || ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getInterfaceConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1224609861009l, "jetbrains.mps.baseLanguage.structure.IThisExpression"), false, new SAbstractConcept[]{})).isNotEmpty() || ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 7812454656619025412l, "jetbrains.mps.baseLanguage.structure.LocalMethodCall"), false, new SAbstractConcept[]{})).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l, -6610165693999523818l), 1204053956946l, 1068499141037l, "baseMethodDeclaration")), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123165l, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"));
        }
      }).toListSequence().isNotEmpty() || ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1073063089578l, "jetbrains.mps.baseLanguage.structure.SuperMethodCall"), false, new SAbstractConcept[]{})).isNotEmpty()) {
        return false;
      }
    }
    return true;
  }
  private List<SNode> calculateInternalExitPoints() {
    List<SNode> result = new ArrayList<SNode>();
    for (SNode node : ListSequence.fromList(this.myPartToExtract)) {
      List<SNode> returns = SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068581242878l, "jetbrains.mps.baseLanguage.structure.ReturnStatement"), true, new SAbstractConcept[]{});
      for (SNode ret : ListSequence.fromList(returns)) {
        SNode a1 = SNodeOperations.getNodeAncestor(ret, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), false, false);
        SNode a2 = SNodeOperations.getNodeAncestor(node, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), false, false);
        if (a1 == a2) {
          ListSequence.fromList(result).addElement(ret);
        }
      }
      List<SNode> statements = new ArrayList<SNode>();
      ListSequence.fromList(statements).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1081855346303l, "jetbrains.mps.baseLanguage.structure.BreakStatement"), false, new SAbstractConcept[]{})));
      ListSequence.fromList(statements).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1082113931046l, "jetbrains.mps.baseLanguage.structure.ContinueStatement"), false, new SAbstractConcept[]{})));
      for (SNode st : ListSequence.fromList(statements)) {
        SNode a1 = SNodeOperations.getNodeAncestor(st, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1154032098014l, "jetbrains.mps.baseLanguage.structure.AbstractLoopStatement"), false, false);
        SNode a2 = SNodeOperations.getNodeAncestor(node, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1154032098014l, "jetbrains.mps.baseLanguage.structure.AbstractLoopStatement"), false, false);
        if (a1 == a2) {
          ListSequence.fromList(result).addElement(st);
        }
      }
    }
    return result;
  }
  /*package*/ List<SNode> getIntenalExitPoints() {
    return this.myInternalExitPoints;
  }
  /*package*/ List<SNode> getOutputVariables() {
    Set<SNode> result = SetSequence.fromSet(new HashSet<SNode>());
    SetSequence.fromSet(result).addSequence(SetSequence.fromSet(this.getVarableLiveAtExitPoints()));
    Iterable<SNode> t = SetSequence.fromSet(result).intersect(SetSequence.fromSet(this.getModificationsReachingExitPoints(true)));
    return ListSequence.fromListWithValues(new ArrayList<SNode>(), Sequence.fromIterable(t).toListSequence());
  }
  private Set<SNode> getModificationsReachingExitPoints(boolean internal) {
    Set<SNode> result = SetSequence.fromSet(new LinkedHashSet<SNode>());
    for (Instruction preExit : SetSequence.fromSet(this.getPreExitPoints())) {
      for (WriteInstruction writeInstruction : SetSequence.fromSet(((Set<WriteInstruction>) this.myReachingDefinitions.get(preExit)))) {
        if (internal == this.isInside(((SNode) writeInstruction.getSource()))) {
          SetSequence.fromSet(result).addElement(((SNode) writeInstruction.getVariable()));
        }
      }
    }
    return result;
  }
  private Set<SNode> getVarableLiveAtExitPoints() {
    Set<SNode> result = SetSequence.fromSet(new LinkedHashSet<SNode>());
    for (Instruction exitPoint : SetSequence.fromSet(this.getExitPoints())) {
      for (Object variable : this.myLiveVariables.get(exitPoint)) {
        SetSequence.fromSet(result).addElement(((SNode) variable));
      }
    }
    return result;
  }
  private Set<Instruction> getExitPoints() {
    Set<Instruction> result = SetSequence.fromSet(new LinkedHashSet<Instruction>());
    Set<Instruction> instructions = this.getInstructions();
    for (Instruction instruction : SetSequence.fromSet(instructions)) {
      SetSequence.fromSet(result).addSequence(SetSequence.fromSet(instruction.succ()));
    }
    SetSequence.fromSet(result).removeSequence(SetSequence.fromSet(instructions));
    return result;
  }
  private Set<Instruction> getPreExitPoints() {
    Set<Instruction> result = SetSequence.fromSet(new LinkedHashSet<Instruction>());
    Set<Instruction> exitPoints = this.getExitPoints();
    for (Instruction exitPoint : SetSequence.fromSet(exitPoints)) {
      SetSequence.fromSet(result).addSequence(SetSequence.fromSet(exitPoint.pred()));
    }
    Set<Instruction> tmp = SetSequence.fromSet(new HashSet<Instruction>());
    SetSequence.fromSet(tmp).addSequence(SetSequence.fromSet(result).intersect(SetSequence.fromSet(this.getInstructions())));
    return tmp;
  }
  /*package*/ boolean isExitPointsDifferent() {
    List<SNode> exits = this.myInternalExitPoints;
    for (int i = 1; i < ListSequence.fromList(exits).count(); i++) {
      if (!(MatchingUtil.matchNodes(ListSequence.fromList(exits).getElement(i - 1), ListSequence.fromList(exits).getElement(i)))) {
        return true;
      }
    }
    return false;
  }
  /*package*/ boolean isAlwaysReturns() {
    for (Instruction instruction : SetSequence.fromSet(this.getInstructions())) {
      if (this.myReachability.get(instruction)) {
        for (Instruction next : SetSequence.fromSet(instruction.succ())) {
          SNode nextNode = (SNode) next.getSource();
          if (!(next instanceof EndInstruction)) {
            if (next.getSource() == null || !(this.isInside(nextNode))) {
              if (!((SNodeOperations.isInstanceOf(SNodeOperations.getParent(nextNode), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) || SNodeOperations.isInstanceOf(SNodeOperations.getParent(nextNode), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1137021947720l, "jetbrains.mps.baseLanguage.structure.ConceptFunction"))))) {
                return false;
              }
            }
          }
        }
      }
    }
    return true;
  }
  /*package*/ Set<Instruction> getInstructions() {
    Set<Instruction> result = SetSequence.fromSet(new LinkedHashSet<Instruction>());
    for (SNode node : ListSequence.fromList(this.myPartToExtract)) {
      SetSequence.fromSet(result).addSequence(ListSequence.fromList(this.myProgram.getInstructionsFor(node)));
    }
    return result;
  }
  /*package*/ boolean isReturnExpressionsNotChangedInStatements() {
    List<SNode> returns = this.calculateInternalExitPoints();
    for (SNode ret : ListSequence.fromList(returns)) {
      for (Instruction instruction : ListSequence.fromList(this.myProgram.getInstructionsFor(ret))) {
        for (WriteInstruction writeInstruction : SetSequence.fromSet(this.myReachingDefinitions.get(instruction))) {
          if (this.isInside(((SNode) writeInstruction.getSource()))) {
            return false;
          }
        }
      }
    }
    return true;
  }
  public List<MethodParameter> getInputVariables() {
    Map<SNode, MethodParameter> result = MapSequence.fromMap(new LinkedHashMap<SNode, MethodParameter>(16, (float) 0.75, false));
    this.addDataflowParameters(result);
    // added to fix problems with closures 
    addExternalParameters(result);
    for (SNode node : ListSequence.fromList(this.myPartToExtract)) {
      for (SNode parameter : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getInterfaceConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1225280593310l, "jetbrains.mps.baseLanguage.structure.IParameter"), true, new SAbstractConcept[]{}))) {
        SNode expressionType = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(parameter), HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.Type"), true);
        MapSequence.fromMap(result).put(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), parameter, "virtual_getDeclaration_1225282371351", new Object[]{}), new MethodParameter(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), parameter, "virtual_getDeclaration_1225282371351", new Object[]{}), expressionType, BehaviorReflection.invokeVirtual(String.class, parameter, "virtual_getParameterName_1225280611056", new Object[]{}), parameter));
      }
    }
    return ListSequence.fromListWithValues(new ArrayList<MethodParameter>(), MapSequence.fromMap(result).values());
  }
  /*package*/ SNode getClassifier() {
    return SNodeOperations.getNodeAncestor(ListSequence.fromList(this.myPartToExtract).first(), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, "jetbrains.mps.baseLanguage.structure.Classifier"), false, false);
  }
  public IExtractMethodRefactoringProcessor getExtractMethodReafactoringProcessor() {
    return this.myProcessor;
  }
  private void findExtractMethodRefactoringProcessor() {
    shouldChooseOuterContainer = false;
    SNode first = ListSequence.fromList(this.myPartToExtract).first();
    SNode classConcept = SNodeOperations.getNodeAncestor(first, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468198l, "jetbrains.mps.baseLanguage.structure.ClassConcept"), false, false);
    if (classConcept != null) {
      this.myProcessor = new ClassExtractMethodRefactoringProcessor(classConcept, this.myPartToExtract);
    } else if (SNodeOperations.getNodeAncestor(first, MetaAdapterFactory.getInterfaceConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1221393582612l, "jetbrains.mps.baseLanguage.structure.IExtractMethodAvailable"), false, false) != null) {
      SNode extractable = SNodeOperations.getNodeAncestor(first, MetaAdapterFactory.getInterfaceConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1221393582612l, "jetbrains.mps.baseLanguage.structure.IExtractMethodAvailable"), false, false);
      this.myProcessor = BehaviorReflection.invokeVirtual(IExtractMethodRefactoringProcessor.class, extractable, "virtual_getExtractMethodRefactoringProcessor_1221393367929", new Object[]{this.myPartToExtract});
    } else {
      this.myProcessor = new AbstractExtractMethodRefactoringProcessor(null, this.myPartToExtract);
      shouldChooseOuterContainer = true;
    }
  }
  private void addExternalParameters(Map<SNode, MethodParameter> result) {
    SNode list = SNodeOperations.getNodeAncestor(ListSequence.fromList(myPartToExtract).getElement(0), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, "jetbrains.mps.baseLanguage.structure.StatementList"), false, false);
    while (SNodeOperations.isInstanceOf(SNodeOperations.getParent(list), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123157l, "jetbrains.mps.baseLanguage.structure.Statement"))) {
      list = SNodeOperations.getNodeAncestor(list, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, "jetbrains.mps.baseLanguage.structure.StatementList"), false, false);
    }
    Program program = DataFlowManager.getInstance().buildProgramFor(list);
    Set<Instruction> nodeInstructions = SetSequence.fromSet(new HashSet<Instruction>());
    for (SNode node : ListSequence.fromList(myPartToExtract)) {
      SetSequence.fromSet(nodeInstructions).addSequence(ListSequence.fromList(program.getInstructionsFor(node)));
    }
    AnalysisResult<Set<WriteInstruction>> reachability = program.analyze(new ReachingDefinitionsAnalyzer());
    for (Instruction instruction : SetSequence.fromSet(nodeInstructions).where(new IWhereFilter<Instruction>() {
      public boolean accept(Instruction it) {
        return it instanceof ReadInstruction;
      }
    })) {
      final ReadInstruction read = (ReadInstruction) instruction;
      Set<WriteInstruction> writes = reachability.get(read);
      if (SetSequence.fromSet(writes).where(new IWhereFilter<WriteInstruction>() {
        public boolean accept(WriteInstruction it) {
          return it.getVariable() == read.getVariable();
        }
      }).isEmpty()) {
        SNode declaration = ((SNode) read.getVariable());
        if (MapSequence.fromMap(result).containsKey(declaration)) {
          continue;
        }
        if (SNodeOperations.isInstanceOf(declaration, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468200l, "jetbrains.mps.baseLanguage.structure.FieldDeclaration")) || SNodeOperations.isInstanceOf(declaration, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1070462154015l, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration"))) {
          continue;
        }
        SNode type = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(declaration), HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.Type"), true);
        SNode reference;
        if (SNodeOperations.isInstanceOf(declaration, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"))) {
          reference = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.cast(declaration, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, "jetbrains.mps.baseLanguage.structure.VariableDeclaration")), "virtual_createReference_1213877517482", new Object[]{});
        } else {
          reference = ((SNode) read.getSource());
        }
        if (SNodeOperations.isInstanceOf(reference, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068431790191l, "jetbrains.mps.baseLanguage.structure.Expression"))) {
          MapSequence.fromMap(result).put(declaration, new MethodParameter(declaration, type, SPropertyOperations.getString(declaration, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name")), reference));
        }
      }
    }
  }
  private void addDataflowParameters(Map<SNode, MethodParameter> result) {
    for (Instruction instruction : SetSequence.fromSet(this.getInstructions())) {
      if ((instruction instanceof ReadInstruction)) {
        ReadInstruction read = (ReadInstruction) instruction;
        Set<WriteInstruction> writes = this.myReachingDefinitions.get(read);
        for (WriteInstruction write : SetSequence.fromSet(writes)) {
          if (write.getVariable() == read.getVariable()) {
            if (!(this.isInside(((SNode) write.getSource())))) {
              SNode declaration = ((SNode) read.getVariable());
              if (!(MapSequence.fromMap(result).containsKey(declaration))) {
                SNode type = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(declaration), HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.Type"), true);
                SNode reference;
                if (SNodeOperations.isInstanceOf(declaration, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"))) {
                  reference = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.cast(declaration, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, "jetbrains.mps.baseLanguage.structure.VariableDeclaration")), "virtual_createReference_1213877517482", new Object[]{});
                } else {
                  reference = ((SNode) read.getSource());
                }
                if (SNodeOperations.isInstanceOf(reference, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068431790191l, "jetbrains.mps.baseLanguage.structure.Expression"))) {
                  MapSequence.fromMap(result).put(declaration, new MethodParameter(declaration, type, SPropertyOperations.getString(declaration, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name")), reference));
                }
              }
            }
          }
        }
      }
    }
  }
  public static boolean isStatements(List<SNode> nodes) {
    return SNodeOperations.isInstanceOf(ListSequence.fromList(nodes).first(), MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123157l, "jetbrains.mps.baseLanguage.structure.Statement"));
  }
}
