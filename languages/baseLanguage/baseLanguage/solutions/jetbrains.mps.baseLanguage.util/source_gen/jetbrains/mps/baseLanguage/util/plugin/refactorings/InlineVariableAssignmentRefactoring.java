package jetbrains.mps.baseLanguage.util.plugin.refactorings;

/*Generated by MPS */

import jetbrains.mps.lang.dataFlow.framework.Program;
import java.util.Set;
import jetbrains.mps.lang.dataFlow.framework.instructions.ReadInstruction;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.dataFlow.DataFlowManager;
import jetbrains.mps.lang.dataFlow.framework.AnalysisResult;
import jetbrains.mps.lang.dataFlow.framework.analyzers.ReachingReadsAnalyzer;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;

public class InlineVariableAssignmentRefactoring extends InlineVariableRefactoring {
  private Program myProgram;
  private Set<ReadInstruction> myReadInstructions;
  private SNode myVariable;

  public InlineVariableAssignmentRefactoring(SNode node) {
    this.myVariable = node;
    SNode body = findStatementList(node);
    this.myProgram = DataFlowManager.getInstance().buildProgramFor(body);
    AnalysisResult<Set<ReadInstruction>> reachingReads = this.myProgram.analyze(new ReachingReadsAnalyzer());
    this.myReadInstructions = SetSequence.fromSet(new HashSet<ReadInstruction>());
    for (Instruction instruction : ListSequence.fromList(this.myProgram.getInstructionsFor(node))) {
      for (Instruction next : SetSequence.fromSet(instruction.succ())) {
        for (ReadInstruction read : reachingReads.get(next)) {
          if (read.getVariable() == node) {
            SetSequence.fromSet(this.myReadInstructions).addElement(read);
          }
        }
      }
    }
  }

  @Override
  public SNode doRefactoring() {
    SNode newSelection = null;
    for (SNode sourceNode : this.getNodesToRefactor()) {
      // <node> 
      for (SNode reference : ListSequence.fromList(SNodeOperations.getDescendants(sourceNode, "jetbrains.mps.baseLanguage.structure.VariableReference", true, new String[]{}))) {
        if (SLinkOperations.getTarget(reference, "variableDeclaration", false) == myVariable) {
          SNodeOperations.replaceWithAnother(reference, SNodeOperations.copyNode(SLinkOperations.getTarget(myVariable, "initializer", true)));
        }
      }
    }
    this.optimizeDeclaration(this.myVariable);
    return newSelection;
  }

  public List<SNode> getNodesToRefactor() {
    List<SNode> result = new ArrayList<SNode>();
    for (ReadInstruction read : SetSequence.fromSet(this.myReadInstructions)) {
      SNode node = (SNode) read.getSource();
      if (!(SNodeOperations.hasRole(node, "jetbrains.mps.baseLanguage.structure.AbstractUnaryNumberOperation", "expression")) && !(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.OperationAssignmentExpression"))) {
        ListSequence.fromList(result).addElement((node));
      }
    }
    return result;
  }

  public static SNode findStatementList(SNode node) {
    SNode body = SNodeOperations.getAncestor(node, "jetbrains.mps.baseLanguage.structure.StatementList", false, false);
    if (SNodeOperations.getAncestor(body, "jetbrains.mps.baseLanguage.structure.StatementList", false, false) == null) {
      return body;
    }
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(body), "jetbrains.mps.baseLanguage.structure.IStatementListContainer") && !(BehaviorReflection.invokeVirtual(Boolean.TYPE, SNodeOperations.cast(SNodeOperations.getParent(body), "jetbrains.mps.baseLanguage.structure.IStatementListContainer"), "virtual_isExecuteSynchronous_1230212745736", new Object[]{}))) {
      return body;
    }
    return findStatementList(body);
  }
}
