package jetbrains.mps.baseLanguage.util.plugin.refactorings;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.HashSet;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import jetbrains.mps.lang.typesystem.runtime.HUtil;

public abstract class ExtractMethodRefactoring {
  protected ExtractMethodRefactoringParameters myParameters;
  protected ExtractMethodRefactoringAnalyzer myAnalyzer;
  private IStaticContainerProcessor myStaticContainer;
  protected List<MethodMatch> myMatches;

  public ExtractMethodRefactoring(ExtractMethodRefactoringParameters parameters) {
    this.myParameters = parameters;
    this.myAnalyzer = parameters.getAnalyzer();
  }

  @NotNull
  public SNode doRefactor() {
    SNode body = createMethodBody();
    List<SNode> params = new ArrayList<SNode>();
    Map<SNode, SNode> inputToParams = this.createInputParameters(body, params);
    Map<SNode, SNode> inputMapping = this.createInputVaryablesMapping(inputToParams, this.myParameters.getNodesToRefactor());
    this.myMatches = new MethodDuplicatesFinder(this.myParameters.getNodesToRefactor(), inputMapping, params, this.getOutputReferences()).findDuplicates(SNodeOperations.getAncestor(ListSequence.fromList(this.myParameters.getNodesToRefactor()).first(), "jetbrains.mps.baseLanguage.structure.Classifier", false, false));
    this.replaceInputVariablesByParameters(SLinkOperations.getTargets(body, "statement", true), inputToParams);
    SNode newMethod = this.createNewMethod(SNodeOperations.copyNode(this.getMethodType()), params, body);

    this.addMethod(newMethod);
    MethodMatch exactMatch = this.createMatch(this.myParameters.getNodesToRefactor(), inputMapping, params);
    this.replaceMatch(exactMatch, newMethod);
    MethodOptimizer.optimize(body);
    return newMethod;
  }

  protected abstract SNode createMethodBody();

  public abstract void replaceMatch(MethodMatch match, SNode methodDeclaration);

  protected MethodMatch createMatch(List<SNode> nodes, Map<SNode, SNode> inputMapping, List<SNode> parametersOrder) {
    MethodMatch match = new MethodMatch(parametersOrder);
    for (SNode node : ListSequence.fromList(nodes)) {
      match.putNode(node);
    }
    for (SNode node : SetSequence.fromSet(MapSequence.fromMap(inputMapping).keySet())) {
      match.putMapping(node, MapSequence.fromMap(inputMapping).get(node));
    }
    return match;
  }

  protected SNode createNewMethod(SNode returnType, List<SNode> params, SNode body) {
    SNode myMethod;
    if (this.myStaticContainer != null) {
      myMethod = this.myStaticContainer.createNewMethod();
    } else {
      IExtractMethodRefactoringProcessor processor = this.myAnalyzer.getExtractMethodReafactoringProcessor();
      if (processor instanceof AbstractExtractMethodRefactoringProcessor) {
        ((AbstractExtractMethodRefactoringProcessor) processor).setStatic(this.myParameters.isStatic());
      }
      myMethod = processor.createNewMethod();
    }
    this.fillBaseMethodDeclaration(myMethod, returnType, params, body);
    this.createNewDeclarations(myMethod);
    this.correctThrowsList(myMethod);
    return myMethod;
  }

  private void correctThrowsList(SNode method) {
    List<SNode> throwables = new ArrayList<SNode>();
    for (SNode statement : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, "body", true), "statement", true))) {
      ListSequence.fromList(throwables).addSequence(SetSequence.fromSet(BehaviorReflection.invokeNonVirtual((Class<Set<SNode>>) ((Class) Object.class), statement, "jetbrains.mps.baseLanguage.structure.Statement", "call_uncaughtThrowables_5412515780383108857", new Object[]{false})));
    }
    ListSequence.fromList(SLinkOperations.getTargets(method, "throwsItem", true)).addSequence(ListSequence.fromList(throwables).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return _quotation_createNode_jq3ovj_a0a0a0a0c0k(it);
      }
    }));
  }

  protected void createNewDeclarations(SNode method) {
    Map<SNode, List<SNode>> mapping = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());
    for (SNode reference : ListSequence.fromList(SNodeOperations.getDescendants(method, "jetbrains.mps.baseLanguage.structure.VariableReference", false, new String[]{}))) {
      SNode declaration = SLinkOperations.getTarget(reference, "variableDeclaration", false);
      if (!(SNodeOperations.isInstanceOf(declaration, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration") || SNodeOperations.isInstanceOf(declaration, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration"))) {
        continue;
      }

      if (!(ListSequence.fromList(SNodeOperations.getAncestors(declaration, null, false)).contains(method))) {
        if (!(SetSequence.fromSet(MapSequence.fromMap(mapping).keySet()).contains(declaration))) {
          MapSequence.fromMap(mapping).put(declaration, new ArrayList<SNode>());
        }
        ListSequence.fromList(MapSequence.fromMap(mapping).get(declaration)).addElement(reference);
      }
    }
    for (SNode declaration : SetSequence.fromSet(MapSequence.fromMap(mapping).keySet())) {
      SNode newDeclaration = _quotation_createNode_jq3ovj_a0a0c0l(SNodeOperations.copyNode(SLinkOperations.getTarget(declaration, "type", true)), SPropertyOperations.getString(declaration, "name"));
      SNodeOperations.insertPrevSiblingChild(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, "body", true), "statement", true)).first(), _quotation_createNode_jq3ovj_a0a1a2a11(newDeclaration));
      for (SNode reference : ListSequence.fromList(MapSequence.fromMap(mapping).get(declaration))) {
        SNodeOperations.replaceWithAnother(reference, BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), newDeclaration, "virtual_createReference_1213877517482", new Object[]{}));
      }
    }
  }

  protected SNode fillBaseMethodDeclaration(SNode declaration, SNode returnType, List<SNode> params, SNode body) {
    if (SNodeOperations.isInstanceOf(declaration, "jetbrains.mps.baseLanguage.structure.IVisible")) {
      SNode visibleDeclaration = SNodeOperations.cast(declaration, "jetbrains.mps.baseLanguage.structure.IVisible");
      SLinkOperations.setTarget(visibleDeclaration, "visibility", this.myParameters.getVisibilityLevel().getNode(), true);
    }
    SNode methodDeclaration = declaration;
    SLinkOperations.setTarget(methodDeclaration, "returnType", SNodeOperations.copyNode(returnType), true);
    SPropertyOperations.set(methodDeclaration, "name", this.myParameters.getName());
    ListSequence.fromList(SLinkOperations.getTargets(methodDeclaration, "parameter", true)).addSequence(ListSequence.fromList(params));
    SLinkOperations.setTarget(methodDeclaration, "body", body, true);
    return methodDeclaration;
  }

  protected void addMethod(SNode node) {
    if (this.myStaticContainer == null) {
      IExtractMethodRefactoringProcessor processor = this.myAnalyzer.getExtractMethodReafactoringProcessor();
      processor.addMethod(node);
    } else {
      this.myStaticContainer.addMethod(node);
    }
  }

  protected Map<SNode, SNode> createInputParameters(SNode body, List<SNode> parameters) {
    Map<SNode, SNode> result = MapSequence.fromMap(new HashMap<SNode, SNode>());
    for (MethodParameter methodParameter : ListSequence.fromList(this.myParameters.getParameters())) {
      if (methodParameter.isSelected()) {
        SNode parameter = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParameterDeclaration", null);
        SLinkOperations.setTarget(parameter, "type", SNodeOperations.copyNode(methodParameter.getType()), true);
        SPropertyOperations.set(parameter, "name", methodParameter.getName());
        if (methodParameter.isFinal()) {
          SPropertyOperations.set(parameter, "isFinal", "" + (true));
        }
        ListSequence.fromList(parameters).addElement(parameter);
        MapSequence.fromMap(result).put(methodParameter.getDeclaration(), parameter);
      }
    }
    return result;
  }

  public void replaceInputVariablesByParameters(List<SNode> nodes, Map<SNode, SNode> mapping) {
    Map<SNode, SNode> anotherMap = this.createInputVaryablesMapping(mapping, nodes);
    for (SNode node : SetSequence.fromSet(MapSequence.fromMap(anotherMap).keySet())) {
      SNodeOperations.replaceWithAnother(node, _quotation_createNode_jq3ovj_a0a0a1a51(MapSequence.fromMap(anotherMap).get(node)));
    }
  }

  public Map<SNode, SNode> createInputVaryablesMapping(Map<SNode, SNode> variableDeclarationToParameter, List<SNode> nodes) {
    Map<SNode, SNode> mapping = MapSequence.fromMap(new HashMap<SNode, SNode>());
    for (SNode node : ListSequence.fromList(nodes)) {
      for (SNode reference : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.lang.core.structure.BaseConcept", false, new String[]{}))) {
        if (MoveRefactoringUtils.isReference(reference)) {
          SNode target = Sequence.fromIterable(SNodeOperations.getReferences(reference)).first().getTargetNode();
          if (MapSequence.fromMap(variableDeclarationToParameter).containsKey(target)) {
            MapSequence.fromMap(mapping).put(reference, MapSequence.fromMap(variableDeclarationToParameter).get(target));
          }
        }
      }
      for (SNode parameter : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.IParameter", false, new String[]{}))) {
        SNode declaration = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), parameter, "virtual_getDeclaration_1225282371351", new Object[]{});
        if (MapSequence.fromMap(variableDeclarationToParameter).containsKey(declaration)) {
          MapSequence.fromMap(mapping).put(parameter, MapSequence.fromMap(variableDeclarationToParameter).get(declaration));
        }
      }
    }
    return mapping;
  }

  protected SNode createReference(SNode variable) {
    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), variable, "virtual_createReference_1213877517482", new Object[]{});
  }

  protected List<SNode> createCallParameters() {
    List<SNode> result = new ArrayList<SNode>();
    for (MethodParameter parameter : ListSequence.fromList(this.myParameters.getParameters())) {
      if (parameter.isSelected()) {
        ListSequence.fromList(result).addElement(parameter.getReference());
      }
    }
    return result;
  }

  protected SNode createMethodCall(SNode methodDeclaration, List<SNode> parameters) {
    if (this.myStaticContainer == null) {
      IExtractMethodRefactoringProcessor processor = this.myAnalyzer.getExtractMethodReafactoringProcessor();
      return processor.createMethodCall(methodDeclaration, parameters);
    } else {
      return this.myStaticContainer.createMethodCall(methodDeclaration, parameters);
    }
  }

  public SNode createMethodCall(MethodMatch match, SNode methodDeclaration) {
    return this.createMethodCall(methodDeclaration, match.getCallParameters());
  }

  public void setStaticContainer(SNode node) {
    if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      this.myStaticContainer = new ClassStaticContainerProcessor(node);
    } else if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.IStaticContainerForMethods")) {
      SNode staticContainer = SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.IStaticContainerForMethods");
      this.myStaticContainer = BehaviorReflection.invokeVirtual(IStaticContainerProcessor.class, staticContainer, "virtual_getStaticContainerProcessor_1222174378300", new Object[]{node});
    } else {
      throw new IllegalArgumentException();
    }
  }

  public Set<SNode> getOutputReferences() {
    Set<SNode> result = SetSequence.fromSet(new HashSet<SNode>());
    List<SNode> outputVariables = myParameters.getAnalyzer().getOutputVariables();
    for (SNode node : ListSequence.fromList(myParameters.getNodesToRefactor())) {
      for (SNode varReference : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.VariableReference", false, new String[]{}))) {
        if (ListSequence.fromList(outputVariables).contains(SLinkOperations.getTarget(varReference, "variableDeclaration", false))) {
          SetSequence.fromSet(result).addElement(varReference);
        }
      }
    }
    return result;
  }

  public List<MethodMatch> getMatches() {
    return this.myMatches;
  }

  public ExtractMethodRefactoringAnalyzer getAnalyzer() {
    return myParameters.getAnalyzer();
  }

  public abstract SNode getMethodType();

  public boolean canBeStatic() {
    return this.myAnalyzer.canBeStatic();
  }

  public boolean shouldBeStatic() {
    return this.myAnalyzer.shouldBeStatic();
  }

  private static SNode _quotation_createNode_jq3ovj_a0a0a0a0c0k(Object parameter_1) {
    SNode quotedNode_2 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ClassifierType", null, null, GlobalScope.getInstance(), false);
    SNodeAccessUtil.setReferenceTarget(quotedNode_2, "classifier", (SNode) parameter_1);
    return quotedNode_2;
  }

  private static SNode _quotation_createNode_jq3ovj_a0a0c0l(Object parameter_1, Object parameter_2) {
    SNode quotedNode_3 = null;
    SNode quotedNode_4 = null;
    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", null, null, GlobalScope.getInstance(), false);
    SNodeAccessUtil.setProperty(quotedNode_3, "name", (String) parameter_2);
    quotedNode_4 = (SNode) parameter_1;
    if (quotedNode_4 != null) {
      quotedNode_3.addChild("type", HUtil.copyIfNecessary(quotedNode_4));
    }
    return quotedNode_3;
  }

  private static SNode _quotation_createNode_jq3ovj_a0a1a2a11(Object parameter_1) {
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    SNode quotedNode_4 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement", null, null, GlobalScope.getInstance(), false);
    quotedNode_3 = (SNode) parameter_1;
    if (quotedNode_3 != null) {
      quotedNode_2.addChild("localVariableDeclaration", HUtil.copyIfNecessary(quotedNode_3));
    }
    return quotedNode_2;
  }

  private static SNode _quotation_createNode_jq3ovj_a0a0a1a51(Object parameter_1) {
    SNode quotedNode_2 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.VariableReference", null, null, GlobalScope.getInstance(), false);
    SNodeAccessUtil.setReferenceTarget(quotedNode_2, "variableDeclaration", (SNode) parameter_1);
    return quotedNode_2;
  }
}
