package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.IModule;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.SModelDescriptor;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.IScope;
import jetbrains.mps.project.GlobalScope;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.LanguageID;
import java.util.Collections;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.scope.ModelPlusImportedScope;
import java.util.StringTokenizer;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.behavior.Tokens_Behavior;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.ListIterator;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.module.SModuleScope;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;

public class ClassifierResolveUtils {
  private ClassifierResolveUtils() {
  }

  public static SNode resolveSpecialSyntax(@NotNull String refText, @NotNull SNode contextNode) {
    if (!(refText.startsWith("["))) {
      throw new IllegalArgumentException();
    }
    if (!(refText.contains("]"))) {
      throw new IllegalArgumentException();
    }
    String targetModelName = refText.substring(1, refText.indexOf("]"));
    String targetNodeFqName = targetModelName + "." + refText.substring(refText.indexOf("]") + 1);

    return resolveWithSpecifiedTargetModelName(targetModelName, targetNodeFqName, SNodeOperations.getModel(contextNode));
  }

  public static SNode resolveNonSpecialSyntax(@NotNull String classifierName, @NotNull SNode contextNode) {
    // try to resolve as nested name in current model 
    Iterable<SNode> result = resolveClassifierByNestedName(check_8z6r2b_a0a1a2(SNodeOperations.getModel(contextNode)), classifierName);
    if (Sequence.fromIterable(result).isNotEmpty()) {
      return ((int) Sequence.fromIterable(result).count() == 1 ?
        Sequence.fromIterable(result).first() :
        null
      );
    }

    // try to resolve as fq name in current model 
    result = resolveClassifierByFqName(check_8z6r2b_a0a5a2(SNodeOperations.getModel(contextNode)), classifierName);
    if (Sequence.fromIterable(result).isNotEmpty()) {
      return ((int) Sequence.fromIterable(result).count() == 1 ?
        Sequence.fromIterable(result).first() :
        null
      );
    }

    // try to resolve as fq name in current scope 
    Iterable<IModule> visibleModules = check_8z6r2b_a0a9a2(check_8z6r2b_a0a0j0c(check_8z6r2b_a0a0a9a2(SNodeOperations.getModel(contextNode)))).getVisibleModules();
    result = resolveClassifierByFqNameWithNonStubPriority(Sequence.fromIterable(visibleModules).translate(new ITranslator2<IModule, SModelDescriptor>() {
      public Iterable<SModelDescriptor> translate(IModule it) {
        return it.getOwnModelDescriptors();
      }
    }), classifierName);
    return ((int) Sequence.fromIterable(result).count() == 1 ?
      Sequence.fromIterable(result).first() :
      null
    );
  }

  public static SNode resolveWithSpecifiedTargetModelName(@NotNull String targetModelName, @NotNull String classifierFqName, @Nullable SModel sourceModel) {
    Iterable<SNode> sameModelResult = resolveClassifierByFqName(check_8z6r2b_a0a0a3(sourceModel), classifierFqName);
    if (Sequence.fromIterable(sameModelResult).isNotEmpty()) {
      return ((int) Sequence.fromIterable(sameModelResult).count() == 1 ?
        Sequence.fromIterable(sameModelResult).first() :
        null
      );
    }

    IScope modelScope = check_8z6r2b_a0d0d(check_8z6r2b_a0a3a3(check_8z6r2b_a0a0d0d(sourceModel)));

    if (modelScope != null) {
      Iterable<SNode> result = resolveInScope(targetModelName, classifierFqName, modelScope);
      if (Sequence.fromIterable(result).isNotEmpty()) {
        return ((int) Sequence.fromIterable(result).count() == 1 ?
          Sequence.fromIterable(result).first() :
          null
        );
      }
    }

    Iterable<SNode> result = resolveInScope(targetModelName, classifierFqName, GlobalScope.getInstance());
    return ((int) Sequence.fromIterable(result).count() == 1 ?
      Sequence.fromIterable(result).first() :
      null
    );
  }

  private static Iterable<SNode> resolveInScope(@NotNull String targetModelName, @NotNull String classifierFqName, @NotNull IScope scope) {
    return resolveClassifierByFqNameWithNonStubPriority(getModelsWithNameInScope(scope, targetModelName), classifierFqName);
  }

  private static Iterable<SModelDescriptor> getModelsWithNameInScope(@NotNull IScope scope, @NotNull String modelLongName) {
    // todo: go through all stereotypes and resolve by long name and stereotype 
    List<SModelDescriptor> result = ListSequence.fromList(new ArrayList<SModelDescriptor>());
    for (IModule module : Sequence.fromIterable(scope.getVisibleModules())) {
      for (SModelDescriptor modelDescriptor : ListSequence.fromList(module.getOwnModelDescriptors())) {
        if (eq_8z6r2b_a0a0a0c0f(modelDescriptor.getLongName(), modelLongName)) {
          ListSequence.fromList(result).addElement(modelDescriptor);
        }
      }
    }
    return result;
  }

  private static Iterable<SNode> resolveClassifierByFqNameWithNonStubPriority(Iterable<SModelDescriptor> models, String classifierFqName) {
    models = Sequence.fromIterable(models).where(new IWhereFilter<SModelDescriptor>() {
      public boolean accept(SModelDescriptor it) {
        return !(it.isTransient());
      }
    });

    final String stubStereoType = SModelStereotype.getStubStereotypeForId(LanguageID.JAVA);

    // resolve without stubs 
    Iterable<SNode> result = resolveClassifierByFqName(Sequence.fromIterable(models).where(new IWhereFilter<SModelDescriptor>() {
      public boolean accept(SModelDescriptor it) {
        return neq_8z6r2b_a0a0a0a0a0a0f0g(it.getStereotype(), stubStereoType);
      }
    }), classifierFqName);
    if (Sequence.fromIterable(result).isNotEmpty()) {
      return result;
    }

    // resolve with stubs 
    return resolveClassifierByFqName(Sequence.fromIterable(models).where(new IWhereFilter<SModelDescriptor>() {
      public boolean accept(SModelDescriptor it) {
        return eq_8z6r2b_a0a0a0a0a0a9a6(it.getStereotype(), stubStereoType);
      }
    }), classifierFqName);
  }

  private static Iterable<SNode> resolveClassifierByFqName(Iterable<SModelDescriptor> models, final String classifierFqName) {
    return Sequence.fromIterable(models).translate(new ITranslator2<SModelDescriptor, SNode>() {
      public Iterable<SNode> translate(SModelDescriptor it) {
        return resolveClassifierByFqName(it, classifierFqName);
      }
    });
  }

  private static Iterable<SNode> resolveClassifierByFqName(SModelDescriptor modelDescriptor, String classifierFqName) {
    assert !(classifierFqName.contains("$"));

    if (!(classifierFqName.startsWith(modelDescriptor.getLongName()))) {
      return Collections.<SNode>emptyList();
    }

    String classifierNestedName = classifierFqName.substring(modelDescriptor.getLongName().length() + 1);
    return resolveClassifierByNestedName(modelDescriptor, classifierNestedName);
  }

  private static Iterable<SNode> resolveClassifierByNestedName(SModelDescriptor modelDescriptor, String classifierNestedName) {
    assert !(classifierNestedName.contains("$"));

    SModel model = modelDescriptor.getSModel();
    if (model == null) {
      // todo: ? 
      return Collections.<SNode>emptyList();
    }

    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());
    for (SNode classifier : getClassifiersInModel(model)) {
      if (classifierNestedName.equals(getNestedName(classifier))) {
        ListSequence.fromList(result).addElement(classifier);
      }
    }
    return result;
  }

  private static String getNestedName(SNode classifier) {
    String name = SPropertyOperations.getString(classifier, "name");
    if (name == null) {
      name = "";
    }
    SNode parent = SNodeOperations.getParent(classifier);
    if (SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      return getNestedName(SNodeOperations.cast(parent, "jetbrains.mps.baseLanguage.structure.Classifier")) + "." + name;
    }
    return name;
  }

  private static Iterable<SNode> getClassifiersInModel(SModel model) {
    Iterable<SNode> classifiers = model.getFastNodeFinder().getNodes("jetbrains.mps.baseLanguage.structure.Classifier", true);
    return (Iterable<SNode>) Sequence.fromIterable(classifiers).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.AnonymousClass"));
      }
    });
  }

  public static SNode resolve(@NotNull String refText, @NotNull SNode contextNode, IScope moduleScope, ModelPlusImportedScope modelsPlusImported, boolean includeAncestors) {
    // The algororithm: 
    // - split refText into tokens A.B.C (separated by dot) 
    // - look for the first token A among the following classifiers and models, in this order: 
    // ourselves 
    // our immediate nested classes 
    // nested classes of our enclosing classes (if we're not root) 
    // foreach C in our hierarchy: 1) try C 2) try C's immediaate nested classes 
    // walk up to our root and see if it has java import data attached 
    //   if yes, use it 
    //   if no, only then traverse all appropriate models 

    SModel oldModel = contextNode.getModel();
    org.jetbrains.mps.openapi.model.SModel contextNodeModel = (oldModel == null ?
      null :
      oldModel.getModelDescriptor()
    );

    StringTokenizer tokenizer = new StringTokenizer(refText, ".");
    if (!(tokenizer.hasMoreTokens())) {
      return null;
    }
    String token = tokenizer.nextToken();

    assert token != null;

    if (!(SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.AnonymousClass"))) {
      if (token.equals(SPropertyOperations.getString(contextNode, "name"))) {
        return construct(contextNode, tokenizer);
      }
    }
    for (SNode nestedClas : Sequence.fromIterable(getImmediateNestedClassifiers(contextNode))) {
      if (token.equals(SPropertyOperations.getString(nestedClas, "name"))) {
        return construct(nestedClas, tokenizer);
      }
    }

    for (SNode enclosingClass : Sequence.fromIterable(getPathToRoot(contextNode))) {
      if (SNodeOperations.isInstanceOf(enclosingClass, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
        continue;
      }
      if (token.equals(SPropertyOperations.getString(enclosingClass, "name"))) {
        return construct(enclosingClass, tokenizer);
      }
      for (SNode nested : Sequence.fromIterable(getImmediateNestedClassifiers(enclosingClass))) {
        if (token.equals(SPropertyOperations.getString(nested, "name"))) {
          return construct(nested, tokenizer);
        }
      }
    }

    if (includeAncestors) {
      for (SNode ancestor : Sequence.fromIterable(getAncestors(contextNode))) {
        if (token.equals(SPropertyOperations.getString(ancestor, "name"))) {
          return construct(ancestor, tokenizer);
        }
        for (SNode nested : Sequence.fromIterable(getImmediateNestedClassifiers(ancestor))) {
          if (token.equals(SPropertyOperations.getString(nested, "name"))) {
            return construct(nested, tokenizer);
          }
        }
      }
    }

    Iterable<org.jetbrains.mps.openapi.model.SModel> models;

    SNode root = Sequence.fromIterable(getPathToRoot(contextNode)).last();
    SNode javaImports = AttributeOperations.getAttribute(root, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.JavaImports")));

    if (javaImports == null) {
      // This is probably too wide 
      // <node> 
      Collection<SModelDescriptor> parentScopeModels = modelsPlusImported.getModels();
      List<org.jetbrains.mps.openapi.model.SModel> ms = ListSequence.fromList(new ArrayList<org.jetbrains.mps.openapi.model.SModel>());
      ListSequence.fromList(ms).addSequence(CollectionSequence.fromCollection(parentScopeModels));
      models = ms;

    } else {
      // walk thru single-type importrs 
      // TODO static imports are not handled yet 
      for (SNode imp : ListSequence.fromList(SLinkOperations.getTargets(javaImports, "entries", true)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return !(SPropertyOperations.getBoolean(it, "onDemand"));
        }
      })) {
        if (!(token.equals(SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(imp, "token", true)).last(), "value")))) {
          continue;
        }

        String fqName = Tokens_Behavior.call_stringRep_6148840541591415725(imp);
        SNode cls = resolveFqName(fqName, moduleScope, contextNodeModel);
        return cls;
      }

      // putting on-demand imports into model list 
      List<org.jetbrains.mps.openapi.model.SModel> javaImportedModels = ListSequence.fromList(new ArrayList<org.jetbrains.mps.openapi.model.SModel>());
      ListSequence.fromList(javaImportedModels).addElement(SModelRepository.getInstance().getModelDescriptor(new SModelReference("java.lang", "java_stub")).getSModel().getModelDescriptor());
      for (SNode imp : ListSequence.fromList(SLinkOperations.getTargets(javaImports, "entries", true)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SPropertyOperations.getBoolean(it, "onDemand");
        }
      })) {
        String pkgName = Tokens_Behavior.call_stringRep_6148840541591415725(imp);
        // FIXME this ignores scope 
        List<SModelDescriptor> ms = SModelRepository.getInstance().getModelDescriptorsByModelName(pkgName);
        ListSequence.fromList(javaImportedModels).addSequence(ListSequence.fromList(ms));
      }
      // adding our MPS module scope after java imports as backup 
      ListSequence.fromList(javaImportedModels).addSequence(CollectionSequence.fromCollection(modelsPlusImported.getModels()));
      models = javaImportedModels;
    }

    // let's see if its an fqName (i.e. starting with a package name) 
    SNode c = resolveFqName(refText, moduleScope, contextNodeModel);
    if ((c != null)) {
      return c;
    }

    // finally, let's go through all appropriate models and see if there is such a root 

    // adding contextNodeModel in the beginning of sequence 
    models = Sequence.fromIterable(Sequence.<org.jetbrains.mps.openapi.model.SModel>singleton(contextNodeModel)).concat(Sequence.fromIterable(models));

    for (org.jetbrains.mps.openapi.model.SModel model : Sequence.fromIterable(models)) {
      // FIXME will be unnecessary when transient models live in a separate repository 
      if (!(model.equals(contextNodeModel)) && model instanceof SModelDescriptor && ((SModelDescriptor) model).isTransient()) {
        continue;
      }

      // TODO try to use some fast find support 
      Iterable<? extends SNode> roots = model.getRootNodes();
      for (SNode r : roots) {
        if (!(SNodeOperations.isInstanceOf(r, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
          continue;
        }
        if (token.equals(SPropertyOperations.getString(SNodeOperations.cast(r, "jetbrains.mps.baseLanguage.structure.Classifier"), "name"))) {
          // see if we can find a node for the whole refText, starting from here 
          SNode node = construct(SNodeOperations.cast(r, "jetbrains.mps.baseLanguage.structure.Classifier"), tokenizer);
          if ((node != null)) {
            return node;
          }
        }
      }
    }

    // <node> 

    // try to use old logic 

    // try to resolve as fq name in current model 
    Iterable<SNode> result;

    result = resolveClassifierByFqName(check_8z6r2b_a0a25a21(SNodeOperations.getModel(contextNode)), refText);
    if (Sequence.fromIterable(result).isNotEmpty()) {
      return ((int) Sequence.fromIterable(result).count() == 1 ?
        Sequence.fromIterable(result).first() :
        null
      );
    }

    // try to resolve as fq name in current scope 
    Iterable<IModule> visibleModules = check_8z6r2b_a0a65a21(check_8z6r2b_a0a0ec0m(check_8z6r2b_a0a0a65a21(SNodeOperations.getModel(contextNode)))).getVisibleModules();
    result = resolveClassifierByFqNameWithNonStubPriority(Sequence.fromIterable(visibleModules).translate(new ITranslator2<IModule, SModelDescriptor>() {
      public Iterable<SModelDescriptor> translate(IModule it) {
        return it.getOwnModelDescriptors();
      }
    }), refText);
    return ((int) Sequence.fromIterable(result).count() == 1 ?
      Sequence.fromIterable(result).first() :
      null
    );

  }

  public static Iterable<SNode> getImmediateNestedClassifiers(SNode clas) {
    // TODO are there other deprecated member roles 
    return ListSequence.fromList(SLinkOperations.getTargets(clas, "member", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SConceptOperations.isSubConceptOf(SNodeOperations.getConceptDeclaration(it), "jetbrains.mps.baseLanguage.structure.Classifier");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.Classifier");
      }
    }).concat(ListSequence.fromList(SLinkOperations.getTargets(clas, "staticInnerClassifiers", true)));
  }

  public static Iterable<SNode> getPathToRoot(SNode clas) {
    // TODO make more precise: take role into consideration 
    return SNodeOperations.getAncestors(clas, "jetbrains.mps.baseLanguage.structure.Classifier", true);
  }

  public static Iterable<SNode> getAncestors(SNode clas) {
    List<SNode> classes = ListSequence.fromList(new ArrayList<SNode>());

    ListSequence.fromList(classes).addElement(clas);

    final ListIterator<SNode> iter = classes.listIterator();
    while (iter.hasNext()) {

      SNode claz = iter.next();

      if (SNodeOperations.isInstanceOf(claz, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
        iter.add(SLinkOperations.getTarget(SNodeOperations.cast(claz, "jetbrains.mps.baseLanguage.structure.AnonymousClass"), "classifier", false));

      } else if (SNodeOperations.isInstanceOf(claz, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        SNode supr = SLinkOperations.getTarget(SLinkOperations.getTarget(SNodeOperations.cast(claz, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "superclass", true), "classifier", false);
        if ((supr != null)) {
          iter.add(supr);
        }
        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(claz, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "implementedInterface", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SLinkOperations.getTarget(it, "classifier", false) != null);
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, "classifier", false);
          }
        }).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            iter.add(it);
          }
        });

      } else if (SNodeOperations.isInstanceOf(claz, "jetbrains.mps.baseLanguage.structure.Interface")) {
        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(claz, "jetbrains.mps.baseLanguage.structure.Interface"), "extendedInterface", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SLinkOperations.getTarget(it, "classifier", false) != null);
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, "classifier", false);
          }
        }).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            iter.add(it);
          }
        });
      }

    }
    // or just classes, doesn't really matter 
    return ListSequence.fromList(classes).skip(1);
  }

  private static SNode construct(SNode base, StringTokenizer tokenizer) {
    SNode curr = base;
    while ((curr != null) && tokenizer.hasMoreTokens()) {
      final String tok = tokenizer.nextToken();
      curr = Sequence.fromIterable(getImmediateNestedClassifiers(curr)).findFirst(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return tok.equals(SPropertyOperations.getString(it, "name"));
        }
      });
    }
    return curr;
  }

  public static SNode resolveFqName(String refText, SModuleScope moduleScope, org.jetbrains.mps.openapi.model.SModel contextNodeModel) {
    // FIXME constant 20 
    int[] dotPositions = new int[20];
    int lastDot = -1;
    int k = 0;
    while ((lastDot = refText.indexOf(".", lastDot + 1)) > 0) {

      dotPositions[k] = lastDot;
      k++;
    }

    // try the longest name first, the shortest last 
    // we start with x.y when refText is x.y.z 
    for (int p = k - 1; p >= 0; p--) {

      String pkgName = refText.substring(0, dotPositions[p]);
      Iterable<org.jetbrains.mps.openapi.model.SModel> models = getModelsByName(moduleScope, pkgName);

      if (Sequence.fromIterable(models).isEmpty()) {
        continue;
      }

      for (org.jetbrains.mps.openapi.model.SModel m : Sequence.fromIterable(models)) {

        // FIXME will be unnecessary when transient models live in a separate repository 
        if (!(m.equals(contextNodeModel)) && m instanceof SModelDescriptor && ((SModelDescriptor) m).isTransient()) {
          continue;
        }

        String refTextWithoutPackage = refText.substring(dotPositions[p] + 1);
        StringTokenizer tokenizer = new StringTokenizer(refTextWithoutPackage, ".");
        assert tokenizer.hasMoreTokens();
        String className = tokenizer.nextToken();
        SNode cls = null;
        for (SNode r : m.getRootNodes()) {
          if (!(SNodeOperations.isInstanceOf(r, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
            continue;
          }
          if (className.equals(SPropertyOperations.getString(SNodeOperations.cast(r, "jetbrains.mps.baseLanguage.structure.Classifier"), "name"))) {
            cls = SNodeOperations.cast(r, "jetbrains.mps.baseLanguage.structure.Classifier");
          }
        }
        if ((cls == null)) {
          continue;
        }
        cls = construct(cls, tokenizer);
        if ((cls == null)) {
          continue;
        }

        return cls;
      }
    }
    return null;
  }

  public static Iterable<org.jetbrains.mps.openapi.model.SModel> getModelsByName(SModuleScope moduleScope, String name) {
    List<org.jetbrains.mps.openapi.model.SModel> models = ListSequence.fromList(new ArrayList<org.jetbrains.mps.openapi.model.SModel>());

    // THINK maybe we should put those models together, not use if-else 

    org.jetbrains.mps.openapi.model.SModel model = moduleScope.resolve(SModelReference.fromString(name));
    if (model != null) {
      ListSequence.fromList(models).addElement(model);
    } else {
      // FIXME it's wrong: deprecated and ignores module scope 
      ListSequence.fromList(models).addSequence(ListSequence.fromList(SModelRepository.getInstance().getModelDescriptorsByModelName(name)));
    }
    return models;
  }

  public static Iterable<SNode> staticImportedMethods(SNode imports) {
    return staticImportedThings(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"), imports);
  }

  public static Iterable<SNode> staticImportedFields(SNode imports) {
    return staticImportedThings(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration"), imports);
  }

  /**
   * methodsOrFields: true for methods. false for fields
   */
  public static Iterable<SNode> staticImportedThings(final SNode neededConcept, SNode imports) {
    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());
    IScope moduleScope = SNodeOperations.getModel(imports).getModelDescriptor().getModule().getScope();
    for (SNode imp : ListSequence.fromList(SLinkOperations.getTargets(imports, "entries", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SPropertyOperations.getBoolean(it, "static");
      }
    })) {

      if (SPropertyOperations.getBoolean(imp, "onDemand")) {
        String className = Tokens_Behavior.call_stringRep_6148840541591415725(imp);
        SNode containingClas = resolveFqName(className, moduleScope, null);
        if ((containingClas == null)) {
          continue;
        }

        Iterable<SNode> neededMembers = ListSequence.fromList(BehaviorReflection.invokeVirtual((Class<List<SNode>>) ((Class) Object.class), containingClas, "virtual_getMembers_1213877531970", new Object[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.getConceptDeclaration(it) == neededConcept;
          }
        });
        ListSequence.fromList(result).addSequence(Sequence.fromIterable(neededMembers));

      } else {

        final String memberName = SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(imp, "token", true)).last(), "value");
        String className = Tokens_Behavior.call_stringRep_6148840541591441572(imp, 1);

        SNode containingClas = resolveFqName(className, moduleScope, null);
        if ((containingClas == null)) {
          continue;
        }

        // or findAll instead of findFirst ? 
        SNode neededMember = ListSequence.fromList(BehaviorReflection.invokeVirtual((Class<List<SNode>>) ((Class) Object.class), containingClas, "virtual_getMembers_1213877531970", new Object[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.getConceptDeclaration(it) == neededConcept;
          }
        }).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return memberName.equals(it.getName());
          }
        });

        if ((neededMember == null)) {
          continue;
        }

        ListSequence.fromList(result).addElement(neededMember);

      }
    }
    return result;
  }

  private static SModelDescriptor check_8z6r2b_a0a1a2(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }

  private static SModelDescriptor check_8z6r2b_a0a5a2(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }

  private static IScope check_8z6r2b_a0a9a2(IModule checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScope();
    }
    return null;
  }

  private static IModule check_8z6r2b_a0a0j0c(SModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }

  private static SModelDescriptor check_8z6r2b_a0a0a9a2(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }

  private static SModelDescriptor check_8z6r2b_a0a0a3(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }

  private static IScope check_8z6r2b_a0d0d(IModule checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScope();
    }
    return null;
  }

  private static IModule check_8z6r2b_a0a3a3(SModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }

  private static SModelDescriptor check_8z6r2b_a0a0d0d(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }

  private static SModelDescriptor check_8z6r2b_a0a25a21(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }

  private static IScope check_8z6r2b_a0a65a21(IModule checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScope();
    }
    return null;
  }

  private static IModule check_8z6r2b_a0a0ec0m(SModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }

  private static SModelDescriptor check_8z6r2b_a0a0a65a21(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }

  private static boolean eq_8z6r2b_a0a0a0c0f(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  private static boolean neq_8z6r2b_a0a0a0a0a0a0f0g(Object a, Object b) {
    return !((a != null ?
      a.equals(b) :
      a == b
    ));
  }

  private static boolean eq_8z6r2b_a0a0a0a0a0a9a6(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }
}
