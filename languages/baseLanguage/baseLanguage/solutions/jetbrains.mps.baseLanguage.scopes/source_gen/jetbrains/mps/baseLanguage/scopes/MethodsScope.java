package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import jetbrains.mps.scope.Scope;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.behavior.IClassifierMember_Behavior;
import jetbrains.mps.baseLanguage.behavior.IClassifierType_Behavior;
import java.util.Collections;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public class MethodsScope extends Scope {
  private final Map<SNode, SNode> typeBindings;
  private final Map<String, List<SNode>> nameToMethods;

  public MethodsScope(SNode classifierTypeNode, Iterable<SNode> methods) {
    nameToMethods = MapSequence.fromMap(new HashMap<String, List<SNode>>());
    for (SNode method : Sequence.fromIterable(methods)) {
      String name = SPropertyOperations.getString(method, "name");
      if (name != null) {
        if (MapSequence.fromMap(nameToMethods).containsKey(name)) {
          ListSequence.fromList(MapSequence.fromMap(nameToMethods).get(name)).addElement(method);
        } else {
          MapSequence.fromMap(nameToMethods).put(name, ListSequence.fromListAndArray(new ArrayList(), method));
        }
      }
    }

    // todo: make static constructors (static and instance methods?) from IClassifierType 
    boolean isStatic = Sequence.fromIterable(methods).all(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.IClassifierMember") && IClassifierMember_Behavior.call_isStatic_7405920559687241224(SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.IClassifierMember"));
      }
    });
    if (isStatic) {
      typeBindings = new HashMap<SNode, SNode>();
    } else {
      SNode classifier = IClassifierType_Behavior.call_getClassifier_7405920559687237513(classifierTypeNode);
      typeBindings = ((classifier != null) ?
        MethodResolveUtil.getTypesByTypeVars(SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.Classifier"), IClassifierType_Behavior.call_getTypeParameters_7405920559687237518(classifierTypeNode)) :
        Collections.<SNode,SNode>emptyMap()
      );
    }
  }

  public Iterable<SNode> getAvailableElements(@Nullable String prefix) {
    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());
    for (String methodName : MapSequence.fromMap(nameToMethods).keySet()) {
      if (prefix == null || methodName.startsWith(prefix)) {
        ListSequence.fromList(result).addSequence(ListSequence.fromList(MapSequence.fromMap(nameToMethods).get(methodName)));
      }
    }
    return result;
  }

  @Nullable
  public String getReferenceText(SNode contextNode, @NotNull SNode node) {
    return SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "name");
  }

  @Override
  public boolean contains(SNode node) {
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"))) {
      return false;
    }
    String name = SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "name");
    return MapSequence.fromMap(nameToMethods).containsKey(name) && ListSequence.fromList(MapSequence.fromMap(nameToMethods).get(name)).contains(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"));
  }

  @Nullable
  public SNode resolve(SNode contextNode, @NotNull String refText) {
    List<SNode> methods = (MapSequence.fromMap(nameToMethods).containsKey(refText) ?
      MapSequence.fromMap(nameToMethods).get(refText) :
      new ArrayList<SNode>()
    );
    if (methods.isEmpty()) {
      return null;
    }
    if (methods.size() == 1) {
      return ListSequence.fromList(methods).first();
    }
    if (!(SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.IMethodCall"))) {
      return null;
    }
    List<SNode> actualArguments = SLinkOperations.getTargets((SNodeOperations.cast(contextNode, "jetbrains.mps.baseLanguage.structure.IMethodCall")), "actualArgument", true);

    methods = MethodResolveUtil.selectByParmCount(methods, actualArguments);
    if (methods.size() == 1) {
      return ListSequence.fromList(methods).first();
    }

    return MethodResolveUtil.chooseByParameterType(methods, actualArguments, typeBindings);
  }
}
