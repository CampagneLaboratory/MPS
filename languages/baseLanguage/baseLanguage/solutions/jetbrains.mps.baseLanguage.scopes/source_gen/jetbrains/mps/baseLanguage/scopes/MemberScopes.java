package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.concurrent.ConcurrentMap;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.scope.EmptyScope;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.baseLanguage.behavior.ClassifierMember_Behavior;
import jetbrains.mps.scope.FilteringScope;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class MemberScopes {
  private static ThreadLocal<Set<Tuples._2<SNode, SNode>>> inCalculatingScopes = new ThreadLocal() {
    @Override
    protected Object initialValue() {
      return SetSequence.fromSet(new HashSet());
    }
  };
  protected static Log log = LogFactory.getLog(MemberScopes.class);

  private MemberScopes() {
  }

  private static Scope calculateScope(SNode classifier, SNode kind, _FunctionTypes._return_P0_E0<? extends Scope> scope) {
    Tuples._2<SNode, SNode> key = MultiTuple.<SNode,SNode>from(classifier, kind);

    boolean isTransient = SNodeOperations.getModel(classifier).isTransient();
    ConcurrentMap<Tuples._2<SNode, SNode>, Scope> cache = null;

    // cache 
    if (!(isTransient)) {
      cache = ModelAccess.instance().getRepositoryStateCache(MemberScopes.class);
      if (cache != null) {
        Scope cached = cache.get(((Object) key));
        if (cached != null) {
          return cached;
        }
      }
    }

    // recursion preventing 
    if (SetSequence.fromSet(inCalculatingScopes.get()).contains(key)) {
      if (log.isWarnEnabled()) {
        log.warn("Recursion preventing for " + key);
      }
      return new EmptyScope();
    }
    SetSequence.fromSet(inCalculatingScopes.get()).addElement(key);

    Scope result = null;
    try {
      result = scope.invoke();
    } finally {
      SetSequence.fromSet(inCalculatingScopes.get()).removeElement(key);
    }

    if (result != null && !(isTransient) && cache != null) {
      cache.put(key, result);
    }

    return result;
  }

  public static Scope forClass(final SNode kind, final SNode classNode, @Nullable final SNode extendsClass, final SNode... implementedInterfaces) {
    return calculateScope(classNode, kind, new _FunctionTypes._return_P0_E0<Scope>() {
      public Scope invoke() {
        // todo: rewrite using  
        SNode node = SConceptOperations.createNewNode(NameUtil.nodeFQName(kind), null);
        return ClassifierMember_Behavior.call_getScopeForClass_1251851371723365193(node, classNode, extendsClass, implementedInterfaces);
      }
    });
  }

  public static Scope forInterface(final SNode kind, final SNode interfaceNode, final SNode... implementedInterfaces) {
    return calculateScope(interfaceNode, kind, new _FunctionTypes._return_P0_E0<Scope>() {
      public Scope invoke() {
        SNode node = SConceptOperations.createNewNode(NameUtil.nodeFQName(kind), null);
        return ClassifierMember_Behavior.call_getScopeForInterface_1251851371723365208(node, interfaceNode, implementedInterfaces);
      }
    });
  }

  public static Scope nonAbstractMethods(Scope scope) {
    return new FilteringScope(scope) {
      @Override
      public boolean isExcluded(SNode node) {
        return !(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) || ((Boolean) BehaviorManager.getInstance().invoke(Boolean.class, SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "virtual_isAbstract_1232982539764", new Class[]{SNode.class}));
      }
    };
  }

  public static Scope visibleClassifierMembers(Scope scope, final SNode contextClassifier, final SNode contextNode) {
    return new FilteringScope(scope) {
      @Override
      public boolean isExcluded(SNode node) {
        return !(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.ClassifierMember")) || !(((Boolean) BehaviorManager.getInstance().invoke(Boolean.class, SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassifierMember"), "virtual_isVisible_8083692786967482069", new Class[]{SNode.class, SNode.class, SNode.class}, contextClassifier, contextNode)));
      }
    };
  }

  public static Scope visibleClassifierMembers(SNode contextClassifier, SNode kind, SNode contextNode) {
    Scope membersScope = Classifier_Behavior.call_getMembers_2201875424515824604(contextClassifier, kind);
    if (membersScope == null) {
      throw new IllegalArgumentException("Member scope for classifier " + SPropertyOperations.getString(contextClassifier, "name") + " and kind " + SPropertyOperations.getString(kind, "name") + " is null");
    }
    return visibleClassifierMembers(membersScope, contextClassifier, contextNode);
  }
}
