package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import jetbrains.mps.scope.Scope;
import jetbrains.mps.smodel.SNode;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.TransactionCache;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.scopes.runtime.FilteringScope;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BehaviorManager;

public class MemberScopes {
  private MemberScopes() {
  }

  public static Scope forClass(SNode kind, SNode classNode, @Nullable SNode extendsClass, SNode... implementedInterfaces) {
    TransactionCache cache = ModelAccess.instance().getTransactionCache(MemberScopes.class);
    Scope cached = (Scope) cache.get(MultiTuple.<SNode,SNode>from(classNode, kind));
    if (cached != null) {
      return cached;
    }

    // todo: use reflection Luke 
    Scope result = null;
    if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.FieldDeclaration")) {
      result = FieldDeclarationScope.forClass(classNode, extendsClass, implementedInterfaces);
    } else if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration")) {
      result = EnumConstantDeclarationScope.forClass(classNode, extendsClass, implementedInterfaces);
    } else if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.Property")) {
      result = PropertyScope.forClass(classNode, extendsClass, implementedInterfaces);
    } else if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")) {
      result = StaticFieldDeclarationScope.forClass(classNode, extendsClass, implementedInterfaces);
    } else if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")) {
      result = StaticMethodDeclarationScope.forClass(classNode, extendsClass, implementedInterfaces);
    } else if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
      result = InstanceMethodDeclarationScope.forClass(classNode, extendsClass, implementedInterfaces);
    }

    if (result != null) {
      cache.put(MultiTuple.<SNode,SNode>from(classNode, kind), result);
    }

    return result;
  }

  public static Scope forInterface(SNode kind, SNode interfaceNode, SNode... implementedInterfaces) {
    TransactionCache cache = ModelAccess.instance().getTransactionCache(MemberScopes.class);
    Scope cached = (Scope) cache.get(MultiTuple.<SNode,SNode>from(interfaceNode, kind));
    if (cached != null) {
      return cached;
    }

    // todo: reflection... 
    Scope result = null;
    if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.FieldDeclaration")) {
      result = FieldDeclarationScope.forInterface(interfaceNode, implementedInterfaces);
    } else if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration")) {
      result = EnumConstantDeclarationScope.forInterface(interfaceNode, implementedInterfaces);
    } else if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.Property")) {
      result = PropertyScope.forInterface(interfaceNode, implementedInterfaces);
    } else if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")) {
      result = StaticFieldDeclarationScope.forInterface(interfaceNode, implementedInterfaces);
    } else if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")) {
      result = StaticMethodDeclarationScope.forInterface(interfaceNode, implementedInterfaces);
    } else if (SConceptOperations.isSubConceptOf(kind, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
      result = InstanceMethodDeclarationScope.forInterface(interfaceNode, implementedInterfaces);
    }

    // cache section 
    if (result != null) {
      cache.put(MultiTuple.<SNode,SNode>from(interfaceNode, kind), result);
    }

    return result;
  }

  public static Scope nonAbstractMethods(Scope scope) {
    return new FilteringScope(scope) {
      @Override
      public boolean isExcluded(SNode node) {
        return !(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) || ((Boolean) BehaviorManager.getInstance().invoke(Boolean.class, SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "virtual_isAbstract_1232982539764", new Class[]{SNode.class}));
      }
    };
  }

  public static Scope visibleClassifierMembers(Scope scope, final SNode contextClassifier, final SNode contextNode) {
    return new FilteringScope(scope) {
      @Override
      public boolean isExcluded(SNode node) {
        return !(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.ClassifierMember")) || !(((Boolean) BehaviorManager.getInstance().invoke(Boolean.class, SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassifierMember"), "virtual_isVisible_8083692786967482069", new Class[]{SNode.class, SNode.class, SNode.class}, contextClassifier, contextNode)));
      }
    };
  }

  public static Scope visibleClassifierMembers(SNode contextClassifier, SNode kind, SNode contextNode) {
    return visibleClassifierMembers(((Scope) BehaviorManager.getInstance().invoke(Object.class, contextClassifier, "virtual_getMembers_2201875424515824604", new Class[]{SNode.class, SNode.class}, kind)), contextClassifier, contextNode);
  }
}
