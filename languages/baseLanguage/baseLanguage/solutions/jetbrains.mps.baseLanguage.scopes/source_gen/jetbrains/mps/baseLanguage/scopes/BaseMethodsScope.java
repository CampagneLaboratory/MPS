package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import jetbrains.mps.scope.Scope;
import java.util.Map;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.Nullable;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.internal.collections.runtime.IMapping;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.search.MethodResolveUtil;

public abstract class BaseMethodsScope extends Scope {
  private final Map<String, List<SNode>> nameToMethods;
  protected final SNode kind;
  protected final SNode classifier;
  protected final Iterable<SNode> extendedClassifiers;
  private SNode[] allMethods;

  public BaseMethodsScope(final SNode kind, SNode classifier, Iterable<SNode> extendedClassifiers) {
    this.kind = kind;
    this.classifier = classifier;
    this.extendedClassifiers = extendedClassifiers;

    nameToMethods = MapSequence.fromMap(new HashMap<String, List<SNode>>());
    for (SNode node : ListSequence.fromList(SNodeOperations.getChildren(classifier)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, NameUtil.nodeFQName(kind));
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
      }
    })) {
      if (MapSequence.fromMap(nameToMethods).containsKey(SPropertyOperations.getString(node, "name"))) {
        ListSequence.fromList(MapSequence.fromMap(nameToMethods).get(SPropertyOperations.getString(node, "name"))).addElement(node);
      } else {
        MapSequence.fromMap(nameToMethods).put(SPropertyOperations.getString(node, "name"), ListSequence.fromListAndArray(new ArrayList(), node));
      }
    }
  }

  public abstract String getSignatureForOverriding(SNode method, SNode contextClassifier);

  public Iterable<SNode> getMethodsFromGroup(Iterable<SNode> groupWithEqualSignature) {
    if ((int) Sequence.fromIterable(groupWithEqualSignature).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(SNodeOperations.getParent(it), "jetbrains.mps.baseLanguage.structure.Classifier");
      }
    }).distinct().count() == 1) {
      return groupWithEqualSignature;
    } else {
      return ListSequence.fromList(new ArrayList<SNode>());
    }
  }

  public List<SNode> getAvailableElements(@Nullable final String prefix) {
    if (allMethods != null) {
      return Sequence.fromIterable(Sequence.fromArray(allMethods)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return prefix == null || SPropertyOperations.getString(it, "name").startsWith(prefix);
        }
      }).toListSequence();
    }

    List<SNode> result = ListSequence.fromList(new ArrayList());
    Set<String> overridenSignatures = SetSequence.fromSet(new HashSet<String>());

    for (String name : SetSequence.fromSet(MapSequence.fromMap(nameToMethods).keySet())) {
      if (prefix == null || name.startsWith(prefix)) {
        Iterable<SNode> methods = MapSequence.fromMap(nameToMethods).get(name);
        ListSequence.fromList(result).addSequence(Sequence.fromIterable(methods));
        SetSequence.fromSet(overridenSignatures).addSequence(Sequence.fromIterable(methods).select(new ISelector<SNode, String>() {
          public String select(SNode it) {
            return getSignatureForOverriding(it, classifier);
          }
        }));
      }
    }

    Map<String, Set<SNode>> groups = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
    for (SNode extendedClassifier : Sequence.fromIterable(extendedClassifiers)) {
      for (SNode method : ListSequence.fromList(((Scope) BehaviorManager.getInstance().invoke(Object.class, extendedClassifier, "virtual_getVisibleMembers_8083692786967356611", new Class[]{SNode.class, SNode.class, SNode.class}, classifier, kind)).getAvailableElements(prefix)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(it, NameUtil.nodeFQName(kind));
        }
      }).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
        }
      })) {
        String signature = getSignatureForOverriding(method, classifier);
        if (!(SetSequence.fromSet(overridenSignatures).contains(signature))) {
          if (MapSequence.fromMap(groups).containsKey(signature)) {
            SetSequence.fromSet(MapSequence.fromMap(groups).get(signature)).addElement(method);
          } else {
            MapSequence.fromMap(groups).put(signature, SetSequence.fromSetAndArray(new HashSet<SNode>(), method));
          }
        }
      }
    }

    for (IMapping<String, Set<SNode>> group : MapSequence.fromMap(groups)) {
      // todo: extension methods? 
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(getMethodsFromGroup(group.value())));
    }

    if (prefix == null) {
      allMethods = ListSequence.fromList(result).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
        }
      }).toGenericArray(SNode.class);
    }

    return result;
  }

  @Nullable
  public SNode resolve(SNode contextNode, @NotNull final String refText) {
    List<SNode> methods = ListSequence.fromList(this.getAvailableElements(refText)).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
      }
    }).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return refText.equals(SPropertyOperations.getString(it, "name"));
      }
    }).toListSequence();
    if (methods.isEmpty()) {
      return null;
    }
    if (methods.size() == 1) {
      return ListSequence.fromList(methods).first();
    }
    if (!(SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.IMethodCall"))) {
      return null;
    }
    List<SNode> actualArguments = SLinkOperations.getTargets((SNodeOperations.cast(contextNode, "jetbrains.mps.baseLanguage.structure.IMethodCall")), "actualArgument", true);

    methods = MethodResolveUtil.selectByParmCount(methods, actualArguments);
    if (methods.size() == 1) {
      return ListSequence.fromList(methods).first();
    }

    return resolveMethod(contextNode, refText, actualArguments, methods);
  }

  @Nullable
  public SNode resolveMethod(SNode contextNode, @NotNull String refText, List<SNode> actualArguments, List<SNode> methods) {
    // all methods have exactly actualArguments.size arguments and name of all methods is refText 
    throw new UnsupportedOperationException();
  }

  @Nullable
  public String getReferenceText(SNode contextNode, @NotNull SNode node) {
    return SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "name");
  }

  @Override
  public boolean contains(SNode node) {
    return SNodeOperations.isInstanceOf(node, NameUtil.nodeFQName(kind)) && ListSequence.fromList(getAvailableElements(SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "name"))).contains(node);
  }
}
