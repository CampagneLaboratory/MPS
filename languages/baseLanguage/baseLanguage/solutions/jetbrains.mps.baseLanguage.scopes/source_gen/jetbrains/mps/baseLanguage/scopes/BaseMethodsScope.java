package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import jetbrains.mps.scope.Scope;
import java.util.Map;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.internal.collections.runtime.IMapping;
import org.jetbrains.annotations.NotNull;

public abstract class BaseMethodsScope extends Scope {
  private final Map<String, List<SNode>> nameToMethods;
  private final SNode kind;
  private final SNode classifier;
  private final Iterable<SNode> extendedClassifiers;

  public BaseMethodsScope(final SNode kind, SNode classifier, Iterable<SNode> extendedClassifiers) {
    this.kind = kind;
    this.classifier = classifier;
    this.extendedClassifiers = extendedClassifiers;

    nameToMethods = MapSequence.fromMap(new HashMap<String, List<SNode>>());
    for (SNode node : ListSequence.fromList(SNodeOperations.getChildren(classifier)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, NameUtil.nodeFQName(kind));
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
      }
    })) {
      if (MapSequence.fromMap(nameToMethods).containsKey(SPropertyOperations.getString(node, "name"))) {
        ListSequence.fromList(MapSequence.fromMap(nameToMethods).get(SPropertyOperations.getString(node, "name"))).addElement(node);
      } else {
        MapSequence.fromMap(nameToMethods).put(SPropertyOperations.getString(node, "name"), ListSequence.fromListAndArray(new ArrayList(), node));
      }
    }
  }

  public abstract String getSignatureForOverriding(SNode method, SNode contextClassifier);

  public List<SNode> getAvailableElements(@Nullable String prefix) {
    List<SNode> result = ListSequence.fromList(new ArrayList());
    Set<String> overridenSignatures = SetSequence.fromSet(new HashSet());

    for (List<SNode> methods : Sequence.fromIterable(MapSequence.fromMap(nameToMethods).values())) {
      ListSequence.fromList(result).addSequence(ListSequence.fromList(methods));
      SetSequence.fromSet(overridenSignatures).addSequence(ListSequence.fromList(methods).select(new ISelector<SNode, String>() {
        public String select(SNode it) {
          return getSignatureForOverriding(it, classifier);
        }
      }));
    }

    Map<String, List<SNode>> groups = MapSequence.fromMap(new HashMap<String, List<SNode>>());
    for (SNode extendedClassifier : Sequence.fromIterable(extendedClassifiers)) {
      for (SNode method : ListSequence.fromList(((Scope) BehaviorManager.getInstance().invoke(Object.class, extendedClassifier, "virtual_getVisibleMembers_8083692786967356611", new Class[]{SNode.class, SNode.class, SNode.class}, classifier, kind)).getAvailableElements(prefix)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(it, NameUtil.nodeFQName(kind));
        }
      }).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
        }
      })) {
        if (!(SetSequence.fromSet(overridenSignatures).contains(getSignatureForOverriding(method, extendedClassifier)))) {
          if (MapSequence.fromMap(groups).containsKey(SPropertyOperations.getString(method, "name"))) {
            ListSequence.fromList(MapSequence.fromMap(groups).get(SPropertyOperations.getString(method, "name"))).addElement(method);
          } else {
            MapSequence.fromMap(groups).put(SPropertyOperations.getString(method, "name"), ListSequence.fromListAndArray(new ArrayList<SNode>(), method));
          }
        }
      }
    }

    for (IMapping<String, List<SNode>> group : MapSequence.fromMap(groups)) {
      // todo: extension methods? 
      if ((int) ListSequence.fromList(group.value()).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return SNodeOperations.cast(SNodeOperations.getParent(it), "jetbrains.mps.baseLanguage.structure.Classifier");
        }
      }).distinct().count() == 1) {
        ListSequence.fromList(result).addSequence(ListSequence.fromList(group.value()));
      }
    }

    return result;
  }

  @Nullable
  public SNode resolve(SNode contextNode, @NotNull String refText) {
    // todo 
    return null;
  }

  @Nullable
  public String getReferenceText(SNode contextNode, @NotNull SNode node) {
    return SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "name");
  }

  @Override
  public boolean contains(SNode node) {
    return SNodeOperations.isInstanceOf(node, NameUtil.nodeFQName(kind)) && ListSequence.fromList(getAvailableElements(SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "name"))).contains(node);
  }
}
