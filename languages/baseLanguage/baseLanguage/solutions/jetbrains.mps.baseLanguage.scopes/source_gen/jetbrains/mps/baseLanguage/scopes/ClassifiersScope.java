package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import jetbrains.mps.scope.FilteringScope;
import jetbrains.mps.smodel.IScope;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.scope.ModelPlusImportedScope;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class ClassifiersScope extends FilteringScope {
  private IScope myModuleScope;
  private boolean myInlcudeAncestors;

  public ClassifiersScope(SModel model, String conceptFqName, boolean includeAncestors) {
    super(new ModelPlusImportedScope(model, false, model.getModelDescriptor().getModule().getScope(), conceptFqName));
    myModuleScope = model.getModelDescriptor().getModule().getScope();
    myInlcudeAncestors = includeAncestors;
  }

  public ClassifiersScope(SModel model, String conceptFqName, boolean includeAncestors, IScope scope) {
    super(new ModelPlusImportedScope(model, false, scope, conceptFqName));
    myModuleScope = scope;
    myInlcudeAncestors = includeAncestors;
  }

  public ClassifiersScope(SModel model, String conceptFqName) {
    this(model, conceptFqName, false);
  }

  @Override
  public boolean isExcluded(SNode node) {
    return SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.AnonymousClass");
  }

  @Override
  public SNode resolve(SNode contextNode, String refText) {
    // hack for [model]node construction, remove it 
    if (refText.startsWith("[")) {
      return ClassifierResolveUtils.resolveSpecialSyntax(refText, contextNode);
    }
    // end of hack 
    // TODO Must be done through ScopeProvider 
    SNode contextClass = SNodeOperations.getAncestor(contextNode, "jetbrains.mps.baseLanguage.structure.Classifier", true, false);
    return ClassifierResolveUtils.resolve(refText, contextClass, myModuleScope, (ModelPlusImportedScope) wrapped, myInlcudeAncestors);
    // <node> 
  }
}
