package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import jetbrains.mps.cache.AbstractCache;
import jetbrains.mps.cache.KeyProducer;
import jetbrains.mps.cache.DataSet;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import java.util.Map;
import java.util.Set;
import jetbrains.mps.smodel.SModelDescriptor;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.cache.CachesManager;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import java.util.LinkedHashSet;
import java.util.ArrayList;
import java.util.Iterator;

public class ClassifierAndSuperClassifiersCache extends AbstractCache {
  private static final KeyProducer keyProducer = new KeyProducer();
  private static final AbstractCache.DataSetCreator<ClassifierAndSuperClassifiersCache> CLASSIFIERS_CACHE_CREATOR = new AbstractCache.DataSetCreator<ClassifierAndSuperClassifiersCache>() {
    public DataSet create(ClassifierAndSuperClassifiersCache ownerCache) {
      return new ClassifierAndSuperClassifiersCache.ClassifiersDataSet(ownerCache.myTopClassifier, ownerCache);
    }
  };

  private final SNode myTopClassifier;

  private ClassifierAndSuperClassifiersCache(Object key, SNode topClassifier) {
    super(key);
    this.myTopClassifier = topClassifier;
  }

  /*package*/ List<SNode> getClassifiers() {
    ClassifierAndSuperClassifiersCache.ClassifiersDataSet dataSet = (ClassifierAndSuperClassifiersCache.ClassifiersDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.ClassifiersDataSet.ID, CLASSIFIERS_CACHE_CREATOR);
    return dataSet.getClassifiers();
  }

  /*package*/ Map<SNode, SNode> getTypeByTypeVariableMap() {
    ClassifierAndSuperClassifiersCache.ClassifiersDataSet dataSet = (ClassifierAndSuperClassifiersCache.ClassifiersDataSet) this.getDataSet(ClassifierAndSuperClassifiersCache.ClassifiersDataSet.ID, CLASSIFIERS_CACHE_CREATOR);
    return dataSet.getTypeByTypeVariableMap();
  }

  @Override
  public Set<SModelDescriptor> getDependsOnModels(Object element) {
    Set<SModelDescriptor> dependsOnModel = new HashSet<SModelDescriptor>();
    for (SNode classifier : this.getClassifiers()) {
      SModelDescriptor descriptor = SNodeOperations.getModel(classifier).getModelDescriptor();
      assert descriptor != null : "Model descriptor is null for classifier: " + classifier;
      dependsOnModel.add(descriptor);
    }
    return dependsOnModel;
  }

  /*package*/ static ClassifierAndSuperClassifiersCache getInstance(SNode topClassifierNode) {
    Object key = keyProducer.createKey(topClassifierNode);
    return (ClassifierAndSuperClassifiersCache) CachesManager.getInstance().getCache(key, topClassifierNode, new CachesManager.CacheCreator<SNode>() {
      public AbstractCache create(Object key, SNode element) {
        assert SNodeOperations.getModel(element).getModelDescriptor() != null : "Classifier cache root node has no model descriptor";
        return new ClassifierAndSuperClassifiersCache(key, element);
      }
    });

  }

  private static final class ClassifiersDataSet extends DataSet {
    public static final String ID = "CLASSIFIERS_DATASET";

    private SNode myTopClassifier;
    private List<SNode> myClassifiers;
    private Map<SNode, SNode> myTypeByTypeVariable;
    private Set<SNode> myDependsOnNodes;

    public ClassifiersDataSet(SNode topClassifier, AbstractCache ownerCache) {
      super(ID, ownerCache, DataSet.DefaultNodeChangedProcessing.DROP_OWNER_CACHE);
      this.myTopClassifier = topClassifier;
    }

    public List<SNode> getClassifiers() {
      return this.myClassifiers;
    }

    public Set<SNode> getDependsOnNodes() {
      return this.myDependsOnNodes;
    }

    /*package*/ Map<SNode, SNode> getTypeByTypeVariableMap() {
      return this.myTypeByTypeVariable;
    }

    protected void init() {
      this.myTypeByTypeVariable = MapSequence.fromMap(new HashMap<SNode, SNode>());
      this.myClassifiers = ClassifierAndSuperClassifiersCache.ClassifiersDataSet.getImplementedAndExtended(this.myTopClassifier, this.myTypeByTypeVariable);
      this.myDependsOnNodes = SetSequence.fromSet(new HashSet<SNode>());
      for (SNode classifier : this.myClassifiers) {
        SetSequence.fromSet(this.myDependsOnNodes).addElement(classifier);
        if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
          for (SNode type : SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass")), "typeParameter", true)) {
            SetSequence.fromSet(this.myDependsOnNodes).addElement(type);
            SetSequence.fromSet(this.myDependsOnNodes).addSequence(ListSequence.fromList(type.getDescendants()));
          }
        } else {
          for (SNode typeVariableDecl : SLinkOperations.getTargets(classifier, "typeVariableDeclaration", true)) {
            SetSequence.fromSet(this.myDependsOnNodes).addElement(typeVariableDecl);
          }
        }
        if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept") && !(SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass"))) {
          SNode classifierType0 = SLinkOperations.getTarget((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "superclass", true);
          if (classifierType0 != null) {
            SetSequence.fromSet(this.myDependsOnNodes).addElement(classifierType0);
            SetSequence.fromSet(this.myDependsOnNodes).addSequence(ListSequence.fromList(classifierType0.getDescendants()));
          }
          for (SNode classifierType1 : SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "implementedInterface", true)) {
            SetSequence.fromSet(this.myDependsOnNodes).addElement(classifierType1);
            SetSequence.fromSet(this.myDependsOnNodes).addSequence(ListSequence.fromList(classifierType1.getDescendants()));
          }
        } else
        if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.Interface")) {
          for (SNode classifierType : SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.Interface")), "extendedInterface", true)) {
            SetSequence.fromSet(this.myDependsOnNodes).addElement(classifierType);
            SetSequence.fromSet(this.myDependsOnNodes).addSequence(ListSequence.fromList(classifierType.getDescendants()));
          }
        }
      }
    }

    public void childAdded(SModelChildEvent event) {
      if (event.getParent().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.Classifier")) {
        String role = event.getChildRole();
        if (!(("typeVariableDeclaration".equals(role) || "superclass".equals(role) || "implementedInterface".equals(role) || "extendedInterface".equals(role) || "typeParameter".equals(role)))) {
          return;
        }
      }
      super.childAdded(event);
    }

    public void childRemoved(SModelChildEvent event) {
      if (event.getParent().isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.Classifier")) {
        String role = event.getChildRole();
        if (!(("typeVariableDeclaration".equals(role) || "superclass".equals(role) || "implementedInterface".equals(role) || "extendedInterface".equals(role) || "typeParameter".equals(role)))) {
          return;
        }
      }
      super.childRemoved(event);
    }

    public void propertyChanged(SModelPropertyEvent event) {
    }

    private static List<SNode> getImplementedAndExtended(SNode classifier, Map<SNode, SNode> typeByTypeVar) {
      Set<SNode> set = SetSequence.fromSet(new LinkedHashSet<SNode>());
      ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(classifier, set, null, typeByTypeVar);
      List<SNode> result = new ArrayList<SNode>();
      ListSequence.fromList(result).addSequence(SetSequence.fromSet(set));
      SNode objectClass = SNodeOperations.getNode("f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)", "~Object");
      if (objectClass != null && !(SetSequence.fromSet(set).contains(objectClass))) {
        int indexOfFirstInterface = 0;
        for (SNode classifierInResult : set) {
          if (SNodeOperations.isInstanceOf(classifierInResult, "jetbrains.mps.baseLanguage.structure.Interface")) {
            break;
          }
          indexOfFirstInterface++;
        }
        if (indexOfFirstInterface == 0) {
          result.add(objectClass);
        } else {
          result.add(indexOfFirstInterface, objectClass);
        }
      }
      return result;
    }

    private static void collectImplementedAndExtended(SNode classifier, Set<SNode> result, List<SNode> typeParms, Map<SNode, SNode> typeByTypeVar) {
      if ((classifier == null)) {
        return;
      }
      if (SetSequence.fromSet(result).contains(classifier)) {
        return;
      }
      SetSequence.fromSet(result).addElement(classifier);
      if (typeParms != null && ListSequence.fromList(typeParms).count() > 0) {
        Iterator<SNode> typeVars = ListSequence.fromList(SLinkOperations.getTargets(classifier, "typeVariableDeclaration", true)).iterator();
        for (SNode typeParm : typeParms) {
          if (!(typeVars.hasNext())) {
            break;
          }
          SNode typeVar = typeVars.next();
          MapSequence.fromMap(typeByTypeVar).put(typeVar, typeParm);
        }
      }
      if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
        SNode cls = SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.AnonymousClass");
        ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(SLinkOperations.getTarget(cls, "classifier", false), result, SLinkOperations.getTargets(cls, "typeParameter", true), typeByTypeVar);
      } else
      if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        SNode classifierType0 = SLinkOperations.getTarget((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "superclass", true);
        if (classifierType0 != null) {
          ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(SLinkOperations.getTarget(classifierType0, "classifier", false), result, SLinkOperations.getTargets(classifierType0, "parameter", true), typeByTypeVar);
        }
        for (SNode classifierType1 : SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept")), "implementedInterface", true)) {
          ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(SLinkOperations.getTarget(classifierType1, "classifier", false), result, SLinkOperations.getTargets(classifierType1, "parameter", true), typeByTypeVar);
        }
        if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
          ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(SNodeOperations.getNode("f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)", "~Enum"), result, null, typeByTypeVar);
        }
      } else
      if (SNodeOperations.isInstanceOf(classifier, "jetbrains.mps.baseLanguage.structure.Interface")) {
        for (SNode classifierType : SLinkOperations.getTargets((SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.Interface")), "extendedInterface", true)) {
          ClassifierAndSuperClassifiersCache.ClassifiersDataSet.collectImplementedAndExtended(SLinkOperations.getTarget(classifierType, "classifier", false), result, SLinkOperations.getTargets(classifierType, "parameter", true), typeByTypeVar);
        }
      }
    }
  }
}
