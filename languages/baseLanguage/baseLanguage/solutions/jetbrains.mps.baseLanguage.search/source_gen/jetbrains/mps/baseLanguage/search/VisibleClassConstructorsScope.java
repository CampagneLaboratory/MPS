package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.UUID;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.search.IReferenceInfoResolver;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;

@Deprecated
public class VisibleClassConstructorsScope extends VisibleClassifiersScope {
  @Deprecated
  public VisibleClassConstructorsScope(SModel model) {
    super(model, IClassifiersSearchScope.CONSTRUCTOR);
  }
  @Deprecated
  public VisibleClassConstructorsScope(@NotNull SNode contextNode) {
    // use VisibleClassConstructorsScope in j.m.baseLanguage.scopes instead 
    super(contextNode, IClassifiersSearchScope.CONSTRUCTOR);
  }
  @NotNull
  @Override
  public List<SNode> getClassifiers() {
    List<SNode> list = super.getClassifiers();
    List<SNode> result = new ArrayList<SNode>();
    for (SNode classifier : list) {
      if (SNodeOperations.isInstanceOf(classifier, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1107796713796l, "jetbrains.mps.baseLanguage.structure.Interface"))) {
        continue;
      }
      if (SNodeOperations.isInstanceOf(classifier, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468198l, "jetbrains.mps.baseLanguage.structure.ClassConcept")) && SPropertyOperations.getBoolean((SNodeOperations.cast(classifier, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468198l, "jetbrains.mps.baseLanguage.structure.ClassConcept"))), MetaAdapterFactory.getProperty(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468198l, 1075300953594l, "abstractClass"))) {
        continue;
      }
      result.add(classifier);
    }
    return result;
  }
  @Override
  public IReferenceInfoResolver getReferenceInfoResolver(SNode referenceNode, SNode targetConcept) {
    if (SModelUtil.isAssignableConcept(NameUtil.nodeFQName(targetConcept), "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration")) {
      if (SNodeOperations.isInstanceOf(referenceNode, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1212685548494l, "jetbrains.mps.baseLanguage.structure.ClassCreator"))) {
        SNode classCreator = SNodeOperations.cast(referenceNode, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1212685548494l, "jetbrains.mps.baseLanguage.structure.ClassCreator"));
        return new VisibleClassConstructorsScope.ConstructorDeclarationReferenceInfoResolver(SLinkOperations.getChildren(classCreator, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1204053956946l, 1068499141038l, "actualArgument")), SLinkOperations.getChildren(classCreator, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1212685548494l, 1212687122400l, "typeParameter")), getModel());
      }
    }
    return super.getReferenceInfoResolver(referenceNode, targetConcept);
  }
  private static class ConstructorDeclarationReferenceInfoResolver extends ReachableClassifiersScope.ClassifierReferenceInfoResolver {
    private List<SNode> myActualArgs;
    private List<SNode> myTypeParms;
    /*package*/ ConstructorDeclarationReferenceInfoResolver(List<SNode> actualArgs, List<SNode> typeParms, SModel model) {
      super(model);
      myActualArgs = actualArgs;
      myTypeParms = typeParms;
    }
    @Override
    public SNode resolve(String referenceInfo, @Nullable SModelReference targetModelReference) {
      SNode classifier_ = super.resolve(referenceInfo, targetModelReference);
      if (classifier_ == null) {
        return null;
      }
      SNode classifier = SNodeOperations.cast(classifier_, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1107461130800l, "jetbrains.mps.baseLanguage.structure.Classifier"));
      if (SNodeOperations.isInstanceOf(classifier, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468198l, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
        List<SNode> constructors = Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), (SNodeOperations.cast(classifier, MetaAdapterFactory.getConcept(new UUID(-935030926396207931l, -6610165693999523818l), 1068390468198l, "jetbrains.mps.baseLanguage.structure.ClassConcept"))), "jetbrains.mps.baseLanguage.structure.ClassConcept", "call_constructors_5292274854859503373", new Object[]{})).toListSequence();
        if (ListSequence.fromList(constructors).count() == 1) {
          return ListSequence.fromList(constructors).first();
        } else
        if (ListSequence.fromList(constructors).count() > 1) {
          constructors = (List<SNode>) MethodResolveUtil.selectByParmCount(constructors, myActualArgs);
          if (ListSequence.fromList(constructors).count() == 1) {
            return ListSequence.fromList(constructors).first();
          } else {
            Iterator<SNode> typeParms = (Iterator<SNode>) myTypeParms.iterator();
            Iterator<SNode> typeVars = (Iterator<SNode>) SLinkOperations.getChildren(classifier, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1109279851642l, 1109279881614l, "typeVariableDeclaration")).iterator();
            Map<SNode, SNode> typeByTypeVar = new HashMap<SNode, SNode>();
            while (typeParms.hasNext() && typeVars.hasNext()) {
              typeByTypeVar.put(typeVars.next(), typeParms.next());
            }
            return MethodResolveUtil.chooseByParameterType(constructors, myActualArgs, typeByTypeVar);
          }
        }
      }
      return null;
    }
  }
}
