package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.search.IReferenceInfoResolver;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;

@Deprecated
public class VisibleClassConstructorsScope extends VisibleClassifiersScope {
  @Deprecated
  public VisibleClassConstructorsScope(SModel model) {
    super(model, IClassifiersSearchScope.CONSTRUCTOR);
  }
  @Deprecated
  public VisibleClassConstructorsScope(@NotNull SNode contextNode) {
    // use VisibleClassConstructorsScope in j.m.baseLanguage.scopes instead 
    super(contextNode, IClassifiersSearchScope.CONSTRUCTOR);
  }
  @NotNull
  @Override
  public List<SNode> getClassifiers() {
    List<SNode> list = super.getClassifiers();
    List<SNode> result = new ArrayList<SNode>();
    for (SNode classifier : list) {
      if (SNodeOperations.isInstanceOf(classifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"))) {
        continue;
      }
      if (SNodeOperations.isInstanceOf(classifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")) && SPropertyOperations.getBoolean((SNodeOperations.cast(classifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))), MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0xfa5cee6dfaL, "abstractClass"))) {
        continue;
      }
      result.add(classifier);
    }
    return result;
  }
  @Override
  public IReferenceInfoResolver getReferenceInfoResolver(SNode referenceNode, SNode targetConcept) {
    if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.asSConcept(targetConcept)), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b204L, "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration"))) {
      if (SNodeOperations.isInstanceOf(referenceNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11a59b0fbceL, "jetbrains.mps.baseLanguage.structure.ClassCreator"))) {
        SNode classCreator = SNodeOperations.cast(referenceNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11a59b0fbceL, "jetbrains.mps.baseLanguage.structure.ClassCreator"));
        return new VisibleClassConstructorsScope.ConstructorDeclarationReferenceInfoResolver(SLinkOperations.getChildren(classCreator, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, "actualArgument")), SLinkOperations.getChildren(classCreator, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11a59b0fbceL, 0x11a59c8ffe0L, "typeParameter")), getModel());
      }
    }
    return super.getReferenceInfoResolver(referenceNode, targetConcept);
  }
  private static class ConstructorDeclarationReferenceInfoResolver extends ReachableClassifiersScope.ClassifierReferenceInfoResolver {
    private List<SNode> myActualArgs;
    private List<SNode> myTypeParms;
    /*package*/ ConstructorDeclarationReferenceInfoResolver(List<SNode> actualArgs, List<SNode> typeParms, SModel model) {
      super(model);
      myActualArgs = actualArgs;
      myTypeParms = typeParms;
    }
    @Override
    public SNode resolve(String referenceInfo, @Nullable SModelReference targetModelReference) {
      SNode classifier_ = super.resolve(referenceInfo, targetModelReference);
      if (classifier_ == null) {
        return null;
      }
      SNode classifier = SNodeOperations.cast(classifier_, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"));
      if (SNodeOperations.isInstanceOf(classifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
        List<SNode> constructors = Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), (SNodeOperations.cast(classifier, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))), "jetbrains.mps.baseLanguage.structure.ClassConcept", "call_constructors_5292274854859503373", new Object[]{})).toListSequence();
        if (ListSequence.fromList(constructors).count() == 1) {
          return ListSequence.fromList(constructors).first();
        } else
        if (ListSequence.fromList(constructors).count() > 1) {
          constructors = (List<SNode>) MethodResolveUtil.selectByParmCount(constructors, myActualArgs);
          if (ListSequence.fromList(constructors).count() == 1) {
            return ListSequence.fromList(constructors).first();
          } else {
            Iterator<SNode> typeParms = (Iterator<SNode>) myTypeParms.iterator();
            Iterator<SNode> typeVars = (Iterator<SNode>) SLinkOperations.getChildren(classifier, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x102463b447aL, 0x102463bb98eL, "typeVariableDeclaration")).iterator();
            Map<SNode, SNode> typeByTypeVar = new HashMap<SNode, SNode>();
            while (typeParms.hasNext() && typeVars.hasNext()) {
              typeByTypeVar.put(typeVars.next(), typeParms.next());
            }
            return MethodResolveUtil.chooseByParameterType(constructors, myActualArgs, typeByTypeVar);
          }
        }
      }
      return null;
    }
  }
}
