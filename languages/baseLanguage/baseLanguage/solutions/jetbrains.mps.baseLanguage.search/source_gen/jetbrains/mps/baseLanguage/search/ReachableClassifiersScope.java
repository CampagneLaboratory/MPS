package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.search.ModelAndImportedModelsScope;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.search.IReferenceInfoResolver;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.project.dependency.VisibilityUtil;
import jetbrains.mps.smodel.SModelStereotype;
import java.util.Collection;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

@Deprecated
public class ReachableClassifiersScope extends AbstractClassifiersScope {
  private SModel myModel;
  @Deprecated
  public ReachableClassifiersScope(SModel model, int constraint) {
    // use ClassifierScopes.getReachableClassifiersScope instead 
    super(constraint);
    this.myModel = model;
  }
  public SModel getModel() {
    return this.myModel;
  }
  @NotNull
  @Override
  public List<SNode> getClassifiers() {
    List<? extends SModel> models = new ModelAndImportedModelsScope(this.myModel, false).getModels();
    List<SNode> result = new ArrayList<SNode>();
    for (SModel model : models) {
      List<SNode> classifiers = ClassifiersCache.getInstance(model).getClassifiers();
      ListSequence.fromList(result).addSequence(ListSequence.fromList(classifiers));
    }
    return result;
  }
  @Override
  public IReferenceInfoResolver getReferenceInfoResolver(SNode referenceNode, SNode targetConcept) {
    if (MetaAdapterByDeclaration.getConcept(targetConcept).isSubConceptOf(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
      return new ReachableClassifiersScope.ClassifierReferenceInfoResolver(this.myModel);
    }
    return super.getReferenceInfoResolver(referenceNode, targetConcept);
  }
  protected static class ClassifierReferenceInfoResolver implements IReferenceInfoResolver {
    private SModel myModel;
    public ClassifierReferenceInfoResolver(SModel model) {
      this.myModel = model;
    }
    @Override
    public SNode resolve(String referenceInfo, @Nullable SModelReference targetModelReference) {
      String classname = referenceInfo;
      int dotIndex = classname.lastIndexOf(".");
      if (dotIndex >= 0 && targetModelReference == null) {
        // try local nested classes 
        List<SNode> localClassifiers = ClassifiersCache.getInstance(myModel).getClassifiersByRefName(classname);
        if (ListSequence.fromList(localClassifiers).count() >= 1) {
          return ListSequence.fromList(localClassifiers).first();
        }

        // search everywhere 
        String package_ = classname.substring(0, dotIndex);
        classname = classname.substring(dotIndex + 1);
        if (classname.indexOf('$') >= 0) {
          classname = classname.replace('$', '.');
        }
        return resolveClass(package_, null, classname);
      }

      if (targetModelReference == null) {
        targetModelReference = myModel.getReference();
      }
      if (targetModelReference.getModelId() != null) {
        SModel targetModel = targetModelReference.resolve(MPSModuleRepository.getInstance());
        if (targetModel == null) {
          return null;
        }
        if (!(VisibilityUtil.isVisible(myModel, targetModel))) {
          return null;
        }
        return ListSequence.fromList(ClassifiersCache.getInstance(targetModel).getClassifiersByRefName(classname)).first();
      }
      String modelName = targetModelReference.getModelName();
      return resolveClass(SModelStereotype.withoutStereotype(modelName), SModelStereotype.getStereotype(modelName), classname);
    }
    public SNode resolveClass(String longName, String stereotype, String nestedClassName) {
      Collection<SModule> visibleModules = new GlobalModuleDependenciesManager(myModel.getModule()).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE);
      String modelName = (stereotype != null ? longName + "@" + stereotype : longName);

      List<SNode> classifiers = new ArrayList<SNode>();
      for (SModel m : Sequence.fromIterable(((Iterable<SModule>) visibleModules)).translate(new ITranslator2<SModule, SModel>() {
        public Iterable<SModel> translate(SModule it) {
          return it.getModels();
        }
      }).distinct()) {
        String name = m.getModelName();
        if (stereotype == null) {
          name = SModelStereotype.withoutStereotype(name);
        }
        if (!(name.equals(modelName))) {
          continue;
        }
        ListSequence.fromList(classifiers).addSequence(ListSequence.fromList(ClassifiersCache.getInstance(m).getClassifiersByRefName(nestedClassName)));
      }

      if (ListSequence.fromList(classifiers).isEmpty()) {
        return null;
      }
      if (ListSequence.fromList(classifiers).count() > 1) {
        for (SNode cls : ListSequence.fromList(classifiers)) {
          if (SNodeOperations.getModel(cls) == myModel) {
            return cls;
          }
          if (check_x9ho2v_a0b0a0h0d5_0(myModel) == check_x9ho2v_a0b0a0h0d5(SNodeOperations.getModel(cls))) {
            return cls;
          }
        }
        Iterable<SNode> userClassifiers = ListSequence.fromList(classifiers).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SModelStereotype.isUserModel(SNodeOperations.getModel(it));
          }
        });
        if (Sequence.fromIterable(userClassifiers).count() == 1) {
          return Sequence.fromIterable(userClassifiers).first();
        }

        final StringBuilder warning = new StringBuilder();
        warning.append("reference can't be resolved: ");
        warning.append(nestedClassName);
        warning.append(" in ");
        warning.append(jetbrains.mps.util.SNodeOperations.getModelLongName(myModel));
        warning.append(" can reference nodes from models: ");
        ListSequence.fromList(classifiers).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            warning.append(SNodeOperations.getModel(it).getReference()).append("; ");
          }
        });

        if (LOG.isEnabledFor(Level.WARN)) {
          LOG.warn(warning.toString());
        }
        return null;
      }
      return ListSequence.fromList(classifiers).getElement(0);
    }
    private static SModule check_x9ho2v_a0b0a0h0d5(SModel checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getModule();
      }
      return null;
    }
    private static SModule check_x9ho2v_a0b0a0h0d5_0(SModel checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getModule();
      }
      return null;
    }
  }
  protected static Logger LOG = LogManager.getLogger(ReachableClassifiersScope.class);
}
