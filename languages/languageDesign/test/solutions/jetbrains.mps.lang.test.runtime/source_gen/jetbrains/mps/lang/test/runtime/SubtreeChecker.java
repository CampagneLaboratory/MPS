package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import junit.framework.Assert;
import jetbrains.mps.typesystem.inference.ITypeContextOwner;
import jetbrains.mps.typesystem.inference.DefaultTypecheckingContextOwner;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.typesystem.inference.ITypechecking;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.pattern.util.MatchingUtil;
import jetbrains.mps.errors.MessageStatus;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.lang.dataFlow.framework.Program;
import jetbrains.mps.lang.dataFlow.DataFlowManager;
import java.util.Set;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.lang.dataFlow.framework.AnalysisResult;
import jetbrains.mps.lang.dataFlow.framework.VarSet;
import jetbrains.mps.lang.dataFlow.framework.analyzers.InitializedVariablesAnalyzer;
import jetbrains.mps.lang.dataFlow.framework.analyzers.LivenessAnalyzer;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;

public class SubtreeChecker {
  public SubtreeChecker() {
  }

  public static void checkNodeForErrors(SNode node) {
    checkNodeForErrors(node, false, false);
  }

  public static void checkNodeForErrors(final SNode node, final boolean allowErrors, final boolean allowWarnings) {
    Assert.assertFalse("should be false (never used anyway)", allowErrors || allowWarnings);
    ITypeContextOwner owner = new DefaultTypecheckingContextOwner();
    SNode containingRoot = node.getTopmostAncestor();
    TypeContextManager.getInstance().runTypeCheckingAction(owner, containingRoot, new ITypechecking.Action() {
      public void run(TypeCheckingContext typeCheckingContext) {
        typeCheckingContext.checkIfNotChecked(node, true);
        for (SNode child : SNodeOperations.getDescendants(node, "jetbrains.mps.lang.core.structure.BaseConcept", false, new String[]{})) {
          boolean isError = false;
          if (AttributeOperations.getAttribute(child, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodePropertiesContainer"))) != null) {
            SNode container = AttributeOperations.getAttribute(child, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodePropertiesContainer")));
            for (SNode property : SLinkOperations.getTargets(container, "properties", true)) {
              if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeTypeProperty")) {
                SNode type1 = typeCheckingContext.getTypeDontCheck(child);
                if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeExpectedTypeProperty")) {
                  type1 = TypeChecker.getInstance().getInequalitiesForHole(child, false).getExpectedType();
                  Assert.assertNotNull(type1);
                }
                SNode type2 = SLinkOperations.getTarget(SNodeOperations.cast(property, "jetbrains.mps.lang.test.structure.NodeTypeProperty"), "type", true);
                Assert.assertEquals(null, NodesMatcher.matchNodes(ListSequence.fromListAndArray(new ArrayList<SNode>(), type1), ListSequence.fromListAndArray(new ArrayList<SNode>(), type2)));
              }
              if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeTypeSetProperty")) {
                SNode type1 = typeCheckingContext.getTypeDontCheck(child);
                boolean hasType = false;
                for (SNode type2 : SLinkOperations.getTargets(SNodeOperations.cast(property, "jetbrains.mps.lang.test.structure.NodeTypeSetProperty"), "type", true)) {
                  if (MatchingUtil.matchNodes(type1, type2)) {
                    hasType = true;
                    break;
                  }
                }
                Assert.assertTrue("node type <" + type1 + "> is not in <" + SLinkOperations.getTargets(SNodeOperations.cast(property, "jetbrains.mps.lang.test.structure.NodeTypeSetProperty"), "type", true) + ">", hasType);
              }
              if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeErrorPropety")) {
                Assert.assertTrue("node <" + child + "> does not have expected error message", typeCheckingContext.getTypeMessageDontCheck(child) != null);
                Assert.assertFalse("node <" + child + "> has warning", typeCheckingContext.getTypeMessageDontCheck(child).getMessageStatus() == MessageStatus.WARNING);
                isError = true;
              }
              if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeWarningProperty")) {
                Assert.assertTrue("node <" + child + "> does not have expected warning", typeCheckingContext.getTypeMessageDontCheck(child) != null);
                Assert.assertTrue("node <" + child + "> does not have expected warning", typeCheckingContext.getTypeMessageDontCheck(child).getMessageStatus() == MessageStatus.WARNING);
                isError = true;
              }
            }
          }
          if (!(isError)) {
            IErrorReporter reporter = typeCheckingContext.getTypeMessageDontCheck(child);
            if (reporter != null) {
              String reportError = reporter.reportError();
              if (!(allowErrors)) {
                Assert.assertTrue(reportError, reporter.getMessageStatus() != MessageStatus.ERROR);
              }
              if (!(allowWarnings)) {
                Assert.assertTrue(reportError, reporter.getMessageStatus() != MessageStatus.WARNING);
              }
            }
          }
        }
      }
    });
  }

  public static void checkDataFlow(SNode node) {
    Program program = DataFlowManager.getInstance().buildProgramFor(node);
    Set<Instruction> unreachable = program.getUnreachableInstructions();
    AnalysisResult<VarSet> initialized = program.analyze(new InitializedVariablesAnalyzer());
    AnalysisResult<VarSet> live = program.analyze(new LivenessAnalyzer());
    for (SNode child : SNodeOperations.getDescendants(node, "jetbrains.mps.lang.core.structure.BaseConcept", false, new String[]{})) {
      if (AttributeOperations.getAttribute(child, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodePropertiesContainer"))) != null) {
        SNode container = AttributeOperations.getAttribute(child, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodePropertiesContainer")));
        for (SNode property : SLinkOperations.getTargets(container, "properties", true)) {
          Instruction instruction;
          List<Instruction> instructions = program.getInstructionsFor(child);
          if (ListSequence.fromList(instructions).count() > 0) {
            instruction = program.getInstructionsFor(child).get(0);
          } else {
            continue;
          }
          if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeReachable")) {
            Assert.assertFalse("instruction <" + instruction + "> is unreachable", SetSequence.fromSet(unreachable).contains(instruction));
          }
          if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeUnreachable")) {
            Assert.assertTrue("instruction <" + instruction + "> is reachable", SetSequence.fromSet(unreachable).contains(instruction));
          }
          if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.VariableInialized")) {
            Set<Object> vars = (Set<Object>) initialized.get(instruction);
            SNode var = SLinkOperations.getTarget(SNodeOperations.cast(property, "jetbrains.mps.lang.test.structure.VariableInialized"), "var", true);
            Assert.assertTrue("variable <" + var + "> is not initialized", SetSequence.fromSet(vars).contains(SLinkOperations.getTarget(var, "variableDeclaration", false)));
          }
          if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.VariableLive")) {
            Set<Object> vars = (Set<Object>) live.get(instruction);
            SNode var = SLinkOperations.getTarget(SNodeOperations.cast(property, "jetbrains.mps.lang.test.structure.VariableInialized"), "var", true);
            Assert.assertTrue("variable <" + var + "> is not live", SetSequence.fromSet(vars).contains(SLinkOperations.getTarget(var, "variableDeclaration", false)));
          }
        }
      }
    }
  }

  public static void performOperations(SNode node) {
    for (SNode nodeToCheck : SNodeOperations.getDescendants(node, "jetbrains.mps.lang.core.structure.BaseConcept", false, new String[]{})) {
      if (nodeToCheck != null) {
        if (AttributeOperations.getAttribute(nodeToCheck, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodeOperationsContainer"))) != null) {
          for (SNode operation : SLinkOperations.getTargets(AttributeOperations.getAttribute(nodeToCheck, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodeOperationsContainer"))), "operations", true)) {
            BehaviorReflection.invokeVirtual(Void.class, operation, "virtual_perform_1215601182156", new Object[]{nodeToCheck});
          }
        }
      }
    }
  }

  public static void runTest() {
  }
}
