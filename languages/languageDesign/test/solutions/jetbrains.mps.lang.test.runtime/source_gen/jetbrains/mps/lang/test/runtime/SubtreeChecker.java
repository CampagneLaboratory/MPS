package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.errors.MessageStatus;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.dataFlow.DataFlowManager;
import jetbrains.mps.lang.dataFlow.framework.AnalysisResult;
import jetbrains.mps.lang.dataFlow.framework.Program;
import jetbrains.mps.lang.dataFlow.framework.VarSet;
import jetbrains.mps.lang.dataFlow.framework.analyzers.InitializedVariablesAnalyzer;
import jetbrains.mps.lang.dataFlow.framework.analyzers.LivenessAnalyzer;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.lang.pattern.util.MatchingUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.*;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.typesystem.inference.ITypeContextOwner;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import junit.framework.Assert;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class SubtreeChecker {
  public SubtreeChecker() {
  }

  public static void checkNodeForErrors(SNode node) {
    checkNodeForErrors(node, false, false);
  }

  public static void checkNodeForErrors(SNode node, boolean allowErrors, boolean allowWarnings) {
    Assert.assertFalse("should be false (never used anyway)", allowErrors || allowWarnings);
    ITypeContextOwner owner = new ITypeContextOwner() {};
    SNode containingRoot = node.getTopmostAncestor();
    TypeCheckingContext typeCheckingContext = TypeContextManager.getInstance().getOrCreateContext(containingRoot, owner, true);
    try {
      typeCheckingContext.checkIfNotChecked(node, true);
      for (SNode child : SNodeOperations.getDescendants(node, "jetbrains.mps.lang.core.structure.BaseConcept", false, new String[]{})) {
        boolean isError = false;
        if (AttributeOperations.getAttribute(child, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodePropertiesContainer"))) != null) {
          SNode container = AttributeOperations.getAttribute(child, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodePropertiesContainer")));
          for (SNode property : SLinkOperations.getTargets(container, "properties", true)) {
            if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeTypeProperty")) {
              SNode type1 = typeCheckingContext.getTypeDontCheck(child);
              if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeExpectedTypeProperty")) {
                type1 = TypeChecker.getInstance().getInequalitiesForHole(child, false).getExpectedType();
                Assert.assertNotNull(type1);
              }
              SNode type2 = SLinkOperations.getTarget(SNodeOperations.cast(property, "jetbrains.mps.lang.test.structure.NodeTypeProperty"), "type", true);
              Assert.assertEquals(null, NodesMatcher.matchNodes(ListSequence.fromListAndArray(new ArrayList<SNode>(), type1), ListSequence.fromListAndArray(new ArrayList<SNode>(), type2)));
            }
            if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeTypeSetProperty")) {
              SNode type1 = typeCheckingContext.getTypeDontCheck(child);
              boolean hasType = false;
              for (SNode type2 : SLinkOperations.getTargets(SNodeOperations.cast(property, "jetbrains.mps.lang.test.structure.NodeTypeSetProperty"), "type", true)) {
                if (MatchingUtil.matchNodes(type1, type2)) {
                  hasType = true;
                  break;
                }
              }
              Assert.assertTrue("node type <" + type1 + "> is not in <" + SLinkOperations.getTargets(SNodeOperations.cast(property, "jetbrains.mps.lang.test.structure.NodeTypeSetProperty"), "type", true) + ">", hasType);
            }
            if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeErrorPropety")) {
              Assert.assertTrue("node <" + child + "> does not have expected error message", typeCheckingContext.getTypeMessageDontCheck(child) != null);
              Assert.assertFalse("node <" + child + "> has warning", typeCheckingContext.getTypeMessageDontCheck(child).getMessageStatus() == MessageStatus.WARNING);
              isError = true;
            }
            if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeWarningProperty")) {
              Assert.assertTrue("node <" + child + "> does not have expected warning", typeCheckingContext.getTypeMessageDontCheck(child) != null);
              Assert.assertTrue("node <" + child + "> does not have expected warning", typeCheckingContext.getTypeMessageDontCheck(child).getMessageStatus() == MessageStatus.WARNING);
              isError = true;
            }
          }
        }
        if (!(isError)) {
          IErrorReporter reporter = typeCheckingContext.getTypeMessageDontCheck(child);
          if (reporter != null) {
            String reportError = reporter.reportError();
            if (!(allowErrors)) {
              Assert.assertTrue(reportError, reporter.getMessageStatus() != MessageStatus.ERROR);
            }
            if (!(allowWarnings)) {
              Assert.assertTrue(reportError, reporter.getMessageStatus() != MessageStatus.WARNING);
            }
          }
        }
      }
    } finally {
      TypeContextManager.getInstance().removeOwnerForRootNodeContext(containingRoot, owner);
    }
  }

  public static void checkDataFlow(SNode node) {
    Program program = DataFlowManager.getInstance().buildProgramFor(node);
    Set<Instruction> unreachable = program.getUnreachableInstructions();
    AnalysisResult<VarSet> initialized = program.analyze(new InitializedVariablesAnalyzer());
    AnalysisResult<VarSet> live = program.analyze(new LivenessAnalyzer());
    for (SNode child : SNodeOperations.getDescendants(node, "jetbrains.mps.lang.core.structure.BaseConcept", false, new String[]{})) {
      if (AttributeOperations.getAttribute(child, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodePropertiesContainer"))) != null) {
        SNode container = AttributeOperations.getAttribute(child, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodePropertiesContainer")));
        for (SNode property : SLinkOperations.getTargets(container, "properties", true)) {
          Instruction instruction;
          List<Instruction> instructions = program.getInstructionsFor(child);
          if (ListSequence.fromList(instructions).count() > 0) {
            instruction = program.getInstructionsFor(child).get(0);
          } else {
            continue;
          }
          if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeReachable")) {
            Assert.assertFalse("instruction <" + instruction + "> is unreachable", SetSequence.fromSet(unreachable).contains(instruction));
          }
          if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.NodeUnreachable")) {
            Assert.assertTrue("instruction <" + instruction + "> is reachable", SetSequence.fromSet(unreachable).contains(instruction));
          }
          if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.VariableInialized")) {
            Set<Object> vars = (Set<Object>) initialized.get(instruction);
            SNode var = SLinkOperations.getTarget(SNodeOperations.cast(property, "jetbrains.mps.lang.test.structure.VariableInialized"), "var", true);
            Assert.assertTrue("variable <" + var + "> is not initialized", SetSequence.fromSet(vars).contains(SLinkOperations.getTarget(var, "variableDeclaration", false)));
          }
          if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.VariableLive")) {
            Set<Object> vars = (Set<Object>) live.get(instruction);
            SNode var = SLinkOperations.getTarget(SNodeOperations.cast(property, "jetbrains.mps.lang.test.structure.VariableInialized"), "var", true);
            Assert.assertTrue("variable <" + var + "> is not live", SetSequence.fromSet(vars).contains(SLinkOperations.getTarget(var, "variableDeclaration", false)));
          }
        }
      }
    }
  }

  public static void performOperations(SNode node) {
    for (SNode nodeToCheck : SNodeOperations.getDescendants(node, "jetbrains.mps.lang.core.structure.BaseConcept", false, new String[]{})) {
      if (nodeToCheck != null) {
        if (AttributeOperations.getAttribute(nodeToCheck, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodeOperationsContainer"))) != null) {
          for (SNode operation : SLinkOperations.getTargets(AttributeOperations.getAttribute(nodeToCheck, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.test.structure.NodeOperationsContainer"))), "operations", true)) {
            BehaviorManager.getInstance().invoke(Object.class, operation, "virtual_perform_1215601182156", new Class[]{SNode.class, SNode.class}, nodeToCheck);
          }
        }
      }
    }
  }

  public static void runTest() {
  }
}
