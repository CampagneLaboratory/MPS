package jetbrains.mps.lang.smodel.scripts;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;

public class PropertyValueEscapeUtil {
  private static Map<Character, String> ESCAPING_MAP = MapSequence.fromMap(new HashMap<Character, String>());

  public PropertyValueEscapeUtil() {
  }

  public static boolean hasCharactersToEscape(String propertyValue) {
    if (propertyValue == null) {
      return false;
    }
    for (int i = 0; i < propertyValue.length(); i++) {
      if (MapSequence.fromMap(ESCAPING_MAP).containsKey(propertyValue.charAt(i))) {
        return true;
      }
    }
    return false;
  }

  public static String escape(String propertyValue) {
    if (propertyValue == null) {
      return null;
    }
    StringBuilder escapedValueBuilder = new StringBuilder();
    for (int i = 0; i < propertyValue.length(); i++) {
      char ch = propertyValue.charAt(i);
      String replacement = MapSequence.fromMap(ESCAPING_MAP).get(ch);
      if (replacement != null) {
        escapedValueBuilder.append(replacement);
      } else {
        escapedValueBuilder.append(ch);
      }
    }
    return escapedValueBuilder.toString();
  }

  static {
    MapSequence.fromMap(ESCAPING_MAP).put('\000', "\\000");
    MapSequence.fromMap(ESCAPING_MAP).put('\b', "\\b");
    MapSequence.fromMap(ESCAPING_MAP).put('\t', "\\t");
    MapSequence.fromMap(ESCAPING_MAP).put('\n', "\\n");
    MapSequence.fromMap(ESCAPING_MAP).put('\f', "\\f");
    MapSequence.fromMap(ESCAPING_MAP).put('\r', "\\r");
  }
}
