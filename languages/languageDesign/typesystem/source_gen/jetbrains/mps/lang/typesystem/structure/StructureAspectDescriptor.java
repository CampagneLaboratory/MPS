package jetbrains.mps.lang.typesystem.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.BaseStructureAspectDescriptor;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.impl.ConceptDescriptorBuilder;
import jetbrains.mps.smodel.runtime.StaticScope;
import java.util.Collection;
import java.util.Arrays;
import org.jetbrains.annotations.NotNull;

public class StructureAspectDescriptor extends BaseStructureAspectDescriptor {
  /*package*/ final ConceptDescriptor myConceptAbstractCheckingRule = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule").super_("jetbrains.mps.lang.typesystem.structure.AbstractRule").parents("jetbrains.mps.lang.typesystem.structure.AbstractRule").properties("overrides").children(new String[]{"body"}, new boolean[]{false}).abstract_().create();
  /*package*/ final ConceptDescriptor myConceptAbstractComparableStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement").super_("jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement").parents("jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement").properties("infer").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptAbstractEquationStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement").properties("checkOnly").children(new String[]{"leftExpression", "rightExpression", "nodeToCheck", "errorString", "helginsIntention"}, new boolean[]{false, false, false, false, true}).abstract_().staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptAbstractInequationStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement").super_("jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement").parents("jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement").properties("inequationPriority", "label", "strong", "orientation").children(new String[]{"afterEquations", "beforeEquations", "afterGroups", "beforeGroups", "inequationGroup", "rulesToSkip"}, new boolean[]{true, true, true, true, false, true}).create();
  /*package*/ final ConceptDescriptor myConceptAbstractOverloadedOpsTypeRule = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").children(new String[]{"operationConcept", "function", "isApplicable"}, new boolean[]{true, false, false}).abstract_().create();
  /*package*/ final ConceptDescriptor myConceptAbstractRule = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.AbstractRule").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.baseLanguage.structure.IValidIdentifier", "jetbrains.mps.lang.structure.structure.IConceptAspect").children(new String[]{"applicableNode"}, new boolean[]{false}).abstract_().create();
  /*package*/ final ConceptDescriptor myConceptAbstractSubtypingRule = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule").super_("jetbrains.mps.lang.typesystem.structure.AbstractRule").parents("jetbrains.mps.lang.typesystem.structure.AbstractRule", "jetbrains.mps.baseLanguage.structure.IMethodLike").properties("isWeak").children(new String[]{"body"}, new boolean[]{false}).abstract_().create();
  /*package*/ final ConceptDescriptor myConceptAddDependencyStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.AddDependencyStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement").children(new String[]{"dependency"}, new boolean[]{false}).alias("addDependency", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptApplicableNodeCondition = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept", "jetbrains.mps.lang.core.structure.InterfacePart").abstract_().create();
  /*package*/ final ConceptDescriptor myConceptApplicableNodeReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ApplicableNodeReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("applicableNode").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptAssertStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.AssertStatement").super_("jetbrains.mps.lang.typesystem.structure.ReportErrorStatement").parents("jetbrains.mps.lang.typesystem.structure.ReportErrorStatement").children(new String[]{"condition"}, new boolean[]{false}).alias("ensure", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCaretPositionOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CaretPositionOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.baseLanguage.structure.IOperation").alias("caretPosition", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCoerceExpression = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CoerceExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").properties("strong").children(new String[]{"pattern", "nodeToCoerce"}, new boolean[]{false, false}).alias("coerce", "expression").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCoerceStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CoerceStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement").properties("strong").children(new String[]{"pattern", "nodeToCoerce", "body", "elseClause"}, new boolean[]{false, false, false, false}).alias("coerce", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCoerceStrongExpression = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CoerceStrongExpression").super_("jetbrains.mps.lang.typesystem.structure.CoerceExpression").parents("jetbrains.mps.lang.typesystem.structure.CoerceExpression").alias("coerceStrong", "expression").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptComparisonRule = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ComparisonRule").super_("jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule").parents("jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule", "jetbrains.mps.lang.typesystem.structure.IRuleWithTwoNodes").children(new String[]{"anotherNode"}, new boolean[]{false}).alias("Comparison Rule", "").create();
  /*package*/ final ConceptDescriptor myConceptConceptClauseLinkInfo = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptClauseLinkInfo").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").references("linkDeclaration").children(new String[]{"targetNode", "childIndex"}, new boolean[]{false, false}).create();
  /*package*/ final ConceptDescriptor myConceptConceptFunctionParameter_BlockingComputationNode = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_BlockingComputationNode").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("node", "function parameter").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptConceptFunctionParameter_ContextNode = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_ContextNode").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("contextNode", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptConceptFunctionParameter_DependentComputationNode = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_DependentComputationNode").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("node", "function parameter").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptConceptFunctionParameter_EditorContext = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_EditorContext").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").alias("editorContext", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptConceptFunctionParameter_Role = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_Role").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("role", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptConceptFunctionParameter_Selection = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_Selection").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").alias("selectionBefore", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptConceptFunctionParameter_isAggregation = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_isAggregation").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("isAggregation", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptConceptFunctionParameter_node = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_node").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("node", "function parameter").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptConceptFunctionParameter_var = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_var").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("variable", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptConceptReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptReference").super_("jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition").parents("jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition").references("concept").alias("concept =", "").create();
  /*package*/ final ConceptDescriptor myConceptConceptTypeClause = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ConceptTypeClause").super_("jetbrains.mps.lang.typesystem.structure.TypeClause").parents("jetbrains.mps.lang.typesystem.structure.TypeClause").references("matchingConcept").children(new String[]{"linkInfo"}, new boolean[]{true}).alias("typeInstanceOf", "").create();
  /*package*/ final ConceptDescriptor myConceptCreateComparableEquationStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CreateComparableEquationStatement").super_("jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement").parents("jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement").alias(":~:", "weak comparability").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCreateComparableEquationStatementStrong = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CreateComparableEquationStatementStrong").super_("jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement").parents("jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement").alias(":~~:", "strong comparability").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCreateEquationStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CreateEquationStatement").super_("jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement").parents("jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement").alias(":==:", "typesystem equation").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCreateGreaterThanInequationStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CreateGreaterThanInequationStatement").super_("jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement").parents("jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement").alias(":>=:", "weak subtyping").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCreateLessThanInequationStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CreateLessThanInequationStatement").super_("jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement").parents("jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement").alias(":<=:", "weak subtyping").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCreateStrongGreaterThanInequationStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CreateStrongGreaterThanInequationStatement").super_("jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement").parents("jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement").alias(":>>=:", "strong subtyping").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCreateStrongLessThanInequationStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.CreateStrongLessThanInequationStatement").super_("jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement").parents("jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement").alias(":<<=:", "strong subtyping").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptDefaultGroupReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.DefaultGroupReference").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").alias("default", "").create();
  /*package*/ final ConceptDescriptor myConceptDependency = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.Dependency").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").references("targetConcept", "sourceConcept").children(new String[]{"findSourceBlock"}, new boolean[]{false}).create();
  /*package*/ final ConceptDescriptor myConceptDependentComputationItem = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.DependentComputationItem").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").references("applicableConcept", "blockingNodeConcept").children(new String[]{"findMasterBlock", "isApplicableBlock", "isBlockingBlock"}, new boolean[]{false, false, false}).alias("Dependent Computation Item", "").create();
  /*package*/ final ConceptDescriptor myConceptDependentComputationItem_ApplicableBlock = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.DependentComputationItem_ApplicableBlock").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptDependentComputationItem_BlockingBlock = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.DependentComputationItem_BlockingBlock").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptDependentComputationItem_FindMasterBlock = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.DependentComputationItem_FindMasterBlock").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptErrorInfoExpression = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ErrorInfoExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").alias("equationInfo", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptFindSourceBlock = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.FindSourceBlock").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptFindSourceBlockParameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.FindSourceBlockParameter").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("targetNode", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptGetOperationType = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.GetOperationType").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"operation", "leftOperandType", "rightOperandType"}, new boolean[]{false, false, false}).alias("operation type(..)", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptIRuleWithOneNode = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.IRuleWithOneNode").interface_().create();
  /*package*/ final ConceptDescriptor myConceptIRuleWithTwoNodes = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.IRuleWithTwoNodes").interface_().create();
  /*package*/ final ConceptDescriptor myConceptImmediateSupertypesExpression = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ImmediateSupertypesExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"subtypeExpression"}, new boolean[]{false}).alias("immediateSupertypes()", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptInequationReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.InequationReference").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").references("inequation").create();
  /*package*/ final ConceptDescriptor myConceptInequationReplacementRule = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.InequationReplacementRule").super_("jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule").parents("jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule", "jetbrains.mps.lang.typesystem.structure.IRuleWithTwoNodes").children(new String[]{"supertypeNode", "isApplicableClause"}, new boolean[]{false, false}).create();
  /*package*/ final ConceptDescriptor myConceptInferenceRule = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.InferenceRule").super_("jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule").parents("jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule", "jetbrains.mps.lang.typesystem.structure.IRuleWithOneNode").children(new String[]{"dependency"}, new boolean[]{true}).alias("Inference Rule", "").create();
  /*package*/ final ConceptDescriptor myConceptInfoStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.InfoStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.lang.typesystem.structure.MessageStatement").children(new String[]{"infoText"}, new boolean[]{false}).alias("info", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptInfoStatementAnnotation = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.InfoStatementAnnotation").super_("jetbrains.mps.lang.typesystem.structure.MessageStatementAnnotation").parents("jetbrains.mps.lang.typesystem.structure.MessageStatementAnnotation").create();
  /*package*/ final ConceptDescriptor myConceptIsReplacementRuleApplicable_ConceptFunction = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.IsReplacementRuleApplicable_ConceptFunction").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptIsStrongSubtypeExpression = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.IsStrongSubtypeExpression").super_("jetbrains.mps.lang.typesystem.structure.IsSubtypeExpression").parents("jetbrains.mps.lang.typesystem.structure.IsSubtypeExpression").alias("isStrongSubtype()", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptIsSubtypeExpression = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.IsSubtypeExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"subtypeExpression", "supertypeExpression"}, new boolean[]{false, false}).alias("isSubtype()", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptJoinContainer = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.JoinContainer").super_("jetbrains.mps.lang.core.structure.NodeAttribute").parents("jetbrains.mps.lang.core.structure.NodeAttribute", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"joinType"}, new boolean[]{false}).create();
  /*package*/ final ConceptDescriptor myConceptJoinType = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.JoinType").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.IType", "jetbrains.mps.baseLanguage.structure.IGenericType").children(new String[]{"argument"}, new boolean[]{true}).alias("join", "").create();
  /*package*/ final ConceptDescriptor myConceptLeftOperandType_parameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.LeftOperandType_parameter").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("leftOperandType", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptLinkPatternVariableReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.LinkPatternVariableReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("patternVarDecl").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptListVarDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ListVarDeclaration").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.lang.core.structure.INamedConcept").alias("listVar", "helgins list type variable").create();
  /*package*/ final ConceptDescriptor myConceptMatchStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.MatchStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement").children(new String[]{"expression", "item", "ifFalseStatement"}, new boolean[]{false, true, false}).alias("match", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatchStatementItem = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.MatchStatementItem").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").children(new String[]{"condition", "ifTrue"}, new boolean[]{false, false}).create();
  /*package*/ final ConceptDescriptor myConceptMeetContainer = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.MeetContainer").super_("jetbrains.mps.lang.core.structure.NodeAttribute").parents("jetbrains.mps.lang.core.structure.NodeAttribute", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"meetType"}, new boolean[]{false}).create();
  /*package*/ final ConceptDescriptor myConceptMeetType = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.MeetType").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.IType", "jetbrains.mps.baseLanguage.structure.IGenericType").children(new String[]{"argument"}, new boolean[]{true}).alias("meet", "").create();
  /*package*/ final ConceptDescriptor myConceptMessageStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.MessageStatement").interface_().children(new String[]{"nodeToReport", "helginsIntention", "messageTarget", "foreignMessageSource"}, new boolean[]{false, true, false, false}).create();
  /*package*/ final ConceptDescriptor myConceptMessageStatementAnnotation = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.MessageStatementAnnotation").super_("jetbrains.mps.lang.core.structure.NodeAttribute").parents("jetbrains.mps.lang.core.structure.NodeAttribute", "jetbrains.mps.lang.core.structure.INamedConcept").abstract_().create();
  /*package*/ final ConceptDescriptor myConceptMessageTarget = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.MessageTarget").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").abstract_().create();
  /*package*/ final ConceptDescriptor myConceptMultipleForeachLoop = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.MultipleForeachLoop").super_("jetbrains.mps.baseLanguage.structure.AbstractLoopStatement").parents("jetbrains.mps.baseLanguage.structure.AbstractLoopStatement").children(new String[]{"loopVariable"}, new boolean[]{true}).alias("foreach", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMultipleForeachLoopVariable = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.MultipleForeachLoopVariable").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").children(new String[]{"variable", "iterable"}, new boolean[]{false, false}).create();
  /*package*/ final ConceptDescriptor myConceptNodeInfo = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.NodeInfo").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").properties("modelId", "nodeId").create();
  /*package*/ final ConceptDescriptor myConceptNode_InferTypeOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.Node_InferTypeOperation").super_("jetbrains.mps.lang.smodel.structure.SNodeOperation").parents("jetbrains.mps.lang.smodel.structure.SNodeOperation", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("inferType", "get inferred type").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptNode_TypeOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.Node_TypeOperation").super_("jetbrains.mps.lang.smodel.structure.SNodeOperation").parents("jetbrains.mps.lang.smodel.structure.SNodeOperation", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("type", "get type").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptNonTypesystemRule = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.NonTypesystemRule").super_("jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule").parents("jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule", "jetbrains.mps.lang.typesystem.structure.IRuleWithOneNode").alias("Non-Typesystem Rule", "").create();
  /*package*/ final ConceptDescriptor myConceptNormalTypeClause = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.NormalTypeClause").super_("jetbrains.mps.lang.typesystem.structure.TypeClause").parents("jetbrains.mps.lang.typesystem.structure.TypeClause").children(new String[]{"normalType"}, new boolean[]{false}).alias("( expr )", "").create();
  /*package*/ final ConceptDescriptor myConceptOperationContextExpression = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.OperationContextExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("operationContext", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptOperation_parameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.Operation_parameter").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("operation", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptOrStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.OrStatement").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").children(new String[]{"orClause"}, new boolean[]{true}).create();
  /*package*/ final ConceptDescriptor myConceptOriginalNodeId = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.OriginalNodeId").super_("jetbrains.mps.lang.core.structure.NodeAttribute").parents("jetbrains.mps.lang.core.structure.NodeAttribute").properties("nodeId", "modelId").create();
  /*package*/ final ConceptDescriptor myConceptOverloadedOpIsApplicableFunction = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.OverloadedOpIsApplicableFunction").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptOverloadedOpRulesContainer = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.OverloadedOpRulesContainer").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").children(new String[]{"rule"}, new boolean[]{true}).alias("Overloaded Operations Rules Container", "").create();
  /*package*/ final ConceptDescriptor myConceptOverloadedOpTypeRule_OneTypeSpecified = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.OverloadedOpTypeRule_OneTypeSpecified").super_("jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule").parents("jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule").properties("isExact", "isStrong").children(new String[]{"operandType"}, new boolean[]{false}).create();
  /*package*/ final ConceptDescriptor myConceptOverloadedOperatorTypeFunction = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.OverloadedOperatorTypeFunction").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptOverloadedOperatorTypeRule = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.OverloadedOperatorTypeRule").super_("jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule").parents("jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule").properties("leftIsExact", "rightIsExact", "rightIsStrong", "leftIsStrong").children(new String[]{"leftOperandType", "rightOperandType"}, new boolean[]{false, false}).create();
  /*package*/ final ConceptDescriptor myConceptPatternCondition = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.PatternCondition").super_("jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition").parents("jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition").children(new String[]{"pattern"}, new boolean[]{false}).alias("pattern condition", "").create();
  /*package*/ final ConceptDescriptor myConceptPatternVariableReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.PatternVariableReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("patternVarDecl").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptPrintToTrace = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.PrintToTrace").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement").children(new String[]{"message"}, new boolean[]{false}).alias("print to trace", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptProcessed = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.Processed").super_("jetbrains.mps.lang.core.structure.NodeAttribute").parents("jetbrains.mps.lang.core.structure.NodeAttribute").create();
  /*package*/ final ConceptDescriptor myConceptPropertyMessageTarget = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.PropertyMessageTarget").super_("jetbrains.mps.lang.typesystem.structure.MessageTarget").parents("jetbrains.mps.lang.typesystem.structure.MessageTarget").references("propertyDeclaration").create();
  /*package*/ final ConceptDescriptor myConceptPropertyNameTarget = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.PropertyNameTarget").super_("jetbrains.mps.lang.typesystem.structure.MessageTarget").parents("jetbrains.mps.lang.typesystem.structure.MessageTarget").children(new String[]{"propertyName"}, new boolean[]{false}).alias("property name", "").create();
  /*package*/ final ConceptDescriptor myConceptPropertyPatternVariableReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.PropertyPatternVariableReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("patternVarDecl").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptQuickFixArgument = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.QuickFixArgument").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").children(new String[]{"argumentType"}, new boolean[]{false}).create();
  /*package*/ final ConceptDescriptor myConceptQuickFixArgumentReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.QuickFixArgumentReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("quickFixArgument").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptQuickFixDescriptionBlock = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.QuickFixDescriptionBlock").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").alias("description", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptQuickFixExecuteBlock = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.QuickFixExecuteBlock").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").alias("execute", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptQuickFixField = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.QuickFixField").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").children(new String[]{"fieldType"}, new boolean[]{false}).create();
  /*package*/ final ConceptDescriptor myConceptQuickFixFieldReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.QuickFixFieldReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("quickFixField").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptQuickFixSetSelectionBlock = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.QuickFixSetSelectionBlock").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").alias("set selection", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptReferenceMessageTarget = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ReferenceMessageTarget").super_("jetbrains.mps.lang.typesystem.structure.MessageTarget").parents("jetbrains.mps.lang.typesystem.structure.MessageTarget").references("linkDeclaration").create();
  /*package*/ final ConceptDescriptor myConceptReferenceRoleTarget = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ReferenceRoleTarget").super_("jetbrains.mps.lang.typesystem.structure.MessageTarget").parents("jetbrains.mps.lang.typesystem.structure.MessageTarget").children(new String[]{"referenceRole"}, new boolean[]{false}).alias("reference role", "").create();
  /*package*/ final ConceptDescriptor myConceptReplacementRuleReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ReplacementRuleReference").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").properties("fqName").references("replacementRule").create();
  /*package*/ final ConceptDescriptor myConceptReportErrorStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ReportErrorStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.lang.typesystem.structure.MessageStatement").children(new String[]{"errorString"}, new boolean[]{false}).alias("error", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptReportErrorStatementAnnotation = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.ReportErrorStatementAnnotation").super_("jetbrains.mps.lang.typesystem.structure.MessageStatementAnnotation").parents("jetbrains.mps.lang.typesystem.structure.MessageStatementAnnotation").create();
  /*package*/ final ConceptDescriptor myConceptRightOperandType_parameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.RightOperandType_parameter").super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").alias("rightOperandType", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptRuntimeErrorType = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.RuntimeErrorType").super_("jetbrains.mps.lang.typesystem.structure.RuntimeTypeVariable").parents("jetbrains.mps.lang.typesystem.structure.RuntimeTypeVariable").properties("errorText", "nodeId", "nodeModel").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptRuntimeHoleType = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.RuntimeHoleType").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").create();
  /*package*/ final ConceptDescriptor myConceptRuntimeListVariable = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.RuntimeListVariable").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept").create();
  /*package*/ final ConceptDescriptor myConceptRuntimeTypeVariable = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.RuntimeTypeVariable").super_("jetbrains.mps.baseLanguage.structure.Type").parents("jetbrains.mps.baseLanguage.structure.Type", "jetbrains.mps.lang.core.structure.INamedConcept").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptSelectionType = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.SelectionType").super_("jetbrains.mps.baseLanguage.structure.Type").parents("jetbrains.mps.baseLanguage.structure.Type").alias("selection", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptSubtypingRule = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.SubtypingRule").super_("jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule").parents("jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule", "jetbrains.mps.lang.typesystem.structure.IRuleWithOneNode").alias("Subtyping Rule", "").create();
  /*package*/ final ConceptDescriptor myConceptTypeCheckerAccessExpression = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.TypeCheckerAccessExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").alias("typechecker", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptTypeClause = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.TypeClause").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").abstract_().create();
  /*package*/ final ConceptDescriptor myConceptTypeOfExpression = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.TypeOfExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").properties("skipDependencyOnCurrent").children(new String[]{"term"}, new boolean[]{false}).alias("typeof", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptTypeVarDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.TypeVarDeclaration").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.lang.core.structure.INamedConcept").properties("nullable").alias("var", "typesystem's type variable").create();
  /*package*/ final ConceptDescriptor myConceptTypeVarReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.TypeVarReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("typeVarDeclaration").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptTypesystemIntention = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.TypesystemIntention").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").properties("applyImmediately").references("quickFix").children(new String[]{"actualArgument"}, new boolean[]{true}).create();
  /*package*/ final ConceptDescriptor myConceptTypesystemIntentionArgument = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.TypesystemIntentionArgument").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").references("quickFixArgument").children(new String[]{"value"}, new boolean[]{false}).create();
  /*package*/ final ConceptDescriptor myConceptTypesystemQuickFix = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.TypesystemQuickFix").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.baseLanguage.structure.IValidIdentifier").children(new String[]{"executeBlock", "descriptionBlock", "setSelectionBlock", "quickFixArgument", "quickFixField"}, new boolean[]{false, false, false, true, true}).alias("Quick Fix", "").create();
  /*package*/ final ConceptDescriptor myConceptVariableConverterItem = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.VariableConverterItem").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").children(new String[]{"applicableBlock", "convertBlock"}, new boolean[]{false, false}).create();
  /*package*/ final ConceptDescriptor myConceptVariableConverterItem_ApplicableBlock = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.VariableConverterItem_ApplicableBlock").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptVariableConverterItem_ConvertBlock = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.VariableConverterItem_ConvertBlock").super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptVariableConvertersContainer = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.VariableConvertersContainer").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").children(new String[]{"converterItem"}, new boolean[]{true}).alias("Variable Converters Container", "").create();
  /*package*/ final ConceptDescriptor myConceptWarningStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.WarningStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.lang.typesystem.structure.MessageStatement").children(new String[]{"warningText"}, new boolean[]{false}).alias("warning", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptWarningStatementAnnotation = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.WarningStatementAnnotation").super_("jetbrains.mps.lang.typesystem.structure.MessageStatementAnnotation").parents("jetbrains.mps.lang.typesystem.structure.MessageStatementAnnotation").create();
  /*package*/ final ConceptDescriptor myConceptWasSelectedNodeOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.WasSelectedNodeOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.baseLanguage.structure.IOperation").alias("wasSelectedNode", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptWhenConcreteStatement = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.WhenConcreteStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement", "jetbrains.mps.baseLanguage.structure.Closureoid", "jetbrains.mps.baseLanguage.structure.IControlFlowInterrupter").properties("isShallow", "skipsError").children(new String[]{"body", "argument", "argumentRepresentator"}, new boolean[]{false, false, false}).alias("when concrete", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptWhenConcreteVariableDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.WhenConcreteVariableDeclaration").super_("jetbrains.mps.baseLanguage.structure.VariableDeclaration").parents("jetbrains.mps.baseLanguage.structure.VariableDeclaration").create();
  /*package*/ final ConceptDescriptor myConceptWhenConcreteVariableReference = new ConceptDescriptorBuilder("jetbrains.mps.lang.typesystem.structure.WhenConcreteVariableReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("whenConcreteVar").staticScope(StaticScope.NONE).create();

  @Override
  public Collection<ConceptDescriptor> getDescriptors() {
    return Arrays.asList(myConceptAbstractCheckingRule, myConceptAbstractComparableStatement, myConceptAbstractEquationStatement, myConceptAbstractInequationStatement, myConceptAbstractOverloadedOpsTypeRule, myConceptAbstractRule, myConceptAbstractSubtypingRule, myConceptAddDependencyStatement, myConceptApplicableNodeCondition, myConceptApplicableNodeReference, myConceptAssertStatement, myConceptCaretPositionOperation, myConceptCoerceExpression, myConceptCoerceStatement, myConceptCoerceStrongExpression, myConceptComparisonRule, myConceptConceptClauseLinkInfo, myConceptConceptFunctionParameter_BlockingComputationNode, myConceptConceptFunctionParameter_ContextNode, myConceptConceptFunctionParameter_DependentComputationNode, myConceptConceptFunctionParameter_EditorContext, myConceptConceptFunctionParameter_Role, myConceptConceptFunctionParameter_Selection, myConceptConceptFunctionParameter_isAggregation, myConceptConceptFunctionParameter_node, myConceptConceptFunctionParameter_var, myConceptConceptReference, myConceptConceptTypeClause, myConceptCreateComparableEquationStatement, myConceptCreateComparableEquationStatementStrong, myConceptCreateEquationStatement, myConceptCreateGreaterThanInequationStatement, myConceptCreateLessThanInequationStatement, myConceptCreateStrongGreaterThanInequationStatement, myConceptCreateStrongLessThanInequationStatement, myConceptDefaultGroupReference, myConceptDependency, myConceptDependentComputationItem, myConceptDependentComputationItem_ApplicableBlock, myConceptDependentComputationItem_BlockingBlock, myConceptDependentComputationItem_FindMasterBlock, myConceptErrorInfoExpression, myConceptFindSourceBlock, myConceptFindSourceBlockParameter, myConceptGetOperationType, myConceptIRuleWithOneNode, myConceptIRuleWithTwoNodes, myConceptImmediateSupertypesExpression, myConceptInequationReference, myConceptInequationReplacementRule, myConceptInferenceRule, myConceptInfoStatement, myConceptInfoStatementAnnotation, myConceptIsReplacementRuleApplicable_ConceptFunction, myConceptIsStrongSubtypeExpression, myConceptIsSubtypeExpression, myConceptJoinContainer, myConceptJoinType, myConceptLeftOperandType_parameter, myConceptLinkPatternVariableReference, myConceptListVarDeclaration, myConceptMatchStatement, myConceptMatchStatementItem, myConceptMeetContainer, myConceptMeetType, myConceptMessageStatement, myConceptMessageStatementAnnotation, myConceptMessageTarget, myConceptMultipleForeachLoop, myConceptMultipleForeachLoopVariable, myConceptNodeInfo, myConceptNode_InferTypeOperation, myConceptNode_TypeOperation, myConceptNonTypesystemRule, myConceptNormalTypeClause, myConceptOperationContextExpression, myConceptOperation_parameter, myConceptOrStatement, myConceptOriginalNodeId, myConceptOverloadedOpIsApplicableFunction, myConceptOverloadedOpRulesContainer, myConceptOverloadedOpTypeRule_OneTypeSpecified, myConceptOverloadedOperatorTypeFunction, myConceptOverloadedOperatorTypeRule, myConceptPatternCondition, myConceptPatternVariableReference, myConceptPrintToTrace, myConceptProcessed, myConceptPropertyMessageTarget, myConceptPropertyNameTarget, myConceptPropertyPatternVariableReference, myConceptQuickFixArgument, myConceptQuickFixArgumentReference, myConceptQuickFixDescriptionBlock, myConceptQuickFixExecuteBlock, myConceptQuickFixField, myConceptQuickFixFieldReference, myConceptQuickFixSetSelectionBlock, myConceptReferenceMessageTarget, myConceptReferenceRoleTarget, myConceptReplacementRuleReference, myConceptReportErrorStatement, myConceptReportErrorStatementAnnotation, myConceptRightOperandType_parameter, myConceptRuntimeErrorType, myConceptRuntimeHoleType, myConceptRuntimeListVariable, myConceptRuntimeTypeVariable, myConceptSelectionType, myConceptSubtypingRule, myConceptTypeCheckerAccessExpression, myConceptTypeClause, myConceptTypeOfExpression, myConceptTypeVarDeclaration, myConceptTypeVarReference, myConceptTypesystemIntention, myConceptTypesystemIntentionArgument, myConceptTypesystemQuickFix, myConceptVariableConverterItem, myConceptVariableConverterItem_ApplicableBlock, myConceptVariableConverterItem_ConvertBlock, myConceptVariableConvertersContainer, myConceptWarningStatement, myConceptWarningStatementAnnotation, myConceptWasSelectedNodeOperation, myConceptWhenConcreteStatement, myConceptWhenConcreteVariableDeclaration, myConceptWhenConcreteVariableReference);
  }

  @Override
  @NotNull
  public ConceptDescriptor getDescriptor(String conceptFqName) {
    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0bf, conceptFqName)) {
      case 0:
        return myConceptAbstractCheckingRule;
      case 1:
        return myConceptAbstractComparableStatement;
      case 2:
        return myConceptAbstractEquationStatement;
      case 3:
        return myConceptAbstractInequationStatement;
      case 4:
        return myConceptAbstractOverloadedOpsTypeRule;
      case 5:
        return myConceptAbstractRule;
      case 6:
        return myConceptAbstractSubtypingRule;
      case 7:
        return myConceptAddDependencyStatement;
      case 8:
        return myConceptApplicableNodeCondition;
      case 9:
        return myConceptApplicableNodeReference;
      case 10:
        return myConceptAssertStatement;
      case 11:
        return myConceptCaretPositionOperation;
      case 12:
        return myConceptCoerceExpression;
      case 13:
        return myConceptCoerceStatement;
      case 14:
        return myConceptCoerceStrongExpression;
      case 15:
        return myConceptComparisonRule;
      case 16:
        return myConceptConceptClauseLinkInfo;
      case 17:
        return myConceptConceptFunctionParameter_BlockingComputationNode;
      case 18:
        return myConceptConceptFunctionParameter_ContextNode;
      case 19:
        return myConceptConceptFunctionParameter_DependentComputationNode;
      case 20:
        return myConceptConceptFunctionParameter_EditorContext;
      case 21:
        return myConceptConceptFunctionParameter_Role;
      case 22:
        return myConceptConceptFunctionParameter_Selection;
      case 23:
        return myConceptConceptFunctionParameter_isAggregation;
      case 24:
        return myConceptConceptFunctionParameter_node;
      case 25:
        return myConceptConceptFunctionParameter_var;
      case 26:
        return myConceptConceptReference;
      case 27:
        return myConceptConceptTypeClause;
      case 28:
        return myConceptCreateComparableEquationStatement;
      case 29:
        return myConceptCreateComparableEquationStatementStrong;
      case 30:
        return myConceptCreateEquationStatement;
      case 31:
        return myConceptCreateGreaterThanInequationStatement;
      case 32:
        return myConceptCreateLessThanInequationStatement;
      case 33:
        return myConceptCreateStrongGreaterThanInequationStatement;
      case 34:
        return myConceptCreateStrongLessThanInequationStatement;
      case 35:
        return myConceptDefaultGroupReference;
      case 36:
        return myConceptDependency;
      case 37:
        return myConceptDependentComputationItem;
      case 38:
        return myConceptDependentComputationItem_ApplicableBlock;
      case 39:
        return myConceptDependentComputationItem_BlockingBlock;
      case 40:
        return myConceptDependentComputationItem_FindMasterBlock;
      case 41:
        return myConceptErrorInfoExpression;
      case 42:
        return myConceptFindSourceBlock;
      case 43:
        return myConceptFindSourceBlockParameter;
      case 44:
        return myConceptGetOperationType;
      case 45:
        return myConceptIRuleWithOneNode;
      case 46:
        return myConceptIRuleWithTwoNodes;
      case 47:
        return myConceptImmediateSupertypesExpression;
      case 48:
        return myConceptInequationReference;
      case 49:
        return myConceptInequationReplacementRule;
      case 50:
        return myConceptInferenceRule;
      case 51:
        return myConceptInfoStatement;
      case 52:
        return myConceptInfoStatementAnnotation;
      case 53:
        return myConceptIsReplacementRuleApplicable_ConceptFunction;
      case 54:
        return myConceptIsStrongSubtypeExpression;
      case 55:
        return myConceptIsSubtypeExpression;
      case 56:
        return myConceptJoinContainer;
      case 57:
        return myConceptJoinType;
      case 58:
        return myConceptLeftOperandType_parameter;
      case 59:
        return myConceptLinkPatternVariableReference;
      case 60:
        return myConceptListVarDeclaration;
      case 61:
        return myConceptMatchStatement;
      case 62:
        return myConceptMatchStatementItem;
      case 63:
        return myConceptMeetContainer;
      case 64:
        return myConceptMeetType;
      case 65:
        return myConceptMessageStatement;
      case 66:
        return myConceptMessageStatementAnnotation;
      case 67:
        return myConceptMessageTarget;
      case 68:
        return myConceptMultipleForeachLoop;
      case 69:
        return myConceptMultipleForeachLoopVariable;
      case 70:
        return myConceptNodeInfo;
      case 71:
        return myConceptNode_InferTypeOperation;
      case 72:
        return myConceptNode_TypeOperation;
      case 73:
        return myConceptNonTypesystemRule;
      case 74:
        return myConceptNormalTypeClause;
      case 75:
        return myConceptOperationContextExpression;
      case 76:
        return myConceptOperation_parameter;
      case 77:
        return myConceptOrStatement;
      case 78:
        return myConceptOriginalNodeId;
      case 79:
        return myConceptOverloadedOpIsApplicableFunction;
      case 80:
        return myConceptOverloadedOpRulesContainer;
      case 81:
        return myConceptOverloadedOpTypeRule_OneTypeSpecified;
      case 82:
        return myConceptOverloadedOperatorTypeFunction;
      case 83:
        return myConceptOverloadedOperatorTypeRule;
      case 84:
        return myConceptPatternCondition;
      case 85:
        return myConceptPatternVariableReference;
      case 86:
        return myConceptPrintToTrace;
      case 87:
        return myConceptProcessed;
      case 88:
        return myConceptPropertyMessageTarget;
      case 89:
        return myConceptPropertyNameTarget;
      case 90:
        return myConceptPropertyPatternVariableReference;
      case 91:
        return myConceptQuickFixArgument;
      case 92:
        return myConceptQuickFixArgumentReference;
      case 93:
        return myConceptQuickFixDescriptionBlock;
      case 94:
        return myConceptQuickFixExecuteBlock;
      case 95:
        return myConceptQuickFixField;
      case 96:
        return myConceptQuickFixFieldReference;
      case 97:
        return myConceptQuickFixSetSelectionBlock;
      case 98:
        return myConceptReferenceMessageTarget;
      case 99:
        return myConceptReferenceRoleTarget;
      case 100:
        return myConceptReplacementRuleReference;
      case 101:
        return myConceptReportErrorStatement;
      case 102:
        return myConceptReportErrorStatementAnnotation;
      case 103:
        return myConceptRightOperandType_parameter;
      case 104:
        return myConceptRuntimeErrorType;
      case 105:
        return myConceptRuntimeHoleType;
      case 106:
        return myConceptRuntimeListVariable;
      case 107:
        return myConceptRuntimeTypeVariable;
      case 108:
        return myConceptSelectionType;
      case 109:
        return myConceptSubtypingRule;
      case 110:
        return myConceptTypeCheckerAccessExpression;
      case 111:
        return myConceptTypeClause;
      case 112:
        return myConceptTypeOfExpression;
      case 113:
        return myConceptTypeVarDeclaration;
      case 114:
        return myConceptTypeVarReference;
      case 115:
        return myConceptTypesystemIntention;
      case 116:
        return myConceptTypesystemIntentionArgument;
      case 117:
        return myConceptTypesystemQuickFix;
      case 118:
        return myConceptVariableConverterItem;
      case 119:
        return myConceptVariableConverterItem_ApplicableBlock;
      case 120:
        return myConceptVariableConverterItem_ConvertBlock;
      case 121:
        return myConceptVariableConvertersContainer;
      case 122:
        return myConceptWarningStatement;
      case 123:
        return myConceptWarningStatementAnnotation;
      case 124:
        return myConceptWasSelectedNodeOperation;
      case 125:
        return myConceptWhenConcreteStatement;
      case 126:
        return myConceptWhenConcreteVariableDeclaration;
      case 127:
        return myConceptWhenConcreteVariableReference;
      default:
        throw new IllegalStateException("Wrong fqName of the concept " + conceptFqName);
    }
  }
  private static String[] stringSwitchCases_1htk8d_a0a0bf = new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule", "jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement", "jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement", "jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement", "jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule", "jetbrains.mps.lang.typesystem.structure.AbstractRule", "jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule", "jetbrains.mps.lang.typesystem.structure.AddDependencyStatement", "jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition", "jetbrains.mps.lang.typesystem.structure.ApplicableNodeReference", "jetbrains.mps.lang.typesystem.structure.AssertStatement", "jetbrains.mps.lang.typesystem.structure.CaretPositionOperation", "jetbrains.mps.lang.typesystem.structure.CoerceExpression", "jetbrains.mps.lang.typesystem.structure.CoerceStatement", "jetbrains.mps.lang.typesystem.structure.CoerceStrongExpression", "jetbrains.mps.lang.typesystem.structure.ComparisonRule", "jetbrains.mps.lang.typesystem.structure.ConceptClauseLinkInfo", "jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_BlockingComputationNode", "jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_ContextNode", "jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_DependentComputationNode", "jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_EditorContext", "jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_Role", "jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_Selection", "jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_isAggregation", "jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_node", "jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_var", "jetbrains.mps.lang.typesystem.structure.ConceptReference", "jetbrains.mps.lang.typesystem.structure.ConceptTypeClause", "jetbrains.mps.lang.typesystem.structure.CreateComparableEquationStatement", "jetbrains.mps.lang.typesystem.structure.CreateComparableEquationStatementStrong", "jetbrains.mps.lang.typesystem.structure.CreateEquationStatement", "jetbrains.mps.lang.typesystem.structure.CreateGreaterThanInequationStatement", "jetbrains.mps.lang.typesystem.structure.CreateLessThanInequationStatement", "jetbrains.mps.lang.typesystem.structure.CreateStrongGreaterThanInequationStatement", "jetbrains.mps.lang.typesystem.structure.CreateStrongLessThanInequationStatement", "jetbrains.mps.lang.typesystem.structure.DefaultGroupReference", "jetbrains.mps.lang.typesystem.structure.Dependency", "jetbrains.mps.lang.typesystem.structure.DependentComputationItem", "jetbrains.mps.lang.typesystem.structure.DependentComputationItem_ApplicableBlock", "jetbrains.mps.lang.typesystem.structure.DependentComputationItem_BlockingBlock", "jetbrains.mps.lang.typesystem.structure.DependentComputationItem_FindMasterBlock", "jetbrains.mps.lang.typesystem.structure.ErrorInfoExpression", "jetbrains.mps.lang.typesystem.structure.FindSourceBlock", "jetbrains.mps.lang.typesystem.structure.FindSourceBlockParameter", "jetbrains.mps.lang.typesystem.structure.GetOperationType", "jetbrains.mps.lang.typesystem.structure.IRuleWithOneNode", "jetbrains.mps.lang.typesystem.structure.IRuleWithTwoNodes", "jetbrains.mps.lang.typesystem.structure.ImmediateSupertypesExpression", "jetbrains.mps.lang.typesystem.structure.InequationReference", "jetbrains.mps.lang.typesystem.structure.InequationReplacementRule", "jetbrains.mps.lang.typesystem.structure.InferenceRule", "jetbrains.mps.lang.typesystem.structure.InfoStatement", "jetbrains.mps.lang.typesystem.structure.InfoStatementAnnotation", "jetbrains.mps.lang.typesystem.structure.IsReplacementRuleApplicable_ConceptFunction", "jetbrains.mps.lang.typesystem.structure.IsStrongSubtypeExpression", "jetbrains.mps.lang.typesystem.structure.IsSubtypeExpression", "jetbrains.mps.lang.typesystem.structure.JoinContainer", "jetbrains.mps.lang.typesystem.structure.JoinType", "jetbrains.mps.lang.typesystem.structure.LeftOperandType_parameter", "jetbrains.mps.lang.typesystem.structure.LinkPatternVariableReference", "jetbrains.mps.lang.typesystem.structure.ListVarDeclaration", "jetbrains.mps.lang.typesystem.structure.MatchStatement", "jetbrains.mps.lang.typesystem.structure.MatchStatementItem", "jetbrains.mps.lang.typesystem.structure.MeetContainer", "jetbrains.mps.lang.typesystem.structure.MeetType", "jetbrains.mps.lang.typesystem.structure.MessageStatement", "jetbrains.mps.lang.typesystem.structure.MessageStatementAnnotation", "jetbrains.mps.lang.typesystem.structure.MessageTarget", "jetbrains.mps.lang.typesystem.structure.MultipleForeachLoop", "jetbrains.mps.lang.typesystem.structure.MultipleForeachLoopVariable", "jetbrains.mps.lang.typesystem.structure.NodeInfo", "jetbrains.mps.lang.typesystem.structure.Node_InferTypeOperation", "jetbrains.mps.lang.typesystem.structure.Node_TypeOperation", "jetbrains.mps.lang.typesystem.structure.NonTypesystemRule", "jetbrains.mps.lang.typesystem.structure.NormalTypeClause", "jetbrains.mps.lang.typesystem.structure.OperationContextExpression", "jetbrains.mps.lang.typesystem.structure.Operation_parameter", "jetbrains.mps.lang.typesystem.structure.OrStatement", "jetbrains.mps.lang.typesystem.structure.OriginalNodeId", "jetbrains.mps.lang.typesystem.structure.OverloadedOpIsApplicableFunction", "jetbrains.mps.lang.typesystem.structure.OverloadedOpRulesContainer", "jetbrains.mps.lang.typesystem.structure.OverloadedOpTypeRule_OneTypeSpecified", "jetbrains.mps.lang.typesystem.structure.OverloadedOperatorTypeFunction", "jetbrains.mps.lang.typesystem.structure.OverloadedOperatorTypeRule", "jetbrains.mps.lang.typesystem.structure.PatternCondition", "jetbrains.mps.lang.typesystem.structure.PatternVariableReference", "jetbrains.mps.lang.typesystem.structure.PrintToTrace", "jetbrains.mps.lang.typesystem.structure.Processed", "jetbrains.mps.lang.typesystem.structure.PropertyMessageTarget", "jetbrains.mps.lang.typesystem.structure.PropertyNameTarget", "jetbrains.mps.lang.typesystem.structure.PropertyPatternVariableReference", "jetbrains.mps.lang.typesystem.structure.QuickFixArgument", "jetbrains.mps.lang.typesystem.structure.QuickFixArgumentReference", "jetbrains.mps.lang.typesystem.structure.QuickFixDescriptionBlock", "jetbrains.mps.lang.typesystem.structure.QuickFixExecuteBlock", "jetbrains.mps.lang.typesystem.structure.QuickFixField", "jetbrains.mps.lang.typesystem.structure.QuickFixFieldReference", "jetbrains.mps.lang.typesystem.structure.QuickFixSetSelectionBlock", "jetbrains.mps.lang.typesystem.structure.ReferenceMessageTarget", "jetbrains.mps.lang.typesystem.structure.ReferenceRoleTarget", "jetbrains.mps.lang.typesystem.structure.ReplacementRuleReference", "jetbrains.mps.lang.typesystem.structure.ReportErrorStatement", "jetbrains.mps.lang.typesystem.structure.ReportErrorStatementAnnotation", "jetbrains.mps.lang.typesystem.structure.RightOperandType_parameter", "jetbrains.mps.lang.typesystem.structure.RuntimeErrorType", "jetbrains.mps.lang.typesystem.structure.RuntimeHoleType", "jetbrains.mps.lang.typesystem.structure.RuntimeListVariable", "jetbrains.mps.lang.typesystem.structure.RuntimeTypeVariable", "jetbrains.mps.lang.typesystem.structure.SelectionType", "jetbrains.mps.lang.typesystem.structure.SubtypingRule", "jetbrains.mps.lang.typesystem.structure.TypeCheckerAccessExpression", "jetbrains.mps.lang.typesystem.structure.TypeClause", "jetbrains.mps.lang.typesystem.structure.TypeOfExpression", "jetbrains.mps.lang.typesystem.structure.TypeVarDeclaration", "jetbrains.mps.lang.typesystem.structure.TypeVarReference", "jetbrains.mps.lang.typesystem.structure.TypesystemIntention", "jetbrains.mps.lang.typesystem.structure.TypesystemIntentionArgument", "jetbrains.mps.lang.typesystem.structure.TypesystemQuickFix", "jetbrains.mps.lang.typesystem.structure.VariableConverterItem", "jetbrains.mps.lang.typesystem.structure.VariableConverterItem_ApplicableBlock", "jetbrains.mps.lang.typesystem.structure.VariableConverterItem_ConvertBlock", "jetbrains.mps.lang.typesystem.structure.VariableConvertersContainer", "jetbrains.mps.lang.typesystem.structure.WarningStatement", "jetbrains.mps.lang.typesystem.structure.WarningStatementAnnotation", "jetbrains.mps.lang.typesystem.structure.WasSelectedNodeOperation", "jetbrains.mps.lang.typesystem.structure.WhenConcreteStatement", "jetbrains.mps.lang.typesystem.structure.WhenConcreteVariableDeclaration", "jetbrains.mps.lang.typesystem.structure.WhenConcreteVariableReference"};
}
