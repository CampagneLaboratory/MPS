package jetbrains.mps.lang.migration.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.migration.behavior.MigrationScript_Behavior;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.Language;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.LanguageAspect;
import java.util.Arrays;

public class MigrationsCheckUtil {
  public static boolean hasCycles(SNode migrationScript) {
    List<SNode> step = ListSequence.fromListAndArray(new ArrayList<SNode>(), migrationScript);
    List<SNode> all = ListSequence.fromList(new ArrayList<SNode>());
    while (ListSequence.fromList(step).isNotEmpty()) {
      step = ListSequence.fromList(step).translate(new ITranslator2<SNode, SNode>() {
        public Iterable<SNode> translate(SNode it) {
          return allScriptdependencies(it);
        }
      }).distinct().toListSequence();
      if (ListSequence.fromList(all).intersect(ListSequence.fromList(step)).isNotEmpty()) {
        return true;
      }
      ListSequence.fromList(all).addSequence(ListSequence.fromList(step));
    }
    return false;
  }
  private static Iterable<SNode> allScriptdependencies(final SNode script) {
    Iterable<SNode> result = Sequence.fromIterable(MigrationScript_Behavior.call_getRequiredData_8585153554445862713(script)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x44b28148e401c891L, 0x4f6b4ac0cd6d4af5L, "script")) != null);
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x44b28148e401c891L, 0x4f6b4ac0cd6d4af5L, "script"));
      }
    }).concat(Sequence.fromIterable(MigrationScript_Behavior.call_getExecuteAfter_2521103492728978905(script)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x398343344f099b7aL, 0x398343344f099b7bL, "script")) != null);
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x398343344f099b7aL, 0x398343344f099b7bL, "script"));
      }
    }));
    return result = Sequence.fromIterable(result).concat(ListSequence.fromList(SModelOperations.roots(SNodeOperations.getModel(script), MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, "jetbrains.mps.lang.migration.structure.MigrationScript"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SPropertyOperations.getInteger(it, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, 0x50c63f9f4a0dac17L, "fromVersion")) < SPropertyOperations.getInteger(script, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, 0x50c63f9f4a0dac17L, "fromVersion"));
      }
    }));
  }
  public static void checkLanguageVersionMatchesMigrations(SModule module, List<String> errors) {
    if (!(module instanceof Language)) {
      return;
    }
    SModel migModel = LanguageAspect.MIGRATION.get(((Language) module));
    if (migModel == null) {
      return;
    }
    if (!(migModel.isLoaded())) {
      return;
    }
    boolean hasIncompleteScript = false;
    List<Integer> scripts = new ArrayList<Integer>();
    for (SNode root : SModelOperations.roots(migModel, MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, "jetbrains.mps.lang.migration.structure.MigrationScript"))) {
      if (root.getProperty(MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, 0x50c63f9f4a0dac17L, "fromVersion")) == null) {
        hasIncompleteScript = true;
        continue;
      }
      scripts.add(SPropertyOperations.getInteger(root, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, 0x50c63f9f4a0dac17L, "fromVersion")));
    }
    if (scripts.isEmpty()) {
      return;
    }
    // check that script versions form exactly an interval [x..currentVersion] for some x 
    Integer[] scriptVersions = scripts.toArray(new Integer[scripts.size()]);
    Arrays.sort(scriptVersions);
    int currentVersion = ((Language) module).getLanguageVersion();
    for (int index = 1; index < scriptVersions.length; index++) {
      if (scriptVersions[index - 1].equals(scriptVersions[index])) {
        errors.add("Some scripts have the same 'from' version: " + scriptVersions[index - 1]);
      } else
      if (scriptVersions[index - 1] + 1 != scriptVersions[index]) {
        int noscriptVersion = scriptVersions[index - 1] + 1;
        errors.add("No script found for version " + noscriptVersion);
      }
    }
    if (scriptVersions[scriptVersions.length - 1] != currentVersion - 1 && !(hasIncompleteScript)) {
      errors.add("Can't find a migration script corresponding to current language version (" + currentVersion + ")");
    }
  }
}
