package jetbrains.mps.lang.migration.generator.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import java.util.List;
import jetbrains.mps.smodel.Language;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.LanguageAspect;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.SNodeUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Arrays;

public class MigartionsCheckUtil {
  public static void checkLanguageVersionMatchesMigrations(SModule module, List<String> errors) {
    if (!(module instanceof Language)) {
      return;
    }
    SModel migModel = LanguageAspect.MIGRATION.get(((Language) module));
    if (migModel == null) {
      return;
    }
    if (!(migModel.isLoaded())) {
      return;
    }
    boolean hasIncompleteScript = false;
    List<Integer> scripts = new ArrayList<Integer>();
    for (SNode root : migModel.getRootNodes()) {
      if (!(SNodeOperations.isInstanceOf(root, SNodeUtil.concept_AbstractMigrationScript))) {
        continue;
      }
      if (root.getProperty(SNodeUtil.property_AbstractMigrationScript_fromVersion) == null) {
        hasIncompleteScript = true;
        continue;
      }
      scripts.add(SPropertyOperations.getInteger(root, SNodeUtil.property_AbstractMigrationScript_fromVersion));
    }
    if (scripts.isEmpty()) {
      return;
    }
    // check that script versions form exactly an interval [x..currentVersion] for some x 
    Integer[] scriptVersions = scripts.toArray(new Integer[scripts.size()]);
    Arrays.sort(scriptVersions);
    int currentVersion = ((Language) module).getLanguageVersion();
    for (int index = 1; index < scriptVersions.length; index++) {
      if (scriptVersions[index - 1].equals(scriptVersions[index])) {
        errors.add("Some scripts have the same 'from' version: " + scriptVersions[index - 1]);
      } else
      if (scriptVersions[index - 1] + 1 != scriptVersions[index]) {
        int noscriptVersion = scriptVersions[index - 1] + 1;
        errors.add("No script found for version " + noscriptVersion);
      }
    }
    if (scriptVersions[scriptVersions.length - 1] != currentVersion - 1 && !(hasIncompleteScript)) {
      errors.add("Can't find a migration script corresponding to current language version (" + currentVersion + ")");
    }
  }
}
