/*
 * Copyright 2003-2013 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.lang.editor.figures.sandbox;

/*Generated by MPS */

import jetbrains.jetpad.projectional.view.GroupView;
import jetbrains.jetpad.projectional.view.RectView;
import jetbrains.jetpad.projectional.view.TextView;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.jetpad.projectional.diagram.base.GridDirection;
import jetbrains.jetpad.model.property.Property;
import jetbrains.jetpad.model.property.ValueProperty;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.mapper.Synchronizers;
import jetbrains.jetpad.geometry.Vector;
import jetbrains.jetpad.values.Color;
import jetbrains.jetpad.geometry.Rectangle;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.nodeEditor.cells.jetpad.BlockViewPortLayouter;
import java.util.Iterator;

public class MPSBlockView extends GroupView {
  private RectView myRectView;
  private TextView myTextView = new TextView();
  private final GroupView myInputs = new GroupView();
  private final GroupView myOutputs = new GroupView();
  private final Map<SNode, View> portToViewMap = MapSequence.fromMap(new HashMap<SNode, View>());
  private GridDirection myDir = GridDirection.RIGHT;
  private Property<Integer> myX = new ValueProperty<Integer>(0);
  private Property<Integer> myY = new ValueProperty<Integer>(0);
  private Property<String> myText = new ValueProperty<String>("");



  public MPSBlockView() {
    children().add(myInputs);
    children().add(myOutputs);
    createRectView();
    attach(this, myTextView);
    Mapper<MPSBlockView, MPSBlockView> mapper = new Mapper<MPSBlockView, MPSBlockView>(this, this) {


      @Override
      protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
        configuration.add(Synchronizers.forProperty(getSource().myX, new Runnable() {
          public void run() {
            getTarget().moveTo(new Vector(getTarget().myX.get(), getTarget().myY.get()));
          }
        }));
        configuration.add(Synchronizers.forProperty(getSource().myY, new Runnable() {
          public void run() {
            getTarget().moveTo(new Vector(getTarget().myX.get(), getTarget().myY.get()));
          }
        }));
        configuration.add(Synchronizers.forProperty(getSource().myText, getSource().myTextView.text()));
      }
    };
    mapper.attachRoot();
  }

  public void setText(String text) {
    myText.set(text);
  }

  public String getText() {
    return myText.get();
  }

  public GroupView getInputs() {
    return myInputs;
  }

  public GroupView getOutputs() {
    return myOutputs;
  }

  public int getX() {
    return myX.get();
  }

  public void setX(int x) {
    myX.set(x);
  }

  public int getY() {
    return myY.get();
  }

  public void setY(int y) {
    myY.set(y);
  }

  private void createRectView() {
    myRectView = new RectView();
    myRectView.background().set(Color.LIGHT_GRAY);
    myRectView.visible().set(true);
    myRectView.dimension().set(new Vector(75, 75));
    attach(this, myRectView);
  }

  public GroupView getInputView() {
    return myInputs;
  }

  public GroupView getOutputView() {
    return myOutputs;
  }

  public void addInputPort(View inputPortView, SNode port) {
    attach(myInputs, inputPortView);
    MapSequence.fromMap(portToViewMap).put(port, inputPortView);
  }

  public Property<Vector> dimension() {
    return myRectView.dimension();
  }

  private void attach(View parent, View inputPortView) {
    if (inputPortView.parent() != null) {
      inputPortView.parent().children().remove(inputPortView.parent().children().indexOf(inputPortView));
    }
    parent.children().add(inputPortView);
  }

  public void addOutputPort(View outputPortView, SNode port) {
    attach(myOutputs, outputPortView);
    MapSequence.fromMap(portToViewMap).put(port, outputPortView);
  }

  public View getViewByPort(SNode port) {
    return MapSequence.fromMap(portToViewMap).get(port);
  }

  @Override
  protected void doValidate(View.ValidationContext context) {
    super.doValidate(context);
    Rectangle labelRect = myTextView.bounds().get();
    myRectView.dimension().set(myRectView.dimension().get().max(labelRect.dimension));
    layoutPorts(myInputs.children(), myDir.opposite());
    layoutPorts(myOutputs.children(), myDir);
    super.doValidate(context);

  }

  private void layoutPorts(List<View> views, GridDirection dir) {
    List<Vector> viewDimensions = new ArrayList<Vector>(views.size());
    for (View v : views) {
      viewDimensions.add(v.bounds().get().dimension);
    }
    Rectangle bounds = new Rectangle(myRectView.bounds().get().origin, myRectView.dimension().get());
    List<Vector> viewOrigins = new BlockViewPortLayouter(bounds).layoutPorts(viewDimensions, dir);
    Iterator<Vector> originIter = viewOrigins.iterator();
    for (View v : views) {
      v.moveTo(originIter.next());
    }
  }



}
