package jetbrains.mps.lang.structure.refactorings;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import java.util.Map;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;

public class ConceptMoveUtil {
  public ConceptMoveUtil() {
  }
  public static List<SNode> getConceptsAspects(final List<SNode> concepts, SModel aspectModel) {
    return ListSequence.fromList(SModelOperations.roots(aspectModel, MetaAdapterFactory.getInterfaceConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x24614259e94f0c84L, "jetbrains.mps.lang.structure.structure.IConceptAspect"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        List<SNode> baseConcepts = BehaviorReflection.invokeVirtual((Class<List<SNode>>) ((Class) Object.class), it, "virtual_getBaseConceptCollection_5270353093116013036", new Object[]{});
        return ListSequence.fromList(baseConcepts).isNotEmpty() && ListSequence.fromList(concepts).containsSequence(ListSequence.fromList(baseConcepts));
      }
    }).toListSequence();
  }
  public static List<SNode> getConceptAspects(List<SNode> concepts, SModel aspectModel) {
    return getConceptsAspects(concepts, aspectModel);
  }
  public static Map<LanguageAspect, List<SNode>> getAspectNodes(Language language, List<SNode> nodes) {
    // map with aspects to roots solely attached to list of given nodes 
    Map<LanguageAspect, List<SNode>> aspectNodesMap = MapSequence.fromMap(new HashMap<LanguageAspect, List<SNode>>());
    for (LanguageAspect aspect : LanguageAspect.values()) {
      List<SNode> aspectNodes = ConceptMoveUtil.getConceptAspects(nodes, aspect.get(language));
      if (ListSequence.fromList(aspectNodes).isNotEmpty()) {
        MapSequence.fromMap(aspectNodesMap).put(aspect, aspectNodes);
      }
    }
    return aspectNodesMap;
  }
}
