package jetbrains.mps.lang.structure.editor;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.editor.runtime.cells.AbstractCellAction;
import jetbrains.mps.editor.runtime.cells.ReadOnlyUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import jetbrains.mps.openapi.editor.selection.SelectionManager;

public class ConceptDeclaration_Children {
  public static void setCellActions(EditorCell editorCell, SNode node, EditorContext context) {
    editorCell.setAction(CellActionType.DELETE, new ConceptDeclaration_Children.ConceptDeclaration_Children_DELETE(node));
    editorCell.setAction(CellActionType.BACKSPACE, new ConceptDeclaration_Children.ConceptDeclaration_Children_BACKSPACE(node));
  }

  public static class ConceptDeclaration_Children_DELETE extends AbstractCellAction {
    /*package*/ SNode myNode;

    public ConceptDeclaration_Children_DELETE(SNode node) {
      this.myNode = node;
    }

    public void execute(EditorContext editorContext) {
      this.execute_internal(editorContext, this.myNode);
    }

    public void execute_internal(EditorContext editorContext, final SNode node) {
      EditorCell nodeCell = editorContext.getEditorComponent().findNodeCell(node);
      if (nodeCell == null || ReadOnlyUtil.isCellOrSelectionReadOnlyInEditor(editorContext.getEditorComponent(), nodeCell)) {
        return;
      }

      SNode conceptDeclaration = SNodeOperations.cast(SNodeOperations.getParent(node), "jetbrains.mps.lang.structure.structure.ConceptDeclaration");

      final Wrappers._T<SNode> lastChild = new Wrappers._T<SNode>(null);
      final Wrappers._T<SNode> childToSelect = new Wrappers._T<SNode>(null);
      ListSequence.fromList(SLinkOperations.getTargets(conceptDeclaration, "linkDeclaration", true)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SPropertyOperations.hasValue(it, "metaClass", "aggregation", "reference");
        }
      }).foldLeft(false, new ILeftCombinator<SNode, Boolean>() {
        public Boolean combine(Boolean nodeVisited, SNode nextSibling) {
          if (nextSibling == node) {
            return true;
          }
          if (!(nodeVisited)) {
            lastChild.value = nextSibling;
          } else if (childToSelect.value == null) {
            childToSelect.value = nextSibling;
          }
          return nodeVisited;
        }
      });

      SNodeOperations.deleteNode(node);
      if (childToSelect.value != null) {
        SelectionUtil.selectLabelCellAnSetCaret(editorContext, childToSelect.value, SelectionManager.FIRST_CELL, 0);
      } else if (lastChild.value != null) {
        SelectionUtil.selectLabelCellAnSetCaret(editorContext, lastChild.value, SelectionManager.LAST_CELL, -1);
      } else {
        SelectionUtil.selectLabelCellAnSetCaret(editorContext, conceptDeclaration, "emptyChildrenPlaceHolder", 0);
      }
    }
  }

  public static class ConceptDeclaration_Children_BACKSPACE extends AbstractCellAction {
    /*package*/ SNode myNode;

    public ConceptDeclaration_Children_BACKSPACE(SNode node) {
      this.myNode = node;
    }

    public void execute(EditorContext editorContext) {
      this.execute_internal(editorContext, this.myNode);
    }

    public void execute_internal(EditorContext editorContext, final SNode node) {
      EditorCell nodeCell = editorContext.getEditorComponent().findNodeCell(node);
      if (nodeCell == null || ReadOnlyUtil.isCellOrSelectionReadOnlyInEditor(editorContext.getEditorComponent(), nodeCell)) {
        return;
      }

      SNode conceptDeclaration = SNodeOperations.cast(SNodeOperations.getParent(node), "jetbrains.mps.lang.structure.structure.ConceptDeclaration");

      final Wrappers._T<SNode> childReference = new Wrappers._T<SNode>(null);
      final Wrappers._T<SNode> childToSelect = new Wrappers._T<SNode>(null);
      ListSequence.fromList(SLinkOperations.getTargets(conceptDeclaration, "linkDeclaration", true)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SPropertyOperations.hasValue(it, "metaClass", "aggregation", "reference");
        }
      }).foldLeft(false, new ILeftCombinator<SNode, Boolean>() {
        public Boolean combine(Boolean nodeVisited, SNode nextSibling) {
          if (nextSibling == node) {
            return true;
          }
          if (!(nodeVisited)) {
            childToSelect.value = nextSibling;
          } else if (childReference.value == null) {
            childReference.value = nextSibling;
          }
          return nodeVisited;
        }
      });

      SNodeOperations.deleteNode(node);
      if (childToSelect.value != null) {
        SelectionUtil.selectLabelCellAnSetCaret(editorContext, childToSelect.value, SelectionManager.LAST_CELL, -1);
      } else if (childReference.value != null) {
        SelectionUtil.selectLabelCellAnSetCaret(editorContext, childReference.value, SelectionManager.FIRST_CELL, 0);
      } else {
        SelectionUtil.selectLabelCellAnSetCaret(editorContext, conceptDeclaration, "emptyChildrenPlaceHolder", 0);
      }
    }
  }
}
