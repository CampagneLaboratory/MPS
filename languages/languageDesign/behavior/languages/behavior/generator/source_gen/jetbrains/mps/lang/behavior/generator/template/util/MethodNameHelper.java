package jetbrains.mps.lang.behavior.generator.template.util;

/*Generated by MPS */

import jetbrains.mps.core.aspects.behaviour.SMethodImpl;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.annotations.NotNull;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.apache.log4j.Level;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

/**
 * TODO need to be moved to the behavior of the ConceptBehavior after MPS project rebuilt
 */
public final class MethodNameHelper {
  private static final int MODULE = SMethodImpl.MODULE_FOR_TRIMMING_ID;
  private final SNode myBehavior;
  private final Map<SNodeId, Integer> myMethodToId;

  public MethodNameHelper(@NotNull SNode behavior) {
    myBehavior = behavior;
    myMethodToId = init();
  }

  private Map<SNodeId, Integer> init() {
    final Map<SNodeId, Integer> methodToId = new HashMap<SNodeId, Integer>();

    final Map<Integer, SNodeId> idToMethod = new HashMap<Integer, SNodeId>();

    for (SNode behavior : ListSequence.fromList(BehaviorReflection.invokeNonVirtual((Class<List<SNode>>) ((Class) Object.class), myBehavior, "jetbrains.mps.lang.behavior.structure.ConceptBehavior", "call_getAllSuperBehaviors_1818770337282950280", new Object[]{}))) {
      for (SNode method : ListSequence.fromList(SLinkOperations.getChildren(behavior, MetaAdapterFactory.getContainmentLink(0xaf65afd8f0dd4942L, 0x87d963a55f2a9db1L, 0x11d43447b1aL, 0x11d43447b25L, "method")))) {
        int methodGeneratedId = getTrimmedId(method.getNodeId());
        while (methodToId.containsValue(methodGeneratedId)) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("The methods " + method + " and " + idToMethod.get(methodGeneratedId) + " are colliding");
          }
          methodGeneratedId = (methodGeneratedId + 1) % MODULE;
        }
        methodToId.put(method.getNodeId(), methodGeneratedId);
        idToMethod.put(methodGeneratedId, method.getNodeId());
      }
    }
    return methodToId;
  }

  @NotNull
  public String getGeneratedName(@NotNull SNode methodDecl) {
    SNode baseMethod = methodDecl;
    if (BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), methodDecl, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration", "call_getBaseMethod_5014346297260519893", new Object[]{}) != null) {
      baseMethod = BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), methodDecl, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration", "call_getBaseMethod_5014346297260519893", new Object[]{});
    }

    Integer id = myMethodToId.get(baseMethod.getNodeId());
    if (id == null) {
      throw new IllegalArgumentException("The method cannot found " + methodDecl);
    }
    return SPropertyOperations.getString(baseMethod, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")) + "_id" + id;
  }

  private int getTrimmedId(SNodeId id) {
    int res = id.hashCode() % MODULE;
    if (res < 0) {
      res += MODULE;
    }
    assert res > 0;
    return res;
  }
  protected static Logger LOG = LogManager.getLogger(MethodNameHelper.class);
}
