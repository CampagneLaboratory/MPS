package jetbrains.mps.lang.core.plugin;

/*Generated by MPS */

import jetbrains.mps.generator.textGen.TextGeneratorEngine;
import jetbrains.mps.smodel.resources.GResource;
import jetbrains.mps.smodel.ModelAccess;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Collections;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.textGen.TextGenerationResult;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;
import jetbrains.mps.vfs.FileSystem;

public class TextGenUtil {
  private TextGenUtil() {
  }

  public static void generateText(TextGeneratorEngine engine, Iterable<GResource> inputResources, final TextGenUtil.TextGenerationCallback callback) {
    ModelAccess.assertLegalRead();

    // out map and hashmap doesn't have asSynchronized method 
    final Map<SModel, GResource> modelToInput = Collections.synchronizedMap(new HashMap<SModel, GResource>());

    for (GResource inputResource : Sequence.fromIterable(inputResources)) {
      SModel outputModel = inputResource.status().getOutputModel();
      if (outputModel != null) {
        modelToInput.put(outputModel, inputResource);
      } else {
        callback.textGenerated(inputResource, Collections.<TextGenerationResult>emptyList());
      }
    }

    engine.generateModels(modelToInput.keySet(), new TextGeneratorEngine.GenerateCallback() {
      @Override
      public void modelGenerated(SModel model, List<TextGenerationResult> results) {
        GResource generatedResource = modelToInput.get(model);
        callback.textGenerated(generatedResource, results);
      }
    });
  }

  public static boolean runWriteTransaction(final Runnable runnable, AtomicLong mutableOverheadStatistic) {
    long outerStartTime = System.currentTimeMillis();
    final AtomicLong innerTime = new AtomicLong(0);
    boolean result = FileSystem.getInstance().runWriteTransaction(new Runnable() {
      @Override
      public void run() {
        long innerStartTime = System.currentTimeMillis();
        runnable.run();
        innerTime.set(System.currentTimeMillis() - innerStartTime);
      }
    });
    long outerTime = System.currentTimeMillis() - outerStartTime;
    mutableOverheadStatistic.addAndGet(outerTime - innerTime.get());
    return result;
  }

  public static long withTimeTracking(Runnable runnable) {
    long startTime = System.currentTimeMillis();
    runnable.run();
    return System.currentTimeMillis() - startTime;
  }

  public static interface TextGenerationCallback {
    public void textGenerated(GResource inputResource, List<TextGenerationResult> results);
  }
}
