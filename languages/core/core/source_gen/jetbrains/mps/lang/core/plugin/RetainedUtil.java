package jetbrains.mps.lang.core.plugin;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.project.IModule;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.resources.MResource;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.internal.collections.runtime.ISequenceClosure;
import jetbrains.mps.make.delta.IDelta;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.make.runtime.util.FilesDelta;
import jetbrains.mps.project.SModuleOperations;
import jetbrains.mps.generator.fileGenerator.FileGenerationUtil;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class RetainedUtil {
  public RetainedUtil() {
  }

  public static Map<IModule, Iterable<SModel>> collectModelsToRetain(Iterable<? extends IResource> input) {
    final Map<IModule, Iterable<SModel>> retainedModels = MapSequence.fromMap(new HashMap<IModule, Iterable<SModel>>());
    Iterable<SModel> empty = ListSequence.fromList(new ArrayList<SModel>());
    for (IResource it : input) {
      MResource mres = ((MResource) it);
      IModule module = mres.module();
      MapSequence.fromMap(retainedModels).put(module, empty);
      Iterable<SModel> modelsToRetain = Sequence.fromIterable(((Iterable<SModel>) module.getModels())).where(new IWhereFilter<SModel>() {
        public boolean accept(SModel it2) {
          return SNodeOperations.isGeneratable(it2);
        }
      });
      if (module instanceof Language) {
        for (final Generator gen : ((Language) module).getGenerators()) {
          if (!(MapSequence.fromMap(retainedModels).containsKey(gen))) {
            MapSequence.fromMap(retainedModels).put(gen, Sequence.fromIterable(((Iterable<SModel>) gen.getModels())).where(new IWhereFilter<SModel>() {
              public boolean accept(SModel it2) {
                return SNodeOperations.isGeneratable(it2);
              }
            }));
          }
          modelsToRetain = Sequence.fromIterable(modelsToRetain).concat(Sequence.fromIterable(Sequence.fromClosure(new ISequenceClosure<SModel>() {
            public Iterable<SModel> iterable() {
              return MapSequence.fromMap(retainedModels).get(gen);
            }
          })));
        }
      } else if (module instanceof Generator) {
        final Language slang = ((Generator) module).getSourceLanguage();
        if (!(MapSequence.fromMap(retainedModels).containsKey(slang))) {
          MapSequence.fromMap(retainedModels).put(slang, Sequence.fromIterable(((Iterable<SModel>) slang.getModels())).subtract(Sequence.fromIterable(module.getModels())).where(new IWhereFilter<SModel>() {
            public boolean accept(SModel it3) {
              return SNodeOperations.isGeneratable(it3);
            }
          }));
        }
        for (final Generator gen : slang.getGenerators()) {
          if (gen == module) {
            continue;
          }
          if (!(MapSequence.fromMap(retainedModels).containsKey(gen))) {
            MapSequence.fromMap(retainedModels).put(gen, Sequence.fromIterable(((Iterable<SModel>) gen.getModels())).where(new IWhereFilter<SModel>() {
              public boolean accept(SModel it2) {
                return SNodeOperations.isGeneratable(it2);
              }
            }));
          }
          modelsToRetain = Sequence.fromIterable(modelsToRetain).concat(Sequence.fromIterable(Sequence.fromClosure(new ISequenceClosure<SModel>() {
            public Iterable<SModel> iterable() {
              return MapSequence.fromMap(retainedModels).get(gen);
            }
          })));
        }
        modelsToRetain = Sequence.fromIterable(modelsToRetain).concat(Sequence.fromIterable(Sequence.fromClosure(new ISequenceClosure<SModel>() {
          public Iterable<SModel> iterable() {
            return MapSequence.fromMap(retainedModels).get(slang);
          }
        })));
      }
      MapSequence.fromMap(retainedModels).put(mres.module(), Sequence.fromIterable(modelsToRetain).subtract(Sequence.fromIterable(mres.models())).toListSequence());
    }
    return retainedModels;
  }

  public static Iterable<IDelta> retainedFilesDelta(Iterable<SModel> smd, IModule mod, _FunctionTypes._return_P1_E0<? extends IFile, ? super String> getFile) {
    return new RetainedUtil.RetainedFilesDelta(mod, getFile).deltas(smd);
  }

  public static Iterable<IDelta> retainedCachesDelta(Iterable<SModel> smd, IModule mod, _FunctionTypes._return_P1_E0<? extends IFile, ? super String> getFile) {
    return new RetainedUtil.RetainedCachesDelta(mod, getFile).deltas(smd);
  }

  /*package*/ static class RetainedFilesDelta {
    private IModule module;
    protected Map<String, FilesDelta> dir2delta = MapSequence.fromMap(new HashMap<String, FilesDelta>());
    protected _FunctionTypes._return_P1_E0<? extends IFile, ? super String> getFile;

    public RetainedFilesDelta(IModule module, _FunctionTypes._return_P1_E0<? extends IFile, ? super String> getFile) {
      this.module = module;
      this.getFile = getFile;
    }

    public Iterable<IDelta> deltas(Iterable<SModel> smds) {
      for (SModel smd : smds) {
        String output = SModuleOperations.getOutputPathFor(smd);
        if (output != null) {
          deltaForDir(output).kept(FileGenerationUtil.getDefaultOutputDir(smd, this.getRootOutputDir(output)));
        }
      }
      return this.collectedDeltas();
    }

    protected IFile getRootOutputDir(String output) {
      return getFile.invoke(output);
    }

    private Iterable<IDelta> collectedDeltas() {
      return Sequence.fromIterable(MapSequence.fromMap(dir2delta).values()).select(new ISelector<FilesDelta, IDelta>() {
        public IDelta select(FilesDelta it) {
          return (IDelta) it;
        }
      });
    }

    protected FilesDelta deltaForDir(String dir) {
      if (!(MapSequence.fromMap(dir2delta).containsKey(dir))) {
        MapSequence.fromMap(dir2delta).put(dir, new FilesDelta(this.getRootOutputDir(dir)));
      }
      return MapSequence.fromMap(dir2delta).get(dir);
    }
  }

  /*package*/ static class RetainedCachesDelta extends RetainedUtil.RetainedFilesDelta {
    public RetainedCachesDelta(IModule mod, _FunctionTypes._return_P1_E0<? extends IFile, ? super String> getFile) {
      super(mod, getFile);
    }

    @Override
    protected IFile getRootOutputDir(String output) {
      return getFile.invoke(FileGenerationUtil.getCachesPath(output));
    }
  }
}
