package jetbrains.mps.ide.java.psiStubs;

/*Generated by MPS */

import jetbrains.mps.extapi.persistence.ModelRootBase;
import jetbrains.mps.idea.core.psi.PsiListener;
import jetbrains.mps.logging.Logger;
import com.intellij.openapi.module.Module;
import java.util.Map;
import com.intellij.psi.PsiDirectory;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SModelId;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.roots.ModuleRootManager;
import com.intellij.psi.PsiManager;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.intellij.psi.PsiJavaFile;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.smodel.SModelReference;
import org.jetbrains.mps.openapi.persistence.Memento;
import jetbrains.mps.idea.core.psi.PsiChangesWatcher;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiMethod;
import com.intellij.psi.PsiField;
import com.intellij.psi.PsiParameterList;
import com.intellij.psi.PsiParameter;
import com.intellij.psi.PsiReferenceList;
import com.intellij.psi.PsiModifierList;
import com.intellij.psi.PsiModifier;
import com.intellij.psi.PsiTypeParameterList;
import com.intellij.psi.PsiTypeParameter;
import com.intellij.psi.PsiCodeBlock;
import com.intellij.psi.PsiExpression;
import com.intellij.psi.PsiWhiteSpace;
import com.intellij.psi.PsiFile;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class PsiJavaStubModelRoot extends ModelRootBase implements PsiListener {
  private static Logger LOG = Logger.getLogger(PsiJavaStubModelRoot.class);
  private static final String TYPE = "JavaPsiStubs";

  private Module myModule;
  private Map<PsiDirectory, PsiJavaStubDataSource> myDataSources = MapSequence.fromMap(new HashMap<PsiDirectory, PsiJavaStubDataSource>());
  private List<SModel> myModels = ListSequence.fromList(new ArrayList<SModel>());

  public PsiJavaStubModelRoot(Module module) {
    myModule = module;
  }

  @Override
  public String getType() {
    return TYPE;
  }

  @Override
  public String getPresentation() {
    // <node> 
    return "java PSI stubs";
  }

  @Override
  public SModel getModel(SModelId id) {
    //  not clear if it's needed here 
    return null;
  }

  @Override
  public Iterable<SModel> getModels() {
    setUp(myModule);

    final VirtualFile[] sourceRoots = ModuleRootManager.getInstance(myModule).getSourceRoots(false);
    PsiManager psiMgr = PsiManager.getInstance(myModule.getProject());

    for (VirtualFile root : sourceRoots) {
      PsiDirectory dir = psiMgr.findDirectory(root);
      int skipPrefix = dir.toString().length();
      addModelsForDir(skipPrefix, dir);
    }

    return myModels;
  }

  private void addModelsForDir(int skipPrefix, PsiDirectory dir) {
    if (Sequence.fromIterable(Sequence.fromArray(dir.getFiles())).ofType(PsiJavaFile.class).isNotEmpty()) {
      PsiJavaStubDataSource ds = new PsiJavaStubDataSource(myModule, dir);
      String relativeDirName = dir.toString().substring(skipPrefix);

      // FIXME check different separators 
      String packageName = relativeDirName.replace('/', '.');
      if (packageName.length() > 0 && packageName.charAt(0) == '.') {
        packageName = packageName.substring(1);
      }
      if (packageName.length() == 0) {
        packageName = "<default package>";
      }

      SModelFqName fqName = new SModelFqName(packageName, "java_stub_zzz");
      jetbrains.mps.smodel.SModelId modelId = jetbrains.mps.smodel.SModelId.foreign(fqName.getStereotype(), getModule().getModuleId().toString(), fqName.getLongName());
      SModelReference modelRef = new SModelReference(fqName, modelId);

      PsiJavaStubModelDescriptor model = new PsiJavaStubModelDescriptor(modelRef, ds);

      MapSequence.fromMap(myDataSources).put(dir, ds);
      ListSequence.fromList(myModels).addElement(model);
    }

    for (PsiDirectory subDir : dir.getSubdirectories()) {
      addModelsForDir(skipPrefix, subDir);
    }
  }

  @Override
  public boolean isReadOnly() {
    return true;
  }

  @Override
  public boolean canCreateModel(String modelName) {
    return false;
  }

  @Override
  public SModel createModel(String modelName) {
    return null;
  }

  @Override
  public void save(Memento memento) {
    throw new UnsupportedOperationException("JavaPsiStubs: unsupported for now");
  }

  @Override
  public void load(Memento memento) {
    throw new UnsupportedOperationException("JavaPsiStubs: unsupported for now");
  }

  private void setUp(Module module) {
    //  start to listen 
    PsiChangesWatcher w = myModule.getProject().getComponent(PsiChangesWatcher.class);
    w.addListener(this);

  }

  private boolean interesting(PsiElement elem) {
    if (elem instanceof PsiJavaFile || elem instanceof PsiClass || elem instanceof PsiMethod || elem instanceof PsiField || elem instanceof PsiParameterList || elem instanceof PsiParameter || elem instanceof PsiReferenceList || elem instanceof PsiModifierList || elem instanceof PsiModifier || elem instanceof PsiTypeParameterList || elem instanceof PsiTypeParameter) {
      //  but not PsiReference ! 
      return true;
    }
    return false;
  }

  private boolean notInteresting(PsiElement elem) {
    return elem instanceof PsiCodeBlock || elem instanceof PsiExpression;
  }

  private boolean filter(PsiElement elem) {
    if (elem == null || elem instanceof PsiWhiteSpace) {
      return false;
    }
    PsiElement e = elem;
    do {
      if (interesting(e)) {
        return true;
      }
      if (notInteresting(e)) {
        return false;
      }
      e = e.getParent();
    } while (e != null);
    return false;
  }

  @Override
  public void psiChanged(PsiListener.PsiEvent event) {

    // For each data source (isomorphic to model,package) make an event that contains 
    // only files under its PsiDirectory 
    // Filter it so that only java stub related things are left: non java files are ignored, 
    // stuff inside method bodies is ignored 

    Map<PsiJavaStubDataSource, PsiJavaStubModelRoot.PsiChange> changes = MapSequence.fromMap(new HashMap<PsiJavaStubDataSource, PsiJavaStubModelRoot.PsiChange>());

    for (PsiFile file : Sequence.fromIterable(event.getCreated())) {
      if (!(file instanceof PsiJavaFile)) {
        continue;
      }
      PsiDirectory parent = file.getParent();
      PsiJavaStubDataSource dataSource = MapSequence.fromMap(myDataSources).get(parent);
      if (dataSource == null) {
        continue;
      }

      PsiJavaStubModelRoot.PsiChange change = MapSequence.fromMap(changes).get(dataSource);
      if (change == null) {
        change = new PsiJavaStubModelRoot.PsiChange();
        MapSequence.fromMap(changes).put(dataSource, change);
      }
      SetSequence.fromSet(change.created).addElement(file);
    }

    for (PsiFile file : Sequence.fromIterable(event.getRemoved())) {
      if (!(file instanceof PsiJavaFile)) {
        continue;
      }
      PsiDirectory parent = file.getParent();
      PsiJavaStubDataSource dataSource = MapSequence.fromMap(myDataSources).get(parent);
      if (dataSource == null) {
        continue;
      }

      PsiJavaStubModelRoot.PsiChange change = MapSequence.fromMap(changes).get(dataSource);
      if (change == null) {
        change = new PsiJavaStubModelRoot.PsiChange();
        MapSequence.fromMap(changes).put(dataSource, change);
      }
      SetSequence.fromSet(change.removed).addElement(file);
    }

    for (PsiFile file : SetSequence.fromSet(event.getChanged().keySet())) {
      if (!(file instanceof PsiJavaFile)) {
        continue;
      }
      PsiDirectory parent = file.getParent();
      PsiJavaStubDataSource dataSource = MapSequence.fromMap(myDataSources).get(parent);
      if (dataSource == null) {
        continue;
      }

      Set<PsiElement> changeSet = SetSequence.fromSet(new HashSet<PsiElement>());
      for (PsiElement elem : SetSequence.fromSet(event.getChanged().get(file))) {
        if (!(filter(elem))) {
          continue;
        }
        SetSequence.fromSet(changeSet).addElement(elem);
      }

      PsiJavaStubModelRoot.PsiChange change = MapSequence.fromMap(changes).get(dataSource);
      if (change == null) {
        change = new PsiJavaStubModelRoot.PsiChange();
        MapSequence.fromMap(changes).put(dataSource, change);
      }
      MapSequence.fromMap(change.changed).put(file, changeSet);
    }

    // notify data sources 
    for (IMapping<PsiJavaStubDataSource, PsiJavaStubModelRoot.PsiChange> notification : SetSequence.fromSet(MapSequence.fromMap(changes).mappingsSet())) {
      PsiJavaStubDataSource ds = notification.key();
      PsiJavaStubModelRoot.PsiChange change = notification.value();
      if (!(change.isEmpty())) {
        ds.dispatchEvent(change);
      }
    }
  }

  private static class PsiChange implements PsiListener.PsiEvent {
    private Set<PsiFile> created = SetSequence.fromSet(new HashSet<PsiFile>());
    private Set<PsiFile> removed = SetSequence.fromSet(new HashSet<PsiFile>());
    private Map<PsiFile, Set<PsiElement>> changed = MapSequence.fromMap(new HashMap<PsiFile, Set<PsiElement>>());

    public PsiChange() {
    }

    public boolean isEmpty() {
      return SetSequence.fromSet(created).isEmpty() && SetSequence.fromSet(removed).isEmpty() && MapSequence.fromMap(changed).all(new IWhereFilter<IMapping<PsiFile, Set<PsiElement>>>() {
        public boolean accept(IMapping<PsiFile, Set<PsiElement>> it) {
          return SetSequence.fromSet(it.value()).isEmpty();
        }
      });
    }

    public Iterable<PsiFile> getCreated() {
      return created;
    }

    public Iterable<PsiFile> getRemoved() {
      return removed;
    }

    public Map<PsiFile, Set<PsiElement>> getChanged() {
      return changed;
    }
  }
}
