package jetbrains.mps.ide.java.psiStubs;

/*Generated by MPS */

import com.intellij.openapi.components.ProjectComponent;
import com.intellij.openapi.project.Project;
import com.intellij.psi.PsiManager;
import com.intellij.psi.PsiTreeChangeListener;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import com.intellij.psi.PsiDocumentManager;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import com.intellij.psi.PsiTreeChangeAdapter;
import java.util.Timer;
import java.util.Map;
import com.intellij.psi.PsiFile;
import java.util.TimerTask;
import java.util.WeakHashMap;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiMethod;
import com.intellij.psi.PsiField;
import com.intellij.psi.PsiParameterList;
import com.intellij.psi.PsiParameter;
import com.intellij.psi.PsiReferenceList;
import com.intellij.psi.PsiModifierList;
import com.intellij.psi.PsiModifier;
import com.intellij.psi.PsiTypeParameterList;
import com.intellij.psi.PsiTypeParameter;
import com.intellij.psi.PsiCodeBlock;
import com.intellij.psi.PsiExpression;
import com.intellij.psi.PsiWhiteSpace;
import com.intellij.psi.PsiTreeChangeEvent;
import com.intellij.psi.PsiJavaFile;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;

/**
 * Currently it's specific to Java stubs. That is, it skips PSI event that don't affect stub structure,
 * like changes in method bodies, etc.
 * Maybe it's worthwhile to do it generic in the future.
 */
public class JavaPsiMergeChangesWatcher implements ProjectComponent {
  private Project myProject;
  private PsiManager myPsiManager;
  private PsiTreeChangeListener myOwnListener;
  private Set<JavaPsiMergeListener> myPsiListeners;

  public JavaPsiMergeChangesWatcher() {
  }

  /*package*/ JavaPsiMergeChangesWatcher(Project p) {
    myProject = p;
  }

  public void addListener(JavaPsiMergeListener listener) {
    SetSequence.fromSet(myPsiListeners).addElement(listener);
  }

  public void removeListener(JavaPsiMergeListener listener) {
    SetSequence.fromSet(myPsiListeners).removeElement(listener);
  }

  @Override
  public void initComponent() {
    myPsiManager = PsiManager.getInstance(myProject);
    myOwnListener = new JavaPsiMergeChangesWatcher.JavaStubPsiListener(PsiDocumentManager.getInstance(myProject));
    myPsiListeners = SetSequence.fromSet(new HashSet<JavaPsiMergeListener>());
  }

  @Override
  public void disposeComponent() {
  }

  @NotNull
  @Override
  public String getComponentName() {
    return "PsiChangedWatcher";
  }

  @Override
  public void projectOpened() {
    myPsiManager.addPsiTreeChangeListener(myOwnListener);
  }

  @Override
  public void projectClosed() {
    myPsiManager.removePsiTreeChangeListener(myOwnListener);
  }

  public class JavaStubPsiListener extends PsiTreeChangeAdapter {
    private final long DELAY = 300;
    private PsiDocumentManager myPsiDocumentManager;
    private Timer myTimer = new Timer(true);
    private Map<PsiFile, TimerTask> myFileTasks = new WeakHashMap<PsiFile, TimerTask>();

    public JavaStubPsiListener(PsiDocumentManager psiDocMgr) {
      myPsiDocumentManager = psiDocMgr;
    }

    private boolean interesting(PsiElement elem) {
      if (elem instanceof PsiClass || elem instanceof PsiMethod || elem instanceof PsiField || elem instanceof PsiParameterList || elem instanceof PsiParameter || elem instanceof PsiReferenceList || elem instanceof PsiModifierList || elem instanceof PsiModifier || elem instanceof PsiTypeParameterList || elem instanceof PsiTypeParameter) {
        //  but not PsiReference ! 
        return true;
      }
      return false;
    }

    private boolean notInteresting(PsiElement elem) {
      return elem instanceof PsiFile || elem instanceof PsiCodeBlock || elem instanceof PsiExpression;
    }

    private boolean filter(PsiElement elem) {
      if (elem == null || elem instanceof PsiWhiteSpace) {
        return false;
      }
      PsiElement e = elem;
      do {
        if (interesting(e)) {
          return true;
        }
        if (notInteresting(e)) {
          return false;
        }
        e = e.getParent();
      } while (e != null);
      return false;
    }

    private void handle(PsiTreeChangeEvent e) {
      PsiFile psiFile = e.getFile();
      synchronized (myFileTasks) {
        TimerTask task = myFileTasks.get(psiFile);
        if (task != null) {
          task.cancel();
        }
        task = new JavaPsiMergeChangesWatcher.JavaStubPsiListener.DocTimerTask(psiFile);
        myFileTasks.put(psiFile, task);
        myTimer.schedule(task, DELAY);
      }
    }

    @Override
    public void childAdded(PsiTreeChangeEvent e) {
      if (filter(e.getChild())) {
        handle(e);
      }
      if (e.getChild() instanceof PsiJavaFile) {
        //       System.out.println("NEW ClASS DEBUG **** " + e.getChild().toString() + " " + e.getParent().toString()); 
        //  a file has been added 
        //       myDelegate.childAdded(e); 
      }
    }

    @Override
    public void childReplaced(PsiTreeChangeEvent e) {
      if (filter(e.getNewChild())) {
        handle(e);
      }
      //     System.out.println("CAUGHT PSI: " + e.getFile().getName()); 
      //  TODO currently only a dumb stub 
      //  will do filtering of psi events 
      //     myDelegate.childReplaced(e); 
    }

    @Override
    public void childRemoved(PsiTreeChangeEvent e) {
      if (filter(e.getChild())) {
        handle(e);
      }
    }

    private class DocTimerTask extends TimerTask implements JavaPsiMergeListener.JavaPsiMergeEvent {
      /*package*/ PsiFile myPsiFile;
      /*package*/ Set<PsiFile> myPsiFiles;
      private JavaPsiMergeChangesWatcher.JavaStubPsiListener.DocTimerTask _this = this;

      /*package*/ DocTimerTask(PsiFile f) {
        // <node> 
        myPsiFiles = SetSequence.fromSet(new HashSet<PsiFile>());
        SetSequence.fromSet(myPsiFiles).addElement(f);
      }

      @Override
      public void run() {
        synchronized (myFileTasks) {
          ThreadUtils.runInUIThreadNoWait(new Runnable() {
            @Override
            public void run() {
              ModelAccess.instance().runWriteAction(new Runnable() {
                public void run() {
                  for (JavaPsiMergeListener l : SetSequence.fromSet(myPsiListeners)) {
                    l.psiChanged(_this);
                  }
                }
              });
            }
          });
          myFileTasks.remove(myPsiFile);
        }
      }

      public Iterable<PsiJavaFile> getCreated() {
        return Sequence.fromArray(new PsiJavaFile[0]);
      }

      public Iterable<PsiJavaFile> getRemoved() {
        return Sequence.fromArray(new PsiJavaFile[0]);
      }

      public Iterable<PsiJavaFile> getChanged() {
        return (Iterable) myPsiFiles;
      }
    }
  }
}
