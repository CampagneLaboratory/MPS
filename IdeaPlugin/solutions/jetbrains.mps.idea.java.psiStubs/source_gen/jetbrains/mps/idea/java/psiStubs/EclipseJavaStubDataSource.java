package jetbrains.mps.idea.java.psiStubs;

/*Generated by MPS */

import jetbrains.mps.ide.java.sourceStubs.MPSJavaSrcDataSource;
import java.util.Set;
import org.jetbrains.mps.openapi.persistence.MultiStreamDataSourceListener;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.module.Module;
import jetbrains.mps.project.MPSProject;
import com.intellij.openapi.vfs.VirtualFileManager;
import com.intellij.openapi.fileEditor.FileDocumentManager;
import org.jetbrains.mps.openapi.persistence.DataSource;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.vfs.IFile;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.idea.core.project.PluginModelRootUtil;
import org.jetbrains.mps.openapi.persistence.DataSourceListener;
import jetbrains.mps.idea.core.psi.PsiChangesWatcher;
import java.io.InputStream;
import java.io.IOException;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import com.intellij.openapi.editor.Document;
import java.io.ByteArrayInputStream;
import jetbrains.mps.idea.core.psi.PsiListener;
import com.intellij.psi.PsiFileSystemItem;
import com.intellij.psi.PsiFile;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class EclipseJavaStubDataSource extends MPSJavaSrcDataSource {

  private final Object LOCK = new Object();
  private Set<MultiStreamDataSourceListener> myListeners = SetSequence.fromSet(new HashSet<MultiStreamDataSourceListener>());
  @Nullable
  private Module myIdeaModule;
  /**
   * WILL GO AWAY
   */
  private MPSProject myFakeMpsProject;
  private VirtualFileManager myVirtFileMgr;
  private FileDocumentManager myFileDocMgr;
  private EclipseJavaStubDataSource.MyPsiListener myPsiListener = new EclipseJavaStubDataSource.MyPsiListener();
  /**
   * Needed in inner class MyPsiListener. BL doesn't have qualified this.
   */
  private DataSource _this = this;


  public EclipseJavaStubDataSource(@NotNull IFile dir, ModelRoot modelRoot) {
    super(dir, modelRoot);
    myIdeaModule = PluginModelRootUtil.getIdeaModule(modelRoot);
    if (myIdeaModule != null) {
      myFakeMpsProject = new MPSProject(myIdeaModule.getProject());
    }
    myVirtFileMgr = VirtualFileManager.getInstance();
    myFileDocMgr = FileDocumentManager.getInstance();

  }

  @Override
  public void addListener(DataSourceListener listener) {
    if (!(listener instanceof MultiStreamDataSourceListener)) {
      throw new IllegalArgumentException("Only MultiStreamDataSourceListener expected");
    }
    synchronized (LOCK) {
      SetSequence.fromSet(myListeners).addElement((MultiStreamDataSourceListener) listener);
      if ((int) SetSequence.fromSet(myListeners).count() == 1 && myIdeaModule != null) {
        myIdeaModule.getProject().getComponent(PsiChangesWatcher.class).addListener(myPsiListener);
      }
    }
  }

  @Override
  public void removeListener(DataSourceListener listener) {
    if (!(listener instanceof MultiStreamDataSourceListener)) {
      return;
    }

    synchronized (LOCK) {
      Object removed = SetSequence.fromSet(myListeners).removeElement((MultiStreamDataSourceListener) listener);
      if (removed != null && SetSequence.fromSet(myListeners).isEmpty() && myIdeaModule != null) {
        myIdeaModule.getProject().getComponent(PsiChangesWatcher.class).removeListener(myPsiListener);
      }
    }
  }

  @Override
  public InputStream openInputStream(String name) throws IOException {
    IFile ifile = getFile(name);
    VirtualFile vfile = VirtualFileUtils.getVirtualFile(ifile);
    if (vfile == null) {
      return null;
    }
    Document doc = myFileDocMgr.getDocument(vfile);
    if (doc == null) {
      return vfile.getInputStream();
    } else {
      byte[] textBytes = doc.getText().getBytes();
      return new ByteArrayInputStream(textBytes);
    }
  }

  private class MyPsiListener implements PsiListener {
    public MyPsiListener() {
    }

    @Override
    public void psiChanged(PsiListener.PsiEvent event) {
      String path = getFolder().getPath();
      final Set<String> changedItems = SetSequence.fromSet(new HashSet<String>());
      SetSequence.fromSet(changedItems).addSequence(SetSequence.fromSet(handleFsItems(path, event.getCreated())));
      SetSequence.fromSet(changedItems).addSequence(SetSequence.fromSet(handleFsItems(path, event.getRemoved())));
      // not pretty 
      Set<PsiFileSystemItem> files = SetSequence.fromSet(new HashSet<PsiFileSystemItem>());
      for (PsiFile f : event.getChanged().keySet()) {
        SetSequence.fromSet(files).addElement(f);
      }
      SetSequence.fromSet(changedItems).addSequence(SetSequence.fromSet(handleFsItems(path, files)));

      synchronized (LOCK) {
        ModelAccess.instance().runCommandInEDT(new Runnable() {
          public void run() {
            for (MultiStreamDataSourceListener listener : SetSequence.fromSet(myListeners)) {
              listener.changed(_this, changedItems);
            }
          }
        }, myFakeMpsProject);
      }
    }

    private Set<String> handleFsItems(String path, Iterable<PsiFileSystemItem> items) {
      Set<String> changedItems = SetSequence.fromSet(new HashSet<String>());

      for (PsiFileSystemItem fsItem : Sequence.fromIterable(items)) {
        VirtualFile vFile = fsItem.getVirtualFile();
        String itemPath = vFile.getPath();
        if (!(itemPath.startsWith(path))) {
          continue;
        }
        SetSequence.fromSet(changedItems).addElement(vFile.getName());
      }

      return changedItems;
    }
  }
}
