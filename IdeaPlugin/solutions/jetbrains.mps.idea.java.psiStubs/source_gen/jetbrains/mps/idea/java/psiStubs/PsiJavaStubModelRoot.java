package jetbrains.mps.idea.java.psiStubs;

/*Generated by MPS */

import jetbrains.mps.extapi.persistence.ModelRootBase;
import jetbrains.mps.idea.core.psi.PsiListener;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.module.Module;
import java.util.Map;
import com.intellij.psi.PsiDirectory;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SModelId;
import jetbrains.mps.idea.core.psi.PsiChangesWatcher;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.IMapping;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.roots.ModuleRootManager;
import com.intellij.psi.PsiManager;
import com.intellij.psi.PsiJavaFile;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.persistence.Memento;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiMethod;
import com.intellij.psi.PsiField;
import com.intellij.psi.PsiParameterList;
import com.intellij.psi.PsiParameter;
import com.intellij.psi.PsiReferenceList;
import com.intellij.psi.PsiModifierList;
import com.intellij.psi.PsiModifier;
import com.intellij.psi.PsiTypeParameterList;
import com.intellij.psi.PsiTypeParameter;
import com.intellij.psi.PsiCodeBlock;
import com.intellij.psi.PsiExpression;
import com.intellij.psi.PsiWhiteSpace;
import java.util.Set;
import java.util.HashSet;
import com.intellij.psi.PsiFileSystemItem;
import com.intellij.psi.PsiFile;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class PsiJavaStubModelRoot extends ModelRootBase implements PsiListener {
  private static Logger LOG = Logger.getLogger(PsiJavaStubModelRoot.class);
  private static final String TYPE = "JavaPsiStubs";
  @NotNull
  private Module myIdeaModule;
  private Map<PsiDirectory, PsiJavaStubDataSource> myDataSources = MapSequence.fromMap(new HashMap<PsiDirectory, PsiJavaStubDataSource>());
  private Map<PsiJavaStubDataSource, SModel> myModels = MapSequence.fromMap(new HashMap<PsiJavaStubDataSource, SModel>());

  public PsiJavaStubModelRoot(Module module) {
    myIdeaModule = module;
  }

  /**
   * Equals is defined only by our ideaModule, all the state is not taken into acount
   * We should be careful when working with ModelRoots in collections (see AbstractModule.doUpdateModelSet)
   */
  @Override
  public boolean equals(Object root) {
    if (!(root instanceof PsiJavaStubModelRoot)) {
      return false;
    }
    return myIdeaModule.equals(((PsiJavaStubModelRoot) root).myIdeaModule);
  }

  @Override
  public int hashCode() {
    return myIdeaModule.hashCode();
  }

  @Override
  public String getType() {
    return TYPE;
  }

  @Override
  public String getPresentation() {
    return "Java PSI stubs";
  }

  @Override
  public SModel getModel(SModelId id) {
    // TODO 
    return null;
  }

  @Override
  public void attach() {
    super.attach();

    //  start to listen 
    PsiChangesWatcher w = myIdeaModule.getProject().getComponent(PsiChangesWatcher.class);
    w.addListener(this);
  }

  @Override
  public void dispose() {
    PsiChangesWatcher w = myIdeaModule.getProject().getComponent(PsiChangesWatcher.class);
    w.removeListener(this);
  }

  @Override
  public Iterable<SModel> loadModels() {
    myModels = getModelMap();
    for (SModel model : Sequence.fromIterable(MapSequence.fromMap(myModels).values())) {
      register(model);
    }
    syncDirectoryMap();
    return MapSequence.fromMap(myModels).values();
  }

  @Override
  public void update() {
    ModelAccess.assertLegalWrite();

    Map<PsiJavaStubDataSource, SModel> oldModelMap = new HashMap<PsiJavaStubDataSource, SModel>(myModels);
    Map<PsiJavaStubDataSource, SModel> newModelMap = getModelMap();

    for (IMapping<PsiJavaStubDataSource, SModel> pair : MapSequence.fromMap(oldModelMap)) {
      if (MapSequence.fromMap(newModelMap).containsKey(pair.key())) {
        continue;
      }
      unregister(pair.value());
    }

    for (SModel model : Sequence.fromIterable(MapSequence.fromMap(newModelMap).values())) {
      register(model);
    }

    myModels = newModelMap;
    syncDirectoryMap();
  }

  private Map<PsiJavaStubDataSource, SModel> getModelMap() {
    // <node> 

    Map<PsiJavaStubDataSource, SModel> modelMap = MapSequence.fromMap(new HashMap<PsiJavaStubDataSource, SModel>());

    final VirtualFile[] sourceRoots = ModuleRootManager.getInstance(myIdeaModule).getSourceRoots(false);
    PsiManager psiMgr = PsiManager.getInstance(myIdeaModule.getProject());

    for (VirtualFile root : sourceRoots) {
      PsiDirectory dir = psiMgr.findDirectory(root);
      addModelsForDir(dir, dir, modelMap);
    }

    // <node> 
    return modelMap;
  }

  private void addModelsForDir(PsiDirectory sourceRoot, PsiDirectory dir, Map<PsiJavaStubDataSource, SModel> resultMap) {
    if (Sequence.fromIterable(Sequence.fromArray(dir.getFiles())).ofType(PsiJavaFile.class).isNotEmpty()) {

      SModelReference modelRef = makeModelReference(sourceRoot, dir);
      SModel model = SModelRepository.getInstance().getModelDescriptor(modelRef);

      if (model == null) {
        model = makeModelDescriptor(modelRef, dir);
      }

      assert model instanceof PsiJavaStubModelDescriptor;

      PsiJavaStubDataSource dataSource = ((PsiJavaStubModelDescriptor) model).getSource();
      MapSequence.fromMap(resultMap).put(dataSource, model);
    }

    for (PsiDirectory subDir : dir.getSubdirectories()) {
      addModelsForDir(sourceRoot, subDir, resultMap);
    }
  }

  private PsiJavaStubModelDescriptor makeModelDescriptor(SModelReference modelRef, PsiDirectory dir) {
    PsiJavaStubDataSource ds = new PsiJavaStubDataSource(myIdeaModule, dir);
    return new PsiJavaStubModelDescriptor(modelRef, ds);
  }

  private SModelReference makeModelReference(PsiDirectory sourceRoot, PsiDirectory dir) {
    int skipPrefix = sourceRoot.toString().length();
    String relativeDirName = dir.toString().substring(skipPrefix);
    String packageName = relativeDirName.replace('/', '.').replace('\\', '.');

    if (packageName.length() > 0 && packageName.charAt(0) == '.') {
      packageName = packageName.substring(1);
    }
    // <node> 

    // <node> 
    // <node> 

    // <node> 

    return JavaForeignIdBuilder.computeModelReference(packageName);
  }

  private void syncDirectoryMap() {
    MapSequence.fromMap(myDataSources).clear();
    for (PsiJavaStubDataSource dataSource : SetSequence.fromSet(MapSequence.fromMap(myModels).keySet())) {
      MapSequence.fromMap(myDataSources).put(dataSource.getDirectory(), dataSource);
    }
  }

  public boolean isReadOnly() {
    return true;
  }

  @Override
  public boolean canCreateModel(String modelName) {
    return false;
  }

  @Override
  public SModel createModel(String modelName) {
    return null;
  }

  @Override
  public void save(Memento memento) {
    throw new UnsupportedOperationException("JavaPsiStubs: unsupported for now");
  }

  @Override
  public void load(Memento memento) {
    throw new UnsupportedOperationException("JavaPsiStubs: unsupported for now");
  }

  private boolean interesting(PsiElement elem) {
    if (elem instanceof PsiJavaFile || elem instanceof PsiClass || elem instanceof PsiMethod || elem instanceof PsiField || elem instanceof PsiParameterList || elem instanceof PsiParameter || elem instanceof PsiReferenceList || elem instanceof PsiModifierList || elem instanceof PsiModifier || elem instanceof PsiTypeParameterList || elem instanceof PsiTypeParameter) {
      //  but not PsiReference ! 
      return true;
    }
    return false;
  }

  private boolean notInteresting(PsiElement elem) {
    return elem instanceof PsiCodeBlock || elem instanceof PsiExpression;
  }

  private boolean filter(PsiElement elem) {
    if (elem == null || elem instanceof PsiWhiteSpace) {
      return false;
    }
    PsiElement e = elem;
    do {
      if (interesting(e)) {
        return true;
      }
      if (notInteresting(e)) {
        return false;
      }
      e = e.getParent();
    } while (e != null);
    return false;
  }

  @Override
  public void psiChanged(PsiListener.PsiEvent event) {

    // For each data source (isomorphic to model,package) make an event that contains 
    // only files under its PsiDirectory 
    // Filter it so that only java stub related things are left: non java files are ignored, 
    // stuff inside method bodies is ignored 

    // Also separate directory creates/deletes into other sets 
    Set<PsiDirectory> newDirs = SetSequence.fromSet(new HashSet<PsiDirectory>());
    Set<PsiDirectory> deletedDirs = SetSequence.fromSet(new HashSet<PsiDirectory>());
    Map<PsiJavaStubDataSource, PsiJavaStubModelRoot.PsiChange> changes = MapSequence.fromMap(new HashMap<PsiJavaStubDataSource, PsiJavaStubModelRoot.PsiChange>());

    boolean modelSetChanged = false;

    // TODO check carefully how they interact in different (refactoring) scenarios 

    for (PsiFileSystemItem item : Sequence.fromIterable(event.getCreated())) {

      if (item instanceof PsiDirectory) {
        // it's not interesting per se (while it's empty) 
        continue;
      }

      if (!(item instanceof PsiJavaFile)) {
        continue;
      }

      PsiDirectory parent = ((PsiFile) item).getParent();
      PsiJavaStubDataSource dataSource = MapSequence.fromMap(myDataSources).get(parent);
      if (dataSource == null) {
        // it's a new java file and it's not under one of our tracked packages 
        // it may be a) a java file from outside => ignore it 
        //           b) the first java file in its dir under our source roots => create new model for it 

        PsiDirectory ourSourceRoot = findOurSourceRoot(item);
        if (ourSourceRoot != null) {
          SetSequence.fromSet(newDirs).addElement(parent);
        }

        continue;
      }

      PsiJavaStubModelRoot.PsiChange change = MapSequence.fromMap(changes).get(dataSource);
      if (change == null) {
        change = new PsiJavaStubModelRoot.PsiChange();
        MapSequence.fromMap(changes).put(dataSource, change);
      }
      SetSequence.fromSet(change.created).addElement(item);
    }

    for (PsiFileSystemItem item : Sequence.fromIterable(event.getRemoved())) {

      if (item instanceof PsiDirectory) {
        if (MapSequence.fromMap(myDataSources).containsKey((PsiDirectory) item)) {
          SetSequence.fromSet(deletedDirs).addElement((PsiDirectory) item);
        }
        continue;
      }

      if (!(item instanceof PsiJavaFile)) {
        continue;
      }

      PsiDirectory parent = ((PsiFile) item).getParent();
      PsiJavaStubDataSource dataSource = MapSequence.fromMap(myDataSources).get(parent);
      if (dataSource == null) {
        continue;
      }

      // check if it was the last java file in directory 
      if (Sequence.fromIterable(Sequence.fromArray(parent.getChildren())).ofType(PsiJavaFile.class).isEmpty()) {
        SetSequence.fromSet(deletedDirs).addElement(parent);
      }

      PsiJavaStubModelRoot.PsiChange change = MapSequence.fromMap(changes).get(dataSource);
      if (change == null) {
        change = new PsiJavaStubModelRoot.PsiChange();
        MapSequence.fromMap(changes).put(dataSource, change);
      }
      SetSequence.fromSet(change.removed).addElement(item);
    }

    for (PsiFile file : SetSequence.fromSet(event.getChanged().keySet())) {

      if (!(file instanceof PsiJavaFile)) {
        continue;
      }

      PsiDirectory parent = file.getParent();
      PsiJavaStubDataSource dataSource = MapSequence.fromMap(myDataSources).get(parent);
      if (dataSource == null) {
        continue;
      }

      Set<PsiElement> changeSet = SetSequence.fromSet(new HashSet<PsiElement>());
      for (PsiElement elem : SetSequence.fromSet(event.getChanged().get(file))) {
        if (!(filter(elem))) {
          continue;
        }
        SetSequence.fromSet(changeSet).addElement(elem);
      }

      PsiJavaStubModelRoot.PsiChange change = MapSequence.fromMap(changes).get(dataSource);
      if (change == null) {
        change = new PsiJavaStubModelRoot.PsiChange();
        MapSequence.fromMap(changes).put(dataSource, change);
      }
      MapSequence.fromMap(change.changed).put(file, changeSet);
    }

    // delete models corresponding to directories 
    for (PsiDirectory dir : SetSequence.fromSet(deletedDirs)) {

      PsiJavaStubDataSource ds = MapSequence.fromMap(myDataSources).get(dir);
      if (ds == null) {
        // just in case 
        continue;
      }

      MapSequence.fromMap(myDataSources).removeKey(dir);
      SModel model = MapSequence.fromMap(myModels).get(ds);
      MapSequence.fromMap(myModels).removeKey(ds);
      unregister(model);
    }

    // create models for new directories 
    for (PsiDirectory dir : SetSequence.fromSet(newDirs)) {
      PsiDirectory ourSourceRoot = findOurSourceRoot(dir);

      PsiJavaStubModelDescriptor model = makeModelDescriptor(makeModelReference(ourSourceRoot, dir), dir);
      PsiJavaStubDataSource ds = model.getSource();
      MapSequence.fromMap(myDataSources).put(dir, ds);
      MapSequence.fromMap(myModels).put(ds, model);
      register(model);
    }

    // notify data sources 
    for (IMapping<PsiJavaStubDataSource, PsiJavaStubModelRoot.PsiChange> notification : SetSequence.fromSet(MapSequence.fromMap(changes).mappingsSet())) {
      PsiJavaStubDataSource ds = notification.key();
      PsiJavaStubModelRoot.PsiChange change = notification.value();
      if (!(change.isEmpty())) {
        ds.dispatchEvent(change);
      }
    }
  }

  private PsiDirectory findOurSourceRoot(PsiFileSystemItem item) {
    for (VirtualFile sourceRoot : ModuleRootManager.getInstance(myIdeaModule).getSourceRoots()) {
      String rootPath = sourceRoot.toString();
      String itemPath = item.getVirtualFile().toString();
      if (itemPath.startsWith(rootPath)) {
        return PsiManager.getInstance(myIdeaModule.getProject()).findDirectory(sourceRoot);
      }
    }
    return null;
  }

  /**
   * Contract: getCreated and getRemoved contain only PsiJavaFile (as well as keys in getChanged)
   */
  private static class PsiChange implements PsiListener.PsiEvent {
    private Set<PsiFileSystemItem> created = SetSequence.fromSet(new HashSet<PsiFileSystemItem>());
    private Set<PsiFileSystemItem> removed = SetSequence.fromSet(new HashSet<PsiFileSystemItem>());
    private Map<PsiFile, Set<PsiElement>> changed = MapSequence.fromMap(new HashMap<PsiFile, Set<PsiElement>>());

    public PsiChange() {
    }

    public boolean isEmpty() {
      return SetSequence.fromSet(created).isEmpty() && SetSequence.fromSet(removed).isEmpty() && MapSequence.fromMap(changed).all(new IWhereFilter<IMapping<PsiFile, Set<PsiElement>>>() {
        public boolean accept(IMapping<PsiFile, Set<PsiElement>> it) {
          return SetSequence.fromSet(it.value()).isEmpty();
        }
      });
    }

    public Iterable<PsiFileSystemItem> getCreated() {
      return created;
    }

    public Iterable<PsiFileSystemItem> getRemoved() {
      return removed;
    }

    public Map<PsiFile, Set<PsiElement>> getChanged() {
      return changed;
    }
  }
}
