package jetbrains.mps.idea.java.psiStubs;

/*Generated by MPS */

import jetbrains.mps.extapi.persistence.ModelRootBase;
import jetbrains.mps.idea.core.psi.PsiListener;
import jetbrains.mps.logging.Logger;
import com.intellij.openapi.module.Module;
import java.util.Map;
import com.intellij.psi.PsiDirectory;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SModelId;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.roots.ModuleRootManager;
import com.intellij.psi.PsiManager;
import jetbrains.mps.idea.core.psi.PsiChangesWatcher;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.intellij.psi.PsiJavaFile;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.smodel.SModelReference;
import org.jetbrains.mps.openapi.persistence.Memento;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiMethod;
import com.intellij.psi.PsiField;
import com.intellij.psi.PsiParameterList;
import com.intellij.psi.PsiParameter;
import com.intellij.psi.PsiReferenceList;
import com.intellij.psi.PsiModifierList;
import com.intellij.psi.PsiModifier;
import com.intellij.psi.PsiTypeParameterList;
import com.intellij.psi.PsiTypeParameter;
import com.intellij.psi.PsiCodeBlock;
import com.intellij.psi.PsiExpression;
import com.intellij.psi.PsiWhiteSpace;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.psi.PsiFileSystemItem;
import com.intellij.psi.PsiFile;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class PsiJavaStubModelRoot extends ModelRootBase implements PsiListener {
  private static Logger LOG = Logger.getLogger(PsiJavaStubModelRoot.class);
  private static final String TYPE = "JavaPsiStubs";

  private Module myModule;
  private Map<PsiDirectory, PsiJavaStubDataSource> myDataSources = MapSequence.fromMap(new HashMap<PsiDirectory, PsiJavaStubDataSource>());
  private Map<PsiJavaStubDataSource, SModel> myModels;

  public PsiJavaStubModelRoot(Module module) {
    myModule = module;
  }

  @Override
  public String getType() {
    return TYPE;
  }

  @Override
  public String getPresentation() {
    return "java PSI stubs";
  }

  @Override
  public SModel getModel(SModelId id) {
    //  not clear if it's needed here 
    return null;
  }

  @Override
  public Iterable<SModel> getModels() {

    if (myModels != null) {
      return MapSequence.fromMap(myModels).values();
    }

    myModels = MapSequence.fromMap(new HashMap<PsiJavaStubDataSource, SModel>());

    final VirtualFile[] sourceRoots = ModuleRootManager.getInstance(myModule).getSourceRoots(false);
    PsiManager psiMgr = PsiManager.getInstance(myModule.getProject());

    for (VirtualFile root : sourceRoots) {
      System.out.println("Source root: " + root.getName());
      PsiDirectory dir = psiMgr.findDirectory(root);
      // <node> 
      addModelsForDir(dir, dir);
    }

    //  start to listen 
    PsiChangesWatcher w = myModule.getProject().getComponent(PsiChangesWatcher.class);
    w.addListener(this);

    return MapSequence.fromMap(myModels).values();
  }

  private void addModelsForDir(PsiDirectory sourceRoot, PsiDirectory dir) {
    if (Sequence.fromIterable(Sequence.fromArray(dir.getFiles())).ofType(PsiJavaFile.class).isNotEmpty()) {

      PsiJavaStubModelDescriptor model = makeModelDescriptor(sourceRoot, dir);
      PsiJavaStubDataSource ds = model.getSource();
      MapSequence.fromMap(myDataSources).put(dir, ds);
      MapSequence.fromMap(myModels).put(ds, model);
    }

    for (PsiDirectory subDir : dir.getSubdirectories()) {
      addModelsForDir(sourceRoot, subDir);
    }
  }

  private PsiJavaStubModelDescriptor makeModelDescriptor(PsiDirectory sourceRoot, PsiDirectory dir) {

    int skipPrefix = sourceRoot.toString().length();
    String relativeDirName = dir.toString().substring(skipPrefix);

    String packageName = relativeDirName.replace('/', '.').replace('\\', '.');
    if (packageName.length() > 0 && packageName.charAt(0) == '.') {
      packageName = packageName.substring(1);
    }
    if (packageName.length() == 0) {
      packageName = "<default package>";
    }

    SModelFqName fqName = new SModelFqName(packageName, "java_stub_zzz");
    jetbrains.mps.smodel.SModelId modelId = jetbrains.mps.smodel.SModelId.foreign(fqName.getStereotype(), getModule().getModuleId().toString(), fqName.getLongName());
    SModelReference modelRef = new SModelReference(fqName, modelId);

    PsiJavaStubDataSource ds = new PsiJavaStubDataSource(myModule, dir);
    return new PsiJavaStubModelDescriptor(modelRef, ds);
  }

  @Override
  public boolean isReadOnly() {
    return true;
  }

  @Override
  public boolean canCreateModel(String modelName) {
    return false;
  }

  @Override
  public SModel createModel(String modelName) {
    return null;
  }

  @Override
  public void save(Memento memento) {
    throw new UnsupportedOperationException("JavaPsiStubs: unsupported for now");
  }

  @Override
  public void load(Memento memento) {
    throw new UnsupportedOperationException("JavaPsiStubs: unsupported for now");
  }

  private boolean interesting(PsiElement elem) {
    if (elem instanceof PsiJavaFile || elem instanceof PsiClass || elem instanceof PsiMethod || elem instanceof PsiField || elem instanceof PsiParameterList || elem instanceof PsiParameter || elem instanceof PsiReferenceList || elem instanceof PsiModifierList || elem instanceof PsiModifier || elem instanceof PsiTypeParameterList || elem instanceof PsiTypeParameter) {
      //  but not PsiReference ! 
      return true;
    }
    return false;
  }

  private boolean notInteresting(PsiElement elem) {
    return elem instanceof PsiCodeBlock || elem instanceof PsiExpression;
  }

  private boolean filter(PsiElement elem) {
    if (elem == null || elem instanceof PsiWhiteSpace) {
      return false;
    }
    PsiElement e = elem;
    do {
      if (interesting(e)) {
        return true;
      }
      if (notInteresting(e)) {
        return false;
      }
      e = e.getParent();
    } while (e != null);
    return false;
  }

  @Override
  public void psiChanged(PsiListener.PsiEvent event) {

    // For each data source (isomorphic to model,package) make an event that contains 
    // only files under its PsiDirectory 
    // Filter it so that only java stub related things are left: non java files are ignored, 
    // stuff inside method bodies is ignored 

    // Also separate directory creates/deletes into other sets 
    Set<PsiDirectory> newDirs = SetSequence.fromSet(new HashSet<PsiDirectory>());
    Set<PsiDirectory> deletedDirs = SetSequence.fromSet(new HashSet<PsiDirectory>());
    Map<PsiJavaStubDataSource, PsiJavaStubModelRoot.PsiChange> changes = MapSequence.fromMap(new HashMap<PsiJavaStubDataSource, PsiJavaStubModelRoot.PsiChange>());

    boolean modelSetChanged = false;

    // TODO check carefully how they interact in different (refactoring) scenarios 

    for (PsiFileSystemItem item : Sequence.fromIterable(event.getCreated())) {

      if (item instanceof PsiDirectory) {
        // it's not interesting per se (while it's empty) 
        continue;
      }

      if (!(item instanceof PsiJavaFile)) {
        continue;
      }

      PsiDirectory parent = ((PsiFile) item).getParent();
      PsiJavaStubDataSource dataSource = MapSequence.fromMap(myDataSources).get(parent);
      if (dataSource == null) {
        // it's a new java file and it's not under one of our tracked packages 
        // it may be a) a java file from outside => ignore it 
        //           b) the first java file in its dir under our source roots => create new model for it 

        PsiDirectory ourSourceRoot = findOurSourceRoot(item);
        if (ourSourceRoot != null) {
          SetSequence.fromSet(newDirs).addElement(parent);
        }

        continue;
      }

      PsiJavaStubModelRoot.PsiChange change = MapSequence.fromMap(changes).get(dataSource);
      if (change == null) {
        change = new PsiJavaStubModelRoot.PsiChange();
        MapSequence.fromMap(changes).put(dataSource, change);
      }
      SetSequence.fromSet(change.created).addElement(item);
    }

    for (PsiFileSystemItem item : Sequence.fromIterable(event.getRemoved())) {

      if (item instanceof PsiDirectory) {
        if (MapSequence.fromMap(myDataSources).containsKey((PsiDirectory) item)) {
          SetSequence.fromSet(deletedDirs).addElement((PsiDirectory) item);
        }
        continue;
      }

      if (!(item instanceof PsiJavaFile)) {
        continue;
      }

      PsiDirectory parent = ((PsiFile) item).getParent();
      PsiJavaStubDataSource dataSource = MapSequence.fromMap(myDataSources).get(parent);
      if (dataSource == null) {
        continue;
      }

      // check if it was the last java file in directory 
      if (Sequence.fromIterable(Sequence.fromArray(parent.getChildren())).ofType(PsiJavaFile.class).isEmpty()) {
        SetSequence.fromSet(deletedDirs).addElement(parent);
      }

      PsiJavaStubModelRoot.PsiChange change = MapSequence.fromMap(changes).get(dataSource);
      if (change == null) {
        change = new PsiJavaStubModelRoot.PsiChange();
        MapSequence.fromMap(changes).put(dataSource, change);
      }
      SetSequence.fromSet(change.removed).addElement(item);
    }

    for (PsiFile file : SetSequence.fromSet(event.getChanged().keySet())) {

      if (!(file instanceof PsiJavaFile)) {
        continue;
      }

      PsiDirectory parent = file.getParent();
      PsiJavaStubDataSource dataSource = MapSequence.fromMap(myDataSources).get(parent);
      if (dataSource == null) {
        continue;
      }

      Set<PsiElement> changeSet = SetSequence.fromSet(new HashSet<PsiElement>());
      for (PsiElement elem : SetSequence.fromSet(event.getChanged().get(file))) {
        if (!(filter(elem))) {
          continue;
        }
        SetSequence.fromSet(changeSet).addElement(elem);
      }

      PsiJavaStubModelRoot.PsiChange change = MapSequence.fromMap(changes).get(dataSource);
      if (change == null) {
        change = new PsiJavaStubModelRoot.PsiChange();
        MapSequence.fromMap(changes).put(dataSource, change);
      }
      MapSequence.fromMap(change.changed).put(file, changeSet);
    }

    // delete models corresponding to directories 
    for (PsiDirectory dir : SetSequence.fromSet(deletedDirs)) {

      PsiJavaStubDataSource ds = MapSequence.fromMap(myDataSources).get(dir);
      if (ds == null) {
        // just in case 
        continue;
      }

      MapSequence.fromMap(myDataSources).removeKey(dir);
      MapSequence.fromMap(myModels).removeKey(ds);

      modelSetChanged = true;
    }

    // create models for new directories 
    for (PsiDirectory dir : SetSequence.fromSet(newDirs)) {
      PsiDirectory ourSourceRoot = findOurSourceRoot(dir);

      PsiJavaStubModelDescriptor model = makeModelDescriptor(ourSourceRoot, dir);
      PsiJavaStubDataSource ds = model.getSource();
      MapSequence.fromMap(myDataSources).put(dir, ds);
      MapSequence.fromMap(myModels).put(ds, model);

      System.out.println("Creating new model for dir " + dir.getName());
      modelSetChanged = true;
    }

    // notify data sources 
    for (IMapping<PsiJavaStubDataSource, PsiJavaStubModelRoot.PsiChange> notification : SetSequence.fromSet(MapSequence.fromMap(changes).mappingsSet())) {
      PsiJavaStubDataSource ds = notification.key();
      PsiJavaStubModelRoot.PsiChange change = notification.value();
      if (!(change.isEmpty())) {
        ds.dispatchEvent(change);
      }
    }

    if (modelSetChanged) {
      update();
    }
  }

  private PsiDirectory findOurSourceRoot(PsiFileSystemItem item) {
    for (VirtualFile sourceRoot : ModuleRootManager.getInstance(myModule).getSourceRoots()) {
      String rootPath = sourceRoot.toString();
      String itemPath = item.getVirtualFile().toString();
      if (itemPath.startsWith(rootPath)) {
        return PsiManager.getInstance(myModule.getProject()).findDirectory(sourceRoot);
      }
    }
    return null;
  }

  /**
   * Contract: getCreated and getRemoved contain only PsiJavaFile (as well as keys in getChanged)
   */
  private static class PsiChange implements PsiListener.PsiEvent {
    private Set<PsiFileSystemItem> created = SetSequence.fromSet(new HashSet<PsiFileSystemItem>());
    private Set<PsiFileSystemItem> removed = SetSequence.fromSet(new HashSet<PsiFileSystemItem>());
    private Map<PsiFile, Set<PsiElement>> changed = MapSequence.fromMap(new HashMap<PsiFile, Set<PsiElement>>());

    public PsiChange() {
    }

    public boolean isEmpty() {
      return SetSequence.fromSet(created).isEmpty() && SetSequence.fromSet(removed).isEmpty() && MapSequence.fromMap(changed).all(new IWhereFilter<IMapping<PsiFile, Set<PsiElement>>>() {
        public boolean accept(IMapping<PsiFile, Set<PsiElement>> it) {
          return SetSequence.fromSet(it.value()).isEmpty();
        }
      });
    }

    public Iterable<PsiFileSystemItem> getCreated() {
      return created;
    }

    public Iterable<PsiFileSystemItem> getRemoved() {
      return removed;
    }

    public Map<PsiFile, Set<PsiElement>> getChanged() {
      return changed;
    }
  }
}
