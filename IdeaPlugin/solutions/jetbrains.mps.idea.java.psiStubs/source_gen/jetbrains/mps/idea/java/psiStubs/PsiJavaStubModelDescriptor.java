package jetbrains.mps.idea.java.psiStubs;

/*Generated by MPS */

import jetbrains.mps.smodel.BaseSpecialModelDescriptor;
import jetbrains.mps.idea.core.psi.PsiListener;
import org.jetbrains.mps.openapi.persistence.DataSourceListener;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SModel;
import java.util.Map;
import com.intellij.psi.PsiJavaFile;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SNodeId;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.psi.PsiClass;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.persistence.DataSource;
import com.intellij.psi.PsiFileSystemItem;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiElement;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class PsiJavaStubModelDescriptor extends BaseSpecialModelDescriptor implements PsiListener, DataSourceListener {
  private SModelReference myModelRef;
  private PsiJavaStubDataSource myDataSource;
  private SModel myModel;
  private Map<PsiJavaFile, Set<SNode>> myRootsPerFile = MapSequence.fromMap(new HashMap<PsiJavaFile, Set<SNode>>());
  private Map<SNodeId, SNode> myRootsById = MapSequence.fromMap(new HashMap<SNodeId, SNode>());

  public PsiJavaStubModelDescriptor(SModelReference modelRef, PsiJavaStubDataSource dataSource) {
    super(modelRef);
    myModelRef = modelRef;
    myDataSource = dataSource;
  }

  @Override
  @NotNull
  public PsiJavaStubDataSource getSource() {
    return myDataSource;
  }

  @Override
  public void attach() {
    myDataSource.addListener(this);
  }

  @Override
  public void dispose() {
    myDataSource.removeListener(this);
  }

  @Override
  protected SModel createModel() {

    myModel = new SModel(myModelRef);

    ASTConverter converter = new ASTConverter();

    for (PsiJavaFile jf : Sequence.fromIterable(myDataSource.getJavaFiles())) {
      Set<SNode> roots = SetSequence.fromSet(new HashSet<SNode>());

      for (PsiClass cls : jf.getClasses()) {
        SNode node = converter.convertClass(cls);
        // TODO check for duplicate ids (in java sources there may be 2 classes with the same name 
        //  which is an error but none the less) 
        SModelOperations.addRootNode(myModel, node);
        SetSequence.fromSet(roots).addElement(node);
        MapSequence.fromMap(myRootsById).put(node.getNodeId(), node);
      }

      if (SetSequence.fromSet(roots).isNotEmpty()) {
        MapSequence.fromMap(myRootsPerFile).put(jf, roots);
      }
    }

    return myModel;
  }

  @Override
  public void changed(DataSource source) {
    // ignore, why do we need this? 
  }

  public void psiChanged(PsiListener.PsiEvent event) {

    // already attached, but not createModel'd yet 
    if (myModel == null) {
      return;
    }

    System.out.println("MODEL ROOT RECEIVED EVENT");
    for (PsiFileSystemItem f : Sequence.fromIterable(event.getRemoved())) {
      System.out.println("Psi file removed:  file=" + f.getName());
    }
    for (PsiFileSystemItem f : Sequence.fromIterable(event.getCreated())) {
      System.out.println("Psi file created:  file=" + f.getName());
    }
    for (PsiFile f : SetSequence.fromSet(event.getChanged().keySet())) {
      System.out.print("Psi change:  file=" + f.getName() + " elements=");
      for (PsiElement e : SetSequence.fromSet(event.getChanged().get(f))) {
        System.out.print(" " + e.getClass().getName());
      }
      System.out.println();
    }

    System.out.flush();



    ASTConverter converter = new ASTConverter();

    // TODO Order can be important, be careful with class name changes (how to find old root node?) 

    // FIXME Very dumb for now, just to code something 

    for (PsiFileSystemItem file : Sequence.fromIterable(event.getRemoved())) {
      SetSequence.fromSet(MapSequence.fromMap(myRootsPerFile).get((PsiJavaFile) file)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          SNodeOperations.deleteNode(it);
        }
      });
      MapSequence.fromMap(myRootsPerFile).removeKey((PsiJavaFile) file);

      System.out.println("Removing " + file.getName());
    }

    for (PsiFileSystemItem file : Sequence.fromIterable(event.getCreated())) {
      Set<SNode> roots = SetSequence.fromSet(new HashSet<SNode>());

      for (PsiClass cls : ((PsiJavaFile) file).getClasses()) {
        SNode node = converter.convertClass(cls);
        SModelOperations.addRootNode(myModel, node);
        SetSequence.fromSet(roots).addElement(node);
      }

      if (SetSequence.fromSet(roots).isNotEmpty()) {
        MapSequence.fromMap(myRootsPerFile).put((PsiJavaFile) file, roots);
      }

      System.err.println("Creating " + file.getName());
    }

    for (PsiFile file : SetSequence.fromSet(event.getChanged().keySet())) {
      for (PsiElement elem : SetSequence.fromSet(event.getChanged().get(file))) {
        if (elem instanceof PsiFile) {
          continue;
        }
        // going up to one of top-level classes 
        PsiElement e = elem;
        do {
          e = e.getParent();
        } while (e != null && !(e instanceof PsiClass && e.getParent() instanceof PsiFile));

        if (e != null) {

          SNode node = converter.convertClass((PsiClass) e);
          SNodeId id = node.getNodeId();
          SNode oldNode = myModel.getNodeById(id);

          if ((oldNode != null)) {
            SNodeOperations.replaceWithAnother(oldNode, node);
          } else {
            SModelOperations.addRootNode(myModel, node);
          }

          System.out.println("Re-parsing class " + ((PsiClass) e).getName());
        }
      }
    }
  }
}
