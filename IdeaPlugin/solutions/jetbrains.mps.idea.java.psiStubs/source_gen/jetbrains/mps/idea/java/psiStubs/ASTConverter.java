package jetbrains.mps.idea.java.psiStubs;

/*Generated by MPS */

import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.psi.PsiElement;
import java.util.Set;
import com.intellij.psi.PsiClass;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import com.intellij.psi.PsiClassType;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.intellij.psi.PsiField;
import com.intellij.psi.PsiEnumConstant;
import com.intellij.psi.PsiMethod;
import com.intellij.psi.PsiModifier;
import com.intellij.psi.PsiAnnotationMethod;
import com.intellij.psi.PsiParameter;
import jetbrains.mps.smodel.SNodeId;
import com.intellij.psi.PsiType;
import com.intellij.psi.PsiPrimitiveType;
import com.intellij.psi.PsiArrayType;
import com.intellij.psi.PsiWildcardType;
import com.intellij.psi.PsiTypeParameter;
import com.intellij.psi.PsiExpression;
import com.intellij.psi.PsiLiteralExpression;
import jetbrains.mps.smodel.DynamicReference;
import com.intellij.psi.PsiAnnotation;
import com.intellij.psi.PsiModifierListOwner;
import com.intellij.psi.PsiTypeParameterListOwner;
import com.intellij.psi.PsiNameValuePair;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.smodel.SReference;
import com.intellij.psi.PsiTypeElement;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.lang.typesystem.runtime.HUtil;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import org.jetbrains.mps.util.Consumer;

public class ASTConverter {
  private final ASTConverter.State myState;
  protected final Consumer<Pair<SNode, PsiElement>> myMps2PsiMapper;



  public ASTConverter() {
    myState = new ASTConverter.State();
    myMps2PsiMapper = null;
  }



  public ASTConverter(Consumer<Pair<SNode, PsiElement>> mps2psiMapper) {
    myState = new ASTConverter.State();
    myMps2PsiMapper = mps2psiMapper;
  }



  public ASTConverter(Consumer<Pair<SNode, PsiElement>> mps2psiMapper, ASTConverter.State state) {
    myState = state;
    myMps2PsiMapper = mps2psiMapper;
  }



  private ASTConverter withTypeVarNames(Set<String> typeVarNames) {
    return new ASTConverter(myMps2PsiMapper, new ASTConverter.State(myState, typeVarNames));
  }



  private ASTConverter withTypeVarDecls(Iterable<SNode> typeVars) {
    return new ASTConverter(myMps2PsiMapper, new ASTConverter.State(myState, typeVars));
  }




  protected boolean needToSetId() {
    return true;
  }

  public SNode convertClass(PsiClass x) {

    final Wrappers._T<SNode> classifier = new Wrappers._T<SNode>();

    if (x.isAnnotationType()) {
      classifier.value = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Annotation", null);
    } else if (x.isEnum()) {
      classifier.value = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumClass", null);
    } else if (x.isInterface()) {
      classifier.value = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Interface", null);
    } else {
      classifier.value = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassConcept", null);
    }

    final SNode ourConcept = SNodeOperations.getConceptDeclaration(classifier.value);

    SPropertyOperations.set(classifier.value, "name", x.getName());
    SLinkOperations.setTarget(classifier.value, "visibility", getVisibility(x), true);
    addAnnotations(x, classifier.value);


    if (needToSetId() && isNotEmpty_rbndtb_a0a21a61(SPropertyOperations.getString(classifier.value, "name"))) {
      ((jetbrains.mps.smodel.SNode) classifier.value).setId(JavaForeignIdBuilder.computeNodeId(x));
    }

    // class's super types and implemented ifaces 
    {
      SNode reallyClass = classifier.value;
      if (SNodeOperations.isInstanceOf(reallyClass, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        if (x.getSuperTypes().length > 0) {
          SLinkOperations.setTarget(reallyClass, "superclass", resolveClass(x.getSuperTypes()[0]), true);
        }
        ListSequence.fromList(SLinkOperations.getTargets(reallyClass, "implementedInterface", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.getImplementsListTypes())).select(new ISelector<PsiClassType, SNode>() {
          public SNode select(PsiClassType it) {
            return resolveClass(it);
          }
        }));

        SPropertyOperations.set(reallyClass, "isFinal", "" + (isFinal(x)));
        SPropertyOperations.set(reallyClass, "isStatic", "" + (isStatic(x)));
      }
    }

    // interface's super intefaces 
    {
      SNode iface = classifier.value;
      if (SNodeOperations.isInstanceOf(iface, "jetbrains.mps.baseLanguage.structure.Interface")) {
        ListSequence.fromList(SLinkOperations.getTargets(iface, "extendedInterface", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.getSuperTypes())).select(new ISelector<PsiClassType, SNode>() {
          public SNode select(PsiClassType it) {
            return resolveClass(it);
          }
        }));
      }
    }

    final ASTConverter currConverter = addTypeParams(x, classifier.value);

    Sequence.fromIterable(Sequence.fromArray(x.getFields())).visitAll(new IVisitor<PsiField>() {
      public void visit(PsiField it) {
        if (it instanceof PsiEnumConstant) {
          // in BL it's not a field, it's a separate thing 
          if (!(SNodeOperations.isInstanceOf(classifier.value, "jetbrains.mps.baseLanguage.structure.EnumClass"))) {
            return;
          }
          SNode cnst = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration", null);
          SPropertyOperations.set(cnst, "name", it.getName());
          if (needToSetId() && SPropertyOperations.getString(cnst, "name") != null) {
            ((jetbrains.mps.smodel.SNode) cnst).setId(JavaForeignIdBuilder.computeNodeId(it));
          }
          // TODO maybe we must not touch expressions here (they may be not in the psi index) 
          // <node> 
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(classifier.value, "jetbrains.mps.baseLanguage.structure.EnumClass"), "enumConstant", true)).addElement(cnst);
        }

        // normal field 
        SNode node = currConverter.convertField(it, ourConcept);

        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")) {
          ListSequence.fromList(SLinkOperations.getTargets(classifier.value, "staticField", true)).addElement(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration"));
        } else if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.FieldDeclaration")) {
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(classifier.value, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "field", true)).addElement(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.FieldDeclaration"));
        }
      }
    });

    Sequence.fromIterable(Sequence.fromArray(x.getMethods())).visitAll(new IVisitor<PsiMethod>() {
      public void visit(PsiMethod it) {
        SNode node = currConverter.convertMethod(it, ourConcept);

        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
          ListSequence.fromList(SLinkOperations.getTargets(classifier.value, "method", true)).addElement(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"));
        } else if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")) {
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(classifier.value, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "staticMethod", true)).addElement(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"));
        } else if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration")) {
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(classifier.value, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "constructor", true)).addElement(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration"));
        }

      }
    });

    ListSequence.fromList(SLinkOperations.getTargets(classifier.value, "staticInnerClassifiers", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.getInnerClasses())).select(new ISelector<PsiClass, SNode>() {
      public SNode select(PsiClass it) {
        return currConverter.convertClass(it);
      }
    }));

    if (myMps2PsiMapper != null) {
      myMps2PsiMapper.consume(new Pair<SNode, PsiElement>(classifier.value, x));
    }

    return classifier.value;
  }

  public SNode convertField(PsiField x, SNode parentConcept) {
    SNode field;
    if (isStatic(x) || SConceptOperations.isSubConceptOf(parentConcept, "jetbrains.mps.baseLanguage.structure.Interface")) {
      field = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration", null);
    } else {
      field = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldDeclaration", null);
      SPropertyOperations.set(SNodeOperations.cast(field, "jetbrains.mps.baseLanguage.structure.FieldDeclaration"), "isVolatile", "" + (x.hasModifierProperty(PsiModifier.VOLATILE)));
      SPropertyOperations.set(SNodeOperations.cast(field, "jetbrains.mps.baseLanguage.structure.FieldDeclaration"), "isTransient", "" + (x.hasModifierProperty(PsiModifier.TRANSIENT)));
    }

    SPropertyOperations.set(field, "name", x.getName());
    SLinkOperations.setTarget(SNodeOperations.cast(field, "jetbrains.mps.baseLanguage.structure.ClassifierMember"), "visibility", getVisibility(x), true);
    SPropertyOperations.set(field, "isFinal", "" + (isFinal(x)));
    SLinkOperations.setTarget(field, "type", convertType(x.getType()), true);
    addAnnotations(x, field);

    if (needToSetId() && SPropertyOperations.getString(field, "name") != null) {
      ((jetbrains.mps.smodel.SNode) field).setId(JavaForeignIdBuilder.computeNodeId(x));
    }

    if (myMps2PsiMapper != null) {
      myMps2PsiMapper.consume(new Pair<SNode, PsiElement>(field, x));
    }

    return field;
  }

  public SNode convertMethod(PsiMethod x, SNode parentConcept) {
    SNode method;

    if (x.isConstructor()) {
      method = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", null);

    } else if (x instanceof PsiAnnotationMethod && SConceptOperations.isSubConceptOf(parentConcept, "jetbrains.mps.baseLanguage.structure.Annotation")) {
      method = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration", null);

      if (((PsiAnnotationMethod) x).getDefaultValue() != null) {
        SNode str = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StringLiteral", null);
        SPropertyOperations.set(str, "value", "TODO: SUPPORT EXPRESSIONS IN PSI STUBS?");
        SLinkOperations.setTarget(SNodeOperations.cast(method, "jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration"), "defaultValue", str, true);
      }

    } else if (!(isStatic(x)) || SConceptOperations.isSubConceptOf(parentConcept, "jetbrains.mps.baseLanguage.structure.Interface")) {
      method = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration", null);

    } else {
      method = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration", null);
    }

    SPropertyOperations.set(method, "name", x.getName());
    SLinkOperations.setTarget(SNodeOperations.cast(method, "jetbrains.mps.baseLanguage.structure.ClassifierMember"), "visibility", getVisibility(x), true);
    SPropertyOperations.set(method, "isFinal", "" + (isFinal(x)));
    SPropertyOperations.set(method, "isSynchronized", "" + (x.hasModifierProperty(PsiModifier.SYNCHRONIZED)));

    ListSequence.fromList(SLinkOperations.getTargets(method, "throwsItem", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.getThrowsList().getReferencedTypes())).select(new ISelector<PsiClassType, SNode>() {
      public SNode select(PsiClassType it) {
        SNode typ = resolveClass(it);
        return typ;
      }
    }));

    final ASTConverter currConverter = addTypeParams(x, method);

    SLinkOperations.setTarget(method, "returnType", currConverter.convertType(x.getReturnTypeNoResolve()), true);
    ListSequence.fromList(SLinkOperations.getTargets(method, "parameter", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.getParameterList().getParameters())).select(new ISelector<PsiParameter, SNode>() {
      public SNode select(PsiParameter it) {
        SNode param = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParameterDeclaration", null);
        SPropertyOperations.set(param, "name", it.getName());
        SLinkOperations.setTarget(param, "type", currConverter.convertType(it.getType()), true);
        SPropertyOperations.set(param, "isFinal", "" + (isFinal(it)));

        currConverter.addAnnotations(it, param);

        return param;
      }
    }));

    // not strictly necessary 
    if (1 > 0) {
      SLinkOperations.setTarget(method, "body", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StubStatementList", null), true);
    } else {
      SLinkOperations.setTarget(method, "body", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null), true);
    }

    if (needToSetId()) {
      SNodeId.Foreign nodeId = JavaForeignIdBuilder.computeNodeId(x);
      if (nodeId != null) {
        ((jetbrains.mps.smodel.SNode) method).setId(nodeId);
      }
    }

    if (myMps2PsiMapper != null) {
      myMps2PsiMapper.consume(new Pair<SNode, PsiElement>(method, x));
    }

    return method;
  }

  public SNode convertType(PsiType x) {
    if (x == null) {
      return null;
    }

    if (x instanceof PsiPrimitiveType) {

      PsiPrimitiveType t = (PsiPrimitiveType) x;
      if (x.equals(PsiPrimitiveType.BYTE)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ByteType", null);

      } else if (x.equals(PsiPrimitiveType.INT)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IntegerType", null);

      } else if (x.equals(PsiPrimitiveType.SHORT)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShortType", null);

      } else if (x.equals(PsiPrimitiveType.LONG)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LongType", null);

      } else if (x.equals(PsiPrimitiveType.SHORT)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShortType", null);

      } else if (x.equals(PsiPrimitiveType.FLOAT)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FloatType", null);

      } else if (x.equals(PsiPrimitiveType.DOUBLE)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DoubleType", null);

      } else if (x.equals(PsiPrimitiveType.CHAR)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.CharType", null);

      } else if (x.equals(PsiPrimitiveType.BOOLEAN)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BooleanType", null);

      } else if (x.equals(PsiPrimitiveType.VOID)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.VoidType", null);

      } else {
        return null;
      }

    } else if (x instanceof PsiClassType) {

      PsiClassType t = (PsiClassType) x;

      // ask state if it's a type variable 
      SNode typVarRef = myState.resolveTypeVar(t.getClassName());
      if (typVarRef != null) {
        return typVarRef;
      }

      SNode typ = resolveClass(t);
      return typ;

    } else if (x instanceof PsiArrayType) {

      SNode arrType = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayType", null);
      SLinkOperations.setTarget(arrType, "componentType", convertType(((PsiArrayType) x).getComponentType()), true);
      return arrType;

    } else if (x instanceof PsiWildcardType) {

      PsiWildcardType t = (PsiWildcardType) x;
      if (!(t.isBounded())) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.WildCardType", null);
      }

      SNode bound = convertType(t.getBound());

      if (t.isExtends()) {
        return _quotation_createNode_rbndtb_a0a6a2c0t(bound);
      } else {
        return _quotation_createNode_rbndtb_a0a0g0c2a91(bound);
      }

    } else {
      return null;
    }
  }

  public SNode convertTypeParameter(PsiTypeParameter x) {
    SNode typeVar = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration", null);
    SPropertyOperations.set(typeVar, "name", x.getName());

    if (x.getExtendsListTypes().length > 0) {
      Iterable<PsiClassType> extend = Sequence.fromArray(x.getExtendsListTypes());
      SLinkOperations.setTarget(typeVar, "bound", resolveClass(Sequence.fromIterable(extend).first()), true);
      ListSequence.fromList(SLinkOperations.getTargets(typeVar, "auxBounds", true)).addSequence(Sequence.fromIterable(extend).skip(1).select(new ISelector<PsiClassType, SNode>() {
        public SNode select(PsiClassType it) {
          return resolveClass(it);
        }
      }));
    }

    return typeVar;
  }

  public SNode convertExpression(PsiExpression exp) {
    if (exp instanceof PsiLiteralExpression) {
      Object value = ((PsiLiteralExpression) exp).getValue();
      if (value instanceof String) {
        return _quotation_createNode_rbndtb_a0a1a0a12(value.toString());
      } else if (value instanceof Integer) {
        SNode c = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IntegerConstant", null);
        SPropertyOperations.set(c, "value", "" + (((Integer) value).intValue()));
        return c;
      }
    }
    return null;
  }

  public SNode resolveClass(PsiClassType t) {
    SNode clsType = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierType", null);
    clsType.setReference("classifier", new DynamicReference("classifier", clsType, null, t.getClassName()));

    ListSequence.fromList(SLinkOperations.getTargets(clsType, "parameter", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(t.getParameters())).select(new ISelector<PsiType, SNode>() {
      public SNode select(PsiType it) {
        return convertType(it);
      }
    }));

    return clsType;
  }

  public SNode resolveAnnotation(PsiAnnotation a) {
    String fqName = a.getQualifiedName();

    // TODO q: handle this case? create dynamic reference? 
    if (fqName == null) {
      return null;
    }

    SNode anno = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationInstance", null);
    anno.setReference("annotation", new DynamicReference("annotation", anno, null, fqName));

    return anno;
  }

  private SNode getVisibility(PsiModifierListOwner x) {
    if (x.hasModifierProperty(PsiModifier.PUBLIC)) {
      return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PublicVisibility", null);
    } else if (x.hasModifierProperty(PsiModifier.PROTECTED)) {
      return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ProtectedVisibility", null);
    } else if (x.hasModifierProperty(PsiModifier.PRIVATE)) {
      return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PrivateVisibility", null);
    } else {
      return null;
    }
  }

  private boolean isFinal(PsiModifierListOwner x) {
    return x.hasModifierProperty(PsiModifier.FINAL);
  }

  public boolean isStatic(PsiModifierListOwner x) {
    return x.hasModifierProperty(PsiModifier.STATIC);
  }



  private ASTConverter addTypeParams(PsiTypeParameterListOwner from, SNode to) {
    Iterable<SNode> typeVarDecls = Sequence.fromIterable(Sequence.fromArray(from.getTypeParameters())).select(new ISelector<PsiTypeParameter, SNode>() {
      public SNode select(PsiTypeParameter it) {
        return convertTypeParameter(it);
      }
    });
    ListSequence.fromList(SLinkOperations.getTargets(to, "typeVariableDeclaration", true)).addSequence(Sequence.fromIterable(typeVarDecls));
    return withTypeVarDecls(typeVarDecls);
  }



  private void addAnnotations(PsiModifierListOwner from, SNode to) {

    ListSequence.fromList(SLinkOperations.getTargets(to, "annotation", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(from.getModifierList().getAnnotations())).select(new ISelector<PsiAnnotation, SNode>() {
      public SNode select(PsiAnnotation it) {
        PsiAnnotation psiAnno = it;
        SNode anno = resolveAnnotation(psiAnno);
        if ((anno == null)) {
          return null;
        }
        ListSequence.fromList(SLinkOperations.getTargets(anno, "value", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(psiAnno.getParameterList().getAttributes())).select(new ISelector<PsiNameValuePair, SNode>() {
          public SNode select(PsiNameValuePair it) {

            SNode annoParam = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationInstanceValue", null);

            String paramName = it.getName();
            annoParam.setReference("key", new DynamicReference("key", annoParam, null, paramName));

            return annoParam;

          }
        }));

        return anno;
      }
    }));
  }



  public static class State {
    private ASTConverter.State parentState;
    private Map<String, SNode> myTypeVars = MapSequence.fromMap(new HashMap<String, SNode>());


    public State() {
    }



    public State(ASTConverter.State base, Set<String> typeVarNames) {
      parentState = base;
      SetSequence.fromSet(typeVarNames).visitAll(new IVisitor<String>() {
        public void visit(String it) {
          MapSequence.fromMap(myTypeVars).put(it, null);
        }
      });
    }



    public State(ASTConverter.State base, Iterable<SNode> typeVars) {
      parentState = base;
      for (SNode tv : Sequence.fromIterable(typeVars)) {
        MapSequence.fromMap(myTypeVars).put(SPropertyOperations.getString(tv, "name"), tv);
      }
    }



    protected SNode resolveTypeVar(String name) {
      if (myTypeVars == null) {
        return (parentState == null ?
          null :
          parentState.resolveTypeVar(name)
        );
      }

      if (myTypeVars == null || !(MapSequence.fromMap(myTypeVars).containsKey(name))) {
        // Either type var map is not initialized, this means that this State object was created with something else: 
        // e.g. with id prefix. 
        // Or type var is not part of this state 
        return (parentState == null ?
          null :
          parentState.resolveTypeVar(name)
        );

      } else {
        // we have this var name 
        SNode typeVar = MapSequence.fromMap(myTypeVars).get(name);
        SNode typeVarRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TypeVariableReference", null);
        SReference ref;
        // let's see if var has been parsed already 
        if (typeVar != null) {
          // FIXME static reference doesn't work here for some reason 
          // <node> 
          ref = new DynamicReference("typeVariableDeclaration", typeVarRef, null, name);
        } else {
          ref = new DynamicReference("typeVariableDeclaration", typeVarRef, null, name);
        }

        typeVarRef.setReference(ref.getRole(), ref);
        return typeVarRef;
      }
    }



  }



  public static String typeReferenceId(PsiTypeElement psiTypeElem) {
    // FIXME a) check it's good for node id, b) try to be the same as binary stubs 
    String str = null;
    // FIXME doesn't work properly with a very rare case a.b<X,Y>.c.d<V,W> 
    str = psiTypeElem.getText();
    int firstBracket = str.indexOf("<");
    if (firstBracket > 0) {
      str = str.substring(0, firstBracket);
    }

    PsiType psiType = psiTypeElem.getType();
    if (psiType instanceof PsiArrayType && !(str.endsWith("[]"))) {
      str = str + "[]";
    }

    return str;
  }

  private static SNode _quotation_createNode_rbndtb_a0a6a2c0t(Object parameter_1) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.UpperBoundType", null, null, GlobalScope.getInstance(), false);
    quotedNode_3 = (SNode) parameter_1;
    if (quotedNode_3 != null) {
      quotedNode_2.addChild("bound", HUtil.copyIfNecessary(quotedNode_3));
    }
    return quotedNode_2;
  }

  private static SNode _quotation_createNode_rbndtb_a0a0g0c2a91(Object parameter_1) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.LowerBoundType", null, null, GlobalScope.getInstance(), false);
    quotedNode_3 = (SNode) parameter_1;
    if (quotedNode_3 != null) {
      quotedNode_2.addChild("bound", HUtil.copyIfNecessary(quotedNode_3));
    }
    return quotedNode_2;
  }

  private static SNode _quotation_createNode_rbndtb_a0a1a0a12(Object parameter_1) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode quotedNode_2 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StringLiteral", null, null, GlobalScope.getInstance(), false);
    SNodeAccessUtil.setProperty(quotedNode_2, "value", (String) parameter_1);
    return quotedNode_2;
  }

  public static boolean isNotEmpty_rbndtb_a0a21a61(String str) {
    return str != null && str.length() > 0;
  }
}
