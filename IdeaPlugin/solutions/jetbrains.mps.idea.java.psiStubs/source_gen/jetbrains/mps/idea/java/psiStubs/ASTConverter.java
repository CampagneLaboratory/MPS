package jetbrains.mps.idea.java.psiStubs;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SNodeId;
import com.intellij.psi.PsiElement;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.psi.PsiClass;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import com.intellij.psi.PsiClassType;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.intellij.psi.PsiField;
import com.intellij.psi.PsiEnumConstant;
import com.intellij.psi.PsiMethod;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import com.intellij.psi.PsiModifier;
import com.intellij.psi.PsiAnnotationMethod;
import com.intellij.psi.PsiParameter;
import com.intellij.psi.PsiType;
import com.intellij.psi.PsiPrimitiveType;
import jetbrains.mps.smodel.DynamicReference;
import com.intellij.psi.PsiArrayType;
import com.intellij.psi.PsiWildcardType;
import com.intellij.psi.PsiTypeParameter;
import com.intellij.psi.PsiExpression;
import com.intellij.psi.PsiLiteralExpression;
import com.intellij.psi.PsiAnnotation;
import com.intellij.psi.PsiModifierListOwner;
import com.intellij.psi.PsiTypeParameterListOwner;
import com.intellij.psi.PsiNameValuePair;
import com.intellij.psi.PsiTypeElement;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.lang.typesystem.runtime.HUtil;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;

public class ASTConverter {
  protected final Map<SNodeId, PsiElement> psiSourceMap;

  public ASTConverter() {
    psiSourceMap = null;
  }

  public ASTConverter(Map<SNodeId, PsiElement> psiSourceMap) {
    this.psiSourceMap = psiSourceMap;
  }

  /**
   * State. See ASTConverter.WithState
   */
  protected String getIdPrefix() {
    return jetbrains.mps.smodel.SNodeId.Foreign.ID_PREFIX;
  }

  protected boolean needToSetId() {
    return true;
  }

  public SNode convertClass(PsiClass x) {

    final Wrappers._T<SNode> classifier = new Wrappers._T<SNode>();

    if (x.isAnnotationType()) {
      classifier.value = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Annotation", null);
    } else if (x.isEnum()) {
      classifier.value = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumClass", null);
    } else if (x.isInterface()) {
      classifier.value = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Interface", null);
    } else {
      classifier.value = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassConcept", null);
    }

    final SNode ourConcept = SNodeOperations.getConceptDeclaration(classifier.value);

    SPropertyOperations.set(classifier.value, "name", x.getName());
    SLinkOperations.setTarget(classifier.value, "visibility", getVisibility(x), true);
    addTypeParams(x, classifier.value);
    addAnnotations(x, classifier.value);

    final Wrappers._T<ASTConverter> childConverter = new Wrappers._T<ASTConverter>(this);

    if (needToSetId() && isNotEmpty_rbndtb_a0a41a5(SPropertyOperations.getString(classifier.value, "name"))) {
      String id = getIdPrefix() + SPropertyOperations.getString(classifier.value, "name");
      ((jetbrains.mps.smodel.SNode) classifier.value).setId(new jetbrains.mps.smodel.SNodeId.Foreign(id));
      childConverter.value = new ASTConverter.WithState(this, id + ".");
    }

    // class's super types and implemented ifaces 
    {
      SNode reallyClass = classifier.value;
      if (SNodeOperations.isInstanceOf(reallyClass, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        if (x.getSuperTypes().length > 0) {
          SLinkOperations.setTarget(reallyClass, "superclass", resolveClass(x.getSuperTypes()[0]), true);
        }
        ListSequence.fromList(SLinkOperations.getTargets(reallyClass, "implementedInterface", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.getImplementsListTypes())).select(new ISelector<PsiClassType, SNode>() {
          public SNode select(PsiClassType it) {
            return resolveClass(it);
          }
        }));

        SPropertyOperations.set(reallyClass, "isFinal", "" + (isFinal(x)));
        SPropertyOperations.set(reallyClass, "isStatic", "" + (isStatic(x)));
      }
    }

    // interface's super intefaces 
    {
      SNode iface = classifier.value;
      if (SNodeOperations.isInstanceOf(iface, "jetbrains.mps.baseLanguage.structure.Interface")) {
        ListSequence.fromList(SLinkOperations.getTargets(iface, "extendedInterface", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.getSuperTypes())).select(new ISelector<PsiClassType, SNode>() {
          public SNode select(PsiClassType it) {
            return resolveClass(it);
          }
        }));
      }
    }

    Sequence.fromIterable(Sequence.fromArray(x.getFields())).visitAll(new IVisitor<PsiField>() {
      public void visit(PsiField it) {
        if (it instanceof PsiEnumConstant) {
          // in BL it's not a field, it's a separate thing 
          if (!(SNodeOperations.isInstanceOf(classifier.value, "jetbrains.mps.baseLanguage.structure.EnumClass"))) {
            return;
          }
          SNode cnst = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration", null);
          SPropertyOperations.set(cnst, "name", it.getName());
          if (needToSetId() && SPropertyOperations.getString(cnst, "name") != null) {
            ((jetbrains.mps.smodel.SNode) cnst).setId(new jetbrains.mps.smodel.SNodeId.Foreign(childConverter.value.getIdPrefix() + "." + SPropertyOperations.getString(cnst, "name")));
          }
          // TODO maybe we must not touch expressions here (they may be not in the psi index) 
          // <node> 
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(classifier.value, "jetbrains.mps.baseLanguage.structure.EnumClass"), "enumConstant", true)).addElement(cnst);
          return;
        }

        // normal field 
        SNode node = childConverter.value.convertField(it, ourConcept);

        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")) {
          ListSequence.fromList(SLinkOperations.getTargets(classifier.value, "staticField", true)).addElement(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration"));
        } else if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.FieldDeclaration")) {
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(classifier.value, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "field", true)).addElement(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.FieldDeclaration"));
        }
      }
    });

    Sequence.fromIterable(Sequence.fromArray(x.getMethods())).visitAll(new IVisitor<PsiMethod>() {
      public void visit(PsiMethod it) {
        SNode node = childConverter.value.convertMethod(it, ourConcept);

        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
          ListSequence.fromList(SLinkOperations.getTargets(classifier.value, "method", true)).addElement(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"));
        } else if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")) {
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(classifier.value, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "staticMethod", true)).addElement(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"));
        } else if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration")) {
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(classifier.value, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "constructor", true)).addElement(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration"));
        }

      }
    });

    ListSequence.fromList(SLinkOperations.getTargets(classifier.value, "staticInnerClassifiers", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.getInnerClasses())).select(new ISelector<PsiClass, SNode>() {
      public SNode select(PsiClass it) {
        return childConverter.value.convertClass(it);
      }
    }));

    if (psiSourceMap != null) {
      MapSequence.fromMap(psiSourceMap).put(classifier.value.getNodeId(), x);
    }

    return classifier.value;
  }

  public SNode convertField(PsiField x, SNode parentConcept) {
    SNode field;
    if (isStatic(x) || SConceptOperations.isSubConceptOf(parentConcept, "jetbrains.mps.baseLanguage.structure.Interface")) {
      field = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration", null);
    } else {
      field = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldDeclaration", null);
      SPropertyOperations.set(SNodeOperations.cast(field, "jetbrains.mps.baseLanguage.structure.FieldDeclaration"), "isVolatile", "" + (x.hasModifierProperty(PsiModifier.VOLATILE)));
      SPropertyOperations.set(SNodeOperations.cast(field, "jetbrains.mps.baseLanguage.structure.FieldDeclaration"), "isTransient", "" + (x.hasModifierProperty(PsiModifier.TRANSIENT)));
    }

    SPropertyOperations.set(field, "name", x.getName());
    SLinkOperations.setTarget(SNodeOperations.cast(field, "jetbrains.mps.baseLanguage.structure.ClassifierMember"), "visibility", getVisibility(x), true);
    SPropertyOperations.set(field, "isFinal", "" + (isFinal(x)));
    SLinkOperations.setTarget(field, "type", convertType(x.getType()), true);
    addAnnotations(x, field);

    if (needToSetId() && SPropertyOperations.getString(field, "name") != null) {
      String id = getIdPrefix() + SPropertyOperations.getString(field, "name");
      ((jetbrains.mps.smodel.SNode) field).setId(new jetbrains.mps.smodel.SNodeId.Foreign(id));
    }

    if (psiSourceMap != null) {
      MapSequence.fromMap(psiSourceMap).put(field.getNodeId(), x);
    }

    return field;
  }

  public SNode convertMethod(PsiMethod x, SNode parentConcept) {
    SNode method;

    if (x.isConstructor()) {
      method = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", null);

    } else if (x instanceof PsiAnnotationMethod && SConceptOperations.isSubConceptOf(parentConcept, "jetbrains.mps.baseLanguage.structure.Annotation")) {
      method = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration", null);

      if (((PsiAnnotationMethod) x).getDefaultValue() != null) {
        SNode str = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StringLiteral", null);
        SPropertyOperations.set(str, "value", "TODO: SUPPORT EXPRESSIONS IN PSI STUBS?");
        SLinkOperations.setTarget(SNodeOperations.cast(method, "jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration"), "defaultValue", str, true);
      }

    } else if (!(isStatic(x)) || SConceptOperations.isSubConceptOf(parentConcept, "jetbrains.mps.baseLanguage.structure.Interface")) {
      method = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration", null);

    } else {
      method = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration", null);
    }

    SPropertyOperations.set(method, "name", x.getName());
    SLinkOperations.setTarget(SNodeOperations.cast(method, "jetbrains.mps.baseLanguage.structure.ClassifierMember"), "visibility", getVisibility(x), true);
    SPropertyOperations.set(method, "isFinal", "" + (isFinal(x)));
    SPropertyOperations.set(method, "isSynchronized", "" + (x.hasModifierProperty(PsiModifier.SYNCHRONIZED)));

    SLinkOperations.setTarget(method, "returnType", convertType(x.getReturnTypeNoResolve()), true);
    ListSequence.fromList(SLinkOperations.getTargets(method, "parameter", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.getParameterList().getParameters())).select(new ISelector<PsiParameter, SNode>() {
      public SNode select(PsiParameter it) {
        SNode param = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParameterDeclaration", null);
        SPropertyOperations.set(param, "name", it.getName());
        SLinkOperations.setTarget(param, "type", convertType(it.getType()), true);
        SPropertyOperations.set(param, "isFinal", "" + (isFinal(it)));

        addAnnotations(it, param);

        return param;
      }
    }));

    ListSequence.fromList(SLinkOperations.getTargets(method, "throwsItem", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.getThrowsList().getReferencedTypes())).select(new ISelector<PsiClassType, SNode>() {
      public SNode select(PsiClassType it) {
        SNode typ = resolveClass(it);
        return typ;
      }
    }));

    addTypeParams(x, method);

    // not strictly necessary 
    if (1 > 0) {
      SLinkOperations.setTarget(method, "body", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StubStatementList", null), true);
    } else {
      SLinkOperations.setTarget(method, "body", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null), true);
    }

    if (needToSetId()) {
      jetbrains.mps.smodel.SNodeId.Foreign nodeId = JavaForeignIdBuilder.computeNodeId(getIdPrefix(), x);
      if (nodeId != null) {
        ((jetbrains.mps.smodel.SNode) method).setId(nodeId);
      }
    }

    if (psiSourceMap != null) {
      MapSequence.fromMap(psiSourceMap).put(method.getNodeId(), x);
    }

    return method;
  }

  public SNode convertType(PsiType x) {
    if (x == null) {
      return null;
    }

    if (x instanceof PsiPrimitiveType) {

      PsiPrimitiveType t = (PsiPrimitiveType) x;
      if (x.equals(PsiPrimitiveType.BYTE)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ByteType", null);

      } else if (x.equals(PsiPrimitiveType.INT)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IntegerType", null);

      } else if (x.equals(PsiPrimitiveType.SHORT)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShortType", null);

      } else if (x.equals(PsiPrimitiveType.LONG)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LongType", null);

      } else if (x.equals(PsiPrimitiveType.SHORT)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShortType", null);

      } else if (x.equals(PsiPrimitiveType.FLOAT)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FloatType", null);

      } else if (x.equals(PsiPrimitiveType.DOUBLE)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DoubleType", null);

      } else if (x.equals(PsiPrimitiveType.CHAR)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.CharType", null);

      } else if (x.equals(PsiPrimitiveType.BOOLEAN)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BooleanType", null);

      } else if (x.equals(PsiPrimitiveType.VOID)) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.VoidType", null);

      } else {
        return null;
      }

    } else if (x instanceof PsiClassType) {

      PsiClassType t = (PsiClassType) x;

      // FIXME refactor 

      // TODO ask state if it's a type variable 
      if (1 < 0) {
        SNode typVarRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TypeVariableReference", null);
        typVarRef.setReference("typeVariableDeclaration", new DynamicReference("typeVariableDeclaration", typVarRef, null, "TODO"));
        return typVarRef;
      }

      SNode typ = resolveClass(t);
      return typ;

    } else if (x instanceof PsiArrayType) {

      SNode arrType = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayType", null);
      SLinkOperations.setTarget(arrType, "componentType", convertType(((PsiArrayType) x).getComponentType()), true);
      return arrType;

    } else if (x instanceof PsiWildcardType) {

      PsiWildcardType t = (PsiWildcardType) x;
      if (!(t.isBounded())) {
        return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.WildCardType", null);
      }

      SNode bound = convertType(t.getBound());

      if (t.isExtends()) {
        return _quotation_createNode_rbndtb_a0a6a2c0i(bound);
      } else {
        return _quotation_createNode_rbndtb_a0a0g0c2a8(bound);
      }

    } else {
      return null;
    }
  }

  public SNode convertTypeParameter(PsiTypeParameter x) {
    SNode typeVar = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration", null);
    SPropertyOperations.set(typeVar, "name", x.getName());

    if (x.getExtendsListTypes().length > 0) {
      Iterable<PsiClassType> extend = Sequence.fromArray(x.getExtendsListTypes());
      SLinkOperations.setTarget(typeVar, "bound", resolveClass(Sequence.fromIterable(extend).first()), true);
      ListSequence.fromList(SLinkOperations.getTargets(typeVar, "auxBounds", true)).addSequence(Sequence.fromIterable(extend).skip(1).select(new ISelector<PsiClassType, SNode>() {
        public SNode select(PsiClassType it) {
          return resolveClass(it);
        }
      }));
    }

    return typeVar;
  }

  public SNode convertExpression(PsiExpression exp) {
    if (exp instanceof PsiLiteralExpression) {
      Object value = ((PsiLiteralExpression) exp).getValue();
      if (value instanceof String) {
        return _quotation_createNode_rbndtb_a0a1a0a01(value.toString());
      } else if (value instanceof Integer) {
        SNode c = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IntegerConstant", null);
        SPropertyOperations.set(c, "value", "" + (((Integer) value).intValue()));
        return c;
      }
    }
    return null;
  }

  public SNode resolveClass(PsiClassType t) {
    SNode clsType = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierType", null);
    clsType.setReference("classifier", new DynamicReference("classifier", clsType, null, t.getClassName()));

    ListSequence.fromList(SLinkOperations.getTargets(clsType, "parameter", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(t.getParameters())).select(new ISelector<PsiType, SNode>() {
      public SNode select(PsiType it) {
        return convertType(it);
      }
    }));

    return clsType;
  }

  public SNode resolveAnnotation(PsiAnnotation a) {
    String fqName = a.getQualifiedName();

    // TODO q: handle this case? create dynamic reference? 
    if (fqName == null) {
      return null;
    }

    SNode anno = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationInstance", null);
    anno.setReference("annotation", new DynamicReference("annotation", anno, null, fqName));

    return anno;
  }

  private SNode getVisibility(PsiModifierListOwner x) {
    if (x.hasModifierProperty(PsiModifier.PUBLIC)) {
      return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PublicVisibility", null);
    } else if (x.hasModifierProperty(PsiModifier.PROTECTED)) {
      return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ProtectedVisibility", null);
    } else if (x.hasModifierProperty(PsiModifier.PRIVATE)) {
      return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PrivateVisibility", null);
    } else {
      return null;
    }
  }

  private boolean isFinal(PsiModifierListOwner x) {
    return x.hasModifierProperty(PsiModifier.FINAL);
  }

  public boolean isStatic(PsiModifierListOwner x) {
    return x.hasModifierProperty(PsiModifier.STATIC);
  }

  private void addTypeParams(PsiTypeParameterListOwner from, SNode to) {
    ListSequence.fromList(SLinkOperations.getTargets(to, "typeVariableDeclaration", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(from.getTypeParameters())).select(new ISelector<PsiTypeParameter, SNode>() {
      public SNode select(PsiTypeParameter it) {
        return convertTypeParameter(it);
      }
    }));
  }

  private void addAnnotations(PsiModifierListOwner from, SNode to) {

    ListSequence.fromList(SLinkOperations.getTargets(to, "annotation", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(from.getModifierList().getAnnotations())).select(new ISelector<PsiAnnotation, SNode>() {
      public SNode select(PsiAnnotation it) {
        PsiAnnotation psiAnno = it;
        SNode anno = resolveAnnotation(psiAnno);
        if ((anno == null)) {
          return null;
        }
        ListSequence.fromList(SLinkOperations.getTargets(anno, "value", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(psiAnno.getParameterList().getAttributes())).select(new ISelector<PsiNameValuePair, SNode>() {
          public SNode select(PsiNameValuePair it) {

            SNode annoParam = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationInstanceValue", null);

            String paramName = it.getName();
            annoParam.setReference("key", new DynamicReference("key", annoParam, null, paramName));

            return annoParam;

          }
        }));

        return anno;
      }
    }));
  }

  public static class WithState extends ASTConverter {
    private String myIdPrefix;
    private Map<String, SNode> myTypeVars;


    public WithState(ASTConverter base, String prefix) {
      super(base.psiSourceMap);
      myIdPrefix = prefix;
    }

    @Override
    public String getIdPrefix() {
      return myIdPrefix;
    }


  }



  public static String typeReferenceId(PsiTypeElement psiTypeElem) {
    // FIXME a) check it's good for node id, b) try to be the same as binary stubs 
    String str = null;
    // FIXME doesn't work properly with a very rare case a.b<X,Y>.c.d<V,W> 
    str = psiTypeElem.getText();
    int firstBracket = str.indexOf("<");
    if (firstBracket > 0) {
      str = str.substring(0, firstBracket);
    }

    PsiType psiType = psiTypeElem.getType();
    if (psiType instanceof PsiArrayType && !(str.endsWith("[]"))) {
      str = str + "[]";
    }

    return str;
  }

  private static SNode _quotation_createNode_rbndtb_a0a6a2c0i(Object parameter_1) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.UpperBoundType", null, null, GlobalScope.getInstance(), false);
    quotedNode_3 = (SNode) parameter_1;
    if (quotedNode_3 != null) {
      quotedNode_2.addChild("bound", HUtil.copyIfNecessary(quotedNode_3));
    }
    return quotedNode_2;
  }

  private static SNode _quotation_createNode_rbndtb_a0a0g0c2a8(Object parameter_1) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.LowerBoundType", null, null, GlobalScope.getInstance(), false);
    quotedNode_3 = (SNode) parameter_1;
    if (quotedNode_3 != null) {
      quotedNode_2.addChild("bound", HUtil.copyIfNecessary(quotedNode_3));
    }
    return quotedNode_2;
  }

  private static SNode _quotation_createNode_rbndtb_a0a1a0a01(Object parameter_1) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode quotedNode_2 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StringLiteral", null, null, GlobalScope.getInstance(), false);
    SNodeAccessUtil.setProperty(quotedNode_2, "value", (String) parameter_1);
    return quotedNode_2;
  }

  public static boolean isNotEmpty_rbndtb_a0a41a5(String str) {
    return str != null && str.length() > 0;
  }
}
