package jetbrains.mps.idea.java.psiStubs;

/*Generated by MPS */

import jetbrains.mps.smodel.BaseSpecialModelDescriptor;
import jetbrains.mps.idea.core.psi.PsiListener;
import org.jetbrains.mps.openapi.persistence.DataSourceListener;
import org.jetbrains.mps.openapi.model.SModelReference;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNodeId;
import com.intellij.psi.PsiElement;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SModel;
import com.intellij.psi.PsiJavaFile;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.psi.PsiClass;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.jetbrains.mps.openapi.persistence.DataSource;
import com.intellij.psi.PsiFileSystemItem;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.intellij.psi.PsiFile;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import com.intellij.psi.PsiImportStatementBase;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import com.intellij.psi.PsiImportStaticStatement;
import java.util.StringTokenizer;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.util.Consumer;
import jetbrains.mps.util.Pair;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class PsiJavaStubModelDescriptor extends BaseSpecialModelDescriptor implements PsiListener, DataSourceListener {
  private SModelReference myModelRef;
  private PsiJavaStubDataSource myDataSource;

  private Map<String, Set<SNode>> myRootsPerFile = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private Map<SNodeId, SNode> myRootsById = MapSequence.fromMap(new HashMap<SNodeId, SNode>());
  private Map<SNode, PsiElement> myGlobalMps2PsiMapping = MapSequence.fromMap(new HashMap<SNode, PsiElement>());
  /**
   * todo simplify: make it map(string,set(SNode)) 
   */
  private Map<String, Set<SNode>> myMps2PsiMappings = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private PsiJavaStubModelDescriptor.MyMps2PsiMapper myMps2PsiMapper = new PsiJavaStubModelDescriptor.MyMps2PsiMapper();


  public PsiJavaStubModelDescriptor(jetbrains.mps.smodel.SModelReference modelRef, PsiJavaStubDataSource dataSource) {
    super(modelRef);
    myModelRef = modelRef;
    myDataSource = dataSource;
  }

  @Override
  @NotNull
  public PsiJavaStubDataSource getSource() {
    return myDataSource;
  }

  @Override
  public void attach() {
    myDataSource.addListener(this);
  }

  @Override
  public void dispose() {
    myDataSource.removeListener(this);
  }

  @Override
  protected SModel createModel() {

    SModel ourModel = new SModel(myModelRef);

    for (PsiJavaFile jf : myDataSource.getJavaFiles()) {
      SNode javaImports = getImports(jf.getImportList().getAllImportStatements());

      ASTConverter converter = new ASTConverter(myMps2PsiMapper);
      Set<SNode> roots = SetSequence.fromSet(new HashSet<SNode>());

      for (PsiClass cls : jf.getClasses()) {
        SNode node = converter.convertClass(cls);
        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Classifier")) {
          AttributeOperations.setAttribute(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier"), new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.JavaImports")), javaImports);
        }
        // TODO check for duplicate ids (in java sources there may be 2 classes with the same name 
        //  which is an error but none the less) 
        ourModel.addRootNode(node);
        SetSequence.fromSet(roots).addElement(node);
        MapSequence.fromMap(myRootsById).put(node.getNodeId(), node);
      }

      if (SetSequence.fromSet(roots).isNotEmpty()) {
        MapSequence.fromMap(myRootsPerFile).put(jf.getName(), roots);
      }
    }

    return ourModel;
  }

  @Override
  public void changed(DataSource source) {
    // ignore, why do we need this? 
  }

  public void psiChanged(final PsiListener.PsiEvent event) {
    org.jetbrains.mps.openapi.model.SModel ourModel = this;

    // already attached, but not createModel'd yet? 
    if (ourModel == null) {
      return;
    }

    // TODO Order can be important, be careful with class name changes (how to find old root node?) 

    // I do madeUpEvent for now to simplify the event that comes in: it only has removed and created 
    // and nothing changed. This is to ensure validity for now while I work on refactorings etc. 

    PsiListener.PsiEvent madeUpEvent = new PsiListener.PsiEvent() {
      public Iterable<PsiFileSystemItem> getCreated() {
        Set<PsiFileSystemItem> result = SetSequence.fromSet(new HashSet<PsiFileSystemItem>());
        SetSequence.fromSet(result).addSequence(Sequence.fromIterable((Iterable<PsiFileSystemItem>) event.getCreated()));
        SetSequence.fromSet(result).addSequence(Sequence.fromIterable((Iterable<PsiFile>) event.getChanged().keySet()));
        for (PsiListener.FSRename rename : event.getRenamed()) {
          SetSequence.fromSet(result).addElement(rename.item);
        }
        return result;
      }

      public Iterable<PsiFileSystemItem> getRemoved() {
        Set<PsiFileSystemItem> result = SetSequence.fromSet(new HashSet<PsiFileSystemItem>());
        SetSequence.fromSet(result).addSequence(Sequence.fromIterable((Iterable<PsiFileSystemItem>) event.getRemoved()));
        SetSequence.fromSet(result).addSequence(Sequence.fromIterable((Iterable<PsiFile>) event.getChanged().keySet()));
        return result;
      }

      public Iterable<PsiListener.FSMove> getMoved() {
        return null;
      }

      public Iterable<PsiListener.FSRename> getRenamed() {
        return event.getRenamed();
      }

      public Map<PsiFile, Set<PsiElement>> getChanged() {
        return new HashMap<PsiFile, Set<PsiElement>>();
      }
    };

    for (PsiFileSystemItem file : madeUpEvent.getRemoved()) {
      assert file instanceof PsiJavaFile;
      PsiJavaFile javaFile = (PsiJavaFile) file;

      myMps2PsiMapper.clearFile(javaFile.getName());
    }

    for (PsiListener.FSRename rename : madeUpEvent.getRenamed()) {
      String oldName = rename.oldName;
      myMps2PsiMapper.clearFile(oldName);
    }

    for (PsiFileSystemItem file : madeUpEvent.getCreated()) {

      assert file instanceof PsiJavaFile;
      PsiJavaFile javaFile = (PsiJavaFile) file;

      if (!(javaFile.isValid())) {
        String name = javaFile.getName();
        for (PsiFile f : javaFile.getParent().getFiles()) {
          if (name.equals(f.getName()) && f instanceof PsiJavaFile) {
            javaFile = (PsiJavaFile) f;
            break;
          }
        }
      }
      if (!(javaFile.isValid())) {
        continue;
      }

      SNode javaImports = getImports(javaFile.getImportList().getAllImportStatements());
      ASTConverter converter = new ASTConverter(myMps2PsiMapper);

      Set<SNode> roots = SetSequence.fromSet(new HashSet<SNode>());

      for (PsiClass cls : javaFile.getClasses()) {
        SNode node = converter.convertClass(cls);
        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Classifier")) {
          AttributeOperations.setAttribute(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier"), new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.JavaImports")), javaImports);
        }
        SModelOperations.addRootNode(ourModel, node);
        SetSequence.fromSet(roots).addElement(node);
      }

      if (SetSequence.fromSet(roots).isNotEmpty()) {
        MapSequence.fromMap(myRootsPerFile).put(javaFile.getName(), roots);
      }
    }

    for (PsiFile file : madeUpEvent.getChanged().keySet()) {

      ASTConverter converter = new ASTConverter();

      for (PsiElement elem : madeUpEvent.getChanged().get(file)) {
        if (elem instanceof PsiFile) {
          continue;
        }
        // going up to one of top-level classes 
        PsiElement e = elem;
        do {
          e = e.getParent();
        } while (e != null && !(e instanceof PsiClass && e.getParent() instanceof PsiFile));

        if (e != null) {

          SNode node = converter.convertClass((PsiClass) e);
          SNodeId id = node.getNodeId();
          SNode oldNode = ourModel.getNode(id);

          if ((oldNode != null)) {
            SNodeOperations.replaceWithAnother(oldNode, node);
          } else {
            SModelOperations.addRootNode(ourModel, node);
          }
        }
      }
    }
  }



  private SNode getImports(PsiImportStatementBase[] imports) {
    SNode javaImports = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.JavaImports", null);

    for (PsiImportStatementBase imp : imports) {
      SNode javaImport = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.JavaImport", null);
      SPropertyOperations.set(javaImport, "onDemand", "" + (imp.isOnDemand()));
      SPropertyOperations.set(javaImport, "static", "" + (imp instanceof PsiImportStaticStatement));
      String qName = imp.getImportReference().getQualifiedName();
      StringTokenizer toks = new StringTokenizer(qName, ".");
      while (toks.hasMoreTokens()) {
        String tok = toks.nextToken();
        SNode blToken = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StringToken", null);
        SPropertyOperations.set(blToken, "value", tok);
        ListSequence.fromList(SLinkOperations.getTargets(javaImport, "token", true)).addElement(blToken);
      }
      ListSequence.fromList(SLinkOperations.getTargets(javaImports, "entries", true)).addElement(javaImport);
    }
    return javaImports;
  }



  public PsiElement getPsiSource(SNode node) {
    return MapSequence.fromMap(myGlobalMps2PsiMapping).get(node);
  }



  private class MyMps2PsiMapper implements Consumer<Pair<SNode, PsiElement>> {
    @Override
    public void consume(Pair<SNode, PsiElement> pair) {
      SNode node = pair.o1;
      PsiElement element = pair.o2;
      MapSequence.fromMap(myGlobalMps2PsiMapping).put(node, element);
      PsiFile file = element.getContainingFile();
      Set<SNode> mapForFile = MapSequence.fromMap(myMps2PsiMappings).get(file.getName());
      if (mapForFile == null) {
        mapForFile = SetSequence.fromSet(new HashSet<SNode>());
        MapSequence.fromMap(myMps2PsiMappings).put(file.getName(), mapForFile);
      }
      SetSequence.fromSet(mapForFile).addElement(node);
    }



    /*package*/ void clearFile(String fileName) {

      if (MapSequence.fromMap(myRootsPerFile).get(fileName) != null) {
        SetSequence.fromSet(MapSequence.fromMap(myRootsPerFile).get(fileName)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SNodeOperations.deleteNode(it);
          }
        });
        MapSequence.fromMap(myRootsPerFile).removeKey(fileName);
      }

      Set<SNode> mapForFile = MapSequence.fromMap(myMps2PsiMappings).get(fileName);
      if (mapForFile == null) {
        return;
      }
      MapSequence.fromMap(myMps2PsiMappings).removeKey(fileName);
      for (SNode node : mapForFile) {
        MapSequence.fromMap(myGlobalMps2PsiMapping).removeKey(node);
      }
    }
  }
}
