package jetbrains.mps.baseLanguage.helgins;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.helgins.inference.TypeChecker;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.helgins.QuotationClass_25;
import jetbrains.mps.baseLanguage.helgins.QuotationClass_26;
import jetbrains.mps.baseLanguage.helgins.QuotationClass_27;
import jetbrains.mps.baseLanguage.helgins.QuotationClass_28;
import jetbrains.mps.baseLanguage.helgins.QuotationClass_29;
import jetbrains.mps.baseLanguage.helgins.Queries;
import jetbrains.mps.baseLanguage.ext.collections.internal.query.SequenceOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.helgins.zMapper;

public class RulesFunctions_BaseLanguage {

  public static void comparisonOp(SNode binOp) {
    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(binOp, "rightExpression", true)), SLinkOperations.getTarget(new QuotationClass_25().createNode(), "descriptor", false), SLinkOperations.getTarget(binOp, "rightExpression", true));
    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(binOp, "leftExpression", true)), SLinkOperations.getTarget(new QuotationClass_26().createNode(), "descriptor", false), SLinkOperations.getTarget(binOp, "leftExpression", true));
    TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_27().createNode(), binOp);
  }
  public static void numericOp(SNode binOp) {
    TypeChecker.getInstance().getRuntimeSupport().check(SLinkOperations.getTarget(binOp, "leftExpression", true));
    TypeChecker.getInstance().getRuntimeSupport().check(SLinkOperations.getTarget(binOp, "rightExpression", true));
    SNode rightExpressionType = TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(binOp, "rightExpression", true));
    SNode leftExpressionType = TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(binOp, "leftExpression", true));
    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(rightExpressionType, SLinkOperations.getTarget(new QuotationClass_28().createNode(), "descriptor", false), SLinkOperations.getTarget(binOp, "rightExpression", true));
    TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(leftExpressionType, SLinkOperations.getTarget(new QuotationClass_29().createNode(), "descriptor", false), SLinkOperations.getTarget(binOp, "leftExpression", true));
    TypeChecker.getInstance().getRuntimeSupport().givetype(Queries.getBinaryOperationType(leftExpressionType, rightExpressionType), binOp);
  }
  public static Iterable<SNode> collectReturnStatements(SNode node) {
    Iterable<SNode> returnStatements = SequenceOperations.map(SNodeOperations.getChildren(node), new zMapper(null, null));
    return returnStatements;
  }
  public static SNode computeLeastCommonSupertype(SNode exprWithType, SNode currentLeastCommonSupertype, SNode defaultSupertype) {
    SNode exprType = TypeChecker.getInstance().getRuntimeSupport().typeOf(exprWithType);
    if(exprType == null) {
      TypeChecker.getInstance().reportTypeError(exprWithType, "no type");
      return currentLeastCommonSupertype;
    }
    if((defaultSupertype != null) && !(TypeChecker.getInstance().getSubtypingManager().isSubtype(exprType, defaultSupertype))) {
      TypeChecker.getInstance().reportTypeError(exprWithType, "" + defaultSupertype + " is expected");
      return currentLeastCommonSupertype;
    }
    if(currentLeastCommonSupertype == null) {
      return exprType;
    }
    if(TypeChecker.getInstance().getSubtypingManager().isSubtype(currentLeastCommonSupertype, exprType)) {
      return exprType;
    }
    if(TypeChecker.getInstance().getSubtypingManager().isSubtype(exprType, currentLeastCommonSupertype)) {
      return currentLeastCommonSupertype;
    }
    TypeChecker.getInstance().reportTypeError(exprWithType, "type " + exprType + " is not compatible with infered " + currentLeastCommonSupertype);
    return currentLeastCommonSupertype;
  }
}
