package jetbrains.mps.baseLanguage.actions;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.ext.collections.internal.query.ListOperations;
import jetbrains.mps.baseLanguage.constraints.ConceptFunction_Behavior;
import jetbrains.mps.helgins.inference.TypeChecker;
import jetbrains.mps.baseLanguage.ext.collections.internal.ICursor;
import jetbrains.mps.baseLanguage.ext.collections.internal.CursorFactory;
import jetbrains.mps.patterns.util.MatchingUtil;

public class ExpectedType_FactoryUtil {

  public static boolean canComputeCastType(SNode castExpression) {
    return SNodeOperations.hasRole(castExpression, "jetbrains.mps.baseLanguage.structure.BaseMethodCall", "actualArgument") || SNodeOperations.hasRole(castExpression, "jetbrains.mps.baseLanguage.structure.VariableDeclaration", "initializer") || SNodeOperations.hasRole(castExpression, "jetbrains.mps.baseLanguage.structure.ReturnStatement", "expression");
  }

  public static SNode createExpectedType(SNode contextNode) {
    SNode castType = null;
    if(SNodeOperations.hasRole(contextNode, "jetbrains.mps.baseLanguage.structure.BaseMethodCall", "actualArgument")) {
      SNode methodCall = SNodeOperations.getParent(contextNode, null, false, false);
      SNode method = SLinkOperations.getTarget(methodCall, "baseMethodDeclaration", false);
      int index = SNodeOperations.getIndexInParent(contextNode);
      if(index < SLinkOperations.getCount(method, "parameter")) {
        SNode declaredParm = ListOperations.getElement(SLinkOperations.getTargets(method, "parameter", true), index);
        castType = SNodeOperations.copyNode(SLinkOperations.getTarget(declaredParm, "type", true));
      }
    } else
    if(SNodeOperations.hasRole(contextNode, "jetbrains.mps.baseLanguage.structure.VariableDeclaration", "initializer")) {
      castType = SNodeOperations.copyNode(SLinkOperations.getTarget(SNodeOperations.getParent(contextNode, null, false, false), "type", true));
    } else
    if(SNodeOperations.hasRole(contextNode, "jetbrains.mps.baseLanguage.structure.ReturnStatement", "expression")) {
      SNode ancestor = SNodeOperations.getAncestorWhereConceptInList(contextNode, new String[]{"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration","jetbrains.mps.baseLanguage.structure.ConceptFunction"}, false, false);
      if(SNodeOperations.isInstanceOf(ancestor, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")) {
        castType = SNodeOperations.copyNode(SLinkOperations.getTarget(ancestor, "returnType", true));
      } else
      {
        castType = SNodeOperations.copyNode(ConceptFunction_Behavior.call_getExpectedReturnType_1178571276073(ancestor));
      }
    } else
    if(SNodeOperations.hasRole(contextNode, "jetbrains.mps.baseLanguage.structure.AssignmentExpression", "rValue")) {
      SNode type = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(SNodeOperations.getParent(contextNode, null, false, false), "lValue", true));
      castType = SNodeOperations.copyNode(type);
    }
    return castType;
  }

  public static SNode getOriginalExpression(SNode enclosingNode, SNode copiedExpression) {
    SNode originalExpression = null;
    SNode expressionConcept = SNodeOperations.getConceptDeclaration(copiedExpression);
    {
      ICursor<SNode> _zCursor = CursorFactory.createCursor(SNodeOperations.getChildren(enclosingNode));
      try {
        while(_zCursor.moveToNext()) {
          SNode child = _zCursor.getCurrent();
          if(MatchingUtil.matchNodes(copiedExpression, child)) {
            originalExpression = child;
          }
        }
      } finally {
        _zCursor.release();
      }
    }
    return originalExpression;
  }

}
