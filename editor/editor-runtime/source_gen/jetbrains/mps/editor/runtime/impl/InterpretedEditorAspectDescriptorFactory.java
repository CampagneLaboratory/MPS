package jetbrains.mps.editor.runtime.impl;

/*Generated by MPS */

import jetbrains.mps.smodel.language.InterpretedLanguageAspectsRegistry;
import jetbrains.mps.openapi.editor.node.EditorAspectDescriptor;
import com.intellij.openapi.components.ApplicationComponent;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.ide.MPSCoreComponents;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.language.LanguageRuntime;
import java.util.Map;
import jetbrains.mps.openapi.editor.node.EditorAspect;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.classloading.ClassLoaderManager;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class InterpretedEditorAspectDescriptorFactory implements InterpretedLanguageAspectsRegistry.AspectDescriptorFactory<EditorAspectDescriptor>, ApplicationComponent {
  private static Logger LOG = Logger.getLogger(InterpretedEditorAspectDescriptorFactory.class);

  public InterpretedEditorAspectDescriptorFactory(MPSCoreComponents mpsCoreComponents) {
  }

  public void initComponent() {
    InterpretedLanguageAspectsRegistry.getInstance().registerAspectDescriptorFactory(EditorAspectDescriptor.class, this);
  }

  public void disposeComponent() {
    InterpretedLanguageAspectsRegistry.getInstance().unregisterAspectDescriptorFactory(EditorAspectDescriptor.class);
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "MPS InterpretedEditorAspectDescriptorFactory component";
  }

  public EditorAspectDescriptor createAspectDescriptor(LanguageRuntime runtime) {
    return new InterpretedEditorAspectDescriptorFactory.InterpretedEditorAspectDescriptor(runtime);
  }

  private class InterpretedEditorAspectDescriptor implements EditorAspectDescriptor {
    private LanguageRuntime myLanguageRuntime;
    private Map<String, EditorAspect> myEditorAspects = MapSequence.fromMap(new HashMap<String, EditorAspect>());

    private InterpretedEditorAspectDescriptor(LanguageRuntime runtime) {
      myLanguageRuntime = runtime;
    }

    public EditorAspect getAspect(SAbstractConcept abstractConcept) {
      // TODO: check (assert) if passed concept is a part of associated language 
      // <node> 
      String conceptFQName = abstractConcept.getQualifiedName();
      EditorAspect editorAspect = MapSequence.fromMap(myEditorAspects).get(conceptFQName);
      if (editorAspect != null) {
        return editorAspect;
      }
      editorAspect = loadEditor(abstractConcept);
      if (editorAspect != null) {
        MapSequence.fromMap(myEditorAspects).put(conceptFQName, editorAspect);
        return editorAspect;
      }
      if (abstractConcept instanceof SInterfaceConcept) {
        for (SInterfaceConcept superInterface : Sequence.fromIterable(((SInterfaceConcept) abstractConcept).getSuperInterfaces())) {
          EditorAspect superInerfaceEditor = loadSuperConceptEditor(superInterface);
          if (superInerfaceEditor != null) {
            return superInerfaceEditor;
          }
        }
      } else {
        SConcept concept = (SConcept) abstractConcept;
        EditorAspect superConceptEditor = loadSuperConceptEditor(concept.getSuperConcept());
        if (superConceptEditor != null) {
          return superConceptEditor;
        }
        for (SInterfaceConcept superInterface : Sequence.fromIterable(concept.getSuperInterfaces())) {
          EditorAspect superInerfaceEditor = loadSuperConceptEditor(superInterface);
          if (superInerfaceEditor != null) {
            return superInerfaceEditor;
          }
        }
      }
      return null;
    }

    private EditorAspect loadSuperConceptEditor(SAbstractConcept superConcept) {
      if (superConcept == null) {
        return null;
      }
      LanguageRuntime languageRuntime = LanguageRegistry.getInstance().getLanguage(NameUtil.namespaceFromConceptFQName(superConcept.getQualifiedName()));
      if (languageRuntime == null) {
        return null;
      }
      EditorAspectDescriptor editorAspectDescriptor = languageRuntime.getAspectDescriptor(EditorAspectDescriptor.class);
      if (editorAspectDescriptor == null) {
        return null;
      }
      return editorAspectDescriptor.getAspect(superConcept);
    }

    private EditorAspect loadEditor(SAbstractConcept concept) {
      Language language = ModuleRepositoryFacade.getInstance().getModule(myLanguageRuntime.getNamespace(), Language.class);
      if (language == null) {
        return null;
      }
      String editorClassName = language.getModuleName() + "." + LanguageAspect.EDITOR.getName() + "." + concept.getName() + "_Editor";
      Class<? extends EditorAspect> editorClass = ClassLoaderManager.getInstance().getClass(language, editorClassName);
      if (editorClass == null) {
        return null;
      }
      try {
        Constructor<? extends EditorAspect> cons = editorClass.getConstructor();
        return cons.newInstance();
      } catch (NoSuchMethodException e) {
        LOG.error(e);
      } catch (SecurityException e) {
        LOG.error(e);
      } catch (InstantiationException e) {
        LOG.error(e);
      } catch (IllegalAccessException e) {
        LOG.error(e);
      } catch (InvocationTargetException e) {
        LOG.error(e);
      } catch (IllegalArgumentException e) {
        LOG.error(e);
      } catch (ClassCastException e) {
        LOG.error(e);
      }
      return null;
    }
  }
}
