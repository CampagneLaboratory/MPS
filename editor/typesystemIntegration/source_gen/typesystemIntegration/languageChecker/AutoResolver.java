package typesystemIntegration.languageChecker;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.EditorCheckerAdapter;
import java.util.Set;
import jetbrains.mps.nodeEditor.EditorMessage;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.generator.TransientSModel;
import jetbrains.mps.typesystem.checking.HighlightUtil;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.resolve.ResolverComponent;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.IScope;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.nodeEditor.checking.BaseEditorChecker;
import jetbrains.mps.typesystem.checking.TypesEditorChecker;

public class AutoResolver extends EditorCheckerAdapter {
  public AutoResolver() {
  }

  @Override
  public Set<EditorMessage> createMessages(SNode rootNode, List<SModelEvent> events, boolean wasCheckedOnce, final EditorContext editorContext) {
    Set<EditorMessage> messages = SetSequence.fromSet(new LinkedHashSet<EditorMessage>());
    if (SNodeOperations.getModel(rootNode) == null || SNodeOperations.getModel(rootNode).getModelDescriptor() == null) {
      return messages;
    }
    if (SNodeOperations.getModel(rootNode) instanceof TransientSModel) {
      return messages;
    }
    boolean autoresolve = !(hasUnresolvedImportedModels(SNodeOperations.getModel(rootNode), editorContext));
    if (!(autoresolve)) {
      SetSequence.fromSet(messages).addElement(HighlightUtil.createWarningMessage(rootNode, "Containing model has unresolved model imports. Automatic refrence resolving is switched off to avoid incorrect reference target resolving.", this));
    }
    final Set<SReference> badReferences = collectBadReferences(rootNode);
    for (SReference ref : SetSequence.fromSet(badReferences)) {
      EditorMessage message = HighlightUtil.createHighlighterMessage(ref.getSourceNode(), "Unresolved reference", this, editorContext);
      SetSequence.fromSet(messages).addElement(message);
    }
    if (autoresolve) {
      final IOperationContext operationContext = editorContext.getOperationContext();
      if (operationContext != null) {
        ModelAccess.instance().runWriteInEDT(new Runnable() {
          @Override
          public void run() {
            ModelAccess.instance().runUndoTransparentCommand(new Runnable() {
              @Override
              public void run() {
                // in case this becomes a performance bottleneck, consider reusing the editor's typechecking context  
                ResolverComponent.getInstance().resolveScopesOnly(badReferences, operationContext);
              }
            }, operationContext.getProject());
          }
        });

      }
    }
    return messages;
  }

  private boolean hasUnresolvedImportedModels(SModel model, EditorContext editorContext) {
    if (editorContext == null) {
      return true;
    }
    IScope scope = editorContext.getScope();
    for (SModelReference modelReference : ListSequence.fromList(SModelOperations.getImportedModelUIDs(model))) {
      if (scope.getModelDescriptor(modelReference) == null) {
        return true;
      }
    }
    return false;
  }

  private Set<SReference> collectBadReferences(SNode cellNode) {
    jetbrains.mps.smodel.SReference.disableLogging();
    try {
      Set<SReference> result = SetSequence.fromSet(new LinkedHashSet<SReference>());
      for (SNode node : jetbrains.mps.util.SNodeOperations.getDescendants(cellNode, null, true)) {
        for (SReference ref : SNodeOperations.getReferences(node)) {
          if (jetbrains.mps.util.SNodeOperations.getTargetNodeSilently(ref) == null) {
            SetSequence.fromSet(result).addElement(ref);
          }
        }
      }
      return result;
    } finally {
      jetbrains.mps.smodel.SReference.enableLogging();
    }
  }

  @Override
  public boolean isLaterThan(BaseEditorChecker editorChecker) {
    return editorChecker instanceof TypesEditorChecker;
  }
}
