package typesystemIntegration.languageChecker;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.EditorCheckerAdapter;
import java.util.Set;
import jetbrains.mps.nodeEditor.EditorMessage;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.typesystem.checking.HighlightUtil;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.resolve.ResolverComponent;
import jetbrains.mps.resolve.ReferenceResolverUtils;
import jetbrains.mps.nodeEditor.EditorComponent;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.generator.TransientModelsModule;
import jetbrains.mps.nodeEditor.EditorSettings;
import jetbrains.mps.nodeEditor.checking.BaseEditorChecker;
import jetbrains.mps.typesystem.checking.TypesEditorChecker;
import jetbrains.mps.smodel.event.SModelPropertyEvent;

public class AutoResolver extends EditorCheckerAdapter {
  private boolean myForceAutofix = false;


  public AutoResolver() {
  }

  @Override
  public Set<EditorMessage> createMessages(SNode rootNode, List<SModelEvent> events, boolean wasCheckedOnce, final EditorContext editorContext) {
    Set<EditorMessage> messages = SetSequence.fromSet(new LinkedHashSet<EditorMessage>());
    if (SNodeOperations.getModel(rootNode) == null || SNodeOperations.getModel(rootNode).getModule() == null) {
      return messages;
    }
    // TODO: use same settings as in LanguageEritorChecker 
    boolean autofix = isAutofix(SNodeOperations.getModel(rootNode), editorContext.getRepository());
    final Set<SReference> badReferences = collectBadReferences(rootNode);
    for (SReference ref : SetSequence.fromSet(badReferences)) {
      EditorMessage message = HighlightUtil.createHighlighterMessage(ref.getSourceNode(), "Unresolved reference", this, editorContext);
      SetSequence.fromSet(messages).addElement(message);
    }
    if (autofix) {
      final boolean wasForceAutofix = myForceAutofix;
      myForceAutofix = false;
      final IOperationContext operationContext = editorContext.getOperationContext();
      if (operationContext != null) {
        ModelAccess.instance().runWriteInEDT(new Runnable() {
          @Override
          public void run() {
            ModelAccess.instance().runUndoTransparentCommand(new Runnable() {
              @Override
              public void run() {
                // in case this becomes a performance bottleneck, consider reusing the editor's typechecking context  
                // <node> 
                for (SReference brokenRef : SetSequence.fromSet(badReferences)) {
                  if (!(ResolverComponent.getInstance().resolveScopesOnly(brokenRef, editorContext.getRepository()))) {
                    SNode sourceNode = brokenRef.getSourceNode();
                    if (sourceNode == null) {
                      return;
                    }
                    final String resolveInfo = ReferenceResolverUtils.getResolveInfo(brokenRef, sourceNode);
                    if (resolveInfo == null) {
                      return;
                    }
                    if (!(EditorBasedReferenceResolverUtils.resolveInEditor((EditorComponent) editorContext.getEditorComponent(), sourceNode, resolveInfo, brokenRef.getRole()))) {
                      return;
                    }
                  }
                  if (wasForceAutofix) {
                    // re-running next checker in force autofix mode 
                    myForceAutofix = true;
                  }
                }
              }
            }, operationContext.getProject());
          }
        });
      }
    }
    return messages;
  }

  private Set<SReference> collectBadReferences(SNode cellNode) {
    jetbrains.mps.smodel.SReference.disableLogging();
    try {
      Set<SReference> result = SetSequence.fromSet(new LinkedHashSet<SReference>());
      for (SNode node : jetbrains.mps.util.SNodeOperations.getDescendants(cellNode, null, true)) {
        for (SReference ref : SNodeOperations.getReferences(node)) {
          if (jetbrains.mps.util.SNodeOperations.getTargetNodeSilently(ref) == null) {
            SetSequence.fromSet(result).addElement(ref);
          }
        }
      }
      return result;
    } finally {
      jetbrains.mps.smodel.SReference.enableLogging();
    }
  }

  private boolean isAutofix(SModel model, SRepository repository) {
    return model instanceof EditableSModel && !(model.getModule() instanceof TransientModelsModule) && ReferenceResolverUtils.canExecuteImmediately(model, repository) && (EditorSettings.getInstance().isAutoQuickFix() || myForceAutofix);
  }

  @Override
  public boolean isLaterThan(BaseEditorChecker editorChecker) {
    return editorChecker instanceof TypesEditorChecker;
  }

  @Override
  protected void resetCheckerState() {
    myForceAutofix = true;
    super.resetCheckerState();
  }

  @Override
  protected boolean isPropertyEventDramatical(SModelPropertyEvent event) {
    if (EditorSettings.getInstance().isAutoQuickFix() && "name".equals(event.getPropertyName())) {
      return true;
    }
    return super.isPropertyEventDramatical(event);
  }
}
