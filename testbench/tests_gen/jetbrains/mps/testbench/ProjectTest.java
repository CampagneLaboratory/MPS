package jetbrains.mps.testbench;

/*Generated by MPS */

import jetbrains.mps.testbench.junit.suites.BaseCheckModulesTest;
import java.util.List;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.TestClass;
import org.junit.Test;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SModule;
import org.junit.Rule;
import org.junit.rules.TestWatchman;
import jetbrains.mps.testbench.junit.Order;
import org.junit.Assert;
import jetbrains.mps.internal.collections.runtime.IterableUtils;

public class ProjectTest extends BaseCheckModulesTest {
  private static List<FrameworkMethod> METHODS = new TestClass(ProjectTest.class).getAnnotatedMethods(Test.class);
  private List<FrameworkMethod> methods = new ArrayList<FrameworkMethod>();
  private GenerationResult generationResult;

  public ProjectTest(final SModule module) {
    super(module);
    // todo: introduce @ParameterBefore, @ParameterAfter annotation for that? 
    this.methods.addAll(METHODS);
  }

  @Rule
  public TestWatchman watchman = new TestWatchman() {
    @Override
    public void finished(FrameworkMethod method) {
      methods.remove(method);
      if (methods.size() == 0) {
        generationResult.cleanUp();
      }
    }
  };

  @Test
  @Order(value = 1)
  public void buildModule() throws Exception {
    generationResult = GenerationResult.generateModule(myModule, BaseCheckModulesTest.getContextProject());

    if (!(generationResult.isBuildSucessful())) {
      List<String> errors = generationResult.buildErrors();
      Assert.assertTrue("Build errors:\n" + IterableUtils.join(errors, "\n"), errors.isEmpty());
      List<String> warns = generationResult.buildWarns();
      Assert.assertTrue("Build warnings:\n" + IterableUtils.join(warns, "\n"), warns.isEmpty());
    }
  }

  @Test
  @Order(value = 2)
  public void diffModule() throws Exception {
    List<String> diffReport = generationResult.diff();
    Assert.assertTrue("Difference:\n" + IterableUtils.join(diffReport, "\n"), diffReport.isEmpty());
  }
}
