package jetbrains.mps.testbench;

/*Generated by MPS */

import org.junit.AfterClass;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.TestMode;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.tool.environment.EnvironmentContainer;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.Project;
import java.io.File;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.Generator;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.util.UnzipUtil;
import java.io.IOException;

public abstract class BaseMpsTest {
  /**
   * This is the common way to dispose an environment in tests (which operate {@link jetbrains.mps.tool.environment.Environment } directly)
   * You need to check for the current TestMode to avoid unnecessary environment disposal during tests suite run
   */
  @AfterClass
  public static void tearDownBase() {
    // it is possible we are inside suite run, no need to recreate an environment then 
    if (RuntimeFlags.getTestMode() == TestMode.USUAL) {
      Environment env = EnvironmentContainer.get();
      if (env != null) {
        env.dispose();
      }
    }
  }

  @NotNull
  protected static Environment getEnvironment() {
    Environment env = EnvironmentContainer.get();
    if (env == null) {
      throw new IllegalStateException("No initialized environment is available");
    }
    return env;
  }

  protected static Project openProject(@NotNull File projectFile) {
    return getEnvironment().openProject(projectFile);
  }

  protected static <T extends SModule> T getModule(String moduleFqName, Class<T> cls) {
    SRepository moduleRepository = getEnvironment().getPlatform().getCore().getModuleRepository();
    return new ModuleRepositoryFacade(moduleRepository).getModule(moduleFqName, cls);
  }

  protected static Solution getSolution(String moduleFqName) {
    return getModule(moduleFqName, Solution.class);
  }

  protected static Language getLanguage(String moduleFqName) {
    return getModule(moduleFqName, Language.class);
  }

  protected static Generator getGenerator(String moduleFqName) {
    return getModule(moduleFqName, Generator.class);
  }

  protected static SModel getModel(Project project, String modelName) {
    return project.getScope().resolve(PersistenceFacade.getInstance().createModelReference(modelName));
  }

  /**
   * copies project to some [temporary] destination dir, after that opens it
   */
  protected static Project openClonedProject(File source, final File destinationDir) {
    if (destinationDir.exists()) {
      FileUtil.delete(destinationDir);
    }
    if (source.isDirectory()) {
      FileUtil.copyDir(source, destinationDir);
    } else {
      // it is allowed to have zipped directory here 
      try {
        boolean success = destinationDir.mkdir();
        if (!(success)) {
          throw new IllegalStateException("Could not create dir at the provided destination");
        }
        UnzipUtil.unzip(source, destinationDir);
      } catch (IOException e) {
        throw new RuntimeException("Got error while unzipping the project sources", e);
      }
    }
    return getEnvironment().openProject(destinationDir);
  }

  protected static void closeClonedProject(final Project project, final File destinationDir) {
    Environment env = getEnvironment();
    env.flushAllEvents();
    project.dispose();
    FileUtil.delete(destinationDir);
  }
}
