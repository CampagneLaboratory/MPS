package jetbrains.mps.testbench;

/*Generated by MPS */

import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import jetbrains.mps.tool.environment.EnvironmentUtils;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.Set;
import jetbrains.mps.project.Project;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.tool.environment.ActiveEnvironment;
import jetbrains.mps.ide.IdeMain;
import jetbrains.mps.library.LibraryInitializer;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.idea.IdeaTestApplication;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.ide.ThreadUtils;
import com.intellij.ide.IdeEventQueue;
import jetbrains.mps.TestMain;
import jetbrains.mps.smodel.DefaultModelAccess;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.util.FileUtil;
import java.io.InputStream;
import jetbrains.mps.testbench.junit.suites.ModuleTestSuite;
import java.io.FileOutputStream;
import jetbrains.mps.util.ReadUtil;
import java.io.IOException;
import com.intellij.openapi.project.ex.ProjectManagerEx;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.messages.IMessageHandler;
import jetbrains.mps.logging.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.make.ModuleMaker;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.tool.common.util.PathUtil;
import com.intellij.openapi.application.PathMacros;

public class IdeaEnvironment implements Environment {
  private static final String MISC_XML_URI = "/jetbrains/mps/testbench/junit/runners/misc.xml";

  private void invalidateIdeaCaches() {
    if (!(cachesInvalidated)) {
      if (LOG.isInfoEnabled()) {
        LOG.info("Invalidating caches");
      }
      // <node> 
      cachesInvalidated = true;
    }
  }

  private void setIdeaPluginsToLoad(EnvironmentConfig config) {
    if (isEmptyString(System.getProperty("plugin.path"))) {
      EnvironmentUtils.setPluginPath();
      // Value of this property is comma-separated list of plugin IDs intended to load by platform 
      if (System.getProperty("idea.load.plugins") == null || System.getProperty("idea.load.plugins").equals("false")) {
        System.setProperty("idea.load.plugins.id", IterableUtils.join(config.plugins(), ","));
      }
    }
  }

  private void initMacros(EnvironmentConfig config) {
    for (String macro : MapSequence.fromMap(config.macros()).keySet()) {
      setMacro(macro, MapSequence.fromMap(config.macros()).get(macro));
    }
  }


  private static boolean cachesInvalidated = false;
  private final EnvironmentConfig config;
  private final Set<Project> openedProjects = SetSequence.fromSet(new HashSet<Project>());


  public IdeaEnvironment(EnvironmentConfig config) {
    this.config = config;
    ActiveEnvironment.activateEnvironment(this);
    IdeMain.setTestMode(IdeMain.TestMode.CORE_TEST);
    EnvironmentUtils.setSystemProperties(true);
    setIdeaPluginsToLoad(config);
    invalidateIdeaCaches();

    createIdeaTestApp();

    // TODO: dispose lib contributors like in the MpsEnvironment class TODO: is it the right place? 
    initLibraries();
    initMacros(config);
  }



  private void initLibraries() {
    if (LOG.isInfoEnabled()) {
      LOG.info("Initializing libraries");
    }

    LibraryInitializer.getInstance().addContributor(EnvironmentUtils.createLibContributor(false, config.libs()));
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
          ModelAccess.instance().runWriteAction(new Runnable() {
            public void run() {
              LibraryInitializer.getInstance().update();
            }
          });
        }
      });
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }



  private IdeaTestApplication createIdeaTestApp() {
    if (LOG.isInfoEnabled()) {
      LOG.info("Creating IdeaTestApplication");
    }
    return IdeaTestApplication.getInstance(null);
  }



  @Override
  public EnvironmentConfig getConfig() {
    return config;
  }

  @Override
  public boolean hasIdeaInstance() {
    return true;
  }



  @Override
  public Project openProject(File projectFile) {
    Project project = openProjectInIdeaEnvironment(projectFile);
    return SetSequence.fromSet(openedProjects).addElement(project);
  }

  @Override
  public Project createDummyProject() {
    File dummyProjectFile = createDummyProjectFile();
    Project dummyProject = IdeaEnvironment.openProjectInIdeaEnvironment(dummyProjectFile);
    dummyProjectFile.deleteOnExit();

    SetSequence.fromSet(openedProjects).addElement(dummyProject);
    return dummyProject;
  }



  @Override
  public Iterable<Project> openedProjects() {
    return ListSequence.fromListWithValues(new ArrayList<Project>(), openedProjects);
  }



  @Override
  public void disposeProject(final Project project) {
    ((MPSProject) project).projectClosed();

    // part from ProjectTest 
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        project.dispose();
        IdeEventQueue.getInstance().flushQueue();
        System.gc();
      }
    });
    // comment from ProjectTest: magic 
    ModelAccess.instance().flushEventQueue();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        IdeEventQueue.getInstance().flushQueue();
      }
    });

    SetSequence.fromSet(openedProjects).removeElement(project);
  }

  @Override
  public void disposeEnvironment() {
    // from ModuleTestSuite 
    TestMain.PROJECT_CONTAINER.clear();

    for (Project project : SetSequence.fromSetWithValues(new HashSet<Project>(), openedProjects)) {
      disposeProject(project);
    }

    // todo: fix it in right way 
    ModelAccess.setInstance(new DefaultModelAccess());

    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      @Override
      public void run() {
        ApplicationManager.getApplication().runWriteAction(new Runnable() {
          public void run() {
            IdeaTestApplication.getInstance(null).dispose();
          }
        });
      }
    });

    ActiveEnvironment.deactivateEnvironment(this);
  }



  private File createDummyProjectFile() {
    File projectDir = FileUtil.createTmpDir();
    File dotMps = new File(projectDir, ".mps");
    dotMps.mkdir();
    File projectFile = new File(dotMps, MISC_XML_URI.substring(MISC_XML_URI.lastIndexOf("/") + 1));
    try {
      projectFile.createNewFile();
      InputStream input = ModuleTestSuite.class.getResourceAsStream(MISC_XML_URI);
      FileOutputStream stream = new FileOutputStream(projectFile);
      stream.write(ReadUtil.read(input));
      stream.close();
      input.close();
    } catch (IOException e) {
      e.printStackTrace();
      return null;
    }
    return projectDir;
  }



  /**
   * todo: should be private access
   */
  public static Project openProjectInIdeaEnvironment(File projectFile) {
    if (!(projectFile.exists())) {
      throw new RuntimeException("Can't find project file " + projectFile.getAbsolutePath());
    }
    final ProjectManagerEx projectManager = ProjectManagerEx.getInstanceEx();
    final String filePath = projectFile.getAbsolutePath();
    // this is a workaround for MPS-8840 
    final com.intellij.openapi.project.Project[] project = new com.intellij.openapi.project.Project[1];
    final Throwable[] exc = new Throwable[]{null};
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        try {
          if (LOG.isInfoEnabled()) {
            LOG.info("Load and open the project with path " + filePath);
          }
          project[0] = projectManager.loadAndOpenProject(filePath);
        } catch (Throwable e) {
          exc[0] = e;
        }
      }
    });
    if (project[0] == null) {
      // this actually happens 
      throw new RuntimeException("ProjectManager could not load project from " + projectFile.getAbsolutePath(), exc[0]);
    }
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Set<SModule> moduleSet = SetSequence.fromSet(new HashSet<SModule>());
        SetSequence.fromSet(moduleSet).addSequence(Sequence.fromIterable(MPSModuleRepository.getInstance().getModules()));
        final IMessageHandler logHandler = new IMessageHandler.LogHandler(Logger.wrap(LogManager.getLogger(IdeaEnvironment.class)));
        final ModuleMaker maker = new ModuleMaker(logHandler, MessageKind.INFORMATION);
        maker.make(moduleSet, new EmptyProgressMonitor());
      }
    });
    projectManager.openProject(project[0]);
    return project[0].getComponent(MPSProject.class);
  }



  private void setMacro(String macroName, File file) {
    // todo: move canonicalization logic to EnvironmentBuilder on addMacro, or in utils? 
    String canonicalPath = PathUtil.getCanonicalPath(file.getPath());
    File canonicalFile = new File(canonicalPath);
    if (canonicalFile.exists() && canonicalFile.isDirectory()) {
      PathMacros.getInstance().setMacro(macroName, canonicalPath);
    }
  }

  protected static org.apache.log4j.Logger LOG = LogManager.getLogger(IdeaEnvironment.class);

  private static boolean isEmptyString(String str) {
    return str == null || str.length() == 0;
  }
}
