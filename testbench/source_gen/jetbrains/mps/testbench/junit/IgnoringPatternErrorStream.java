package jetbrains.mps.testbench.junit;

/*Generated by MPS */

import jetbrains.mps.testbench.util.Output;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.regex.Pattern;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.regex.Matcher;

public class IgnoringPatternErrorStream implements Output {
  private static class CompositeStream extends FilterOutputStream {
    private final FilterOutputStream mySecond;

    public CompositeStream(FilterOutputStream first, FilterOutputStream second) {
      super(first);
      mySecond = second;
    }

    @Override
    public void write(int i) throws IOException {
      super.write(i);
      mySecond.write(i);
    }

    @Override
    public void flush() throws IOException {
      super.flush();
      mySecond.flush();
    }

    @Override
    public void write(byte[] array) throws IOException {
      super.write(array);
    }

    @Override
    public void write(byte[] array, int i, int i1) throws IOException {
      super.write(array, i, i1);
    }
  }

  private final List<Pattern> myIgnoredPatterns;
  private ByteArrayOutputStream myByteArrayOutputStream;
  private PrintStream myErrorCachingStream;
  private PrintStream myOldStream;

  public IgnoringPatternErrorStream(List<Pattern> ignoredPatterns) {
    myIgnoredPatterns = ignoredPatterns;
  }

  public void reRoute() {
    System.err.flush();
    myOldStream = System.err;
    myByteArrayOutputStream = new ByteArrayOutputStream();
    myErrorCachingStream = new PrintStream(new IgnoringPatternErrorStream.CompositeStream(myOldStream, new PrintStream(myByteArrayOutputStream)));
    System.setErr(myErrorCachingStream);
  }

  public void reset() {
    myErrorCachingStream.flush();
    System.setErr(myOldStream);
  }

  public void clear() {
    myOldStream = null;
    myByteArrayOutputStream.reset();
  }

  public String getDescription() {
    return "Proxy MPS Error Stream";
  }

  public String getText() {
    return myByteArrayOutputStream.toString();
  }

  public boolean isNotEmpty() {
    String text = getText();
    for (Pattern pattern : myIgnoredPatterns) {
      Matcher m = pattern.matcher(text);
      text = m.replaceAll("");
    }
    return Pattern.compile(".*\\S.*", Pattern.DOTALL).matcher(text).matches();
  }
}
