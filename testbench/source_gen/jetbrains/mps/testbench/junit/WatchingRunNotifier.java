package jetbrains.mps.testbench.junit;

/*Generated by MPS */

import org.apache.log4j.Level;
import java.util.regex.Pattern;
import jetbrains.mps.testbench.util.CachingPrintStream;
import jetbrains.mps.testbench.util.CachingAppender;
import java.util.Map;
import org.junit.runner.Description;
import java.util.HashMap;
import jetbrains.mps.testbench.util.ThreadWatcher;
import org.junit.runner.notification.RunNotifier;
import org.junit.runner.notification.StoppedByUserException;
import org.junit.runner.notification.Failure;
import org.apache.log4j.Logger;

/**
 * fyodor, Aug 18, 2010
 */
public class WatchingRunNotifier extends DelegatingRunNotifier {
  private static final Level DEFAULT_WATCH_LOGGER_LEVEL = Level.ERROR;
  private static final Pattern[] IGNORED_OUTPUT_PATTERNS = new Pattern[]{Pattern.compile("(\\d)* ms execution limit failed for:[^,]*,(\\d*)(\\s)*")};
  private final Level myWatchLevel;
  private final boolean myWatchErrorOutput;

  private final CachingPrintStream myErrorCachingStream = new CachingPrintStream(System.err, "error", IGNORED_OUTPUT_PATTERNS);
  private CachingAppender myCachingAppender;
  private Map<Description, Object> myTestsToIgnore = new HashMap<Description, Object>();
  private ThreadWatcher myThreadWatcher;

  public WatchingRunNotifier(RunNotifier delegate) {
    this(delegate, DEFAULT_WATCH_LOGGER_LEVEL, true);
  }

  public WatchingRunNotifier(RunNotifier delegate, Level watchLevel, boolean watchErrorOutput) {
    super(delegate);
    myWatchLevel = watchLevel;
    myWatchErrorOutput = watchErrorOutput;
  }

  public void dispose() {
  }

  private void reRouteErrorStream() {
    System.err.flush();
    System.setErr(myErrorCachingStream);
    myErrorCachingStream.clear();
    myErrorCachingStream.startCaching();
  }

  private void resetErrorStream() {
    myErrorCachingStream.flush();
    myErrorCachingStream.stopCaching();
    System.setErr(myErrorCachingStream.getOut());
  }

  @Override
  public void fireTestStarted(Description description) throws StoppedByUserException {
    super.fireTestStarted(description);
    try {
      beforeTest(description);
    } catch (Throwable e) {
      super.fireTestFailure(new Failure(description, e));
    }
  }

  @Override
  public void fireTestFinished(Description description) {
    try {
      afterTest(description);
    } catch (Throwable e) {
      super.fireTestFailure(new Failure(description, e));
    }
    super.fireTestFinished(description);
  }

  @Override
  public void fireTestFailure(Failure failure) {
    myTestsToIgnore.put(failure.getDescription(), Boolean.TRUE);
    super.fireTestFailure(failure);
  }

  @Override
  public void fireTestAssumptionFailed(Failure failure) {
    myTestsToIgnore.put(failure.getDescription(), Boolean.TRUE);
    super.fireTestAssumptionFailed(failure);
  }

  @Override
  public void fireTestIgnored(Description description) {
    myTestsToIgnore.put(description, Boolean.TRUE);
    super.fireTestIgnored(description);
  }

  private void beforeTest(Description desc) {
    if (myWatchErrorOutput) {
      reRouteErrorStream();
    }
    myCachingAppender = new CachingAppender(myWatchLevel);
    Logger.getRootLogger().addAppender(myCachingAppender);
    ExpectLogEvent ignoreEvent = desc.getAnnotation(ExpectLogEvent.class);
    if (ignoreEvent != null) {
      for (String text : ignoreEvent.text()) {
        myCachingAppender.expectEvent(ignoreEvent.level(), text);
      }
    }
    myThreadWatcher = new ThreadWatcher(true);
  }

  private void afterTest(Description desc) {
    myThreadWatcher.waitUntilSettled(15000);
    if (myWatchErrorOutput) {
      resetErrorStream();
    }
    myCachingAppender.sealEvents();
    Logger.getRootLogger().removeAppender(myCachingAppender);
    Failure fail = null;
    if (!(myTestsToIgnore.containsKey(desc))) {
      if (myErrorCachingStream.isNotEmpty() || myCachingAppender.isNotEmpty() || myThreadWatcher.isNotEmpty()) {
        fail = new Failure(desc, new UncleanTestExecutionException(myErrorCachingStream, myCachingAppender, myThreadWatcher));
      }
    }
    myErrorCachingStream.clear();
    if (fail != null) {
      super.fireTestFailure(fail);
    }
  }
}
