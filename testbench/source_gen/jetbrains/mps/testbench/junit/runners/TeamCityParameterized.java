package jetbrains.mps.testbench.junit.runners;

/*Generated by MPS */

import org.junit.runners.ParentRunner;
import org.junit.runner.Runner;
import java.util.List;
import org.junit.runners.model.RunnerBuilder;
import java.util.ArrayList;
import org.junit.runner.Description;
import org.junit.runner.notification.RunNotifier;
import jetbrains.mps.testbench.junit.WatchingRunNotifier;
import org.junit.runner.manipulation.Sorter;
import jetbrains.mps.testbench.junit.OrderComparator;
import jetbrains.mps.testbench.PerformanceMessenger;
import org.junit.runners.model.TestClass;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.Parameterized;
import java.lang.reflect.Modifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;

/**
 * + watching
 */
public class TeamCityParameterized extends ParentRunner<Runner> {
  private final List<Runner> children;
  public TeamCityParameterized(Class<?> klass, RunnerBuilder builder) throws Throwable {
    super(klass);
    children = createChildRunners(klass, builder);
  }
  private List<Runner> createChildRunners(Class<?> klass, RunnerBuilder builder) throws Throwable {
    List<Runner> runners = new ArrayList<Runner>();
    List<Object[]> parametersList = getParametersList(getTestClass());
    for (int i = 0; i < parametersList.size(); i++) {
      TeamCityParameterized.TestClassRunnerForParameters runner = new TeamCityParameterized.TestClassRunnerForParameters(getTestClass().getJavaClass(), parametersList, i);
      runners.add(runner);
    }
    return runners;
  }
  protected List<Runner> getChildren() {
    return children;
  }
  protected Description describeChild(Runner child) {
    return child.getDescription();
  }
  protected void runChild(Runner runner, RunNotifier notifier) {
    WatchingRunNotifier runNotifier = new WatchingRunNotifier(notifier);
    try {
      new Sorter(new OrderComparator()).apply(runner);
      runner.run(runNotifier);
    } finally {
      PerformanceMessenger.getInstance().generateReport();
      runNotifier.dispose();
    }
  }
  @SuppressWarnings("unchecked")
  private static List<Object[]> getParametersList(TestClass klass) throws Throwable {
    return (List<Object[]>) getParametersMethod(klass).invokeExplosively(null);
  }
  private static FrameworkMethod getParametersMethod(TestClass testClass) throws Exception {
    List<FrameworkMethod> methods = testClass.getAnnotatedMethods(Parameterized.Parameters.class);
    for (FrameworkMethod each : methods) {
      int modifiers = each.getMethod().getModifiers();
      if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers)) {
        return each;
      }
    }
    throw new Exception("No public static parameters method on class " + testClass.getName());
  }
  private class TestClassRunnerForParameters extends BlockJUnit4ClassRunner {
    private final int fParameterSetNumber;
    private final List<Object[]> fParameterList;
    /*package*/ TestClassRunnerForParameters(Class<?> type, List<Object[]> parameterList, int i) throws InitializationError {
      super(type);
      fParameterList = parameterList;
      fParameterSetNumber = i;
    }
    @Override
    public Object createTest() throws Exception {
      return getTestClass().getOnlyConstructor().newInstance(computeParams());
    }
    private Object[] computeParams() throws Exception {
      try {
        return fParameterList.get(fParameterSetNumber);
      } catch (ClassCastException e) {
        throw new Exception(String.format("%s.%s() must return a Collection of arrays.", getTestClass().getName(), TeamCityParameterized.getParametersMethod(getTestClass()).getName()));
      }
    }
    @Override
    protected String getName() {
      Object firstArg = fParameterList.get(fParameterSetNumber)[0];
      return String.format("%s", String.valueOf(firstArg));
    }
    @Override
    protected String testName(final FrameworkMethod method) {
      return String.format("%s (%s)", method.getName(), fParameterList.get(fParameterSetNumber)[0]);
    }
    @Override
    protected void validateConstructor(List<Throwable> errors) {
      validateOnlyOneConstructor(errors);
    }
    @Override
    protected Statement classBlock(RunNotifier notifier) {
      return childrenInvoker(notifier);
    }
  }
}
