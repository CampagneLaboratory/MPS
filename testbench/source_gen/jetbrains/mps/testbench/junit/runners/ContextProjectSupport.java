package jetbrains.mps.testbench.junit.runners;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.Project;
import org.jetbrains.annotations.Nullable;
import java.io.File;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.tool.environment.ActiveEnvironment;
import java.util.List;
import jetbrains.mps.library.ModulesMiner;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.make.MPSCompilationResult;

public class ContextProjectSupport {
  public static final String PROJECT_PATH_PROPERTY = "mps.junit.project";
  public static final String MODULES_PATHS_PROPERTY = "mps.test.modules";
  public static final String MODULES_ROOT_PROPERTY = "mps.junit.modules.root";

  /**
   * 
   * 
   * @return compiled and reloaded context mps project
   */
  @NotNull
  public static Project loadContextProject() {
    // TODO make three separate classes here 
    final String projectPath = System.getProperty(PROJECT_PATH_PROPERTY);
    if (projectPath != null) {
      return loadProjectFromProjectPath(projectPath);
    }

    final String modulePath = System.getProperty(MODULES_PATHS_PROPERTY);
    if (modulePath != null) {
      return loadProjectFromModulesList(modulePath);
    }

    final String moduleRoot = System.getProperty(MODULES_ROOT_PROPERTY);
    if (moduleRoot != null) {
      return loadProjectFromDirectoryWithModules(moduleRoot);
    }

    throw new IllegalStateException("Could not load context project");
  }

  /**
   * Do not forget set previous context project path after your test!
   * 
   * @return previous context project path
   */
  @Nullable
  public static File setContextProjectPath(@Nullable File projectPath) {
    // todo: create methods like this for modules.root 
    String previous = System.getProperty(PROJECT_PATH_PROPERTY);
    if (projectPath != null) {
      System.setProperty(PROJECT_PATH_PROPERTY, projectPath.getAbsolutePath());
    } else {
      System.clearProperty(PROJECT_PATH_PROPERTY);
    }
    return (previous != null ? new File(previous) : null);
  }

  @NotNull
  private static Project loadProjectFromProjectPath(String projectPath) {
    Environment environment = ActiveEnvironment.getInstance();
    File projectFile = new File(projectPath);
    boolean needNotToMake = environment.isProjectOpened(projectFile);
    final Project openedProject = ActiveEnvironment.getInstance().openProject(projectFile);
    if (needNotToMake) {
      return openedProject;
    } else {
      return makeOnFirstTimeOpened(openedProject);
    }
  }

  @NotNull
  private static Project loadProjectFromDirectoryWithModules(String modulesRootPath) {
    List<ModulesMiner.ModuleHandle> moduleHandles = collectHandles(new File(modulesRootPath));
    return loadProjectFromModuleHandles(moduleHandles);
  }

  @NotNull
  private static Project loadProjectFromModulesList(String modulesString) {
    // todo: merge with "modules collected from dir", or specify here paths to msd/mpl files 
    List<ModulesMiner.ModuleHandle> handles = ListSequence.fromList(new ArrayList<ModulesMiner.ModuleHandle>());
    if ((modulesString == null || modulesString.length() == 0)) {
      return loadProjectFromModuleHandles(handles);
    }
    final String[] modules = modulesString.split(File.pathSeparator);
    for (String modulePath : modules) {
      IFile fileByPath = FileSystem.getInstance().getFileByPath(modulePath);
      ListSequence.fromList(handles).addSequence(ListSequence.fromList(ModulesMiner.getInstance().collectModules(fileByPath, false)));
    }
    return loadProjectFromModuleHandles(handles);
  }

  private static List<ModulesMiner.ModuleHandle> collectHandles(File rootFolder) {
    // todo: remove 
    Set<IFile> excludes = SetSequence.fromSet(new HashSet<IFile>());
    String mpsDir = System.getProperty("user.dir");
    SetSequence.fromSet(excludes).addElement(FileSystem.getInstance().getFileByPath(mpsDir + File.separator + "IdeaPlugin"));
    // todo: end remove 

    List<ModulesMiner.ModuleHandle> minedHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(rootFolder.getAbsolutePath()), excludes, false);
    return ListSequence.fromList(minedHandles).where(new IWhereFilter<ModulesMiner.ModuleHandle>() {
      public boolean accept(ModulesMiner.ModuleHandle it) {
        // temporary ignore .iml files 
        return !(it.getFile().getName().endsWith(".iml"));
      }
    }).toListSequence();
  }

  @NotNull
  private static Project loadProjectFromModuleHandles(final Iterable<ModulesMiner.ModuleHandle> moduleHandles) {
    // todo: check currently opened projects 
    final Project project = ActiveEnvironment.getInstance().createDummyProject();
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        for (ModulesMiner.ModuleHandle moduleHandle : Sequence.fromIterable(moduleHandles)) {
          SModule module = ModuleRepositoryFacade.createModule(moduleHandle, project);
          project.addModule(module.getModuleReference());
        }
      }
    });

    return makeOnFirstTimeOpened(project);
  }

  @NotNull
  private static Project makeOnFirstTimeOpened(@NotNull Project project) {
    // todo: check result of making, throw checked MakeException 
    MPSCompilationResult mpsCompilationResult = MpsTestsSupport.makeAllInCreatedEnvironment();
    try {
      MpsTestsSupport.reloadAllAfterMake(mpsCompilationResult);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
    return project;
  }
}
