package jetbrains.mps.testbench.junit.runners;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.vfs.IFile;
import java.util.HashSet;
import jetbrains.mps.vfs.FileSystem;
import java.io.File;
import jetbrains.mps.tool.environment.Environment;
import java.util.ArrayList;
import org.junit.runner.Runner;
import jetbrains.mps.tool.environment.EnvironmentBuilder;
import java.util.List;
import org.junit.runners.model.Statement;
import java.util.Collection;
import jetbrains.mps.library.ModulesMiner;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.smodel.BaseMPSModuleOwner;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.progress.EmptyProgressMonitor;
import org.junit.runners.model.MultipleFailureException;

/**
 * Use this type @RunWith() carefully. Better specify project with MPSOpenProjectSuite (but i'm not sure that MPSOpenProjectSuite works).
 */
public class WatchingParameterizedWithAllModules extends WatchingParameterized {
  private static final String[] excludes = new String[]{"IdeaPlugin"};
  private static final Set<IFile> excludeSet = new HashSet<IFile>();
  static {
    String mpsDir = System.getProperty("user.dir");
    for (String e : excludes) {
      excludeSet.add(FileSystem.getInstance().getFileByPath(mpsDir + File.separator + e));
    }
  }

  private Environment myEnvironment;
  private ArrayList<Runner> myRunners;

  public WatchingParameterizedWithAllModules(Class<?> clazz) throws Throwable {
    super(clazz);

    myEnvironment = EnvironmentBuilder.defaultEnvironment().build(true);
    myEnvironment.createDummyProject();
    loadAllModulesIntoRepository();
  }

  @Override
  protected List<Runner> getChildren() {
    if (myRunners == null) {
      myRunners = new ArrayList<Runner>();
      myRunners.add(new MakeRunner(getTestClass().getJavaClass()));
      myRunners.addAll(super.getChildren());
    }
    return myRunners;
  }

  @Override
  protected Statement withAfterClasses(Statement statement) {
    return new WatchingParameterizedWithAllModules.DisposeEnvironmentStatement(super.withAfterClasses(statement));
  }



  private static void loadModules(final Collection<ModulesMiner.ModuleHandle> handles) {
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
          ModelAccess.instance().runWriteAction(new Runnable() {
            public void run() {
              MPSModuleOwner mpsModuleOwner = new BaseMPSModuleOwner() {};
              for (ModulesMiner.ModuleHandle handle : handles) {
                if (handle.getFile().getName().endsWith(".iml")) {
                  // temporary ignore .iml files 
                  continue;
                }
                ModuleRepositoryFacade.createModule(handle, mpsModuleOwner);
              }
              ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
            }
          });
        }
      });
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  private static void loadAllModulesIntoRepository() {
    loadModules(ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty("user.dir")), getExcludeSet(), false));
  }

  public static Set<IFile> getExcludeSet() {
    Set<IFile> copy = new HashSet<IFile>();
    copy.addAll(excludeSet);
    return copy;
  }

  private class DisposeEnvironmentStatement extends Statement {
    private Statement myPrev;

    public DisposeEnvironmentStatement(Statement prev) {
      myPrev = prev;
    }

    public void evaluate() throws Throwable {
      List<Throwable> errors = new ArrayList<Throwable>();
      try {
        if (myPrev != null) {
          myPrev.evaluate();
        }
      } catch (Throwable th) {
        errors.add(th);
      } finally {
        try {
          myEnvironment.disposeEnvironment();
        } catch (Throwable th) {
          errors.add(th);
        }
      }
      MultipleFailureException.assertEmpty(errors);
    }
  }
}
