package jetbrains.mps.testbench.junit.runners;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.vfs.IFile;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.idea.LoggerFactory;
import java.util.HashSet;
import jetbrains.mps.vfs.FileSystem;
import java.io.File;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import jetbrains.mps.MPSCore;
import jetbrains.mps.tool.environment.ActiveEnvironment;
import jetbrains.mps.testbench.IdeaEnvironment;
import jetbrains.mps.tool.environment.MpsEnvironment;
import jetbrains.mps.make.MPSCompilationResult;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.Computable;
import jetbrains.mps.make.ModuleMaker;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.progress.EmptyProgressMonitor;
import java.lang.reflect.InvocationTargetException;
import jetbrains.mps.classloading.ClassLoaderManager;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.AbstractModule;
import javax.swing.SwingUtilities;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.vfs.LocalFileSystem;
import jetbrains.mps.library.ModulesMiner;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Collection;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.smodel.BaseMPSModuleOwner;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import org.apache.log4j.LogManager;

public class MpsTestsSupport {
  private static final String[] EXCLUDES = new String[]{"IdeaPlugin"};
  private static final Set<IFile> EXCLUDE_SET = createExcludesSet();
  static {
    initLoggingSystem();
  }


  private static void initLoggingSystem() {
    Logger.setFactory(LoggerFactory.class);
    assert Logger.isInitialized();
    Logger.getInstance("");
  }



  private static Set<IFile> createExcludesSet() {
    Set<IFile> excludesSet = new HashSet<IFile>();
    String userDir = System.getProperty("user.dir");
    for (String e : EXCLUDES) {
      excludesSet.add(FileSystem.getInstance().getFileByPath(userDir + File.separator + e));
    }
    return excludesSet;
  }



  /**
   * 
   * 
   * @return created environment iff there is no active environment currently, do not forget dispose created environment in this case!, null if active environment is satisfies condition
   */
  public static Environment initEnv(boolean withIdea, EnvironmentConfig config) {
    if (LOG.isInfoEnabled()) {
      LOG.info("Initializing environment");
    }
    MPSCore.getInstance().setTestMode(true);
    Environment currentEnv = ActiveEnvironment.getInstance();
    if (currentEnv == null) {
      currentEnv = (withIdea ? new IdeaEnvironment(config) : new MpsEnvironment(config));
    }
    if (withIdea) {
      assert currentEnv.hasIdeaInstance() : "Active environment has not idea instance";
    }
    return currentEnv;
  }



  public static Environment initEnv(boolean withIdea) {
    return initEnv(withIdea, EnvironmentConfig.defaultEnvironment());
  }



  public static MPSCompilationResult makeAllInCreatedEnvironment() {
    if (LOG.isInfoEnabled()) {
      LOG.info("Making modules within environment");
    }
    assert ActiveEnvironment.getInstance() != null;
    return ModelAccess.instance().runReadAction(new Computable<MPSCompilationResult>() {
      public MPSCompilationResult compute() {
        return new ModuleMaker().make(IterableUtil.asCollection(MPSModuleRepository.getInstance().getModules()), new EmptyProgressMonitor());
      }
    });
  }



  public static MPSCompilationResult makeAllWithoutEnvironment() {
    assert ActiveEnvironment.getInstance() == null;
    Environment createdEnv = MpsTestsSupport.initEnv(false);
    MpsTestsSupport.loadAllModulesIntoRepository();
    MPSCompilationResult result = MpsTestsSupport.makeAllInCreatedEnvironment();
    createdEnv.dispose();
    return result;
  }



  public static void reloadAllAfterMake() throws InterruptedException, InvocationTargetException {
    // TODO: refactor 
    if (LOG.isInfoEnabled()) {
      LOG.info("Reloading classes");
    }

    // why we need it? because some classes loaded before maker - LanguageRuntime and TypeSystem classes 
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
      }
    });

    // Danya: added re-load of all changed (or new) models after make. 
    // The problem was: I had a stub model whose source was the classes_gen dir 
    // of a module. That classes_gen got populated only during make. But by that time 
    // model repository had already been filled and obviously it didn't have those stub models 
    // as there were no class files there at the moment yet. 
    ModelAccess.instance().runWriteAction(new Runnable() {
      @Override
      public void run() {
        for (SModule mod : MPSModuleRepository.getInstance().getModules()) {
          if (!(mod instanceof AbstractModule)) {
            continue;
          }
          ((AbstractModule) mod).updateModelsSet();
        }
      }
    });

    if (ActiveEnvironment.getInstance().hasIdeaInstance()) {
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
          ApplicationManager.getApplication().runWriteAction(new Runnable() {
            @Override
            public void run() {
              LocalFileSystem.getInstance().refresh(false);
            }
          });
        }
      });
    } else {
      // update all stubs or maybe everything what depends on make should listen core MakeService? 
    }
  }



  private static void loadAllModulesIntoRepository() {
    loadModules(ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty("user.dir")), SetSequence.fromSetWithValues(new HashSet<IFile>(), EXCLUDE_SET), false));
  }



  private static void loadModules(final Collection<ModulesMiner.ModuleHandle> handles) {
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
          ModelAccess.instance().runWriteAction(new Runnable() {
            public void run() {
              MPSModuleOwner mpsModuleOwner = new BaseMPSModuleOwner();
              for (ModulesMiner.ModuleHandle handle : handles) {
                if (handle.getFile().getName().endsWith(".iml")) {
                  // temporary ignore .iml files 
                  continue;
                }
                ModuleRepositoryFacade.createModule(handle, mpsModuleOwner);
              }
              ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
            }
          });
        }
      });
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }


  protected static org.apache.log4j.Logger LOG = LogManager.getLogger(MpsTestsSupport.class);
}
