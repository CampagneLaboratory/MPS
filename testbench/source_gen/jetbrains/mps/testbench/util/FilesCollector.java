package jetbrains.mps.testbench.util;

/*Generated by MPS */

import java.io.File;
import java.util.Map;
import java.util.Set;
import java.util.HashMap;
import com.intellij.openapi.util.Pair;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.types.FileSet;
import java.util.Iterator;
import org.apache.tools.ant.types.resources.FileResource;
import java.util.regex.Pattern;
import com.intellij.openapi.util.io.FileUtil;

/**
 * fyodor, Aug 27, 2010
 */
public class FilesCollector {
  public FilesCollector() {
  }

  public static Iterable<File> collectFiles(Iterable<FilesCollector.FilePattern> filePtns, Iterable<File> path) {
    Map<File, Set<String>> includePathsMap = new HashMap<File, Set<String>>();
    Map<File, Set<String>> excludePathsMap = new HashMap<File, Set<String>>();
    for (FilesCollector.FilePattern fp : filePtns) {
      FilesCollector.PatternFileSearcher pfs = new FilesCollector.PatternFileSearcher(fp.filePtn, path);
      for (Pair<File, String> pear : pfs.getRelativePaths()) {
        Map<File, Set<String>> pathsMap = (fp.include ?
          includePathsMap :
          excludePathsMap
        );
        Set<String> paths = pathsMap.get(pear.getFirst());
        if (paths == null) {
          paths = new HashSet<String>();
          pathsMap.put(pear.getFirst(), paths);
        }
        paths.add(pear.getSecond());
      }
    }
    final List<File> files = new ArrayList<File>();
    for (Map.Entry<File, Set<String>> en : includePathsMap.entrySet()) {
      Set<String> include = en.getValue();
      Set<String> exclude = excludePathsMap.get(en.getKey());
      if (exclude != null) {
        include.removeAll(exclude);
      }
      for (String p : include) {
        files.add(new File(p));
      }
    }
    return Collections.unmodifiableCollection(files);
  }

  public static Iterable<File> fastCollectFiles(Iterable<FilesCollector.FilePattern> filePtns, Iterable<File> path) {
    Project p = new Project();
    ArrayList<File> res = new ArrayList<File>();
    for (File dir : path) {
      FileSet fs = new FileSet();
      fs.setProject(p);
      fs.setDir(dir);
      for (FilesCollector.FilePattern fp : filePtns) {
        ((fp.include ?
          fs.createInclude() :
          fs.createExclude()
        )).setName(fp.filePtn);
      }
      for (Iterator it = fs.iterator(); it.hasNext();) {
        res.add(((FileResource) it.next()).getFile());
      }
    }
    return res;
  }

  public static class FilePattern {
    public static     enum Type {
      INCLUDE(),
      EXCLUDE();

      Type() {
      }
    }

    public final boolean include;
    public final String filePtn;

    private FilePattern(boolean include, String filePtn) {
      this.include = include;
      this.filePtn = filePtn;
    }

    public static FilesCollector.FilePattern fromTypeAndPattern(Object[] objs) {
      FilesCollector.FilePattern.Type t = (FilesCollector.FilePattern.Type) objs[0];
      boolean include = (t == FilesCollector.FilePattern.Type.INCLUDE);
      return new FilesCollector.FilePattern(include, (String) objs[1]);
    }

    public String toString() {
      return ((include ?
        FilesCollector.FilePattern.Type.INCLUDE.toString() :
        FilesCollector.FilePattern.Type.EXCLUDE.toString()
      )) + " " + filePtn;
    }
  }

  private static class PatternFileSearcher {
    private String pattern;
    private Iterable<File> sourcePath;

    public PatternFileSearcher(String pattern, Iterable<File> sourcePath) {
      this.sourcePath = sourcePath;
      this.pattern = pattern;
    }

    public Iterable<Pair<File, String>> getRelativePaths() {
      Pattern ptn = Pattern.compile(FileUtil.convertAntToRegexp(pattern));
      List<Pair<File, String>> res = new ArrayList<Pair<File, String>>();
      for (File spd : sourcePath) {
        List<File> files = new ArrayList<File>();
        FileUtil.collectMatchedFiles(spd, ptn, files);
        for (File match : files) {
          res.add(new Pair<File, String>(spd, FileUtil.getRelativePath(spd, match)));
        }
      }
      return Collections.unmodifiableList(res);
    }
  }
}
