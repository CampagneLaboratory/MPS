package jetbrains.mps.testbench.util;

/*Generated by MPS */

import java.io.PrintStream;
import java.util.List;
import java.util.regex.Pattern;
import java.io.OutputStream;
import java.io.IOException;

/**
 * fyodor, Aug 18, 2010
 */
public class CachingPrintStream extends PrintStream implements Output {
  private static final int LS_BYTES = System.getProperty("line.separator").getBytes().length;

  private List<Pattern> myIgnoredOutputPatterns = null;
  private int myByteCount = 0;
  private StringBuilder myBuffer = new StringBuilder();
  private String myName;
  private boolean myCachingFlag;

  public CachingPrintStream(OutputStream out, String name) {
    super(out);
    myName = name;
  }

  public CachingPrintStream(OutputStream out, String name, List<Pattern> ignoredOutputPatterns) {
    this(out, name);
    myIgnoredOutputPatterns = ignoredOutputPatterns;
  }

  public PrintStream getOut() {
    return (PrintStream) out;
  }

  public void startCaching() {
    if (myCachingFlag) {
      throw new IllegalStateException("Already caching");
    }
    myCachingFlag = true;
  }

  public void stopCaching() {
    if (!(myCachingFlag)) {
      throw new IllegalStateException("Not caching");
    }
    myCachingFlag = false;
  }

  public void clear() {
    if (myCachingFlag) {
      throw new IllegalStateException("Currently caching");
    }
    myBuffer.setLength(0);
    myByteCount = 0;
  }

  @Override
  public synchronized boolean isNotEmpty() {
    if (myIgnoredOutputPatterns != null && myByteCount > 0) {
      String bufferContents = getText();
      for (Pattern nextPattern : myIgnoredOutputPatterns) {
        if (nextPattern.matcher(bufferContents).matches()) {
          return false;
        }
      }
    }
    return myByteCount > 0;
  }

  @Override
  public synchronized String getDescription() {
    return myByteCount + " bytes in " + myName;
  }

  @Override
  public synchronized String getText() {
    return myBuffer.toString();
  }

  public synchronized int getBytesCount() {
    return myByteCount;
  }

  public synchronized String getBuffer() {
    return myBuffer.toString();
  }

  @Override
  public synchronized void flush() {
    super.flush();
  }

  @Override
  public synchronized void close() {
    super.close();
  }

  @Override
  public synchronized void write(int buf) {
    if (myCachingFlag) {
      myByteCount++;
      myBuffer.append((char) buf);
    }
    super.write(buf);
  }

  @Override
  public synchronized void write(byte[] buf) throws IOException {
    if (myCachingFlag) {
      myByteCount += LS_BYTES;
      myBuffer.append(new String(buf));
    }
    super.write(buf);
  }

  @Override
  public synchronized void write(byte[] buf, int off, int len) {
    if (myCachingFlag) {
      myByteCount += len;
      myBuffer.append(new String(buf, off, len));
    }
    super.write(buf, off, len);
  }

  @Override
  public synchronized void print(boolean b) {
    if (myCachingFlag) {
      myByteCount += String.valueOf(b).getBytes().length;
    }
    super.print(b);
  }

  @Override
  public synchronized void print(char c) {
    if (myCachingFlag) {
      myByteCount += String.valueOf(c).getBytes().length;
    }
    super.print(c);
  }

  @Override
  public synchronized void print(int i) {
    if (myCachingFlag) {
      myByteCount += String.valueOf(i).getBytes().length;
    }
    super.print(i);
  }

  @Override
  public synchronized void print(long l) {
    if (myCachingFlag) {
      myByteCount += String.valueOf(l).getBytes().length;
    }
    super.print(l);
  }

  @Override
  public synchronized void print(float f) {
    if (myCachingFlag) {
      myByteCount += String.valueOf(f).getBytes().length;
    }
    super.print(f);
  }

  @Override
  public synchronized void print(double d) {
    if (myCachingFlag) {
      myByteCount += String.valueOf(d).getBytes().length;
    }
    super.print(d);
  }

  @Override
  public synchronized void print(char[] s) {
    if (myCachingFlag) {
      myByteCount += String.copyValueOf(s).getBytes().length;
    }
    super.print(s);
  }

  @Override
  public synchronized void print(String s) {
    if (myCachingFlag) {
      myByteCount += String.valueOf(s).getBytes().length;
    }
    super.print(s);
  }

  private void addByteCountForNewLine() {
    if (myCachingFlag) {
      myByteCount += LS_BYTES;
    }
  }

  @Override
  public synchronized void print(Object obj) {
    addByteCountForNewLine();
    super.print(obj);
  }
  @Override
  public synchronized void println() {
    addByteCountForNewLine();
    super.println();
  }

  @Override
  public synchronized void println(boolean x) {
    addByteCountForNewLine();
    super.println(x);
  }

  @Override
  public synchronized void println(char x) {
    addByteCountForNewLine();
    super.println(x);
  }

  @Override
  public synchronized void println(int x) {
    addByteCountForNewLine();
    super.println(x);
  }

  @Override
  public synchronized void println(long x) {
    addByteCountForNewLine();
    super.println(x);
  }

  @Override
  public synchronized void println(float x) {
    addByteCountForNewLine();
    super.println(x);
  }

  @Override
  public synchronized void println(double x) {
    addByteCountForNewLine();
    super.println(x);
  }

  @Override
  public synchronized void println(char[] x) {
    addByteCountForNewLine();
    super.println(x);
  }

  @Override
  public synchronized void println(String x) {
    addByteCountForNewLine();
    super.println(x);
  }

  @Override
  public synchronized void println(Object x) {
    addByteCountForNewLine();
    super.println(x);
  }
}
