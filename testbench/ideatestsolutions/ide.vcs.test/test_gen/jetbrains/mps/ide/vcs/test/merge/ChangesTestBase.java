package jetbrains.mps.ide.vcs.test.merge;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import com.intellij.openapi.vcs.changes.ChangeListManagerImpl;
import jetbrains.mps.vcs.changesmanager.CurrentDifference;
import com.intellij.openapi.vcs.AbstractVcs;
import org.junit.BeforeClass;
import jetbrains.mps.testbench.junit.runners.MpsTestsSupport;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import jetbrains.mps.smodel.SReference;
import com.intellij.openapi.util.registry.Registry;
import jetbrains.mps.tool.environment.ActiveEnvironment;
import java.io.File;
import jetbrains.mps.ide.platform.watching.FSChangesWatcher;
import org.junit.AfterClass;
import jetbrains.mps.testbench.junit.runners.ProjectTestsSupport;
import org.junit.Before;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import com.intellij.openapi.vcs.impl.projectlevelman.AllVcses;
import com.intellij.openapi.vcs.VcsShowConfirmationOption;
import javax.swing.SwingUtilities;
import com.intellij.openapi.vcs.FileStatusManager;
import java.lang.reflect.InvocationTargetException;
import org.junit.After;
import jetbrains.mps.nodeEditor.InspectorTool;
import org.junit.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import com.intellij.openapi.vcs.VcsConfiguration;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.vcs.diff.ChangeSet;
import jetbrains.mps.vcs.diff.ChangeSetBuilder;
import jetbrains.mps.vcs.changesmanager.NodeFileStatusMapping;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vcs.changes.Change;
import java.util.List;
import com.intellij.openapi.vcs.VcsException;
import java.util.ArrayList;
import java.util.Arrays;
import com.intellij.openapi.vcs.rollback.RollbackProgressListener;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.extapi.persistence.FileDataSource;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.persistence.PersistenceRegistry;

public abstract class ChangesTestBase {
  protected static Project ourProject;
  protected static boolean ourEnabled;

  protected com.intellij.openapi.project.Project myIdeaProject;
  protected ChangesManagerTestWaitHelper myWaitHelper;

  protected ChangeListManagerImpl myChangeListManager;
  protected CurrentDifference myDiff;
  protected AbstractVcs myGitVcs;

  public ChangesTestBase() {
    // todo add group changes tests 
  }

  @BeforeClass
  public static void setUp() {
    MpsTestsSupport.initEnv(true, EnvironmentConfig.emptyEnvironment().withBootstrapLibraries().addPlugin("Git4Idea").addPlugin("jetbrains.mps.vcs").addPlugin("jetbrains.mps.ide.make"));

    SReference.disableLogging();
    Registry.get("vcs.showConsole").setValue(false);

    ourProject = ActiveEnvironment.getInstance().openProject(new File("."));
    FSChangesWatcher.instance().initComponent(true);
  }
  @AfterClass
  public static void tearDown() {
    ProjectTestsSupport.waitUntilAllEventsFlushed();
    ActiveEnvironment.getInstance().disposeProject(ourProject.getProjectFile());
  }
  @Before
  public void init() {
    myIdeaProject = ProjectHelper.toIdeaProject(ourProject);
    CurrentDifferenceRegistry.getInstance(myIdeaProject).getCommandQueue().setHadExceptions(false);
    myWaitHelper = new ChangesManagerTestWaitHelper(myIdeaProject);
    myWaitHelper.waitForChangesManager();

    myGitVcs = AllVcses.getInstance(myIdeaProject).getByName("Git");
    assert myGitVcs != null;

    myDiff = CurrentDifferenceRegistry.getInstance(myIdeaProject).getCurrentDifference((getTestModel()));
    myChangeListManager = ChangeListManagerImpl.getInstanceImpl(myIdeaProject);
    setAutoaddPolicy(VcsShowConfirmationOption.Value.DO_NOTHING_SILENTLY);

    if (!(ChangesTestBase.ourEnabled)) {
      myChangeListManager.ensureUpToDate(false);
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
            FileStatusManager.getInstance(myIdeaProject).fileStatusesChanged();
          }
        });
      } catch (InterruptedException e) {
        throw new AssertionError(e);
      } catch (InvocationTargetException e) {
        throw new AssertionError(e);
      }

      checkAndEnable();
      ChangesTestBase.ourEnabled = true;
    }
  }
  @After
  public void after() throws InvocationTargetException, InterruptedException {
    revertMemChangesAndWait();
    SwingUtilities.invokeAndWait(new Runnable() {
      public void run() {
        myIdeaProject.getComponent(InspectorTool.class).getInspector().editNode(null);
      }
    });
    Assert.assertFalse(CurrentDifferenceRegistry.getInstance(myIdeaProject).getCommandQueue().hadExceptions());
    myWaitHelper.dispose();
  }

  protected void checkAndEnable() {
    Assert.assertNull(myDiff.getChangeSet());

    myDiff.setEnabled(true);
    myWaitHelper.waitForChangesManager();

    Assert.assertTrue(ListSequence.fromList(check_l1nwgz_a0a5a71(myDiff.getChangeSet())).isNotEmpty());
  }

  protected void setAutoaddPolicy(VcsShowConfirmationOption.Value value) {
    ProjectLevelVcsManager vcsManager = ProjectLevelVcsManager.getInstance(myIdeaProject);
    vcsManager.getStandardConfirmation(VcsConfiguration.StandardConfirmation.ADD, myGitVcs).setValue(value);
  }

  protected void testChanges(Runnable change) {
    makeChangeAndWait(change);

    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ChangeSet cs = myDiff.getChangeSet();
        ChangeSet rebuiltChangeSet = ChangeSetBuilder.buildChangeSet(cs.getOldModel(), cs.getNewModel());
        Assert.assertEquals(getChangeSetString(rebuiltChangeSet), getChangeSetString(cs));
      }
    });
  }

  protected void makeChangeAndWait(Runnable change) {
    ProjectHelper.toMPSProject(myIdeaProject).getRepository().getModelAccess().executeCommandInEDT(change);

    ModelAccess.instance().flushEventQueue();
    myWaitHelper.waitForChangesManager();
  }

  protected void checkRootStatuses(final RootStatusItem... statuses) {
    final NodeFileStatusMapping fsm = myIdeaProject.getComponent(NodeFileStatusMapping.class);
    final SModel model = myDiff.getModelDescriptor();
    // query for first time 
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ListSequence.fromList(SModelOperations.roots(model, null)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode r) {
            fsm.getStatus(r);
          }
        });
      }
    });
    // wait while statuses update 
    myWaitHelper.waitForChangesManager();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ListSequence.fromList(SModelOperations.roots(model, null)).visitAll(new IVisitor<SNode>() {
          public void visit(final SNode r) {
            FileStatus actual = fsm.getStatus(r);
            FileStatus expected = check_l1nwgz_a0b0a0a0a0g0z(Sequence.fromIterable(Sequence.fromArray(statuses)).findFirst(new IWhereFilter<RootStatusItem>() {
              public boolean accept(RootStatusItem it) {
                return it.rootName().equals(r.getName());
              }
            }));
            if (expected == null) {
              expected = FileStatus.NOT_CHANGED;
            }
            Assert.assertSame(expected, actual);
          }
        });
      }
    });
  }

  protected void revertMemChangesAndWait() {
    getTestModel().reloadFromSource();
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_l1nwgz_a0a2a72(myDiff.getChangeSet())).isEmpty());
  }

  protected void revertDiskChangesAndWait(VirtualFile modelFile) {
    Change modelFileChange = myChangeListManager.getChange(modelFile);
    List<VcsException> exceptions = ListSequence.fromList(new ArrayList<VcsException>());
    myGitVcs.getRollbackEnvironment().rollbackChanges(Arrays.asList(modelFileChange), exceptions, RollbackProgressListener.EMPTY);
    Assert.assertTrue(ListSequence.fromList(exceptions).isEmpty());

    myWaitHelper.waitForFileStatusChange(modelFile, FileStatus.MODIFIED);
    myWaitHelper.waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_l1nwgz_a0a7a92(myDiff.getChangeSet())).isEmpty());
  }

  protected EditableSModel getTestModel() {
    return (EditableSModel) SModelRepository.getInstance().getModelDescriptor("jetbrains.mps.ide.vcs.test.testModel");
  }

  protected VirtualFile getTestModelFile() {
    return VirtualFileUtils.getVirtualFile(((FileDataSource) getTestModel().getSource()).getFile());
  }

  protected String getChangeSetString(ChangeSet changeSet) {
    return getChangeSetString(changeSet.getModelChanges());
  }

  protected String getChangeSetString(List<ModelChange> modelChanges) {
    return IterableUtils.join(ListSequence.fromList(modelChanges).select(new ISelector<ModelChange, String>() {
      public String select(ModelChange c) {
        return c.toString();
      }
    }).sort(new ISelector<String, String>() {
      public String select(String s) {
        return s;
      }
    }, true), "|");
  }

  public String getDefaultExt() {
    return PersistenceRegistry.getInstance().getDefaultModelFactory().getFileExtension();
  }
  private static List<ModelChange> check_l1nwgz_a0a5a71(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static FileStatus check_l1nwgz_a0b0a0a0a0g0z(RootStatusItem checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.status();
    }
    return null;
  }
  private static List<ModelChange> check_l1nwgz_a0a2a72(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
  private static List<ModelChange> check_l1nwgz_a0a7a92(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
}
