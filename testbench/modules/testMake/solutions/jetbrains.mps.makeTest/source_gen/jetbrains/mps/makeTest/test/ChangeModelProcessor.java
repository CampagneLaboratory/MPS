package jetbrains.mps.makeTest.test;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import jetbrains.mps.extapi.model.EditableSModel;
import jetbrains.mps.generator.generationTypes.IGenerationHandler;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.make.MPSCompilationResult;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.make.ModuleMaker;
import java.util.Collections;
import jetbrains.mps.progress.EmptyProgressMonitor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.messages.IMessageHandler;
import jetbrains.mps.messages.IMessage;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.generator.GenerationFacade;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.project.ModuleContext;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.generator.GenerationOptions;
import jetbrains.mps.ide.generator.TransientModelsComponent;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.smodel.SModelFileTracker;
import jetbrains.mps.smodel.SModelInternal;

public class ChangeModelProcessor {
  private static final String TEST_RESOURCES_PATH = "core/kernel/testMake/solutions/jetbrains.mps.testModels/jetbrains/mps/testModels/";
  private static final String STEP_TYPE_CHANGE = "changed";
  private static final String STEP_TYPE_REVERT = "reverted";
  private Project myProject;
  private EditableSModel myTestModel;
  private EditableSModel myModelToChange;
  private ChangeModel myChangeModel;

  public ChangeModelProcessor(Project project, String baseModelName, ChangeModel changeModel) {
    this.myProject = project;
    this.myTestModel = ((EditableSModel) this.getModelDescriptorByName(baseModelName + '1'));
    this.myModelToChange = ((EditableSModel) this.getModelDescriptorByName(baseModelName + '2'));
    this.myChangeModel = changeModel;
  }

  public boolean changeStep(IGenerationHandler generationHandler) {
    final SModel modelToChange = this.getModelToChange();
    return this.step(new Runnable() {
      public void run() {
        ChangeModelProcessor.this.myChangeModel.change(modelToChange);
      }
    }, STEP_TYPE_CHANGE, generationHandler);
  }

  public boolean revertStep(IGenerationHandler generationHandler) {
    final SModel modelToChange = this.getModelToChange();
    return this.step(new Runnable() {
      public void run() {
        ChangeModelProcessor.this.myChangeModel.change(modelToChange);
      }
    }, STEP_TYPE_REVERT, generationHandler);
  }

  private boolean step(final Runnable runnable, String type, IGenerationHandler generationHandler) {
    this.generateModelToChange(generationHandler);
    final MPSCompilationResult[] cr = new MPSCompilationResult[]{null};
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        cr[0] = new ModuleMaker().make(Collections.singleton(ChangeModelProcessor.this.myTestModel.getModule()), new EmptyProgressMonitor());
      }
    });
    if (cr[0].isOk()) {
      System.out.println("No compilation problem");
    } else {
      System.out.println("Compilation failed");
    }
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        runnable.run();
      }
    });
    System.out.println("Model " + this.myModelToChange.getModelName() + " " + type);
    return cr[0].isOk();
  }

  public List<String> generateTestModel(IGenerationHandler generationHandler) {
    return this.generate(this.myTestModel, generationHandler);
  }

  public List<String> generateModelToChange(IGenerationHandler generationHandler) {
    return this.generate(this.myModelToChange, generationHandler);
  }

  private List<String> generate(EditableSModel model, IGenerationHandler generationHandler) {
    final List<String> results = ListSequence.fromList(new ArrayList<String>());
    List<EditableSModel> models = Collections.singletonList(model);
    IMessageHandler handler = new IMessageHandler() {
      @Override
      public void handle(IMessage msg) {
        if (msg.getKind() == MessageKind.ERROR) {
          ListSequence.fromList(results).addElement(msg.getText());
        }
      }

      @Override
      public void clear() {
      }
    };
    GenerationFacade.generateModels(this.myProject.getComponent(MPSProject.class), models, new ModuleContext(model.getModule(), ProjectHelper.toMPSProject(this.myProject)), generationHandler, new EmptyProgressMonitor(), handler, GenerationOptions.getDefaults().create(), this.myProject.getComponent(TransientModelsComponent.class));
    return results;
  }

  public SModel getModelDescriptorByName(String name) {
    String path = TEST_RESOURCES_PATH + name + ".mps";
    IFile file = FileSystem.getInstance().getFileByPath(path);
    return SModelFileTracker.getInstance().findModel(file);
  }

  public SModel getTestModel() {
    return this.getModel(this.myTestModel);
  }

  public SModel getModelToChange() {
    return this.getModel(this.myModelToChange);
  }

  private SModel getModel(final SModel modelDescriptor) {
    final SModel[] model = new SModel[]{null};
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        model[0] = ((SModelInternal) modelDescriptor).getSModel();
      }
    });
    return model[0];
  }
}
