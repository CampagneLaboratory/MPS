package jetbrains.mps.makeTest.test;

/*Generated by MPS */

import jetbrains.mps.MPSLaunch;
import junit.framework.TestCase;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

@MPSLaunch
public class NotMake_Test extends TestCase {
  @MPSLaunch
  public void test_abstractMethodNotImplement() throws Exception {
    MakeAssert.assertNotMake("abstractMethodNotImplement", new ChangeModel() {
      @Override
      public void change(SModel model) {
        super.change(model);
        SPropertyOperations.set(Sequence.fromIterable(Classifier_Behavior.call_methods_5292274854859311639(ListSequence.fromList(SModelOperations.getRoots(model, "jetbrains.mps.baseLanguage.structure.Classifier")).first())).first(), "isAbstract", "" + (true));
      }
    });
  }
  @MPSLaunch
  public void test_finalClass() throws Exception {
    MakeAssert.assertNotMake("finalClass", new ChangeModel() {
      @Override
      public void change(SModel model) {
        super.change(model);
        SPropertyOperations.set(ListSequence.fromList(SModelOperations.getRoots(model, "jetbrains.mps.baseLanguage.structure.ClassConcept")).first(), "isFinal", "" + (true));
      }
    });
  }
  @MPSLaunch
  public void test_recursiveInHierarchy() throws Exception {
    MakeAssert.assertNotMake("recursiveInHierarchy", new ChangeModel() {
      @Override
      public void change(SModel model) {
        super.change(model);
        for (SNode root : SModelOperations.getRoots(model, "jetbrains.mps.baseLanguage.structure.Interface")) {
          SNode method = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration", null);
          SNode voidType = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.VoidType", null);
          SPropertyOperations.set(method, "name", "abc");
          SLinkOperations.setTarget(method, "returnType", voidType, true);
          ListSequence.fromList(SLinkOperations.getTargets(root, "member", true)).addElement(method);
        }
      }
    });
  }
  @MPSLaunch
  public void test_anonymousClass() throws Exception {
    MakeAssert.assertNotMake("anonymousClass", new ChangeModel() {
      @Override
      public void change(SModel model) {
        super.change(model);
        SPropertyOperations.set(Sequence.fromIterable(Classifier_Behavior.call_methods_5292274854859311639(ListSequence.fromList(SModelOperations.getRoots(model, "jetbrains.mps.baseLanguage.structure.Classifier")).first())).first(), "isAbstract", "" + (true));
      }
    });
  }
  public NotMake_Test() {
  }
}
