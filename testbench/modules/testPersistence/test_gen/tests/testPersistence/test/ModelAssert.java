package tests.testPersistence.test;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.junit.Assert;
import java.util.List;
import jetbrains.mps.smodel.ImplicitImportsLegacyHolder;
import java.util.Comparator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import java.util.HashSet;
import jetbrains.mps.util.IterableUtil;
import java.util.Iterator;
import jetbrains.mps.util.SNodeOperations;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SModelReference;
import java.util.Collections;

public class ModelAssert {
  public static void assertDeepModelEquals(SModel expectedModel, SModel actualModel) {
    ModelAccess.instance().checkReadAccess();
    assertSameImports(expectedModel, actualModel);
    assertSameModelImports(expectedModel, actualModel);
    assertSameLanguageAspects(expectedModel, actualModel);
    assertSameNodesCollections("root", expectedModel.getRootNodes(), actualModel.getRootNodes());
  }
  private static void assertSameNodesCollections(String objectName, Iterable<SNode> expected, Iterable<SNode> actual) {
    HashMap<SNodeId, SNode> actualIdToNodeMap = new HashMap<SNodeId, SNode>();
    for (SNode actualNode : actual) {
      actualIdToNodeMap.put(actualNode.getNodeId(), actualNode);
    }
    for (SNode expectedNode : expected) {
      SNodeId rootId = expectedNode.getNodeId();
      SNode actualNode = actualIdToNodeMap.get(rootId);
      Assert.assertNotNull("Not found expected " + objectName + " " + expectedNode, actualNode);
      assertDeepNodeEquals(expectedNode, actualNode);
      actualIdToNodeMap.remove(rootId);
    }
    Assert.assertTrue("Found not expected " + objectName + " " + actualIdToNodeMap, actualIdToNodeMap.isEmpty());
  }
  private static void assertSameModelImports(SModel expectedModel, SModel actualModel) {
    assertListsEqual(getImportedModelUIDs(expectedModel), getImportedModelUIDs(actualModel), "model import");
  }
  private static void assertSameLanguageAspects(SModel expectedModel, SModel actualModel) {
    List<SModel.ImportElement> expectedLanguageAspects = expectedModel.getImplicitImportsSupport().getAdditionalModelVersions();
    List<SModel.ImportElement> actualLanguageAspects = actualModel.getImplicitImportsSupport().getAdditionalModelVersions();
    for (SModel.ImportElement expectedEl : expectedLanguageAspects) {
      boolean found = false;
      for (SModel.ImportElement actualEl : actualLanguageAspects) {
        if (actualEl.getModelReference().equals(expectedEl.getModelReference())) {
          found = true;
          break;
        }
      }
      if (!(found)) {
        Assert.fail("Not found expected language aspect " + expectedEl.getModelReference());
      }
    }
    for (SModel.ImportElement actualEl : actualLanguageAspects) {
      boolean found = false;
      for (SModel.ImportElement expectedEl : expectedLanguageAspects) {
        if (actualEl.getModelReference().equals(expectedEl.getModelReference())) {
          found = true;
          break;
        }
      }
      if (!(found)) {
        Assert.fail("Unexpected language aspect " + actualEl.getModelReference());
      }
    }
  }
  private static void assertSameImports(SModel expectedModel, SModel actualModel) {
    final ImplicitImportsLegacyHolder is1 = expectedModel.getImplicitImportsSupport();
    final ImplicitImportsLegacyHolder is2 = actualModel.getImplicitImportsSupport();
    is1.calculateImplicitImports();
    is2.calculateImplicitImports();
    assertListsEqual(is1.getAdditionalModelVersions(), is2.getAdditionalModelVersions(), new Comparator<SModel.ImportElement>() {
      @Override
      public int compare(SModel.ImportElement import1, SModel.ImportElement import2) {
        return (import1.getModelReference().equals(import2.getModelReference()) ? 0 : 1);
      }
    }, "import");
  }
  private static <C> void assertListsEqual(List<C> expectedList, List<C> actualList, String name) {
    assertListsEqual(expectedList, actualList, new Comparator<C>() {
      @Override
      public int compare(C o1, C o2) {
        return (o1.equals(o2) ? 0 : 1);
      }
    }, name);
  }
  private static <C> void assertListsEqual(List<C> expectedList, List<C> actualList, Comparator<C> comparator, String name) {
    List<C> notFoundExpected = new ArrayList<C>();
    List<C> notFoundActual = new ArrayList<C>();
    for (C expected : expectedList) {
      boolean found = false;
      for (C actual : actualList) {
        if (comparator.compare(actual, expected) == 0) {
          found = true;
          break;
        }
      }
      if (!(found)) {
        notFoundExpected.add(expected);
      }
    }
    for (C actual : actualList) {
      boolean found = false;
      for (C expected : expectedList) {
        if (comparator.compare(actual, expected) == 0) {
          found = true;
          break;
        }
      }
      if (!(found)) {
        notFoundActual.add(actual);
      }
    }
    if (!(notFoundExpected.isEmpty())) {
      Assert.fail("Not found expected " + name + " " + Arrays.toString(notFoundExpected.toArray()));
    }
    if (!(notFoundActual.isEmpty())) {
      Assert.fail("Not expected " + name + " " + Arrays.toString(notFoundActual.toArray()));
    }
  }
  public static void assertDeepNodeEquals(SNode expectedNode, SNode actualNode) {
    Assert.assertEquals(getErrorString("concept", expectedNode, actualNode), expectedNode.getConcept().getQualifiedName(), actualNode.getConcept().getQualifiedName());
    // match properties 
    assertPropertyEquals(expectedNode, actualNode);
    // match references 
    assertReferenceEquals(expectedNode, actualNode);
    // match children 
    assertDeepChildrenEquals(expectedNode, actualNode);
  }
  private static void assertDeepChildrenEquals(SNode expectedNode, SNode actualNode) {
    Set<SContainmentLink> roles = new HashSet<SContainmentLink>();
    for (SNode child : expectedNode.getChildren()) {
      roles.add(child.getContainmentLink());
    }
    for (SNode child : actualNode.getChildren()) {
      roles.add(child.getContainmentLink());
    }
    for (SContainmentLink role : roles) {
      Iterable<? extends SNode> expectedChildren = expectedNode.getChildren(role);
      Iterable<? extends SNode> actualChildren = actualNode.getChildren(role);
      int esize = IterableUtil.asCollection(expectedChildren).size();
      int asize = IterableUtil.asCollection(actualChildren).size();
      Assert.assertEquals(getErrorString("child count in role " + role, expectedNode, actualNode), esize, asize);
      Iterator<? extends SNode> actualIterator = actualChildren.iterator();
      for (SNode expectedChild : expectedChildren) {
        SNode actualChild = actualIterator.next();
        Assert.assertEquals(getErrorString("children in role " + role, expectedNode, actualNode), expectedChild.getNodeId(), actualChild.getNodeId());
        assertDeepNodeEquals(expectedChild, actualChild);
      }
    }
  }
  private static void assertPropertyEquals(SNode expectedNode, SNode actualNode) {
    HashSet<String> propertes = new HashSet<String>();
    propertes.addAll(IterableUtil.asCollection(expectedNode.getPropertyNames()));
    propertes.addAll(IterableUtil.asCollection(actualNode.getPropertyNames()));
    for (String key : propertes) {
      String expectedProperty = SNodeOperations.getProperties(expectedNode).get(key);
      String actualProperty = SNodeOperations.getProperties(actualNode).get(key);
      Assert.assertEquals(getErrorString("property " + key, expectedNode, actualNode), expectedProperty, actualProperty);
    }
  }
  private static String getErrorString(String text, SNode expectedNode, SNode actualNode) {
    return "Different " + text + " for nodes " + expectedNode + " and " + actualNode + ".";
  }
  private static void assertReferenceEquals(SNode expectedNode, SNode actualNode) {
    Set<String> roles = new HashSet<String>();
    roles.addAll(SNodeOperations.getReferenceRoles(expectedNode));
    roles.addAll(SNodeOperations.getReferenceRoles(actualNode));
    Map<String, Set<SReference>> expRoleToReferenceMap = createRoleToReferenceMap(expectedNode);
    Map<String, Set<SReference>> actRoleToReferenceMap = createRoleToReferenceMap(actualNode);
    for (String role : roles) {
      Assert.assertEquals(getErrorString("different number of referents in role " + role, expectedNode, actualNode), expRoleToReferenceMap.get(role).size(), actRoleToReferenceMap.get(role).size());
      SReference expectedReference = expectedNode.getReference(role);
      SReference actualReference = actualNode.getReference(role);
      assertReferenceEquals(getErrorString("reference in role " + role, expectedNode, actualNode), expectedReference, actualReference);
    }
  }
  private static Map<String, Set<SReference>> createRoleToReferenceMap(SNode expectedNode) {
    Map<String, Set<SReference>> expRoleToReferenceMap = new HashMap<String, Set<SReference>>();
    for (SReference ref : expectedNode.getReferences()) {
      if (expRoleToReferenceMap.get(ref.getRole()) == null) {
        expRoleToReferenceMap.put(ref.getRole(), new HashSet<SReference>());
      }
      expRoleToReferenceMap.get(ref.getRole()).add(ref);
    }
    return expRoleToReferenceMap;
  }
  private static void assertReferenceEquals(String errorString, SReference expectedReference, SReference actualReference) {
    if (expectedReference == null) {
      Assert.assertNull(errorString, actualReference);
      return;
    }
    Assert.assertNotNull(errorString, actualReference);
    // assertIdEqualsOrBothNull(errorString, expectedReference.getTargetNode(), actualReference.getTargetNode()); 
    Assert.assertEquals(errorString, ((jetbrains.mps.smodel.SReference) expectedReference).getResolveInfo(), ((jetbrains.mps.smodel.SReference) actualReference).getResolveInfo());
    Assert.assertEquals(errorString, expectedReference.getRole(), actualReference.getRole());
    Assert.assertEquals(errorString, expectedReference.getTargetNodeId(), actualReference.getTargetNodeId());
  }
  private static void assertIdEqualsOrBothNull(String errorString, SNode expectedNode, SNode actualNode) {
    if (expectedNode == null) {
      Assert.assertNull(errorString, actualNode);
      return;
    }
    Assert.assertNotNull(errorString, actualNode);
    Assert.assertEquals(errorString, expectedNode.getNodeId(), actualNode.getNodeId());
  }
  @NotNull
  private static List<SModelReference> getImportedModelUIDs(SModel sModel) {
    List<SModelReference> references = new ArrayList<SModelReference>();
    for (SModel.ImportElement importElement : sModel.importedModels()) {
      references.add(importElement.getModelReference());
    }
    return Collections.unmodifiableList(references);
  }
}
