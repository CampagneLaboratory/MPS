package jetbrains.mps.nanoc.plugin;

/*Generated by MPS */

import jetbrains.mps.nanoc.debug.ProgramsLocationUtil;
import jetbrains.mps.util.annotation.ToRemove;
import com.intellij.execution.process.ProcessHandler;
import jetbrains.mps.smodel.SNode;
import com.intellij.execution.ExecutionException;
import org.apache.commons.lang.StringUtils;
import java.io.File;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.generator.traceInfo.TraceInfoUtil;
import jetbrains.mps.vfs.FileSystem;

public class Gcc_Command {
  private String myGccLocation_String = ProgramsLocationUtil.getGccLocation();

  public Gcc_Command() {
  }

  @Deprecated
  @ToRemove(version = 2.1)
  public Gcc_Command setGccLocation(String gccLocation) {
    // this methods only exist to not make users regenerate their code 
    if (gccLocation != null) {
      myGccLocation_String = gccLocation;
    }
    return this;
  }

  public Gcc_Command setGccLocation_String(String gccLocation) {
    if (gccLocation != null) {
      myGccLocation_String = gccLocation;
    }
    return this;
  }

  public ProcessHandler createProcess(SNode file) throws ExecutionException {
    if (StringUtils.isEmpty(myGccLocation_String) || !(new File(myGccLocation_String).exists())) {
      throw new ExecutionException("Could not find gcc by path " + myGccLocation_String);
    }

    IFile sourceFile = Gcc_Command.getSourceFile(file);
    if (!((sourceFile.exists()))) {
      throw new ExecutionException("Source file " + sourceFile + " does not exist. Can't compile it.");
    }
    IFile executableFile = Gcc_Command.getExecutableFile(file);
    executableFile.getParent().mkdirs();

    // -xc -- specifies source language (c) 
    // -g -- save debug information 
    return new Exec_Command().setWorkingDirectory_File(new File(sourceFile.getParent().getAbsolutePath())).setProgramParameters_String("-xc" + " " + "-g" + " " + Gcc_Command.protect(sourceFile.getAbsolutePath()) + " " + "-o " + Gcc_Command.protect(executableFile.getAbsolutePath())).createProcess(new File(myGccLocation_String));
  }

  private static String protect(String rawString) {
    if (rawString.contains(" ")) {
      return "\"" + rawString + "\"";
    }
    return rawString;
  }

  private static String getSourceExtension() {
    return ".c";
  }

  private static String getOutputExtension() {
    String osName = System.getProperty("os.name");
    if (osName.startsWith("Windows")) {
      return ".exe";
    }
    return "";
  }

  public static IFile getExecutableFile(final SNode file) {
    final Wrappers._T<IModule> module = new Wrappers._T<IModule>();
    final Wrappers._T<String> sourceName = new Wrappers._T<String>();
    final Wrappers._T<String> packageName = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        module.value = SNodeOperations.getModel(file).getModelDescriptor().getModule();
        sourceName.value = TraceInfoUtil.getUnitName(file);
        packageName.value = SNodeOperations.getModel(file).getLongName().replace(".", "/");
      }
    });
    return module.value.getClassesGen().getDescendant(packageName.value).getDescendant(sourceName.value + Gcc_Command.getOutputExtension());
  }

  public static IFile getSourceFile(final SNode file) {
    final Wrappers._T<IModule> module = new Wrappers._T<IModule>();
    final Wrappers._T<String> sourceName = new Wrappers._T<String>();
    final Wrappers._T<String> packageName = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        module.value = SNodeOperations.getModel(file).getModelDescriptor().getModule();
        sourceName.value = TraceInfoUtil.getUnitName(file);
        packageName.value = SNodeOperations.getModel(file).getLongName().replace(".", "/");
      }
    });
    return FileSystem.getInstance().getFileByPath(module.value.getGeneratorOutputPath()).getDescendant(packageName.value).getDescendant(sourceName.value + Gcc_Command.getSourceExtension());
  }
}
