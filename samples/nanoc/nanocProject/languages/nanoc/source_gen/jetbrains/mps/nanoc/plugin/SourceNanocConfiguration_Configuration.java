package jetbrains.mps.nanoc.plugin;

/*Generated by MPS */

import jetbrains.mps.plugins.pluginparts.runconfigs.BaseRunConfig;
import com.intellij.util.xmlb.annotations.Tag;
import com.intellij.openapi.project.Project;
import com.intellij.execution.configurations.ConfigurationFactory;
import com.intellij.execution.configurations.RunConfiguration;
import com.intellij.execution.configurations.RuntimeConfigurationException;
import com.intellij.execution.configurations.RuntimeConfigurationError;
import jetbrains.mps.logging.Logger;
import com.intellij.execution.configurations.RunProfileState;
import org.jetbrains.annotations.NotNull;
import com.intellij.execution.Executor;
import com.intellij.execution.runners.ExecutionEnvironment;
import com.intellij.execution.ExecutionException;
import jetbrains.mps.plugins.pluginparts.runconfigs.BaseRunProfileState;
import org.jetbrains.annotations.Nullable;
import com.intellij.execution.ExecutionResult;
import com.intellij.execution.runners.ProgramRunner;
import com.intellij.execution.impl.ConsoleViewImpl;
import jetbrains.mps.debug.info.StacktraceUtil;
import jetbrains.mps.workbench.MPSDataKeys;
import javax.swing.JComponent;
import java.util.List;
import com.intellij.openapi.actionSystem.AnAction;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.intellij.execution.process.ProcessHandler;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.openapi.util.Disposer;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.util.NameUtil;
import java.io.File;
import jetbrains.mps.nanoc.debug.ProgramsLocationUtil;
import java.io.IOException;
import jetbrains.mps.debug.executable.SimpleConsoleProcessHandler;
import com.intellij.execution.ui.ExecutionConsole;
import jetbrains.mps.debug.api.AbstractDebugSessionCreator;
import com.intellij.execution.configurations.RunnerSettings;
import com.intellij.execution.configurations.ConfigurationPerRunnerSettings;
import com.intellij.openapi.util.JDOMExternalizable;
import com.intellij.execution.configurations.ConfigurationInfoProvider;
import com.intellij.openapi.options.SettingsEditor;
import org.jdom.Element;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.util.xmlb.XmlSerializer;
import com.intellij.openapi.util.InvalidDataException;
import jetbrains.mps.baseLanguage.runConfigurations.runtime.MainNodeChooser;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;

public class SourceNanocConfiguration_Configuration extends BaseRunConfig {
  @Tag(value = "state")
  private SourceNanocConfiguration_Configuration.MyState myState = new SourceNanocConfiguration_Configuration.MyState();

  public SourceNanocConfiguration_Configuration(Project p, ConfigurationFactory f, String name) {
    super(p, f, name);
  }

  public RunConfiguration clone() {
    try {
      SourceNanocConfiguration_Configuration result = ((SourceNanocConfiguration_Configuration) super.clone());
      result.myState = ((SourceNanocConfiguration_Configuration.MyState) this.myState.clone());
      return result;
    } catch (CloneNotSupportedException e) {
      return null;
    }
  }

  public void checkConfiguration() throws RuntimeConfigurationException {
    final StringBuilder error_22042010 = new StringBuilder();
    try {

    } catch (Throwable t_22042010) {
      if (t_22042010 instanceof RuntimeConfigurationException) {
        throw (RuntimeConfigurationException) t_22042010;
      }
      if (t_22042010 instanceof RuntimeConfigurationError) {
        throw (RuntimeConfigurationError) t_22042010;
      }
      Logger.getLogger(SourceNanocConfiguration_Configuration.class).error(t_22042010);
    }
    if (error_22042010.length() != 0) {
      throw new RuntimeConfigurationException(error_22042010.toString());
    }
  }

  public RunProfileState getState(@NotNull final Executor executor, @NotNull final ExecutionEnvironment environment) throws ExecutionException {
    return new BaseRunProfileState() {
      @Nullable
      public ExecutionResult execute(Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {
        final ConsoleViewImpl consoleView_22042010 = StacktraceUtil.createConsoleView(MPSDataKeys.PROJECT.getData(environment.getDataContext()));
        JComponent consoleComponent_22042010 = null;
        Runnable consoleDispose_22042010 = null;
        final List<AnAction> actions_22042010 = ListSequence.fromList(new ArrayList<AnAction>());
        ProcessHandler handler_22042010 = null;

        // user's execute code 
        try {
          {
            // calculate parameter 

            ListSequence.fromList(actions_22042010).addSequence(ListSequence.fromList(new _FunctionTypes._return_P0_E0<List<AnAction>>() {
              public List<AnAction> invoke() {
                {
                  final List<AnAction> actionsList = ListSequence.fromListAndArray(new ArrayList<AnAction>(), consoleView_22042010.createConsoleActions());
                  return actionsList;
                }
              }
            }.invoke()));

            // create console component 
            consoleComponent_22042010 = consoleView_22042010.getComponent();
            consoleDispose_22042010 = new Runnable() {
              public void run() {
                Disposer.dispose(consoleView_22042010);
              }
            };

            final Wrappers._T<ExecutionException> ex = new Wrappers._T<ExecutionException>(null);
            // create process handler 
            handler_22042010 = (ProcessHandler) new _FunctionTypes._return_P0_E6<ProcessHandler, ExecutionException, ExecutionException, ExecutionException, ExecutionException, ExecutionException, ExecutionException>() {
              public ProcessHandler invoke() throws ExecutionException, ExecutionException, ExecutionException, ExecutionException, ExecutionException, ExecutionException {
                try {
                  SModelDescriptor descriptor = SModelRepository.getInstance().getModelDescriptor(SModelReference.fromString(SourceNanocConfiguration_Configuration.this.getStateObject().modelRef));
                  SNode node = descriptor.getSModel().getNodeById(SourceNanocConfiguration_Configuration.this.getStateObject().nodeId);
                  final SNode sourceFileNode = SNodeOperations.cast(node, "jetbrains.mps.nanoc.structure.File");
                  IModule module = descriptor.getModule();
                  String folder = module.getGeneratorOutputPath();
                  final Wrappers._T<String> sourceFileName = new Wrappers._T<String>();
                  ModelAccess.instance().runReadAction(new Runnable() {
                    public void run() {
                      sourceFileName.value = SPropertyOperations.getString(sourceFileNode, "name");
                    }
                  });
                  String packageName = NameUtil.pathFromNamespace(descriptor.getLongName());
                  File modelFolder = new File(folder + File.separator + packageName);
                  File f = new File(modelFolder, sourceFileName.value + ".c");
                  if (!(f.exists())) {
                    throw new ExecutionException("node is not generated");
                  }
                  File gcc = new File(ProgramsLocationUtil.getGccLocation());
                  if (!(gcc.exists())) {
                    throw new ExecutionException("no GCC found");
                  }
                  ProcessBuilder processBuilder = new ProcessBuilder();
                  processBuilder.command(gcc.getAbsolutePath(), f.getAbsolutePath(), "-g", "-x c");
                  processBuilder.directory(f.getParentFile());
                  try {
                    Process compileProcess = processBuilder.start();
                    try {
                      compileProcess.waitFor();
                    } catch (InterruptedException ex) {
                      throw new ExecutionException("waiting for gcc compiler interrupted", ex);
                    }
                  } catch (IOException ioException) {
                    throw new ExecutionException("error executing gcc compiler", ioException);
                  }
                  String outputExtension = ".exe";
                  File executableFile = new File(folder, sourceFileName.value + outputExtension);
                  if (!(executableFile.exists())) {
                    throw new ExecutionException("executable file not found");
                  }

                  List<String> params = new ArrayList<String>();
                  params.add(executableFile.getAbsolutePath());
                  File workingDir = executableFile.getParentFile();
                  ProcessBuilder executableProcessBuilder = new ProcessBuilder();
                  executableProcessBuilder.directory(workingDir);
                  executableProcessBuilder.command(params);
                  Process process;
                  try {
                    process = executableProcessBuilder.start();
                  } catch (IOException e) {
                    throw new ExecutionException("", e);
                  }
                  ProcessHandler handler = new SimpleConsoleProcessHandler(consoleView_22042010, process, params.get(0));
                  return handler;
                } catch (ExecutionException e) {
                  ex.value = e;
                  return null;
                }
              }
            }.invoke();
            if (ex.value != null) {
              throw ex.value;
            }
          }
        } catch (Throwable t) {
          if (t instanceof ExecutionException) {
            throw (ExecutionException) t;
          } else {
            Logger.getLogger(SourceNanocConfiguration_Configuration.class).error(t);
            throw new ExecutionException("Execution code threw an exception: " + t.getMessage(), t);
          }
        }

        final JComponent finalConsoleComponent = consoleComponent_22042010;
        final Runnable finalConsoleDispose = consoleDispose_22042010;
        final ProcessHandler finalHandler = handler_22042010;
        if (finalHandler == null) {
          return null;
        }
        return new ExecutionResult() {
          public ExecutionConsole getExecutionConsole() {
            return new ExecutionConsole() {
              public void dispose() {
                if (finalConsoleDispose == null) {
                  return;
                }
                finalConsoleDispose.run();
              }

              public JComponent getComponent() {
                return finalConsoleComponent;
              }

              public JComponent getPreferredFocusableComponent() {
                return finalConsoleComponent;
              }
            };
          }

          public AnAction[] getActions() {
            return ListSequence.fromList(actions_22042010).toGenericArray(AnAction.class);
          }

          public ProcessHandler getProcessHandler() {
            return finalHandler;
          }
        };
      }

      public AbstractDebugSessionCreator createDebugSessionCreator(Project p) {
        return null;
      }

      public RunnerSettings getRunnerSettings() {
        return null;
      }

      public ConfigurationPerRunnerSettings getConfigurationSettings() {
        return null;
      }
    };
  }

  public JDOMExternalizable createRunnerSettings(ConfigurationInfoProvider p0) {
    return null;
  }

  public SettingsEditor<? extends RunConfiguration> getConfigurationEditor() {
    return new SourceNanocConfiguration_Configuration.MySettingsEditor();
  }

  @Nullable
  public SettingsEditor<JDOMExternalizable> getRunnerSettingsEditor(ProgramRunner p0) {
    return null;
  }

  public void writeExternal(Element e) throws WriteExternalException {
    e.addContent(XmlSerializer.serialize(this.myState));
  }

  public void readExternal(Element e) throws InvalidDataException {
    XmlSerializer.deserializeInto(this.myState, ((Element) e.getChildren().get(0)));
  }

  public SourceNanocConfiguration_Configuration.MyState getStateObject() {
    return this.myState;
  }

  public boolean isDebuggable() {
    return true;
  }

  private static class MySettingsEditor extends SettingsEditor<SourceNanocConfiguration_Configuration> {
    private MainNodeChooser<SNode> myComponent = null;

    public MySettingsEditor() {
    }

    protected void resetEditorFrom(SourceNanocConfiguration_Configuration c) {
      if (c.getStateObject().modelRef != null && c.getStateObject().nodeId != null) {
        SModelDescriptor descriptor = SModelRepository.getInstance().getModelDescriptor(SModelReference.fromString(c.getStateObject().modelRef));
        if (descriptor == null) {
          return;
        }
        SModel model = descriptor.getSModel();
        SNode node = model.getNodeById(c.getStateObject().nodeId);
        if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.nanoc.structure.File"))) {
          return;
        }
        MySettingsEditor.this.myComponent.setNode(node);
      }
    }

    protected void applyEditorTo(final SourceNanocConfiguration_Configuration c) {
      final SNode node = MySettingsEditor.this.myComponent.getNode();
      if (node != null) {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            c.getStateObject().nodeId = node.getId();
            c.getStateObject().modelRef = node.getModel().getSModelReference().toString();
          }
        });
      }
    }

    @NotNull
    protected JComponent createEditor() {
      this.myComponent = new MainNodeChooser<SNode>(SConceptOperations.findConceptDeclaration("jetbrains.mps.nanoc.structure.File"), new _FunctionTypes._return_P1_E0<Boolean, SNode>() {
        public Boolean invoke(SNode n) {
          return true;
        }
      });
      return this.myComponent;
    }

    protected void disposeEditor() {
    }
  }

  public static class MyState implements Cloneable {
    public String nodeId;
    public String modelRef;

    public MyState() {
    }

    public Object clone() throws CloneNotSupportedException {
      SourceNanocConfiguration_Configuration.MyState object = (SourceNanocConfiguration_Configuration.MyState) super.clone();
      return object;
    }
  }
}
