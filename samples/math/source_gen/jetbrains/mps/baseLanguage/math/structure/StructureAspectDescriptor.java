package jetbrains.mps.baseLanguage.math.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.BaseStructureAspectDescriptor;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.impl.ConceptDescriptorBuilder;
import jetbrains.mps.smodel.runtime.StaticScope;
import java.util.Collection;
import java.util.Arrays;
import org.jetbrains.annotations.NotNull;

public class StructureAspectDescriptor extends BaseStructureAspectDescriptor {
  /*package*/ final ConceptDescriptor myConceptAbsExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.AbsExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"expr"}, new boolean[]{false}).alias("abs", "Absolute value of a number").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptAbstractIndex = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.AbstractIndex").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.baseLanguage.structure.IValidIdentifier").abstract_().create();
  /*package*/ final ConceptDescriptor myConceptArithmSymbol = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ArithmSymbol").super_("jetbrains.mps.baseLanguage.math.structure.MathSymbol").parents("jetbrains.mps.baseLanguage.math.structure.MathSymbol").abstract_().staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptBigComplexType = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigComplexType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").alias("bigcomplex", "Arbitrary precision complex number").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptBigDecimalType = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigDecimalType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").alias("bigdecimal", "Arbitrary precision signed decimal number").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptBigIntegerType = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigIntegerType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").alias("biginteger", "Arbitrary precision integer").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptBigMaxExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigMaxExpression").super_("jetbrains.mps.baseLanguage.math.structure.ExtrSymbol").parents("jetbrains.mps.baseLanguage.math.structure.ExtrSymbol").alias("max", "Maximum of expressions").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptBigMinExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigMinExpression").super_("jetbrains.mps.baseLanguage.math.structure.ExtrSymbol").parents("jetbrains.mps.baseLanguage.math.structure.ExtrSymbol").alias("min", "Minimum of expressions").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptBigProdExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigProdExpression").super_("jetbrains.mps.baseLanguage.math.structure.ArithmSymbol").parents("jetbrains.mps.baseLanguage.math.structure.ArithmSymbol").alias("prod", "Product of expressions").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptBigSumExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigSumExpression").super_("jetbrains.mps.baseLanguage.math.structure.ArithmSymbol").parents("jetbrains.mps.baseLanguage.math.structure.ArithmSymbol").alias("sum", "Sum of expressions").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptComplexLiteral = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ComplexLiteral").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"real", "imag"}, new boolean[]{false, false}).staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptComplexType = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ComplexType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").alias("complex", "Double precision complex number").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptConjugateOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ConjugateOperation").super_("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").parents("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").alias("", "Matrix conjugate").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptCosineExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.CosineExpression").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("cos", "Trigonometric cosine of a value").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptDecimalBinaryOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").super_("jetbrains.mps.baseLanguage.structure.BinaryOperation").parents("jetbrains.mps.baseLanguage.structure.BinaryOperation").children(new String[]{"context"}, new boolean[]{false}).abstract_().staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptDecimalDivExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DecimalDivExpression").super_("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").parents("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").alias(":/d", "divide operation for big decimal types").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptDecimalMinusExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DecimalMinusExpression").super_("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").parents("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").alias(":-d", "minus operation for big decimal types").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptDecimalMulExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DecimalMulExpression").super_("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").parents("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").alias(":*d", "multiplication operation for big decimal types").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptDecimalPlusExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DecimalPlusExpression").super_("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").parents("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").alias(":+d", "plus operation for bigdecimal types").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptDeterminant = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.Determinant").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("det", "Matrix determinant").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptDivExpressionFraction = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DivExpressionFraction").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"numerator", "denominator"}, new boolean[]{false, false}).alias("frac", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptExponentExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ExponentExpression").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("exp", "Exponent of a value").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptExponentialOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ExponentialOperation").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"expr"}, new boolean[]{false}).abstract_().staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptExtrSymbol = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ExtrSymbol").super_("jetbrains.mps.baseLanguage.math.structure.MathSymbol").parents("jetbrains.mps.baseLanguage.math.structure.MathSymbol").abstract_().staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptInIntervalExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.InIntervalExpression").super_("jetbrains.mps.baseLanguage.structure.BinaryOperation").parents("jetbrains.mps.baseLanguage.structure.BinaryOperation").alias(":in:", "is in interval").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptIntervalContainsExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.IntervalContainsExpression").super_("jetbrains.mps.baseLanguage.structure.BinaryOperation").parents("jetbrains.mps.baseLanguage.structure.BinaryOperation").alias(":contains:", "(?) interval contains").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptIntervalLiteral = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.IntervalLiteral").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").properties("startIncluded", "endIncluded").children(new String[]{"start", "end"}, new boolean[]{false, false}).alias("interval", "Interval literal").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptIntervalType = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.IntervalType").super_("jetbrains.mps.baseLanguage.structure.Type").parents("jetbrains.mps.baseLanguage.structure.Type").children(new String[]{"elementType"}, new boolean[]{false}).alias("interval", "Interval type").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptLinearSolveOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.LinearSolveOperation").super_("jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration").parents("jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration").children(new String[]{"type_M", "matrix", "vector", "context"}, new boolean[]{false, false, false, false}).alias("lsolve", "").create();
  /*package*/ final ConceptDescriptor myConceptLiteralI = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.LiteralI").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").alias("I", "Imaginary unit").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptLogExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.LogExpression").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("ln", "Natural logarithm of a value").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMathContext = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathContext").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").properties("roundingMode", "precision", "precisionSetting").create();
  /*package*/ final ConceptDescriptor myConceptMathFuncExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"param"}, new boolean[]{false}).abstract_().staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMathPrimitiveType = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").super_("jetbrains.mps.baseLanguage.structure.Type").parents("jetbrains.mps.baseLanguage.structure.Type").abstract_().staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMathSymbol = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathSymbol").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"var", "expression", "precondition", "upperBound"}, new boolean[]{false, false, false, false}).abstract_().staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMathSymbolFromToIndex = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathSymbolFromToIndex").super_("jetbrains.mps.baseLanguage.math.structure.AbstractIndex").parents("jetbrains.mps.baseLanguage.math.structure.AbstractIndex").children(new String[]{"from"}, new boolean[]{false}).alias("", "iterate over interval of integers").create();
  /*package*/ final ConceptDescriptor myConceptMathSymbolIndex = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathSymbolIndex").super_("jetbrains.mps.baseLanguage.math.structure.AbstractIndex").parents("jetbrains.mps.baseLanguage.math.structure.AbstractIndex").children(new String[]{"iterable"}, new boolean[]{false}).alias("", "iterate over arbitrary iterable class").create();
  /*package*/ final ConceptDescriptor myConceptMathSymbolIndexReference = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathSymbolIndexReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("indexRef").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMathTypeCast = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathTypeCast").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").properties("target").children(new String[]{"castedExpr"}, new boolean[]{false}).staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixConstructor = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixConstructor").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").properties("column").children(new String[]{"components"}, new boolean[]{true}).alias("[", "Matrix row constructor").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixElementAccessExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixElementAccessExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"expression", "rowIndex", "colIndex"}, new boolean[]{false, false, false}).staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixExponentialOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").super_("jetbrains.mps.baseLanguage.math.structure.ExponentialOperation").parents("jetbrains.mps.baseLanguage.math.structure.ExponentialOperation").abstract_().staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixIndexWildcard = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixIndexWildcard").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").alias("*", "Wildcard index").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixInitializer = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixInitializer").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorInitializer").children(new String[]{"rowIndex", "colIndex", "rowsCount", "colsCount", "expression"}, new boolean[]{false, false, false, false, false}).alias("matrix", "Matrix initializer").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixInitializerIndex = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixInitializerIndex").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorInitializer").create();
  /*package*/ final ConceptDescriptor myConceptMatrixInitializerIndexReference = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixInitializerIndexReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("index").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixInverseOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixInverseOperation").super_("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").parents("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").children(new String[]{"context"}, new boolean[]{false}).alias("", "Matrix inverse operation").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixNorm = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixNorm").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").properties("deg").children(new String[]{"mat"}, new boolean[]{false}).alias("norm", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixOrVectorInitializer = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorInitializer").interface_().create();
  /*package*/ final ConceptDescriptor myConceptMatrixOrVectorType = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorType").interface_().create();
  /*package*/ final ConceptDescriptor myConceptMatrixType = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorType").properties("rows", "columns").children(new String[]{"elementType"}, new boolean[]{false}).alias("matrix", "").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixUnit = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixUnit").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"size"}, new boolean[]{false}).alias("identity", "Identity matrix").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptMatrixZero = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixZero").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").properties("square").children(new String[]{"rows", "columns"}, new boolean[]{false, false}).alias("zero", "Zero matrix").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptPowExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.PowExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"base", "exponent"}, new boolean[]{false, false}).alias("^", "Power expression").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptSineExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.SineExpression").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("sin", "Trigonometric sine of a value").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptTangentExpression = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.TangentExpression").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("tan", "Trigonometric tangent of a value").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptTransposeOperation = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.TransposeOperation").super_("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").parents("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").alias("", "Transpose operation").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptVectorInitializer = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.VectorInitializer").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorInitializer").children(new String[]{"rowIndex", "expression", "rowsCount"}, new boolean[]{false, false, false}).alias("vector", "Vector initializer").staticScope(StaticScope.NONE).create();
  /*package*/ final ConceptDescriptor myConceptVectorType = new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.VectorType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorType").properties("height").children(new String[]{"elementType"}, new boolean[]{false}).alias("vector", "").staticScope(StaticScope.NONE).create();

  @Override
  public Collection<ConceptDescriptor> getDescriptors() {
    return Arrays.asList(myConceptAbsExpression, myConceptAbstractIndex, myConceptArithmSymbol, myConceptBigComplexType, myConceptBigDecimalType, myConceptBigIntegerType, myConceptBigMaxExpression, myConceptBigMinExpression, myConceptBigProdExpression, myConceptBigSumExpression, myConceptComplexLiteral, myConceptComplexType, myConceptConjugateOperation, myConceptCosineExpression, myConceptDecimalBinaryOperation, myConceptDecimalDivExpression, myConceptDecimalMinusExpression, myConceptDecimalMulExpression, myConceptDecimalPlusExpression, myConceptDeterminant, myConceptDivExpressionFraction, myConceptExponentExpression, myConceptExponentialOperation, myConceptExtrSymbol, myConceptInIntervalExpression, myConceptIntervalContainsExpression, myConceptIntervalLiteral, myConceptIntervalType, myConceptLinearSolveOperation, myConceptLiteralI, myConceptLogExpression, myConceptMathContext, myConceptMathFuncExpression, myConceptMathPrimitiveType, myConceptMathSymbol, myConceptMathSymbolFromToIndex, myConceptMathSymbolIndex, myConceptMathSymbolIndexReference, myConceptMathTypeCast, myConceptMatrixConstructor, myConceptMatrixElementAccessExpression, myConceptMatrixExponentialOperation, myConceptMatrixIndexWildcard, myConceptMatrixInitializer, myConceptMatrixInitializerIndex, myConceptMatrixInitializerIndexReference, myConceptMatrixInverseOperation, myConceptMatrixNorm, myConceptMatrixOrVectorInitializer, myConceptMatrixOrVectorType, myConceptMatrixType, myConceptMatrixUnit, myConceptMatrixZero, myConceptPowExpression, myConceptSineExpression, myConceptTangentExpression, myConceptTransposeOperation, myConceptVectorInitializer, myConceptVectorType);
  }

  @Override
  @NotNull
  public ConceptDescriptor getDescriptor(String conceptFqName) {
    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0kc, conceptFqName)) {
      case 0:
        return myConceptAbsExpression;
      case 1:
        return myConceptAbstractIndex;
      case 2:
        return myConceptArithmSymbol;
      case 3:
        return myConceptBigComplexType;
      case 4:
        return myConceptBigDecimalType;
      case 5:
        return myConceptBigIntegerType;
      case 6:
        return myConceptBigMaxExpression;
      case 7:
        return myConceptBigMinExpression;
      case 8:
        return myConceptBigProdExpression;
      case 9:
        return myConceptBigSumExpression;
      case 10:
        return myConceptComplexLiteral;
      case 11:
        return myConceptComplexType;
      case 12:
        return myConceptConjugateOperation;
      case 13:
        return myConceptCosineExpression;
      case 14:
        return myConceptDecimalBinaryOperation;
      case 15:
        return myConceptDecimalDivExpression;
      case 16:
        return myConceptDecimalMinusExpression;
      case 17:
        return myConceptDecimalMulExpression;
      case 18:
        return myConceptDecimalPlusExpression;
      case 19:
        return myConceptDeterminant;
      case 20:
        return myConceptDivExpressionFraction;
      case 21:
        return myConceptExponentExpression;
      case 22:
        return myConceptExponentialOperation;
      case 23:
        return myConceptExtrSymbol;
      case 24:
        return myConceptInIntervalExpression;
      case 25:
        return myConceptIntervalContainsExpression;
      case 26:
        return myConceptIntervalLiteral;
      case 27:
        return myConceptIntervalType;
      case 28:
        return myConceptLinearSolveOperation;
      case 29:
        return myConceptLiteralI;
      case 30:
        return myConceptLogExpression;
      case 31:
        return myConceptMathContext;
      case 32:
        return myConceptMathFuncExpression;
      case 33:
        return myConceptMathPrimitiveType;
      case 34:
        return myConceptMathSymbol;
      case 35:
        return myConceptMathSymbolFromToIndex;
      case 36:
        return myConceptMathSymbolIndex;
      case 37:
        return myConceptMathSymbolIndexReference;
      case 38:
        return myConceptMathTypeCast;
      case 39:
        return myConceptMatrixConstructor;
      case 40:
        return myConceptMatrixElementAccessExpression;
      case 41:
        return myConceptMatrixExponentialOperation;
      case 42:
        return myConceptMatrixIndexWildcard;
      case 43:
        return myConceptMatrixInitializer;
      case 44:
        return myConceptMatrixInitializerIndex;
      case 45:
        return myConceptMatrixInitializerIndexReference;
      case 46:
        return myConceptMatrixInverseOperation;
      case 47:
        return myConceptMatrixNorm;
      case 48:
        return myConceptMatrixOrVectorInitializer;
      case 49:
        return myConceptMatrixOrVectorType;
      case 50:
        return myConceptMatrixType;
      case 51:
        return myConceptMatrixUnit;
      case 52:
        return myConceptMatrixZero;
      case 53:
        return myConceptPowExpression;
      case 54:
        return myConceptSineExpression;
      case 55:
        return myConceptTangentExpression;
      case 56:
        return myConceptTransposeOperation;
      case 57:
        return myConceptVectorInitializer;
      case 58:
        return myConceptVectorType;
      default:
        throw new IllegalStateException("Wrong fqName of the concept " + conceptFqName);
    }
  }
  private static String[] stringSwitchCases_1htk8d_a0a0kc = new String[]{"jetbrains.mps.baseLanguage.math.structure.AbsExpression", "jetbrains.mps.baseLanguage.math.structure.AbstractIndex", "jetbrains.mps.baseLanguage.math.structure.ArithmSymbol", "jetbrains.mps.baseLanguage.math.structure.BigComplexType", "jetbrains.mps.baseLanguage.math.structure.BigDecimalType", "jetbrains.mps.baseLanguage.math.structure.BigIntegerType", "jetbrains.mps.baseLanguage.math.structure.BigMaxExpression", "jetbrains.mps.baseLanguage.math.structure.BigMinExpression", "jetbrains.mps.baseLanguage.math.structure.BigProdExpression", "jetbrains.mps.baseLanguage.math.structure.BigSumExpression", "jetbrains.mps.baseLanguage.math.structure.ComplexLiteral", "jetbrains.mps.baseLanguage.math.structure.ComplexType", "jetbrains.mps.baseLanguage.math.structure.ConjugateOperation", "jetbrains.mps.baseLanguage.math.structure.CosineExpression", "jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation", "jetbrains.mps.baseLanguage.math.structure.DecimalDivExpression", "jetbrains.mps.baseLanguage.math.structure.DecimalMinusExpression", "jetbrains.mps.baseLanguage.math.structure.DecimalMulExpression", "jetbrains.mps.baseLanguage.math.structure.DecimalPlusExpression", "jetbrains.mps.baseLanguage.math.structure.Determinant", "jetbrains.mps.baseLanguage.math.structure.DivExpressionFraction", "jetbrains.mps.baseLanguage.math.structure.ExponentExpression", "jetbrains.mps.baseLanguage.math.structure.ExponentialOperation", "jetbrains.mps.baseLanguage.math.structure.ExtrSymbol", "jetbrains.mps.baseLanguage.math.structure.InIntervalExpression", "jetbrains.mps.baseLanguage.math.structure.IntervalContainsExpression", "jetbrains.mps.baseLanguage.math.structure.IntervalLiteral", "jetbrains.mps.baseLanguage.math.structure.IntervalType", "jetbrains.mps.baseLanguage.math.structure.LinearSolveOperation", "jetbrains.mps.baseLanguage.math.structure.LiteralI", "jetbrains.mps.baseLanguage.math.structure.LogExpression", "jetbrains.mps.baseLanguage.math.structure.MathContext", "jetbrains.mps.baseLanguage.math.structure.MathFuncExpression", "jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType", "jetbrains.mps.baseLanguage.math.structure.MathSymbol", "jetbrains.mps.baseLanguage.math.structure.MathSymbolFromToIndex", "jetbrains.mps.baseLanguage.math.structure.MathSymbolIndex", "jetbrains.mps.baseLanguage.math.structure.MathSymbolIndexReference", "jetbrains.mps.baseLanguage.math.structure.MathTypeCast", "jetbrains.mps.baseLanguage.math.structure.MatrixConstructor", "jetbrains.mps.baseLanguage.math.structure.MatrixElementAccessExpression", "jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation", "jetbrains.mps.baseLanguage.math.structure.MatrixIndexWildcard", "jetbrains.mps.baseLanguage.math.structure.MatrixInitializer", "jetbrains.mps.baseLanguage.math.structure.MatrixInitializerIndex", "jetbrains.mps.baseLanguage.math.structure.MatrixInitializerIndexReference", "jetbrains.mps.baseLanguage.math.structure.MatrixInverseOperation", "jetbrains.mps.baseLanguage.math.structure.MatrixNorm", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorInitializer", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorType", "jetbrains.mps.baseLanguage.math.structure.MatrixType", "jetbrains.mps.baseLanguage.math.structure.MatrixUnit", "jetbrains.mps.baseLanguage.math.structure.MatrixZero", "jetbrains.mps.baseLanguage.math.structure.PowExpression", "jetbrains.mps.baseLanguage.math.structure.SineExpression", "jetbrains.mps.baseLanguage.math.structure.TangentExpression", "jetbrains.mps.baseLanguage.math.structure.TransposeOperation", "jetbrains.mps.baseLanguage.math.structure.VectorInitializer", "jetbrains.mps.baseLanguage.math.structure.VectorType"};
}
