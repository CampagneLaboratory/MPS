package Samples;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.Collections;
import utils.ParallelLoopException;

public class ThreadSafeSample {
  private static final String fixedFieldValue = "Fixed value for ever";

  public ThreadSafeSample() {
  }

  public static void main(String[] args) throws InterruptedException {
    // This sample shows that classes marked thread-safe will not be reported 
    //  as inproperly used from within parallel for loops 

    // This is a thread safe class to exchange a single value between a producer and a consumer 
    // Open the DropBox class definition and notice the "@thread safe" annotation for the class 
    final DropBox<String> box = new DropBox<String>();

    // A consumer thread reading and printing values exchanged through the drop box 
    Thread thread = new Thread(new Runnable() {
      public void run() {
        try {
          while (true) {
            System.out.println("Received: " + box.retrieve());
          }
        } catch (InterruptedException e) {
          System.out.println("Interrupted");
        }
      }
    });
    thread.start();

    final List<String> names = ListSequence.fromListAndArray(new ArrayList<String>(), "Joe", "Dave", "Alice");

    {
      final CountDownLatch latch = new CountDownLatch(ListSequence.fromList(names).count());
      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();

      for (final String name : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<String>(), names))) {

        final String localA = name;

        Runnable runnable = new Runnable() {
          public void run() {
            try {
              try {
                // Notice no warning nor error reported 
                box.store(localA);
                // If the DropBox class was annotated as "@non thread safe", we would get an error reported 
                // No annotation on the class would result in a warning 
              } catch (InterruptedException e) {
                throw new RuntimeException(e);
              }
            } catch (RuntimeException e) {
              ListSequence.fromList(exceptions).addElement(e);
            } finally {
              latch.countDown();
            }
          }
        };

        new Thread(runnable).start();

      }
      try {
        latch.await();
      } catch (InterruptedException e) {
        ListSequence.fromList(exceptions).addElement(e);
      }
      if (ListSequence.fromList(exceptions).isNotEmpty()) {
        throw new ParallelLoopException("Some parallel calculations failed", exceptions);
      }

    }

    // By annotating a local variable, field or parameter declaration as thread safe you indicate that calling methods 
    // on the object is thread-safe 
    // Alt + Enter on variable declarations will let you mark and unmark them as thread-safe 
    final String fixedValue = "fixed value";

    {
      final CountDownLatch latch = new CountDownLatch(ListSequence.fromList(names).count());
      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();

      for (final String name : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<String>(), names))) {

        final String localA = name;

        Runnable runnable = new Runnable() {
          public void run() {
            try {
              String finalString = localA + fixedValue.toUpperCase() + fixedFieldValue;
              log("Result: " + finalString);
            } catch (RuntimeException e) {
              ListSequence.fromList(exceptions).addElement(e);
            } finally {
              latch.countDown();
            }
          }
        };

        new Thread(runnable).start();

      }
      try {
        latch.await();
      } catch (InterruptedException e) {
        ListSequence.fromList(exceptions).addElement(e);
      }
      if (ListSequence.fromList(exceptions).isNotEmpty()) {
        throw new ParallelLoopException("Some parallel calculations failed", exceptions);
      }

    }
    thread.interrupt();
  }

  public static void log(String message) {
    System.out.println(message);
  }
}
