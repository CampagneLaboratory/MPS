package Samples;

/*Generated by MPS */

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISequenceClosure;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;
import java.util.concurrent.CountDownLatch;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import utils.ParallelLoopException;
import java.util.concurrent.atomic.AtomicInteger;

public class ParallelForSample {
  public ParallelForSample() {
  }

  public static void main(String[] args) {
    // Some thread pools to use 
    final ExecutorService myPool = Executors.newFixedThreadPool(3);
    final ExecutorService youPool = Executors.newFixedThreadPool(10);

    // A collection of numbers to play with 
    final Iterable<Integer> numbers = Sequence.fromClosure(new ISequenceClosure<Integer>() {
      public Iterable<Integer> iterable() {
        return new Iterable<Integer>() {
          public Iterator<Integer> iterator() {
            return new YieldingIterator<Integer>() {
              private int __CP__ = 0;

              protected boolean moveToNext() {
__loop__:
                do {
__switch__:
                  switch (this.__CP__) {
                    case -1:
                      assert false : "Internal error";
                      return false;
                    case 2:
                      this.__CP__ = 3;
                      this.yield(1);
                      return true;
                    case 3:
                      this.__CP__ = 4;
                      this.yield(2);
                      return true;
                    case 4:
                      this.__CP__ = 5;
                      this.yield(3);
                      return true;
                    case 5:
                      this.__CP__ = 6;
                      this.yield(4);
                      return true;
                    case 6:
                      this.__CP__ = 1;
                      this.yield(5);
                      return true;
                    case 0:
                      this.__CP__ = 2;
                      break;
                    default:
                      break __loop__;
                  }
                } while (true);
                return false;
              }
            };
          }
        };
      }
    });

    // The optional reference to a thread pool is set in the Inspector (Alt|Command + 2) 
    {
      final CountDownLatch latch = new CountDownLatch(Sequence.fromIterable(numbers).count());
      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();

      for (final int a : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<Integer>(), numbers))) {

        final int localA = a;

        Runnable runnable = new Runnable() {
          public void run() {
            try {
              log("Starting calculation for number " + localA + " in thread " + Thread.currentThread());
              ParallelForSample.sleep(localA * 1000);
              log("Finished calculation for number " + localA + " in thread " + Thread.currentThread());
            } catch (RuntimeException e) {
              ListSequence.fromList(exceptions).addElement(e);
            } finally {
              latch.countDown();
            }
          }
        };

        myPool.execute(runnable);

      }
      try {
        latch.await();
      } catch (InterruptedException e) {
        ListSequence.fromList(exceptions).addElement(e);
      }
      if (ListSequence.fromList(exceptions).isNotEmpty()) {
        throw new ParallelLoopException("Some parallel calculations failed", exceptions);
      }

    }
    log("Done");


    // References to non-final variables and parameters from within parallel loops are reported as errors 
    // Try making the following variable non-final (Alt + Enter) 
    final String doNotMessupWith = "The Shared State";

    // Accessing non-thread-safe classes, such as lists, is reported as warnings 
    final List<String> names = ListSequence.fromListAndArray(new ArrayList<String>(), "Joe", "Dave", "Alice");

    // Accessing thread-safe classes is considered ok 
    final AtomicInteger counter = new AtomicInteger(0);

    {
      final CountDownLatch latch = new CountDownLatch(Sequence.fromIterable(numbers).count());
      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();

      for (final int b : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<Integer>(), numbers))) {

        final int localA = b;

        Runnable runnable = new Runnable() {
          public void run() {
            try {
              log("Touching " + doNotMessupWith);

              int messupWithMeSinceImlocal = 1;
              messupWithMeSinceImlocal += 10;
              log("Local variables can be used without restrictions " + messupWithMeSinceImlocal);

              // Warning since we are accessing a non-local object 
              ListSequence.fromList(names).removeElement("Joe");

              List<String> localNames = ListSequence.fromList(new ArrayList<String>());
              // Local references can be called without restrictions 
              ListSequence.fromList(localNames).addElement("Susan");

              // Thread-safe objects are safe to use as well 
              log("Counter: " + counter.incrementAndGet());

              ParallelForSample.sleep(1000);
            } catch (RuntimeException e) {
              ListSequence.fromList(exceptions).addElement(e);
            } finally {
              latch.countDown();
            }
          }
        };

        youPool.execute(runnable);

      }
      try {
        latch.await();
      } catch (InterruptedException e) {
        ListSequence.fromList(exceptions).addElement(e);
      }
      if (ListSequence.fromList(exceptions).isNotEmpty()) {
        throw new ParallelLoopException("Some parallel calculations failed", exceptions);
      }

    }

    // Iterating over a collection of strings 
    // No thread pool is set (Alt|Command + 2) so using threads directly 
    {
      final CountDownLatch latch = new CountDownLatch(ListSequence.fromList(names).count());
      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();

      for (final String c : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<String>(), names))) {

        final String localA = c;

        Runnable runnable = new Runnable() {
          public void run() {
            try {
              log("Name: " + localA);
              if (localA == "Joe") {
                throw new RuntimeException("test");
              }
            } catch (RuntimeException e) {
              ListSequence.fromList(exceptions).addElement(e);
            } finally {
              latch.countDown();
            }
          }
        };

        new Thread(runnable).start();

      }
      try {
        latch.await();
      } catch (InterruptedException e) {
        ListSequence.fromList(exceptions).addElement(e);
      }
      if (ListSequence.fromList(exceptions).isNotEmpty()) {
        throw new ParallelLoopException("Some parallel calculations failed", exceptions);
      }

    }

    // Shutdown the thread pools 
    myPool.shutdown();
    youPool.shutdown();
  }

  private static void sleep(final int timeout) {
    try {
      Thread.sleep(timeout);
    } catch (InterruptedException e) {
      System.out.println("Interrupted");
    }
  }

  private static void log(String message) {
    System.out.println("Logging: " + message);
  }
}
