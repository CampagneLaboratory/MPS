package Samples;

/*Generated by MPS */

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.Collections;
import utils.ParallelLoopException;
import java.util.concurrent.atomic.AtomicInteger;

public class ParallelForSample {
  public ParallelForSample() {
  }

  public static void main(String[] args) {
    // Some thread pools to use 
    final ExecutorService myPool = Executors.newFixedThreadPool(3);
    final ExecutorService youPool = Executors.newFixedThreadPool(10);

    // A collection of numbers to play with 
    final Iterable<Integer> numbers = ListSequence.fromListAndArray(new ArrayList<Integer>(), 1, 2, 3, 4, 5);

    // The optional reference to a thread pool is set in the Inspector (Alt|Command + 2) 
    {
      final CountDownLatch latch_i0a = new CountDownLatch(Sequence.fromIterable(numbers).count());
      final List<Exception> exceptions_i0a = new CopyOnWriteArrayList<Exception>();

      for (final int a : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<Integer>(), numbers))) {

        final int localA = a;

        Runnable runnable = new Runnable() {
          public void run() {
            try {
              System.out.println("FooBar");
              log("Starting calculation for number " + localA + " in thread " + Thread.currentThread());
              ParallelForSample.sleep(localA * 1000);
              // External (compiled) method calls can be annotated as thread-safe to indicate that they are safe to call 
              log("Finished calculation for number " + localA + " in thread " + Thread.currentThread());
            } catch (RuntimeException e) {
              ListSequence.fromList(exceptions_i0a).addElement(e);
            } finally {
              latch_i0a.countDown();
            }
          }
        };

        myPool.execute(runnable);

      }
      try {
        latch_i0a.await();
      } catch (InterruptedException e) {
        ListSequence.fromList(exceptions_i0a).addElement(e);
      }
      if (ListSequence.fromList(exceptions_i0a).isNotEmpty()) {
        throw new ParallelLoopException("Some parallel calculations failed", exceptions_i0a);
      }

    }
    log("Done");


    // References to non-final variables and parameters from within parallel loops are reported as errors 
    // Try making the following variable non-final (Alt + Enter) 
    final String doNotMessupWith = "The Shared State";

    // Accessing non-thread-safe classes, such as lists, is reported as warnings 
    final List<String> names = ListSequence.fromListAndArray(new ArrayList<String>(), "Joe", "Dave", "Alice");

    // Accessing thread-safe classes is considered ok 
    final AtomicInteger counter = new AtomicInteger(0);

    {
      final CountDownLatch latch_w0a = new CountDownLatch(Sequence.fromIterable(numbers).count());
      final List<Exception> exceptions_w0a = new CopyOnWriteArrayList<Exception>();

      for (final int b : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<Integer>(), numbers))) {

        final int localA = b;

        Runnable runnable = new Runnable() {
          public void run() {
            try {
              System.out.println("FooBar");
              log("Touching " + doNotMessupWith);

              int messupWithMeSinceImlocal = 1;
              messupWithMeSinceImlocal += 10;
              log("Local variables can be used without restrictions " + messupWithMeSinceImlocal);

              // Warning since we are accessing a non-local object 
              ListSequence.fromList(names).removeElement("Joe");

              List<String> localNames = ListSequence.fromList(new ArrayList<String>());
              // Local references can be called without restrictions 
              ListSequence.fromList(localNames).addElement("Susan");

              // Thread-safe objects are safe to use as well 
              log("Counter: " + counter.incrementAndGet());

              ParallelForSample.sleep(1000);
            } catch (RuntimeException e) {
              ListSequence.fromList(exceptions_w0a).addElement(e);
            } finally {
              latch_w0a.countDown();
            }
          }
        };

        youPool.execute(runnable);

      }
      try {
        latch_w0a.await();
      } catch (InterruptedException e) {
        ListSequence.fromList(exceptions_w0a).addElement(e);
      }
      if (ListSequence.fromList(exceptions_w0a).isNotEmpty()) {
        throw new ParallelLoopException("Some parallel calculations failed", exceptions_w0a);
      }

    }

    // Iterating over a collection of strings 
    // No thread pool is set (Alt|Command + 2) so using threads directly 
    {
      final CountDownLatch latch_ab0a = new CountDownLatch(ListSequence.fromList(names).count());
      final List<Exception> exceptions_ab0a = new CopyOnWriteArrayList<Exception>();

      for (final String c : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<String>(), names))) {

        final String localA = c;

        Runnable runnable = new Runnable() {
          public void run() {
            try {
              System.out.println("FooBar");
              log("Name: " + localA);
              if (localA == "Joe") {
                throw new RuntimeException("test");
              }
            } catch (RuntimeException e) {
              ListSequence.fromList(exceptions_ab0a).addElement(e);
            } finally {
              latch_ab0a.countDown();
            }
          }
        };

        new Thread(runnable).start();

      }
      try {
        latch_ab0a.await();
      } catch (InterruptedException e) {
        ListSequence.fromList(exceptions_ab0a).addElement(e);
      }
      if (ListSequence.fromList(exceptions_ab0a).isNotEmpty()) {
        throw new ParallelLoopException("Some parallel calculations failed", exceptions_ab0a);
      }

    }

    // Shutdown the thread pools 
    myPool.shutdown();
    youPool.shutdown();
  }

  private static void sleep(final int timeout) {
    try {
      Thread.sleep(timeout);
    } catch (InterruptedException e) {
      System.out.println("Interrupted");
    }
  }

  private static void log(String message) {
    System.out.println("Logging: " + message);
  }
}
