package jetbrains.mps.lang.structure.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.platform.actions.core.MoveNodeRefactoringParticipant;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.ide.platform.actions.core.RecursiveParticipant;
import jetbrains.mps.smodel.structure.Extension;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.ide.platform.actions.core.RefactoringParticipant;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.platform.actions.core.RefactoringSession;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import java.util.HashMap;
import jetbrains.mps.smodel.CopyUtil;

public class MoveAspectsParticipant implements MoveNodeRefactoringParticipant<SNodeReference, SNodeReference>, RecursiveParticipant<SNodeReference, SNodeReference> {

  public static class MoveAspectsParticipant_extension extends Extension.Default<MoveNodeRefactoringParticipant<?, ?>> {
    public MoveAspectsParticipant_extension() {
      super("jetbrains.mps.ide.platform.MoveNodeParticipantEP");
    }
    public MoveNodeRefactoringParticipant<?, ?> get() {
      return new MoveAspectsParticipant();
    }
  }

  private MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference> myDataCollector = new MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference>() {
    public SNodeReference beforeMove(SNode nodeToMove) {
      return nodeToMove.getReference();
    }
    public SNodeReference afterMove(SNode movedNode) {
      return movedNode.getReference();
    }
  };

  public MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference> getDataCollector() {
    return myDataCollector;
  }

  @Override
  public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> getChanges(final SNodeReference initialState, final SRepository repository, final SearchScope searchScope) {
    return getChanges(initialState, repository, searchScope, Sequence.fromIterable(Collections.<RefactoringParticipant.ParticipantState>emptyList()));
  }

  public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> getChanges(final SNodeReference initialState, final SRepository repository, final SearchScope searchScope, final Iterable<RefactoringParticipant.ParticipantState> parents) {
    if (!(((SNodeOperations.as(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration")) != null) && SNodeOperations.getModel(SNodeOperations.cast(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"))).getModule() instanceof Language))) {
      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<SNodeReference, SNodeReference>>());
    } else {
      final SNode sourceConcept = SNodeOperations.cast(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"));
      Language sourceLanguage = ((Language) SNodeOperations.getModel(sourceConcept).getModule());

      Map<LanguageAspect, List<SNode>> aspectsMap = MoveConceptUtil.getAspectNodes(sourceLanguage, Sequence.<SNode>singleton(sourceConcept));

      return MapSequence.fromMap(aspectsMap).translate(new ITranslator2<IMapping<LanguageAspect, List<SNode>>, RefactoringParticipant.Change<SNodeReference, SNodeReference>>() {
        public Iterable<RefactoringParticipant.Change<SNodeReference, SNodeReference>> translate(final IMapping<LanguageAspect, List<SNode>> mapping) {
          return ListSequence.fromList(mapping.value()).select(new ISelector<SNode, RefactoringParticipant.Change<SNodeReference, SNodeReference>>() {
            public RefactoringParticipant.Change<SNodeReference, SNodeReference> select(final SNode aspect) {

              final List<RecursiveParticipant.RecursiveParticipantState<?, ?>> childparticipantStates = Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.ide.platform.MoveNodeParticipantEP").getObjects()).select(new ISelector<MoveNodeRefactoringParticipant<?, ?>, RecursiveParticipant.RecursiveParticipantState<?, ?>>() {
                public RecursiveParticipant.RecursiveParticipantState<?, ?> select(MoveNodeRefactoringParticipant<?, ?> participant) {
                  return RecursiveParticipant.RecursiveParticipantState.create(participant, aspect, repository, searchScope, parents);
                }
              }).toListSequence();

              final SearchResults results = new SearchResults();
              results.addAll(new SearchResults(SetSequence.fromSetAndArray(new HashSet<SNode>(), sourceConcept), ListSequence.fromListAndArray(new ArrayList<SearchResult<SNode>>(), new SearchResult<SNode>(aspect, "concept aspect"))));
              ListSequence.fromList(childparticipantStates).translate(new ITranslator2<RecursiveParticipant.RecursiveParticipantState<?, ?>, RefactoringParticipant.Change<Object, Object>>() {
                public Iterable<RefactoringParticipant.Change<Object, Object>> translate(RecursiveParticipant.RecursiveParticipantState<?, ?> it) {
                  return ((RefactoringParticipant.ParticipantState) it).getChanges();
                }
              }).select(new ISelector<RefactoringParticipant.Change<Object, Object>, SearchResults>() {
                public SearchResults select(RefactoringParticipant.Change<Object, Object> it) {
                  return it.getSearchResults();
                }
              }).visitAll(new IVisitor<SearchResults>() {
                public void visit(SearchResults it) {
                  results.addAll(it);
                }
              });

              RefactoringParticipant.Change<SNodeReference, SNodeReference> change = new RefactoringParticipant.Change<SNodeReference, SNodeReference>() {
                public SearchResults getSearchResults() {
                  return results;
                }
                public boolean needsToPreserveOldNode() {
                  return ListSequence.fromList(childparticipantStates).translate(new ITranslator2<RecursiveParticipant.RecursiveParticipantState<?, ?>, RefactoringParticipant.Change<Object, Object>>() {
                    public Iterable<RefactoringParticipant.Change<Object, Object>> translate(RecursiveParticipant.RecursiveParticipantState<?, ?> it) {
                      return ((RefactoringParticipant.ParticipantState) it).getChanges();
                    }
                  }).any(new IWhereFilter<RefactoringParticipant.Change<Object, Object>>() {
                    public boolean accept(RefactoringParticipant.Change<Object, Object> it) {
                      return it.needsToPreserveOldNode();
                    }
                  });
                }
                public void confirm(SNodeReference finalState, final SRepository repository, final RefactoringSession refactoringSession) {
                  SNode targetConcept = SNodeOperations.cast(finalState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"));
                  Language targetLanguage = ((Language) SNodeOperations.getModel(targetConcept).getModule());
                  NodeLocation.NodeLocationRootWithAspectModelCreation newLocation = new NodeLocation.NodeLocationRootWithAspectModelCreation(targetLanguage, mapping.key());

                  Map<SNode, SNode> copyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
                  final List<SNode> copied = CopyUtil.copyAndPreserveId(ListSequence.fromListAndArray(new ArrayList<SNode>(), aspect), copyMap);

                  if (!(needsToPreserveOldNode())) {
                    SNodeOperations.detachNode(aspect);
                  }
                  newLocation.insertNode(repository, ListSequence.fromList(copied).first());
                  ListSequence.fromList(childparticipantStates).visitAll(new IVisitor<RecursiveParticipant.RecursiveParticipantState<?, ?>>() {
                    public void visit(RecursiveParticipant.RecursiveParticipantState<?, ?> pis) {
                      pis.confirm(ListSequence.fromList(copied).first(), repository, refactoringSession);
                    }
                  });
                }
              };
              return (RefactoringParticipant.Change<SNodeReference, SNodeReference>) change;
            }
          });
        }
      }).toListSequence();
    }
  }
  public String getId() {
    return "moveNode.moveConceptAspects";
  }
  public String getDescription() {
    return "Move concept aspects";
  }
}
