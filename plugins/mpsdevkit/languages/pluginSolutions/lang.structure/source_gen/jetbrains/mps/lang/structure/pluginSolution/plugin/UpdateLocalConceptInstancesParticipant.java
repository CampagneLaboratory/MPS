package jetbrains.mps.lang.structure.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.platform.actions.core.MoveNodeRefactoringParticipant;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.structure.Extension;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import java.util.List;
import jetbrains.mps.ide.platform.actions.core.RefactoringParticipant;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.query.CommandUtil;
import jetbrains.mps.smodel.query.QueryExecutionContext;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.ide.platform.actions.core.RefactoringSession;
import jetbrains.mps.ide.platform.actions.core.MoveNodesDefault;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.lang.structure.plugin.RefactoringRuntime;

public class UpdateLocalConceptInstancesParticipant implements MoveNodeRefactoringParticipant<SAbstractConcept, SAbstractConcept> {

  public static class UpdateLocalInstances_extension extends Extension.Default<MoveNodeRefactoringParticipant<?, ?>> {
    public UpdateLocalInstances_extension() {
      super("jetbrains.mps.ide.platform.MoveNodeParticipantEP");
    }
    public MoveNodeRefactoringParticipant<?, ?> get() {
      return new UpdateLocalConceptInstancesParticipant();
    }
  }

  public String getId() {
    return "moveNode.updateConceptInstances";
  }
  public String getDescription() {
    return "Update concept instances in current project";
  }
  private MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SAbstractConcept, SAbstractConcept> myDataCollector = new MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SAbstractConcept, SAbstractConcept>() {
    public SAbstractConcept beforeMove(SNode nodeToMove) {
      if (SNodeOperations.isInstanceOf(nodeToMove, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration")) && SNodeOperations.getModel(nodeToMove).getModule() instanceof Language) {
        return MetaAdapterByDeclaration.getConcept(nodeToMove);
      } else {
        return null;
      }
    }
    public SAbstractConcept afterMove(SNode movedNode) {
      if (SNodeOperations.isInstanceOf(movedNode, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration")) && SNodeOperations.getModel(movedNode).getModule() instanceof Language) {
        return MetaAdapterByDeclaration.getConcept(movedNode);
      } else {
        return null;
      }
    }
  };
  public MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SAbstractConcept, SAbstractConcept> getDataCollector() {
    return myDataCollector;
  }
  public List<RefactoringParticipant.Change<SAbstractConcept, SAbstractConcept>> getChanges(final SAbstractConcept initialState, SRepository repository, SearchScope searchScope) {
    if (initialState == null) {
      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<SAbstractConcept, SAbstractConcept>>());
    }
    {
      final SearchScope scope = CommandUtil.createScope(searchScope);
      QueryExecutionContext context = new QueryExecutionContext() {
        public SearchScope getDefaultSearchScope() {
          return scope;
        }
      };
      Collection<SNode> instances = CollectionSequence.fromCollection(CommandUtil.instances(CommandUtil.createConsoleScope(null, false, context), SNodeOperations.asSConcept(initialState))).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(it)), SNodeOperations.asSConcept(initialState));
        }
      }).toListSequence();

      return CollectionSequence.fromCollection(instances).select(new ISelector<SNode, RefactoringParticipant.Change<SAbstractConcept, SAbstractConcept>>() {
        public RefactoringParticipant.Change<SAbstractConcept, SAbstractConcept> select(SNode instance) {
          final SNodeReference nodeRef = instance.getReference();
          final SearchResults searchResults = new SearchResults();
          searchResults.add(new SearchResult<SNode>(instance, "instance"));
          RefactoringParticipant.Change<SAbstractConcept, SAbstractConcept> change = new RefactoringParticipant.Change<SAbstractConcept, SAbstractConcept>() {
            public MoveNodeRefactoringParticipant<SAbstractConcept, SAbstractConcept> getParticipant() {
              return UpdateLocalConceptInstancesParticipant.this;
            }
            public SearchResults getSearchResults() {
              return searchResults;
            }
            public boolean needsToPreserveOldNode() {
              return false;
            }
            public void confirm(final SAbstractConcept finalState, final SRepository repository, final RefactoringSession refactoringSession) {
              refactoringSession.registerChange(new Runnable() {
                public void run() {
                  SNode node = nodeRef.resolve(repository);
                  MoveNodesDefault.CopyMapObject copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession);
                  if (node == null || MapSequence.fromMap(copyMap.getCopyMap()).containsKey(node)) {
                    RefactoringRuntime.replaceWithNewConcept(MapSequence.fromMap(copyMap.getCopyMap()).get(node), finalState);
                  }
                  RefactoringRuntime.replaceWithNewConcept(node, finalState);
                }
              });
            }
          };
          return change;
        }
      }).toListSequence();
    }
  }
}
