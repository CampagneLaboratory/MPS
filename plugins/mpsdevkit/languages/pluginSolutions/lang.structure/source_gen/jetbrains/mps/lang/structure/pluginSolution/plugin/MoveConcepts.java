package jetbrains.mps.lang.structure.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.platform.actions.core.MoveNodesDefault;
import jetbrains.mps.project.MPSProject;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration_Behavior;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.ide.refactoring.SModelReferenceDialog;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.ide.findusages.model.SearchResults;
import java.util.Map;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.findUsages.FindUsagesManager;
import jetbrains.mps.project.GlobalScope;
import java.util.HashSet;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.ide.platform.actions.core.RefactoringViewUtil;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.lang.structure.plugin.RefactoringRuntime;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import java.util.ArrayList;

public class MoveConcepts extends MoveNodesDefault {


  public String getName() {
    return "Move Concepts";
  }
  public boolean isApplicable(MPSProject project, final List<SNode> target) {
    final Wrappers._boolean result = new Wrappers._boolean();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        result.value = ListSequence.fromList(target).all(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration")) && SNodeOperations.getModel(it) == SNodeOperations.getModel(ListSequence.fromList(target).first());
          }
        });
      }
    });
    return result.value;
  }
  public void apply(final MPSProject project, List<SNode> target) {
    final List<SNode> conceptsToMove = (List<SNode>) target;
    final SModel sourceModel = SNodeOperations.getModel(ListSequence.fromList(conceptsToMove).first());
    final Language sourceLanguage = Language.getLanguageFor(sourceModel);

    MoveNodesUI moveNodesUI = MoveNodesUI.MoveNodesUIImpl.getIsntance();

    final Wrappers._boolean hasGenerator = new Wrappers._boolean(false);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        hasGenerator.value = ListSequence.fromList(conceptsToMove).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode node) {
            return ListSequence.fromList(AbstractConceptDeclaration_Behavior.call_findGeneratorFragments_6409339300305625383(node)).isNotEmpty();
          }
        });
      }
    });
    if (hasGenerator.value) {
      moveNodesUI.showWarningDialog(project, "Generator fragments will not be moved.", "Move concepts");
    }

    final Wrappers._T<List<SModelReference>> structureModels = new Wrappers._T<List<SModelReference>>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = project.getRepository().getModules();
        structureModels.value = Sequence.fromIterable(modules).ofType(Language.class).select(new ISelector<Language, SModelReference>() {
          public SModelReference select(Language it) {
            return it.getStructureModelDescriptor().getReference();
          }
        }).toListSequence();
      }
    });
    final SModelReference targetModelRef = SModelReferenceDialog.getSelectedModel(project.getProject(), structureModels.value);
    if (targetModelRef == null) {
      return;
    }

    final MoveNodesUI.WhetherWriteMigration writeMigration = moveNodesUI.askAboutMigration(project);

    if (writeMigration == MoveNodesUI.WhetherWriteMigration.CANCEL) {
      return;
    }

    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        for (SNode concept : ListSequence.fromList(conceptsToMove)) {
          if (!(SNodeUtil.isAccessible(concept, project.getRepository()))) {
            return;
          }
        }
        final SModel targetModel = targetModelRef.resolve(project.getRepository());
        if (targetModel == null) {
          return;
        }
        final Language targetLanguage = (Language) targetModel.getModule();

        if (writeMigration == MoveNodesUI.WhetherWriteMigration.WRITE_MIGRATION) {
          MoveConceptUtil.moveConcepts(conceptsToMove, targetModel);
        }
        if (writeMigration == MoveNodesUI.WhetherWriteMigration.LOCALLY) {
          SearchResults<SNode> searchResults = new SearchResults<SNode>();

          final Map<LanguageAspect, List<SNode>> aspectsMap = MoveConceptUtil.getAspectNodes(sourceLanguage, conceptsToMove);
          Iterable<SNode> aspectNodes = MapSequence.fromMap(aspectsMap).translate(new ITranslator2<IMapping<LanguageAspect, List<SNode>>, SNode>() {
            public Iterable<SNode> translate(IMapping<LanguageAspect, List<SNode>> it) {
              return it.value();
            }
          });
          searchResults.addAll(nodesToRefactoringResult(conceptsToMove, aspectNodes, "concept aspect"));


          final Set<SReference> refUsages = findUsages(project, ListSequence.fromList(conceptsToMove).concat(Sequence.fromIterable(aspectNodes)));
          searchResults.addAll(nodesToRefactoringResult(conceptsToMove, SetSequence.fromSet(refUsages).select(new ISelector<SReference, SNode>() {
            public SNode select(SReference it) {
              return it.getSourceNode();
            }
          }), "reference"));
          final Set<SNode> instances = FindUsagesManager.getInstance().findInstances(GlobalScope.getInstance(), SetSequence.fromSetWithValues(new HashSet<SAbstractConcept>(), ListSequence.fromList(conceptsToMove).select(new ISelector<SNode, SAbstractConcept>() {
            public SAbstractConcept select(SNode it) {
              return SNodeOperations.asSConcept(it);
            }
          })), false, new EmptyProgressMonitor());
          searchResults.addAll(nodesToRefactoringResult(conceptsToMove, instances, "instance"));

          RefactoringViewUtil.refactor(project, searchResults, new _FunctionTypes._void_P1_E0<Set<SNode>>() {
            public void invoke(final Set<SNode> included) {
              Map<SReference, SNode> usagesMap = classifyUsages(SetSequence.fromSet(refUsages).where(new IWhereFilter<SReference>() {
                public boolean accept(SReference it) {
                  return SetSequence.fromSet(included).contains(it.getSourceNode());
                }
              }));
              Map<SAbstractConcept, Tuples._2<MoveConcepts.ConceptInfo, MoveConcepts.ConceptInfo>> sConceptMap = MapSequence.fromMap(new HashMap<SAbstractConcept, Tuples._2<MoveConcepts.ConceptInfo, MoveConcepts.ConceptInfo>>());
              for (SNode concept : ListSequence.fromList(conceptsToMove)) {
                SAbstractConcept oldConcept = SNodeOperations.asSConcept(concept);
                MoveConcepts.ConceptInfo oldConceptInfo = new MoveConcepts.ConceptInfo(oldConcept);
                for (SNode prop : ListSequence.fromList(SLinkOperations.getChildren(concept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, "propertyDeclaration")))) {
                  ListSequence.fromList(oldConceptInfo.propMap).addElement(MetaAdapterByDeclaration.getProperty(prop));
                }
                for (SNode link : ListSequence.fromList(SLinkOperations.getChildren(concept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, "linkDeclaration"))).where(new IWhereFilter<SNode>() {
                  public boolean accept(SNode it) {
                    return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, "metaClass"), "reference", "reference");
                  }
                })) {
                  ListSequence.fromList(oldConceptInfo.refMap).addElement(MetaAdapterByDeclaration.getReferenceLink(link));
                }
                for (SNode link : ListSequence.fromList(SLinkOperations.getChildren(concept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, "linkDeclaration"))).where(new IWhereFilter<SNode>() {
                  public boolean accept(SNode it) {
                    return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, "metaClass"), "aggregation", "reference");
                  }
                })) {
                  ListSequence.fromList(oldConceptInfo.childMap).addElement(MetaAdapterByDeclaration.getContainmentLink(link));
                }
                concept.getModel().removeRootNode(concept);
                targetModel.addRootNode(concept);
                SAbstractConcept newConcept = SNodeOperations.asSConcept(concept);
                MoveConcepts.ConceptInfo newConceptInfo = new MoveConcepts.ConceptInfo(newConcept);
                for (SNode prop : ListSequence.fromList(SLinkOperations.getChildren(concept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, "propertyDeclaration")))) {
                  ListSequence.fromList(newConceptInfo.propMap).addElement(MetaAdapterByDeclaration.getProperty(prop));
                }
                for (SNode link : ListSequence.fromList(SLinkOperations.getChildren(concept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, "linkDeclaration"))).where(new IWhereFilter<SNode>() {
                  public boolean accept(SNode it) {
                    return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, "metaClass"), "reference", "reference");
                  }
                })) {
                  ListSequence.fromList(newConceptInfo.refMap).addElement(MetaAdapterByDeclaration.getReferenceLink(link));
                }
                for (SNode link : ListSequence.fromList(SLinkOperations.getChildren(concept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, "linkDeclaration"))).where(new IWhereFilter<SNode>() {
                  public boolean accept(SNode it) {
                    return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, "metaClass"), "aggregation", "reference");
                  }
                })) {
                  ListSequence.fromList(newConceptInfo.childMap).addElement(MetaAdapterByDeclaration.getContainmentLink(link));
                }
                MapSequence.fromMap(sConceptMap).put(oldConcept, MultiTuple.<MoveConcepts.ConceptInfo,MoveConcepts.ConceptInfo>from(oldConceptInfo, newConceptInfo));
              }
              for (LanguageAspect aspect : SetSequence.fromSet(MapSequence.fromMap(aspectsMap).keySet())) {
                SModel toModel = aspect.getOrCreate(targetLanguage);
                for (SNode aspectNode : ListSequence.fromList(MapSequence.fromMap(aspectsMap).get(aspect)).where(new IWhereFilter<SNode>() {
                  public boolean accept(SNode it) {
                    return SetSequence.fromSet(included).contains(it);
                  }
                })) {
                  aspectNode.getModel().removeRootNode(aspectNode);
                  toModel.addRootNode(aspectNode);
                }
              }
              for (IMapping<SReference, SNode> mapping : MapSequence.fromMap(usagesMap)) {
                updateUsage(mapping.key(), mapping.value());
              }
              for (final SNode instance : SetSequence.fromSet(instances).where(new IWhereFilter<SNode>() {
                public boolean accept(SNode it) {
                  return SetSequence.fromSet(included).contains(it);
                }
              })) {
                for (SAbstractConcept concept : SetSequence.fromSet(MapSequence.fromMap(sConceptMap).keySet()).where(new IWhereFilter<SAbstractConcept>() {
                  public boolean accept(SAbstractConcept it) {
                    return instance.isInstanceOfConcept(it);
                  }
                })) {
                  for (int i = 0; i < ListSequence.fromList(MapSequence.fromMap(sConceptMap).get(concept)._0().propMap).count(); i++) {
                    RefactoringRuntime.changePropertyInstance(instance, ListSequence.fromList(MapSequence.fromMap(sConceptMap).get(concept)._0().propMap).getElement(i), ListSequence.fromList(MapSequence.fromMap(sConceptMap).get(concept)._1().propMap).getElement(i));
                  }
                  for (int i = 0; i < ListSequence.fromList(MapSequence.fromMap(sConceptMap).get(concept)._0().refMap).count(); i++) {
                    RefactoringRuntime.changeReferenceLinkInstances(instance, ListSequence.fromList(MapSequence.fromMap(sConceptMap).get(concept)._0().refMap).getElement(i), ListSequence.fromList(MapSequence.fromMap(sConceptMap).get(concept)._1().refMap).getElement(i));
                  }
                  for (int i = 0; i < ListSequence.fromList(MapSequence.fromMap(sConceptMap).get(concept)._0().childMap).count(); i++) {
                    RefactoringRuntime.changeContainmentLinkInstance(instance, ListSequence.fromList(MapSequence.fromMap(sConceptMap).get(concept)._0().childMap).getElement(i), ListSequence.fromList(MapSequence.fromMap(sConceptMap).get(concept)._1().childMap).getElement(i));
                  }
                  if (instance.getConcept().equals(concept)) {
                    // exact instance 
                    RefactoringRuntime.replaceWithNewConcept(instance, MapSequence.fromMap(sConceptMap).get(instance.getConcept())._1().concept);
                  }
                }
              }
            }
          }, "Move concepts");
        }
      }
    });

  }

  public static class ConceptInfo {
    public final SAbstractConcept concept;
    public final List<SProperty> propMap;
    public final List<SReferenceLink> refMap;
    public final List<SContainmentLink> childMap;
    public ConceptInfo(SAbstractConcept concept) {
      this.concept = concept;
      propMap = ListSequence.fromList(new ArrayList<SProperty>());
      refMap = ListSequence.fromList(new ArrayList<SReferenceLink>());
      childMap = ListSequence.fromList(new ArrayList<SContainmentLink>());
    }
  }

}
