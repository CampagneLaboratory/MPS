package jetbrains.mps.lang.structure.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.platform.actions.core.MoveNodeRefactoringParticipant;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.smodel.Language;
import java.util.Collection;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SearchScope;
import java.util.List;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.ide.platform.actions.core.RefactoringParticipant;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.ide.platform.actions.core.RefactoringSession;
import jetbrains.mps.ide.platform.actions.core.MoveNodesDefault;

public abstract class UpdateLocalInstancesParticipant<I, F> implements MoveNodeRefactoringParticipant<Tuples._2<Language, I>, Tuples._2<Language, F>>, MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<Tuples._2<Language, I>, Tuples._2<Language, F>> {


  public MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<Tuples._2<Language, I>, Tuples._2<Language, F>> getDataCollector() {
    return this;
  }

  public abstract Collection<SNode> findInstances(I concept, SearchScope searchScope);

  public List<String> getOptions(Tuples._2<Language, I> initialState, SRepository repository) {
    if (initialState != null) {
      return ListSequence.fromListAndArray(new ArrayList<String>(), getDescription());
    } else {
      return ListSequence.fromList(new ArrayList<String>());
    }
  }
  public String getDescription() {
    return "Update instances in current project";
  }

  public List<RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>> getChanges(Tuples._2<Language, I> initialState, SRepository repository, Map<String, Boolean> options, SearchScope searchScope) {
    if (!(MapSequence.fromMap(options).get(getDescription())) || initialState == null) {
      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>>());
    }
    Collection<SNode> instances = findInstances(initialState._1(), searchScope);

    return CollectionSequence.fromCollection(instances).select(new ISelector<SNode, RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>>() {
      public RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>> select(SNode instance) {
        final SNodeReference nodeRef = instance.getReference();
        final SearchResults searchResults = new SearchResults();
        searchResults.add(new SearchResult<SNode>(instance, "instance"));
        RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>> change = new RefactoringParticipant.Change<Tuples._2<Language, I>, Tuples._2<Language, F>>() {
          public MoveNodeRefactoringParticipant<Tuples._2<Language, I>, Tuples._2<Language, F>> getParticipant() {
            return UpdateLocalInstancesParticipant.this;
          }
          public SearchResults getSearchResults() {
            return searchResults;
          }
          public boolean needsToPreserveOldNode() {
            return false;
          }
          public void confirm(final Tuples._2<Language, F> finalState, final SRepository repository, final RefactoringSession refactoringSession) {
            refactoringSession.registerChange(new Runnable() {
              public void run() {
                SNode node = nodeRef.resolve(repository);
                MoveNodesDefault.CopyMapObject copyMap = MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession);
                if (node == null || MapSequence.fromMap(copyMap.getCopyMap()).containsKey(node)) {
                  doReplaceInstance(MapSequence.fromMap(copyMap.getCopyMap()).get(node), finalState._1());
                }
                doReplaceInstance(node, finalState._1());
              }
            });
          }
        };
        return change;
      }
    }).toListSequence();
  }

  public abstract void doReplaceInstance(SNode instance, F newConcept);
}
