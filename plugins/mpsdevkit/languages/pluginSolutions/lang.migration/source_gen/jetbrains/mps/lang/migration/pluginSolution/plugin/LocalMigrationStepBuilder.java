package jetbrains.mps.lang.migration.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.platform.actions.core.MoveRefactoringContributor;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.List;
import jetbrains.mps.lang.migration.runtime.base.MoveNodePart;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.smodel.structure.Extension;
import jetbrains.mps.ide.platform.actions.core.MoveContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.ide.findusages.model.SearchResult;
import java.util.Iterator;

public class LocalMigrationStepBuilder implements MoveRefactoringContributor {
  private SearchScope mySearchScope;
  private SRepository myRepository;
  private List<MoveNodePart> myParts;
  private List<List<SNodeReference>> affectedNodes;



  public static class LocalMigrationStepBuilder_extension extends Extension.Default<MoveRefactoringContributor.MoveNodesBuilderFactory> {
    public LocalMigrationStepBuilder_extension() {
      super("jetbrains.mps.ide.platform.MoveNodesBuilderEP");
    }
    public MoveRefactoringContributor.MoveNodesBuilderFactory get() {
      return new MoveRefactoringContributor.MoveNodesBuilderFactory() {
        public MoveRefactoringContributor createContributor(MoveContext context) {
          return new LocalMigrationStepBuilder(context.getSearchScope());
        }
      };
    }
  }


  public LocalMigrationStepBuilder(SearchScope searchScope) {
    mySearchScope = searchScope;
  }

  public void willBeMoved(List<SNode> nodes) {
    myParts = ListSequence.fromList(new ArrayList<MoveNodePart>(ListSequence.fromList(nodes).count()));
    if (ListSequence.fromList(nodes).isNotEmpty()) {
      Iterable<SRepository> seq = ListSequence.fromList(nodes).select(new ISelector<SNode, SRepository>() {
        public SRepository select(SNode it) {
          return SNodeOperations.getModel(it).getRepository();
        }
      });
      myRepository = Sequence.fromIterable(seq).first();
      if (!(Sequence.fromIterable(seq).all(new IWhereFilter<SRepository>() {
        public boolean accept(SRepository it) {
          return eq_f4ilh2_a0a0a0a0a0a2a1a21(it, myRepository);
        }
      }))) {
        throw new IllegalArgumentException("All nodes should be from the same repository.");
      }
    }
    for (SNode from : ListSequence.fromList(nodes)) {
      ListSequence.fromList(myParts).addElement(new MoveNodePart(from.getReference()));
    }
    affectedNodes = ListSequence.fromList(new ArrayList<List<SNodeReference>>());
    for (MoveNodePart part : ListSequence.fromList(myParts)) {
      ListSequence.fromList(affectedNodes).addElement(Sequence.fromIterable(part.getAffectedNodes(mySearchScope, myRepository)).toListSequence());
    }
  }
  public SearchResults getAffectedNodes() {
    if (affectedNodes == null) {
      throw new IllegalStateException("isMoved() can be called only after willBeMoved()");
    }
    SearchResults results = new SearchResults();
    results.getSearchedNodes().addAll(ListSequence.fromList(myParts).select(new ISelector<MoveNodePart, SNodeReference>() {
      public SNodeReference select(MoveNodePart it) {
        return it.getFrom();
      }
    }).toListSequence());
    results.getSearchResults().addAll(ListSequence.fromList(affectedNodes).translate(new ITranslator2<List<SNodeReference>, SNodeReference>() {
      public Iterable<SNodeReference> translate(List<SNodeReference> it) {
        return it;
      }
    }).select(new ISelector<SNodeReference, SearchResult>() {
      public SearchResult select(SNodeReference it) {
        return new SearchResult(it, "reference");
      }
    }).toListSequence());
    return results;
  }
  public void isMoved(List<SNode> nodes) {
    if (myParts == null) {
      throw new IllegalStateException("isMoved() should be called after willBeMoved()");
    }

    if (ListSequence.fromList(nodes).isNotEmpty()) {
      Iterable<SRepository> seq = ListSequence.fromList(nodes).select(new ISelector<SNode, SRepository>() {
        public SRepository select(SNode it) {
          return SNodeOperations.getModel(it).getRepository();
        }
      });
      if (!(Sequence.fromIterable(seq).all(new IWhereFilter<SRepository>() {
        public boolean accept(SRepository it) {
          return eq_f4ilh2_a0a0a0a0a0a1a2a41(it, myRepository);
        }
      }))) {
        throw new IllegalArgumentException("All nodes should be from the same repository.");
      }
    }
    if (ListSequence.fromList(myParts).count() != ListSequence.fromList(nodes).count()) {
      throw new IllegalArgumentException("List size mismatch");
    }
    {
      Iterator<SNode> to_it = ListSequence.fromList(nodes).iterator();
      Iterator<MoveNodePart> moveNodePart_it = ListSequence.fromList(myParts).iterator();
      SNode to_var;
      MoveNodePart moveNodePart_var;
      while (to_it.hasNext() && moveNodePart_it.hasNext()) {
        to_var = to_it.next();
        moveNodePart_var = moveNodePart_it.next();
        moveNodePart_var.setTo(to_var.getReference());
      }
    }
  }
  public void commit() {
    if (myParts == null) {
      throw new IllegalStateException("commit() should be called after willBeMoved() and isMoved()");
    }
    if (ListSequence.fromList(myParts).count() == ListSequence.fromList(affectedNodes).count()) {
      throw new IllegalStateException("affectedNodes is not properly initialized");
    }
    if (ListSequence.fromList(myParts).isEmpty()) {
      return;
    }
    if (myRepository == null) {
      throw new IllegalStateException("repository is null");
    }

    {
      Iterator<MoveNodePart> part_it = ListSequence.fromList(myParts).iterator();
      Iterator<List<SNodeReference>> affected_it = ListSequence.fromList(affectedNodes).iterator();
      MoveNodePart part_var;
      List<SNodeReference> affected_var;
      while (part_it.hasNext() && affected_it.hasNext()) {
        part_var = part_it.next();
        affected_var = affected_it.next();
        part_var.execute(ListSequence.fromList(affected_var).select(new ISelector<SNodeReference, SNode>() {
          public SNode select(SNodeReference it) {
            return it.resolve(myRepository);
          }
        }));
      }
    }
  }
  private static boolean eq_f4ilh2_a0a0a0a0a0a2a1a21(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
  private static boolean eq_f4ilh2_a0a0a0a0a0a1a2a41(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
