package jetbrains.mps.ide.devkit.actions;

/*Generated by MPS */

import jetbrains.mps.plugins.relations.RelationDescriptor;
import javax.swing.Icon;
import jetbrains.mps.icons.MPSIcons;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import com.intellij.openapi.project.Project;
import jetbrains.mps.workbench.MPSDataKeys;
import com.intellij.ide.DataManager;
import javax.swing.JFrame;
import com.intellij.openapi.wm.WindowManager;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.smodel.Generator;
import java.util.ArrayList;
import jetbrains.mps.ide.dialogs.project.creation.NewGeneratorDialog;
import jetbrains.mps.extapi.model.EditableSModel;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.generator.GenerationFacade;
import jetbrains.mps.ide.actions.MappingDialog;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public class Generator_TabDescriptor extends RelationDescriptor {
  private static final Icon ICON = MPSIcons.Nodes.Reduction;

  public Generator_TabDescriptor() {
  }

  public String getTitle() {
    return "Generator";
  }

  public Character getShortcutChar() {
    return 'G';
  }

  public int compareTo(RelationDescriptor descriptor) {
    return new Generator_Order().compare(this, descriptor);
  }

  public void startListening() {
  }

  public SNode getBaseNode(SNode node) {
    return ConceptEditorOpenHelper.getBaseNode(node);
  }

  public boolean isApplicable(SNode node) {
    return SNodeOperations.isInstanceOf(node, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration");
  }

  @Nullable
  public Icon getIcon() {
    return ICON;
  }

  public List<SNode> getNodes(SNode node) {
    Set<SNode> nodes = SetSequence.fromSet(new HashSet<SNode>());
    SetSequence.fromSet(nodes).addSequence(ListSequence.fromList(BehaviorReflection.invokeNonVirtual((Class<List<SNode>>) ((Class) Object.class), node, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", "call_findGeneratorFragments_6409339300305625383", new Object[]{})));
    return SetSequence.fromSet(nodes).toListSequence();
  }

  public boolean isSingle() {
    return false;
  }

  public List<SNode> getConcepts(final SNode node) {
    List<SNode> result = ConceptEditorHelper.getAvailableConceptAspects(SNodeOperations.getModel(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.generator.structure.TemplateSwitch")), node);
    ListSequence.fromList(result).addElement(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.generator.structure.InlineTemplate_RuleConsequence"));
    ListSequence.fromList(result).addElement(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.generator.structure.InlineTemplateWithContext_RuleConsequence"));
    boolean rootable = SNodeOperations.isInstanceOf(node, "jetbrains.mps.lang.structure.structure.ConceptDeclaration") && SPropertyOperations.getBoolean((SNodeOperations.cast(node, "jetbrains.mps.lang.structure.structure.ConceptDeclaration")), "rootable");
    boolean isInterface = SNodeOperations.isInstanceOf(node, "jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration");
    if (rootable || isInterface) {
      boolean isNeedRootTemplate = true;
      for (SNode genFragment : BehaviorReflection.invokeNonVirtual((Class<List<SNode>>) ((Class) Object.class), node, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", "call_findGeneratorFragments_6409339300305625383", new Object[]{})) {
        if ((AttributeOperations.getAttribute(genFragment, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.generator.structure.RootTemplateAnnotation"))) != null)) {
          isNeedRootTemplate = false;
          break;
        }
      }
      if (isNeedRootTemplate) {
        for (ModuleReference moduleRef : ((jetbrains.mps.smodel.SModel) SNodeOperations.getModel(node)).importedLanguages()) {
          Language language = ModuleRepositoryFacade.getInstance().getModule(moduleRef, Language.class);
          if (language == null) {
            continue;
          }
          SModel structureModel = language.getStructureModelDescriptor().getSModel();
          for (SNode nodeToAdd : SModelOperations.getRoots(structureModel, "jetbrains.mps.lang.structure.structure.ConceptDeclaration")) {
            SNode conceptToAdd = (SNode) nodeToAdd;
            if (SPropertyOperations.getBoolean(nodeToAdd, "rootable")) {
              ListSequence.fromList(result).addElement(conceptToAdd);
            }
          }
        }
      }
    }
    return result;
  }

  public boolean commandOnCreate() {
    return false;
  }

  public SNode createNode(final SNode node, final SNode concept) {
    Project project = MPSDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext());
    JFrame frame = WindowManager.getInstance().getFrame(project);

    final Wrappers._T<Language> language = new Wrappers._T<Language>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        language.value = SModelUtil.getDeclaringLanguage(node);
        assert language.value != null : "Language shouldn't be null for " + node;
      }
    });

    final List<Generator> genList = ListSequence.fromListWithValues(new ArrayList<Generator>(), language.value.getGenerators());
    if (ListSequence.fromList(genList).isEmpty()) {
      NewGeneratorDialog dialog = new NewGeneratorDialog(project, language.value);
      dialog.show();
      Generator createdGenerator = dialog.getResult();
      if (createdGenerator == null) {
        return null;
      }
      ListSequence.fromList(genList).addElement(createdGenerator);
    } else {
      ModelAccess.instance().runWriteActionInCommand(new Runnable() {
        public void run() {
          for (Generator generator : genList) {
            if (generator.getOwnTemplateModels().isEmpty()) {
              continue;
            }
            return;
          }
          // this means there are generators, but no template models 
          Generator firstGen = ListSequence.fromList(genList).first();
          EditableSModel templateModelDescriptor = firstGen.createModel(language.value.getModuleName() + ".generator.template.main@" + SModelStereotype.GENERATOR, firstGen.getModelRoots().iterator().next(), null);
          templateModelDescriptor.save();
          language.value.save();
        }
      });
    }

    final List<SNode> mappings = new ArrayList<SNode>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        for (Generator generator : genList) {
          for (SNode confAdapter : GenerationFacade.getOwnMappings(generator)) {
            ListSequence.fromList(mappings).addElement((SNode) confAdapter);
          }
        }
      }
    });

    if (ListSequence.fromList(mappings).isEmpty()) {
      // generator is present - this means we don't have template models or mappings 
      ModelAccess.instance().runWriteActionInCommand(new Runnable() {
        public void run() {
          SModel model = null;
          for (Generator generator : genList) {
            if (generator.getOwnTemplateModels().isEmpty()) {
              continue;
            }
            model = generator.getOwnTemplateModels().get(0).getSModel();
          }
          assert model != null : "model should have been already created";

          SNode node = SConceptOperations.createNewNode("jetbrains.mps.lang.generator.structure.MappingConfiguration", null);
          SPropertyOperations.set(node, "name", "main");
          SModelOperations.addRootNode(model, node);
          ListSequence.fromList(mappings).addElement(node);
        }
      });
    }

    final Wrappers._T<SNode> mapping = new Wrappers._T<SNode>();
    if (ListSequence.fromList(mappings).count() > 1) {
      MappingDialog configurationDialog = new MappingDialog(project, language.value);
      configurationDialog.show();
      mapping.value = configurationDialog.getResult();
    } else {
      mapping.value = ListSequence.fromList(mappings).first();
    }
    final Wrappers._T<SNode> result = new Wrappers._T<SNode>();
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        SModel model = SNodeOperations.getModel(mapping.value);
        if (SConceptOperations.isSubConceptOf(concept, "jetbrains.mps.lang.structure.structure.IConceptAspect")) {
          result.value = ConceptEditorHelper.createNewConceptAspectInstance(node, concept, model);
          BehaviorReflection.invokeNonVirtual(Void.class, mapping.value, "jetbrains.mps.lang.generator.structure.MappingConfiguration", "call_addMember_3166264919334415805", new Object[]{result.value});
        } else if (SConceptOperations.isSubConceptOf(concept, "jetbrains.mps.lang.generator.structure.InlineTemplate_RuleConsequence") || SNodeOperations.isInstanceOf(result.value, "jetbrains.mps.lang.generator.structure.InlineTemplateWithContext_RuleConsequence")) {
          SNode mappingRule = SLinkOperations.addNewChild(mapping.value, "reductionMappingRule", "jetbrains.mps.lang.generator.structure.Reduction_MappingRule");
          SLinkOperations.setTarget(mappingRule, "applicableConcept", node, false);
          SLinkOperations.setTarget(mappingRule, "ruleConsequence", SNodeOperations.cast(result.value, "jetbrains.mps.lang.generator.structure.RuleConsequence"), true);
        } else {
          SNode rootTemplateNode = SModelOperations.createNewNode(model, null, "jetbrains.mps.lang.generator.structure.RootTemplateAnnotation");
          SLinkOperations.setTarget(rootTemplateNode, "applicableConcept", node, false);
          AttributeOperations.setAttribute(result.value, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.generator.structure.RootTemplateAnnotation")), rootTemplateNode);
          SPropertyOperations.set(SNodeOperations.cast(result.value, "jetbrains.mps.lang.core.structure.INamedConcept"), "name", SPropertyOperations.getString(node, "name"));
          SModelOperations.addRootNode(model, result.value);
          BehaviorReflection.invokeNonVirtual(Void.class, mapping.value, "jetbrains.mps.lang.generator.structure.MappingConfiguration", "call_addMember_3166264919334415805", new Object[]{result.value});
        }
      }
    });
    return result.value;
  }
}
