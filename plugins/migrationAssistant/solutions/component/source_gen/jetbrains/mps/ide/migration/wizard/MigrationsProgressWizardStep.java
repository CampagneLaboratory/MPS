package jetbrains.mps.ide.migration.wizard;

/*Generated by MPS */

import jetbrains.mps.ide.migration.MigrationManager;
import com.intellij.ui.components.JBList;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.wm.impl.status.InlineProgressIndicator;
import java.util.Set;
import java.util.HashSet;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.persistence.PersistenceRegistry;
import javax.swing.JComponent;
import javax.swing.DefaultListModel;
import java.util.Collections;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import javax.swing.BorderFactory;
import com.intellij.ui.components.JBScrollPane;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.progress.ProgressManager;
import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.ide.migration.check.MigrationCheckUtil;
import jetbrains.mps.smodel.MPSModuleRepository;
import com.intellij.openapi.application.ModalityState;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.ide.migration.check.Problem;
import jetbrains.mps.lang.migration.runtime.util.MigrationsUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.ide.migration.check.MissingMigrationProblem;

public class MigrationsProgressWizardStep extends MigrationWizardStep {
  public static final String ID = "progress";
  private MigrationManager myManager;
  private JBList myList;
  private Task myTask;
  private InlineProgressIndicator myProgress;
  private Set<String> myExecuted = new HashSet<String>();
  private MigrationErrorContainer myErrorContainer;
  private boolean myIsComplete = false;

  public MigrationsProgressWizardStep(Project project, MigrationManager manager, MigrationErrorContainer errorContainer) {
    super(project, "Migration In Progress", ID);
    myManager = manager;
    myErrorContainer = errorContainer;
    this.myTask = new Task.Modal(project, "Migrating", false) {
      public void run(@NotNull ProgressIndicator progress) {
        PersistenceRegistry.getInstance().disableFastFindUsages();
        try {
          doRun(progress);
        } finally {
          myIsComplete = true;
          PersistenceRegistry.getInstance().enableFastFindUsages();
        }
      }
    };
  }

  @Override
  protected final void doCreateComponent(JComponent mainPanel) {
    myList = new JBList(new DefaultListModel());
    myList.setCellRenderer(new MigrationsListRenderer(myExecuted, Collections.emptySet()));
    JPanel listPanel = new JPanel(new BorderLayout(5, 5));
    listPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(0, 0, 2, 0), BorderFactory.createEtchedBorder()));
    listPanel.add(new JBScrollPane(myList), BorderLayout.CENTER);
    myProgress = new InlineProgressIndicator(true, myTask);
    myProgress.setIndeterminate(false);
    mainPanel.add(listPanel, BorderLayout.CENTER);
    mainPanel.add(myProgress.getComponent(), BorderLayout.SOUTH);
  }

  @Override
  public void autostart(final _FunctionTypes._void_P0_E0 later) {
    // this is needed to fully show the step before first migration is started 
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
          public void run() {
            ProgressManager.getInstance().runProcess(new Runnable() {
              public void run() {
                myTask.run(myProgress);
                later.invoke();
              }
            }, myProgress);

          }
        });

      }
    });
  }

  private void doRun(ProgressIndicator progress) {
    Map<String, Object> options = InitialStep.getOptions();

    // project steps are considered to be X percent of the whole process 
    double projectStepsFraction = 0.3;

    int projectStepsCount = myManager.projectStepsCount();
    setFraction(progress, 0);

    boolean cleanNotification = false;
    List<MigrationManager.MigrationStep> cleanupMigrations = ListSequence.fromList(new ArrayList<MigrationManager.MigrationStep>());
    while (true) {
      MigrationManager.MigrationStep step = myManager.nextProjectStep(options, true);
      if (step == null) {
        break;
      }

      ListSequence.fromList(cleanupMigrations).addElement(step);
      if (!(executeSingleStep(step))) {
        break;
      }

      if (!(cleanNotification)) {
        cleanNotification = true;
        addElementToMigrationList("Cleaning project... Please wait.");
      }
      setFraction(progress, progress.getFraction() + projectStepsFraction / projectStepsCount);
    }

    addElementToMigrationList("Checking models... Please wait.");
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = ((Iterable<SModule>) ProjectHelper.toMPSProject(myProject).getModulesWithGenerators());
        if (MigrationCheckUtil.haveProblems(modules)) {
          myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.PreCheckError());
        }
      }
    });
    if (myErrorContainer.getErrorDescriptor() != null) {
      // start cleanup migrations next time migration is started 
      for (MigrationManager.MigrationStep cleanupMigration : ListSequence.fromList(cleanupMigrations)) {
        cleanupMigration.forceExecutionNextTime();
      }
      addElementToMigrationList("Can't start migration: errors detected. Press 'Next' to continue.");
      return;
    }

    while (executeSingleStep(myManager.nextProjectStep(options, false))) {
      setFraction(progress, progress.getFraction() + projectStepsFraction / projectStepsCount);
    }
    setFraction(progress, projectStepsFraction);
    if (myErrorContainer.getErrorDescriptor() != null) {
      addElementToMigrationList("Exception while running migration. Press 'Next' to continue.");
      return;
    }

    int languageStepsCount = myManager.languageStepsCount();
    while (executeSingleStep(myManager.nextLanguageStep())) {
      setFraction(progress, progress.getFraction() + (1.0 - projectStepsFraction) / languageStepsCount);
    }
    setFraction(progress, 1.0);
    if (myErrorContainer.getErrorDescriptor() != null) {
      addElementToMigrationList("Exception while running migration. Press 'Next' to continue.");
      return;
    }

    addElementToMigrationList("Saving changed models... Please wait.");
    ModelAccess.instance().runWriteInEDT(new Runnable() {
      public void run() {
        MPSModuleRepository.getInstance().saveAll();
      }
    });

    addElementToMigrationList("Checking models... Please wait.");
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = ((Iterable<SModule>) ProjectHelper.toMPSProject(myProject).getModulesWithGenerators());
        if (MigrationCheckUtil.haveProblems(modules)) {
          myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.PostCheckError());
        }
      }
    });
    if (myErrorContainer.getErrorDescriptor() != null) {
      addElementToMigrationList("Errors are detected in project after executing migrations. Press 'Next' to continue.");
      return;
    }

    if (myManager.isMigrationRequired()) {
      myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.MigrationsMissingError());
      addElementToMigrationList("Some migrations are missing. Press 'Next' to continue.");
      return;
    }

    addElementToMigrationList("Done!");
  }

  public void setFraction(final ProgressIndicator p, final double fraction) {
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        p.setFraction(fraction);
      }
    }, ModalityState.any());
  }

  private void addElementToMigrationList(final String step) {
    final DefaultListModel model = (DefaultListModel) myList.getModel();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        model.addElement(step);
        myList.ensureIndexIsVisible(model.indexOf(step));
        myList.repaint();
      }
    });
  }

  private boolean executeSingleStep(final MigrationManager.MigrationStep result) {
    if (result == null) {
      return false;
    }

    final String step = ((MigrationManager.MigrationStep) result).getDescription();
    addElementToMigrationList(step);

    final Wrappers._boolean noException = new Wrappers._boolean();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        noException.value = ((MigrationManager.MigrationStep) result).execute();
      }
    });

    if (!(noException.value)) {
      myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.MigrationExceptionError());
    }

    return noException.value;
  }

  @Override
  public Object getNextStepId() {
    if (!(isComplete())) {
      return null;
    }
    if (myErrorContainer.getErrorDescriptor() != null) {
      return null;
    }

    return MigrationErrorWizardStep.ID;
  }

  @Override
  public Object getPreviousStepId() {
    return null;
  }

  @Override
  public boolean isComplete() {
    return myIsComplete;
  }

  @Override
  public boolean canBeCancelled() {
    return false;
  }

  private class PreCheckError extends MigrationErrorDescriptor {
    public PreCheckError() {
    }
    public String getMessage() {
      return "Migration Assistant found that some problems that prevent this project from being migrated.<br><br>" + "Try running migrations after correcting your project and/or adding necessary libraries.<br>" + "Migration Assistant will be started again on next project opening or it can be started " + "manually by choosing Tools->Run Migration Assistant from the main menu.<br><br>" + "Problems will be shown in Usages tool when the project is loaded.";
    }
    public Iterable<Problem> getProblems() {
      jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);
      Iterable<SModule> modules = ((Iterable<SModule>) mpsProject.getModulesWithGenerators());
      return MigrationCheckUtil.getProblems(modules, 100);
    }
  }

  private class PostCheckError extends MigrationErrorDescriptor {
    public PostCheckError() {
    }
    public String getMessage() {
      return "Migration Assistant was unable to migrate some nodes in this project.<br><br>" + "Problem nodes will be shown in Usages tool after the project is loaded.<br>" + "Please correct them manually.";
    }
    public Iterable<Problem> getProblems() {
      jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);
      Iterable<SModule> modules = ((Iterable<SModule>) mpsProject.getModulesWithGenerators());
      return MigrationCheckUtil.getProblems(modules, 100);
    }
  }
  private class MigrationExceptionError extends MigrationErrorDescriptor {
    public MigrationExceptionError() {
    }
    public String getMessage() {
      return "Exception while running migration. See error log for details.";
    }
    public Iterable<Problem> getProblems() {
      return Collections.<Problem>emptyList();
    }
  }
  private class MigrationsMissingError extends MigrationErrorDescriptor {
    public MigrationsMissingError() {
    }
    public String getMessage() {
      return "Migration was not completed.<br>" + "Some migration scripts are missing or finished with errors.<br><br>" + "Problems will be shown in Usages tool after the project is loaded.<br>" + "You can try to continue migrations manually or execute Migration Assistant later by selecting Tools->Run Migration Assistant from the main menu.";
    }
    public Iterable<Problem> getProblems() {
      List<Problem> result = ListSequence.fromList(new ArrayList<Problem>());

      Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject));
      for (SModule module : Sequence.fromIterable(modules)) {
        for (SLanguage lang : SetSequence.fromSet(((AbstractModule) module).getAllUsedLanguages())) {
          int currentLangVersion = lang.getLanguageVersion();
          int ver = ((AbstractModule) module).getUsedLanguageVersion(lang);

          ver = Math.max(ver, 0);
          currentLangVersion = Math.max(currentLangVersion, 0);

          if (ver >= currentLangVersion) {
            continue;
          }

          ListSequence.fromList(result).addElement(new MissingMigrationProblem(module, lang));
        }
      }

      return ListSequence.fromList(result).take(100);
    }
  }
}
