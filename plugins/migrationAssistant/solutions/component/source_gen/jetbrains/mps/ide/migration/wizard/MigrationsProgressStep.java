package jetbrains.mps.ide.migration.wizard;

/*Generated by MPS */

import jetbrains.mps.ide.migration.MigrationManager;
import com.intellij.ui.components.JBList;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.wm.impl.status.InlineProgressIndicator;
import java.util.Set;
import java.util.HashSet;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import javax.swing.DefaultListModel;
import java.util.Collections;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import javax.swing.BorderFactory;
import com.intellij.ui.components.JBScrollPane;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.progress.ProgressManager;
import jetbrains.mps.persistence.PersistenceRegistry;
import java.util.Map;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.ide.project.ProjectHelper;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.migration.MigrationCheckUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.ide.ThreadUtils;

public class MigrationsProgressStep extends MigrationStep {
  public static final String ID = "progress";
  private volatile MigrationsProgressStep.FinishedState myFinishedState = null;
  private boolean myNoErrors = true;
  private MigrationManager myManager;
  private JBList myList;
  private Task myTask;
  private InlineProgressIndicator myProgress;
  private Set<String> myExecuted = new HashSet<String>();

  public MigrationsProgressStep(Project project, MigrationManager manager) {
    super(project, "Migration In Progress", ID);
    myManager = manager;
    this.myTask = new Task.Modal(project, "Migrating", false) {
      public void run(@NotNull ProgressIndicator progress) {
        doRun(progress);
      }
    };
    createComponent();
  }

  @Override
  protected final void createComponent() {
    super.createComponent();
    myList = new JBList(new DefaultListModel());
    myList.setCellRenderer(new MigrationsListRenderer(myExecuted, Collections.emptySet()));
    JPanel listPanel = new JPanel(new BorderLayout(5, 5));
    listPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(0, 0, 2, 0), BorderFactory.createEtchedBorder()));
    listPanel.add(new JBScrollPane(myList), BorderLayout.CENTER);
    myProgress = new InlineProgressIndicator(true, myTask);
    myProgress.setIndeterminate(false);
    myComponent.add(listPanel, BorderLayout.CENTER);
    myComponent.add(myProgress.getComponent(), BorderLayout.SOUTH);
  }

  @Override
  public void autostart(final _FunctionTypes._void_P0_E0 later) {
    // this is needed to fully show the step before first migration is started 
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
          public void run() {
            ProgressManager.getInstance().runProcess(new Runnable() {
              public void run() {
                myTask.run(myProgress);
                later.invoke();
              }
            }, myProgress);

          }
        });

      }
    });
  }

  private void doRun(ProgressIndicator progress) {
    PersistenceRegistry.getInstance().disableFastFindUsages();

    Map<String, Object> options = InitialStep.getOptions();

    // project steps are considered to be X percent of the whole process 
    double projectStepsFraction = 0.3;

    int projectStepsCount = myManager.projectStepsCount();
    setFraction(progress, 0);

    boolean cleanNotification = false;
    while (executeSingleStep(myManager.nextProjectStep(options, true))) {
      if (!(cleanNotification)) {
        cleanNotification = true;
        addElementToMigrationList("Cleaning project... Please wait.");
      }
      setFraction(progress, progress.getFraction() + projectStepsFraction / projectStepsCount);
    }

    addElementToMigrationList("Checking models... Please wait.");
    final Wrappers._boolean preProblems = new Wrappers._boolean();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = ((Iterable<SModule>) ProjectHelper.toMPSProject(myProject).getModulesWithGenerators());
        Iterable<SNode> problems = MigrationCheckUtil.getProblemNodes(modules);
        preProblems.value = Sequence.fromIterable(problems).isNotEmpty();
      }
    });

    final Wrappers._boolean postProblems = new Wrappers._boolean(false);
    if (!(preProblems.value)) {
      while (executeSingleStep(myManager.nextProjectStep(options, false))) {
        setFraction(progress, progress.getFraction() + projectStepsFraction / projectStepsCount);
      }
      setFraction(progress, projectStepsFraction);

      int languageStepsCount = myManager.languageStepsCount();
      while (executeSingleStep(myManager.nextLanguageStep())) {
        setFraction(progress, progress.getFraction() + (1.0 - projectStepsFraction) / languageStepsCount);
      }
      setFraction(progress, 1.0);

      addElementToMigrationList("Saving changed models... Please wait.");
      ModelAccess.instance().runWriteInEDT(new Runnable() {
        public void run() {
          MPSModuleRepository.getInstance().saveAll();
        }
      });

      addElementToMigrationList("Checking models... Please wait.");
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          Iterable<SModule> modules = ((Iterable<SModule>) ProjectHelper.toMPSProject(myProject).getModulesWithGenerators());
          Iterable<SNode> problems = MigrationCheckUtil.getProblemNodes(modules);
          postProblems.value = Sequence.fromIterable(problems).isNotEmpty();
        }
      });
    }

    myFinishedState = new MigrationsProgressStep.FinishedState(preProblems.value, myNoErrors && !(myManager.isMigrationRequired()), postProblems.value);

    addElementToMigrationList((myFinishedState.isEverythingOk() ? "Done!" : "Finished with errors. Click 'Next' to continue."));

    PersistenceRegistry.getInstance().enableFastFindUsages();
  }

  public void setFraction(final ProgressIndicator p, final double fraction) {
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        p.setFraction(fraction);
      }
    });
  }

  private void addElementToMigrationList(final String step) {
    final DefaultListModel model = (DefaultListModel) myList.getModel();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        model.addElement(step);
        myList.ensureIndexIsVisible(model.indexOf(step));
        myList.repaint();
      }
    });
  }

  private boolean executeSingleStep(final MigrationManager.MigrationStep result) {
    if (!(result instanceof MigrationManager.MigrationStep)) {
      return false;
    }

    final String step = ((MigrationManager.MigrationStep) result).getDescription();
    addElementToMigrationList(step);
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        myNoErrors &= ((MigrationManager.MigrationStep) result).execute();
      }
    });

    return myNoErrors;
  }

  @Override
  public Object getNextStepId() {
    if (myFinishedState == null) {
      return null;
    }
    if (isEverythingOk()) {
      return null;
    } else if (myFinishedState.preErrors()) {
      return MigrationErrorStep_Pre.ID;
    } else if (!(myFinishedState.migrationsCompleted())) {
      return MigrationErrorStep_Migration.ID;
    } else if (myFinishedState.postErrors()) {
      return MigrationErrorStep_Post.ID;
    }
    throw new IllegalStateException();
  }

  @Override
  public Object getPreviousStepId() {
    return null;
  }

  @Override
  public boolean isComplete() {
    return myFinishedState != null;
  }

  @Override
  public boolean canBeCancelled() {
    return false;
  }

  public boolean isEverythingOk() {
    return myFinishedState.isEverythingOk();
  }

  public static class FinishedState {
    private final boolean myPreErrors;
    private final boolean myMigrationsCompleted;
    private final boolean myPostErrors;

    public FinishedState(boolean preErrors, boolean migrationsCompleted, boolean postErrors) {
      myPreErrors = preErrors;
      myMigrationsCompleted = migrationsCompleted;
      myPostErrors = postErrors;
    }

    public boolean preErrors() {
      return myPreErrors;
    }

    public boolean migrationsCompleted() {
      return myMigrationsCompleted;
    }

    public boolean postErrors() {
      return myPostErrors;
    }

    public boolean isEverythingOk() {
      return !(myPreErrors) && myMigrationsCompleted && !(myPostErrors);
    }
  }
}
