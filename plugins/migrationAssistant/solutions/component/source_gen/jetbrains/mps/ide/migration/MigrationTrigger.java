package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.components.StoragePathMacros;
import com.intellij.openapi.components.AbstractProjectComponent;
import com.intellij.openapi.components.PersistentStateComponent;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import com.intellij.openapi.startup.StartupManager;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.vfs.VirtualFileManager;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.migration.component.util.MigrationComponent;
import jetbrains.mps.smodel.Language;
import java.util.List;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.openapi.ui.Messages;
import com.intellij.util.PairFunction;
import javax.swing.JCheckBox;
import com.intellij.openapi.vfs.newvfs.persistent.FSRecords;
import com.intellij.openapi.project.ex.ProjectManagerEx;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.generator.fileGenerator.FileGenerationUtil;
import jetbrains.mps.project.facets.JavaModuleFacet;
import org.jetbrains.mps.openapi.module.SRepositoryContentAdapter;
import jetbrains.mps.classloading.MPSClassesListenerAdapter;
import jetbrains.mps.module.ReloadableModuleBase;
import com.intellij.util.Consumer;
import jetbrains.mps.ide.migration.wizard.MigrationErrorStep;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.openapi.application.ModalityState;
import org.jetbrains.annotations.Nullable;

/**
 * At the first startup, migraion is not required
 * The need for migration is determined after startup by checking all modules once and then watching the repo
 * Whether some change requires migration to be executed, the user is notified about that and the project is reloaded 
 * with myState.migrationRequired set to true.
 * In this case, the migration is executed and no watchers are added (as they could try to run the migration once again)
 * After the migration is completed, myState.migrationRequired is set to false again and the project is reloaded
 * 
 * Reasons to reload project after migration:
 * 1. The reload cycle with migration wizard happens w/o addig repo listeners
 * 2. Models should be unloaded after migration
 */
@State(name = "MigrationTrigger", storages = {@Storage(file = StoragePathMacros.WORKSPACE_FILE)
})
public class MigrationTrigger extends AbstractProjectComponent implements PersistentStateComponent<MigrationTrigger.MyState>, IStartupMigrationExecutor {
  private static final String DIALOG_TEXT = "Some of the modules in project require migration.\n" + "It is recommended to clean generated files before you start the migration.\n" + "In case the migration is postponed, this notification will not appear until the project is reopened.\n" + "Migration assistant can be invoked at any time by clicking Tools->Run Migration Assistant.\n" + "Would you like to reload project and start the migration immediately?";

  private Project myMpsProject;
  private final MigrationManager myMigrationManager;
  private MigrationTrigger.MyState myState = new MigrationTrigger.MyState();
  private volatile boolean myMigrationQueued = false;

  private MigrationTrigger.MyRepoListener myRepoListener = new MigrationTrigger.MyRepoListener();
  private MigrationTrigger.MyClassesListener myClassesListener = new MigrationTrigger.MyClassesListener();

  public MigrationTrigger(com.intellij.openapi.project.Project ideaProject, Project p, MigrationManager migrationManager) {
    super(ideaProject);
    myMpsProject = p;
    myMigrationManager = migrationManager;
  }

  public void projectOpened() {
    if (!(myState.migrationRequired)) {
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          MPSModuleRepository.getInstance().addRepositoryListener(MigrationTrigger.this.myRepoListener);
          ClassLoaderManager.getInstance().addClassesHandler(MigrationTrigger.this.myClassesListener);
        }
      });
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          postponeMigrationIfNeededOnModuleChange(MigrationsUtil.getMigrateableModulesFromProject(myMpsProject));
        }
      });
      return;
    }

    StartupManager.getInstance(myProject).registerPostStartupActivity(new Runnable() {
      public void run() {
        // this line should be executed in post-startup activity as we can have language in the same project 
        // with the solution to migrate, and in this case classes of this language will be cleared, but after 
        // they are compiled at startup, they are only reloaded in a pre-startuo activity 
        if (!(myMigrationManager.isMigrationRequired())) {
          return;
        }

        ApplicationManager.getApplication().runWriteAction(new Runnable() {
          public void run() {
            VirtualFileManager.getInstance().syncRefresh();
          }
        });
        executeWizard();
      }
    });
  }

  public void projectClosed() {
    // these listeners can be not registered at the time 
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ClassLoaderManager.getInstance().removeClassesHandler(myClassesListener);
        MPSModuleRepository.getInstance().removeRepositoryListener(MigrationTrigger.this.myRepoListener);
      }
    });
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "MigrationTrigger";
  }

  private void postponeMigrationIfNeededOnModuleChange(Iterable<SModule> modules) {
    if (myMigrationQueued) {
      return;
    }

    Set<SModule> modules2Check = SetSequence.fromSetWithValues(new HashSet<SModule>(), modules);
    if (!(MigrationComponent.isLanguageMigrationRequired(modules2Check))) {
      return;
    }

    postponeMigration();
  }

  private void postponeMigrationIfNeededOnLanguageReload(Iterable<Language> languages) {
    if (myMigrationQueued) {
      return;
    }

    // if a new language is added to a repo, all modules in project using it  
    // should be checked for whether their migration is needed  
    final Set<SModule> modules2Check = SetSequence.fromSet(new HashSet<SModule>());
    final List<SLanguage> addedLanguages = Sequence.fromIterable(languages).select(new ISelector<Language, SLanguage>() {
      public SLanguage select(Language it) {
        return MetaIdByDeclaration.ref2Id(it.getModuleReference());
      }
    }).toListSequence();
    Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(myMpsProject)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        Set<SLanguage> used = new HashSet<SLanguage>(it.getUsedLanguages());
        used.retainAll(addedLanguages);
        if (!(used.isEmpty())) {
          SetSequence.fromSet(modules2Check).addElement(it);
        }
      }
    });
    if (!(MigrationComponent.isLanguageMigrationRequired(modules2Check))) {
      return;
    }

    postponeMigration();
  }

  private synchronized void postponeMigration() {
    // note this check is under sync block so we don't queue more than 1 reload 
    if (myMigrationQueued) {
      return;
    }

    final com.intellij.openapi.project.Project ideaProject = ProjectHelper.toIdeaProject(myMpsProject);

    // wait until project is fully loaded (if not yet) 
    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {
      public void run() {
        // as we use ui, postpone to EDT 
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            String[] choises = new String[]{"Migrate", "Postpone"};
            final int result = Messages.showCheckboxMessageDialog(DIALOG_TEXT, "Migration required", choises, "Clean generated sources", true, 0, 0, null, new PairFunction<Integer, JCheckBox, Integer>() {
              public Integer fun(Integer selected, JCheckBox cb) {
                if (selected == 1) {
                  return 2;
                }
                return (cb.isSelected() ? 0 : 1);
              }
            });
            if (result == 2) {
              return;
            }

            ApplicationManager.getApplication().runWriteAction(new Runnable() {
              public void run() {
                if (result == 0) {
                  removeGenSources();
                }

                // clean genclasses 
                removeClassesGen();
                // invalidate FS caches (see InvalidateCachesAction) 
                FSRecords.invalidateCaches();
              }
            });
            // set flag to execute migration after startup 
            myState.migrationRequired = true;
            // reload project and start migration assist 
            ProjectManagerEx.getInstance().reloadProject(ideaProject);
          }
        });
      }
    });

    myMigrationQueued = true;
  }

  /**
   * todo. Was originally copied from IdeCommandUtil, then changed. Check whether they could 
   * be combined into one piece of universal code
   */
  public void removeGenSources() {
    Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(myMpsProject)).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        IFile outputDir = it.getOutputPath();
        IFile testDir = check_feb5zp_a0b0a0a0a42(it.getFacet(TestsFacet.class));
        if (outputDir != null) {
          IFile cacheDir = FileGenerationUtil.getCachesDir(outputDir);
          outputDir.delete();
          cacheDir.delete();
        }
        if (testDir != null) {
          IFile testCacheDir = FileGenerationUtil.getCachesDir(testDir);
          testDir.delete();
          testCacheDir.delete();
        }
      }
    });
  }

  public void removeClassesGen() {
    Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(myMpsProject)).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        IFile outputDir = it.getOutputPath();
        IFile classesGen = check_feb5zp_a0b0a0a0a62(it.getFacet(JavaModuleFacet.class));
        if (classesGen != null) {
          classesGen.delete();
        }
      }
    });
  }

  private class MyRepoListener extends SRepositoryContentAdapter {
    public MyRepoListener() {
    }
    @Override
    public void moduleAdded(@NotNull SModule module) {
      ModelAccess.assertLegalWrite();
      if (!(MPSModuleRepository.getInstance().getOwners(module).contains(myMpsProject))) {
        return;
      }
      if (!(MigrationsUtil.isModuleMigrateable(module))) {
        return;
      }
      postponeMigrationIfNeededOnModuleChange(Sequence.<SModule>singleton(module));
    }

    @Override
    public void moduleChanged(SModule module) {
      ModelAccess.assertLegalWrite();
      if (!(MPSModuleRepository.getInstance().getOwners(module).contains(myMpsProject))) {
        return;
      }
      if (!(MigrationsUtil.isModuleMigrateable(module))) {
        return;
      }
      postponeMigrationIfNeededOnModuleChange(Sequence.<SModule>singleton(module));
    }
  }

  private class MyClassesListener extends MPSClassesListenerAdapter {
    public MyClassesListener() {
    }
    @Override
    public void afterClassesLoaded(Set<? extends ReloadableModuleBase> modules) {
      ModelAccess.assertLegalWrite();
      postponeMigrationIfNeededOnLanguageReload(SetSequence.fromSet(modules).ofType(Language.class));
    }
  }

  @Override
  public void executeWizard() {
    final MigrationAssistantWizard wizard = new MigrationAssistantWizard(myProject, myMigrationManager);
    // final reload is needed to cleanup memory (unload models) and do possible switches (e.g. to a new persistence) 
    wizard.showAndGetOk().doWhenDone(new Consumer<Boolean>() {
      @Override
      public void consume(Boolean finished) {
        if (!(finished)) {
          return;
        }
        if (wizard.isFinishSuccessfull()) {
          myState.migrationRequired = false;
          ApplicationManager.getApplication().runWriteAction(new Runnable() {
            public void run() {
              ProjectManagerEx.getInstance().reloadProject(myProject);
            }
          });
          return;
        }

        MigrationErrorStep lastStep = as_feb5zp_a0a3a0a0a0a2a23(wizard.getCurrentStepObject(), MigrationErrorStep.class);
        if (lastStep == null) {
          return;
        }

        final _FunctionTypes._void_P0_E0 afterProjectInitialized = lastStep.afterProjectInitialized();
        if (afterProjectInitialized == null) {
          return;
        }

        StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {
          public void run() {
            ApplicationManager.getApplication().invokeLater(new Runnable() {
              public void run() {
                afterProjectInitialized.invoke();
              }
            }, ModalityState.NON_MODAL);

          }
        });
      }
    });
  }

  @Nullable
  @Override
  public MigrationTrigger.MyState getState() {
    return myState;
  }

  @Override
  public void loadState(MigrationTrigger.MyState state) {
    myState = state;
  }

  public static class MyState {
    public boolean migrationRequired = false;
  }
  private static IFile check_feb5zp_a0b0a0a0a42(TestsFacet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTestsOutputPath();
    }
    return null;
  }
  private static IFile check_feb5zp_a0b0a0a0a62(JavaModuleFacet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getClassesGen();
    }
    return null;
  }
  private static <T> T as_feb5zp_a0a3a0a0a0a2a23(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
