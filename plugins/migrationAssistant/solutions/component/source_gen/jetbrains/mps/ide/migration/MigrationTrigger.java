package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.components.StoragePathMacros;
import com.intellij.openapi.components.AbstractProjectComponent;
import com.intellij.openapi.components.PersistentStateComponent;
import jetbrains.mps.ide.migration.wizard.MigrationErrorContainer;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.project.Project;
import jetbrains.mps.ide.migration.wizard.MigrationErrorDescriptor;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.migration.global.ProjectMigrationProperties;
import jetbrains.mps.lang.migration.runtime.util.MigrationsUtil;
import com.intellij.openapi.startup.StartupManager;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import com.intellij.openapi.vfs.VirtualFileManager;
import javax.swing.SwingUtilities;
import jetbrains.mps.ide.platform.watching.ReloadManager;
import com.intellij.openapi.project.ex.ProjectManagerEx;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import com.intellij.ide.GeneralSettings;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.migration.component.util.MigrationComponent;
import com.intellij.openapi.ui.Messages;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.smodel.Language;
import java.util.List;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import org.jetbrains.mps.openapi.module.SRepositoryContentAdapter;
import jetbrains.mps.classloading.MPSClassesListenerAdapter;
import jetbrains.mps.module.ReloadableModuleBase;
import jetbrains.mps.ide.migration.wizard.MigrationErrorWizardStep;
import jetbrains.mps.ide.migration.check.Problem;
import jetbrains.mps.ide.modelchecker.platform.actions.ModelCheckerViewer;
import jetbrains.mps.ide.modelchecker.platform.actions.ModelCheckerTool;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.modelchecker.platform.actions.ModelCheckerIssue;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.ide.icons.IdeIcons;
import com.intellij.openapi.application.ModalityState;
import org.jetbrains.annotations.Nullable;

/**
 * At the first startup, migration is not required
 * The need for migration is determined after startup by checking all modules once and then watching the repo
 * Whether some change requires migration to be executed, the user is notified about that and the project is reloaded
 * with myState.migrationRequired set to true.
 * In this case, the migration is executed and no watchers are added (as they could try to run the migration once again)
 * After the migration is completed, myState.migrationRequired is set to false again and the project is reloaded
 * 
 * Reasons to reload project after migration:
 * 1. The reload cycle with migration wizard happens w/o adding repo listeners
 * 2. Models should be unloaded after migration
 */
@State(name = "MigrationTrigger", storages = {@Storage(file = StoragePathMacros.WORKSPACE_FILE)
})
public class MigrationTrigger extends AbstractProjectComponent implements PersistentStateComponent<MigrationTrigger.MyState>, IStartupMigrationExecutor, MigrationErrorContainer {
  private static final String DIALOG_TEXT = "Some of the modules in project require migration.\n" + "In case the migration is postponed, this notification will not appear until the project is reopened.\n" + "Migration Assistant can be invoked at any time by clicking Tools->Run Migration Assistant.\n" + "Would you like to reload project and start the migration immediately?";

  private static void updateLanguageVersions(Iterable<SModule> modules) {
    Sequence.fromIterable(modules).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        it.validateLanguageVersions();
      }
    });
  }

  private Project myMpsProject;
  private final MigrationManager myMigrationManager;
  private MigrationTrigger.MyState myState = new MigrationTrigger.MyState();
  private boolean myMigrationQueued = false;

  private MigrationTrigger.MyRepoListener myRepoListener = new MigrationTrigger.MyRepoListener();
  private MigrationTrigger.MyClassesListener myClassesListener = new MigrationTrigger.MyClassesListener();
  private MigrationTrigger.MyPropertiesListener myPropertiesListener = new MigrationTrigger.MyPropertiesListener();

  private MigrationErrorDescriptor myErrors = null;

  public MigrationTrigger(com.intellij.openapi.project.Project ideaProject, Project p, MigrationManager migrationManager) {
    super(ideaProject);
    myMpsProject = p;
    myMigrationManager = migrationManager;
  }

  public void projectOpened() {
    if (!(myState.migrationRequired)) {
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          MPSModuleRepository.getInstance().addRepositoryListener(MigrationTrigger.this.myRepoListener);
          ClassLoaderManager.getInstance().addClassesHandler(MigrationTrigger.this.myClassesListener);
          myProject.getComponent(ProjectMigrationProperties.class).addListener(MigrationTrigger.this.myPropertiesListener);
        }
      });
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          MigrationTrigger.updateLanguageVersions(MigrationsUtil.getMigrateableModulesFromProject(myMpsProject));
          tryMigratingProject();
        }
      });
      return;
    }

    saveAndSetTipsState();
    StartupManager.getInstance(myProject).registerPostStartupActivity(new Runnable() {
      public void run() {
        ModelAccess.instance().runWriteAction(new Runnable() {
          public void run() {
            MigrationTrigger.updateLanguageVersions(MigrationsUtil.getMigrateableModulesFromProject(myMpsProject));
          }
        });

        // this line should be executed in post-startup activity as we can have language in the same project 
        // with the solution to migrate, and in this case classes of this language will be cleared, but after 
        // they are compiled at startup, they are only reloaded in a pre-startup activity 
        if (!(myMigrationManager.isMigrationRequired())) {
          restoreTipsState();
          return;
        }

        ApplicationManager.getApplication().runWriteAction(new Runnable() {
          public void run() {
            VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir());
            VirtualFileManager.getInstance().asyncRefresh(new Runnable() {
              public void run() {
                SwingUtilities.invokeLater(new Runnable() {
                  public void run() {
                    ReloadManager.getInstance().flush();
                    ProjectManagerEx.getInstanceEx().unblockReloadingProjectOnExternalChanges();
                    executeWizard();
                  }
                });
              }
            });
          }
        });
      }
    });
  }

  public void projectClosed() {
    // these listeners can be not registered at the time 
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ClassLoaderManager.getInstance().removeClassesHandler(myClassesListener);
        MPSModuleRepository.getInstance().removeRepositoryListener(MigrationTrigger.this.myRepoListener);
      }
    });
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "MigrationTrigger";
  }

  private void saveAndSetTipsState() {
    if (myState.tips == null) {
      myState.tips = GeneralSettings.getInstance().showTipsOnStartup();
    }
    GeneralSettings.getInstance().setShowTipsOnStartup(false);
  }

  private void restoreTipsState() {
    if (myState.tips == null) {
      return;
    }
    GeneralSettings.getInstance().setShowTipsOnStartup(myState.tips);
    myState.tips = null;
  }


  public synchronized void tryMigratingProjectNoQueue() {
    final Iterable<SModule> allModules = MigrationsUtil.getMigrateableModulesFromProject(myMpsProject);
    final Wrappers._boolean migrationRequired = new Wrappers._boolean();
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        MigrationTrigger.updateLanguageVersions(allModules);
        migrationRequired.value = MigrationComponent.isMigrationRequired(myMpsProject, allModules);
      }
    });
    if (!(migrationRequired.value)) {
      ApplicationManager.getApplication().invokeLater(new Runnable() {
        public void run() {
          Messages.showMessageDialog(myProject, "None of the modules in project require migration.\n" + "Migration assistant will not be started.", "Migration not required", null);
        }
      });
      return;
    }

    postponeMigration();
  }

  public synchronized void tryMigratingProject() {
    postponeMigrationIfNeededOnModuleChange(myMpsProject, MigrationsUtil.getMigrateableModulesFromProject(myMpsProject));
  }

  private synchronized void postponeMigrationIfNeededOnModuleChange(Project p, Iterable<SModule> modules) {
    if (myMigrationQueued) {
      return;
    }

    MigrationTrigger.updateLanguageVersions(modules);
    Set<SModule> modules2Check = SetSequence.fromSetWithValues(new HashSet<SModule>(), modules);
    if (!(MigrationComponent.isMigrationRequired(p, modules2Check))) {
      return;
    }

    postponeMigration();
  }

  private synchronized void postponeMigrationIfNeededOnLanguageReload(Iterable<Language> languages) {
    if (myMigrationQueued) {
      return;
    }

    // if a new language is added to a repo, all modules in project using it  
    // should be checked for whether their migration is needed  
    final Set<SModule> modules2Check = SetSequence.fromSet(new HashSet<SModule>());
    final List<SLanguage> addedLanguages = Sequence.fromIterable(languages).select(new ISelector<Language, SLanguage>() {
      public SLanguage select(Language it) {
        return MetaIdByDeclaration.ref2Id(it.getModuleReference());
      }
    }).toListSequence();
    Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(myMpsProject)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        Set<SLanguage> used = new HashSet<SLanguage>(it.getUsedLanguages());
        used.retainAll(addedLanguages);
        if (!(used.isEmpty())) {
          SetSequence.fromSet(modules2Check).addElement(it);
        }
      }
    });
    MigrationTrigger.updateLanguageVersions(modules2Check);
    if (!(MigrationComponent.isLanguageMigrationRequired(modules2Check))) {
      return;
    }

    postponeMigration();
  }

  private void postponeMigration() {
    final com.intellij.openapi.project.Project ideaProject = myProject;

    saveAndSetTipsState();
    // wait until project is fully loaded (if not yet) 
    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {
      public void run() {
        // as we use ui, postpone to EDT 
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            int result = Messages.showYesNoDialog(myProject, DIALOG_TEXT, "Migration Required", "Migrate", "Postpone", null);
            restoreTipsState();
            if (result == Messages.NO) {
              return;
            }

            VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir());
            VirtualFileManager.getInstance().asyncRefresh(new Runnable() {
              public void run() {
                ApplicationManager.getApplication().invokeLater(new Runnable() {
                  public void run() {
                    ReloadManager.getInstance().flush();
                    ProjectManagerEx.getInstanceEx().unblockReloadingProjectOnExternalChanges();
                    // set flag to execute migration after startup 
                    myState.migrationRequired = true;
                    // reload project and start migration assist 
                    ProjectManagerEx.getInstance().reloadProject(ideaProject);
                  }
                });
              }
            });
          }
        });
      }
    });

    myMigrationQueued = true;
  }

  private class MyRepoListener extends SRepositoryContentAdapter {
    public MyRepoListener() {
    }
    @Override
    public void moduleAdded(@NotNull SModule module) {
      ModelAccess.assertLegalWrite();
      if (!(MPSModuleRepository.getInstance().getOwners(module).contains(myMpsProject))) {
        return;
      }
      if (!(MigrationsUtil.isModuleMigrateable(module))) {
        return;
      }
      postponeMigrationIfNeededOnModuleChange(myMpsProject, Sequence.<SModule>singleton(module));
    }

    @Override
    public void moduleChanged(SModule module) {
      ModelAccess.assertLegalWrite();
      if (!(MPSModuleRepository.getInstance().getOwners(module).contains(myMpsProject))) {
        return;
      }
      if (!(MigrationsUtil.isModuleMigrateable(module))) {
        return;
      }
      postponeMigrationIfNeededOnModuleChange(myMpsProject, Sequence.<SModule>singleton(module));
    }
  }

  private class MyClassesListener extends MPSClassesListenerAdapter {
    public MyClassesListener() {
    }
    @Override
    public void afterClassesLoaded(Set<? extends ReloadableModuleBase> modules) {
      ModelAccess.assertLegalWrite();
      postponeMigrationIfNeededOnLanguageReload(SetSequence.fromSet(modules).ofType(Language.class));
    }
  }

  private class MyPropertiesListener implements ProjectMigrationProperties.MigrationPropertiesReloadListener {
    @Override
    public void onReload() {
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          tryMigratingProject();
        }
      });
    }
  }

  public MigrationErrorDescriptor getErrorDescriptor() {
    return myErrors;
  }

  public void setErrorDescriptor(MigrationErrorDescriptor errors) {
    myErrors = errors;
  }

  @Override
  public void executeWizard() {
    myState.migrationRequired = false;

    final MigrationAssistantWizard wizard = new MigrationAssistantWizard(myProject, myMigrationManager, this);
    // final reload is needed to cleanup memory (unload models) and do possible switches (e.g. to a new persistence) 
    boolean finished = wizard.showAndGet();
    restoreTipsState();
    if (!(finished)) {
      return;
    }

    if (myErrors == null) {
      ApplicationManager.getApplication().runWriteAction(new Runnable() {
        public void run() {
          ProjectManagerEx.getInstance().reloadProject(myProject);
        }
      });
      return;
    }

    MigrationErrorWizardStep lastStep = as_feb5zp_a0a01a84(wizard.getCurrentStepObject(), MigrationErrorWizardStep.class);
    if (lastStep == null) {
      return;
    }

    final Wrappers._T<Iterable<Problem>> problems = new Wrappers._T<Iterable<Problem>>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        problems.value = myErrors.getProblems();
      }
    });
    if (Sequence.fromIterable(problems.value).isEmpty()) {
      return;
    }

    StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {
      public void run() {
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            ModelAccess.instance().runReadAction(new Runnable() {
              public void run() {
                ModelCheckerViewer v = new ModelCheckerViewer(myProject) {
                  @Override
                  protected void close() {
                    ModelCheckerTool.getInstance(myProject).closeTab(this);
                    super.close();
                  }
                };
                final SearchResults<ModelCheckerIssue> result = new SearchResults<ModelCheckerIssue>();
                Sequence.fromIterable(problems.value).visitAll(new IVisitor<Problem>() {
                  public void visit(Problem it) {
                    Object r = it.getReason();

                    ModelCheckerIssue mci;
                    if (r instanceof SNode) {
                      mci = new ModelCheckerIssue.NodeIssue(((org.jetbrains.mps.openapi.model.SNode) r), it.getMessage(), null);
                    } else if (r instanceof SModule) {
                      mci = new ModelCheckerIssue.ModuleIssue(it.getMessage(), null);
                    } else {
                      throw new IllegalArgumentException(r.getClass().getName());
                    }
                    result.add(new SearchResult<ModelCheckerIssue>(mci, r, it.getCategory()));
                  }
                });
                v.setSearchResults(result);
                ModelCheckerTool.getInstance(myProject).showTabWithResults(v, "Migration issues", IdeIcons.MODULE_GROUP_CLOSED);
              }
            });
          }
        }, ModalityState.NON_MODAL);

      }
    });
  }

  @Nullable
  @Override
  public MigrationTrigger.MyState getState() {
    return myState;
  }

  @Override
  public void loadState(MigrationTrigger.MyState state) {
    myState = state;
  }

  public static class MyState {
    public boolean migrationRequired = false;
    public Boolean tips;
  }
  private static <T> T as_feb5zp_a0a01a84(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
