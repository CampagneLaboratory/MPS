package jetbrains.mps.ide.migration.executor;

/*Generated by MPS */

import com.intellij.openapi.components.ProjectComponent;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.classloading.ClassLoaderManager;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.ModelAccess;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.migration.component.util.MigrationComponent;
import jetbrains.mps.smodel.Language;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.openapi.startup.StartupManager;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.vfs.newvfs.persistent.FSRecords;
import com.intellij.openapi.project.ex.ProjectManagerEx;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.generator.fileGenerator.FileGenerationUtil;
import jetbrains.mps.project.facets.JavaModuleFacet;
import org.jetbrains.mps.openapi.module.SRepositoryContentAdapter;
import jetbrains.mps.classloading.MPSClassesListenerAdapter;
import jetbrains.mps.module.ReloadableModuleBase;

public class MigrationTrigger implements ProjectComponent {
  private Project myProject;
  private MPSModuleRepository myRepo;
  private ClassLoaderManager myClassManager;

  private volatile boolean myMigrationQueued = false;
  private MigrationTrigger.MyRepoListener myRepoListener = new MigrationTrigger.MyRepoListener();
  private MigrationTrigger.MyClassesListener myClassesListener = new MigrationTrigger.MyClassesListener();

  public MigrationTrigger(Project p) {
    myProject = p;
    myRepo = MPSModuleRepository.getInstance();
    myClassManager = ClassLoaderManager.getInstance();
  }

  public void projectOpened() {
    addListeners();
    postponeMigrationIfNeededOnModuleChange(((Iterable<SModule>) myProject.getModulesWithGenerators()));
  }

  public void projectClosed() {
    removeListeners();
  }

  public void initComponent() {
  }

  public void disposeComponent() {
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "MigrationTrigger";
  }

  private void addListeners() {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        myRepo.addRepositoryListener(MigrationTrigger.this.myRepoListener);
        myClassManager.addClassesHandler(MigrationTrigger.this.myClassesListener);
      }
    });
  }

  private void removeListeners() {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        myClassManager.removeClassesHandler(myClassesListener);
        myRepo.removeRepositoryListener(MigrationTrigger.this.myRepoListener);
      }
    });
  }

  private void postponeMigrationIfNeededOnModuleChange(Iterable<SModule> modules) {
    if (myMigrationQueued) {
      return;
    }

    Set<SModule> modules2Check = SetSequence.fromSetWithValues(new HashSet<SModule>(), modules);
    if (!(MigrationComponent.isLanguageMigrationRequired(modules2Check))) {
      return;
    }

    postponeMigration();
  }

  private void postponeMigrationIfNeededOnLanguageReload(Iterable<Language> languages) {
    if (myMigrationQueued) {
      return;
    }

    // if a new language is added to a repo, all modules in project using it  
    // should be checked for whether their migration is needed  
    final Set<SModule> modules2Check = SetSequence.fromSet(new HashSet<SModule>());
    Iterable<? extends SModule> projectModules = myProject.getModulesWithGenerators();
    final List<Language> addedLanguages = Sequence.fromIterable(languages).ofType(Language.class).toListSequence();
    Sequence.fromIterable(projectModules).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        Set<SLanguage> used = new HashSet<SLanguage>(it.getUsedLanguages());
        used.retainAll(addedLanguages);
        if (!(used.isEmpty())) {
          SetSequence.fromSet(modules2Check).addElement(it);
        }
      }
    });
    if (!(MigrationComponent.isLanguageMigrationRequired(modules2Check))) {
      return;
    }

    postponeMigration();
  }

  private synchronized void postponeMigration() {
    // note this check is under sync block so we don't queue more than 1 reload 
    if (myMigrationQueued) {
      return;
    }

    final com.intellij.openapi.project.Project ideaProject = ProjectHelper.toIdeaProject(myProject);

    // wait until project is fully loaded (if not yet) 
    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {
      public void run() {
        // as we use ui, postpone to EDT 
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            String[] choises = new String[]{"Clean sources and migrate", "Migrate", "Postpone"};
            int result = Messages.showChooseDialog(ideaProject, "Some of the modules in project require migration.\n" + "It is advised to clean generated files before you start the migration.\n" + "Would you like to reload project and start the migration immediately?", "Migration required", null, choises, choises[0]);
            if (result == 2) {
              return;
            }
            if (result == 0) {
              removeGenSources();
            }

            // clean genclasses 
            removeClassesGen();
            // invalidate FS caches (see InvalidateCachesAction) 
            FSRecords.invalidateCaches();
            // reload project and start migration assist 
            ProjectManagerEx.getInstance().reloadProject(ideaProject);
          }
        });
      }
    });

    myMigrationQueued = true;
  }


  /**
   * todo. Was originally copied from IdeCommandUtil, then changed. Check whether they could 
   * be combined into one piece of universal code
   */
  public void removeGenSources() {
    Iterable<? extends SModule> modules = myProject.getModulesWithGenerators();
    Sequence.fromIterable(modules).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        IFile outputDir = it.getOutputPath();
        IFile testDir = check_feb5zp_a0b0a0a1a13(it.getFacet(TestsFacet.class));
        if (outputDir != null) {
          IFile cacheDir = FileGenerationUtil.getCachesDir(outputDir);
          outputDir.delete();
          cacheDir.delete();
        }
        if (testDir != null) {
          IFile testCacheDir = FileGenerationUtil.getCachesDir(testDir);
          testDir.delete();
          testCacheDir.delete();
        }
      }
    });
  }

  public void removeClassesGen() {
    Iterable<? extends SModule> modules = myProject.getModulesWithGenerators();
    Sequence.fromIterable(modules).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        IFile outputDir = it.getOutputPath();
        IFile classesGen = check_feb5zp_a0b0a0a1a33(it.getFacet(JavaModuleFacet.class));
        if (classesGen != null) {
          classesGen.delete();
        }
      }
    });
  }


  private class MyRepoListener extends SRepositoryContentAdapter {
    public MyRepoListener() {
    }
    @Override
    public void moduleAdded(@NotNull SModule module) {
      if (!(myRepo.getOwners(module).contains(myProject))) {
        return;
      }
      postponeMigrationIfNeededOnModuleChange(Sequence.<SModule>singleton(module));
    }

    @Override
    public void moduleChanged(SModule module) {
      if (!(myRepo.getOwners(module).contains(myProject))) {
        return;
      }
      postponeMigrationIfNeededOnModuleChange(Sequence.<SModule>singleton(module));
    }
  }

  private class MyClassesListener extends MPSClassesListenerAdapter {
    public MyClassesListener() {
    }
    @Override
    public void afterClassesLoaded(Set<? extends ReloadableModuleBase> modules) {
      postponeMigrationIfNeededOnLanguageReload(SetSequence.fromSet(modules).ofType(Language.class));
    }
  }
  private static IFile check_feb5zp_a0b0a0a1a13(TestsFacet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTestsOutputPath();
    }
    return null;
  }
  private static IFile check_feb5zp_a0b0a0a1a33(JavaModuleFacet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getClassesGen();
    }
    return null;
  }
}
