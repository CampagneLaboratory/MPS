package jetbrains.mps.ide.migration.check;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Collection;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConceptFeature;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.adapter.structure.concept.SAbstractConceptAdapter;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.util.IterableUtil;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.model.SReference;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.module.ReloadableModule;
import jetbrains.mps.classloading.ModuleClassLoaderSupport;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.project.structure.modules.Dependency;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapter;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;

public class MigrationCheckUtil {
  public static boolean haveProblems(Iterable<SModule> modules) {
    return CollectionSequence.fromCollection(getProblems(modules, 1)).isNotEmpty();
  }

  public static Collection<Problem> getProblems(Iterable<SModule> modules, int maxErrors) {
    List<Problem> result = ListSequence.fromList(new ArrayList<Problem>());

    Collection<DependencyProblem> badModuleProblems = findBadModules(modules, maxErrors);
    ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(badModuleProblems));

    maxErrors -= CollectionSequence.fromCollection(badModuleProblems).count();
    if (maxErrors == 0) {
      return result;
    }

    // find missing languages 
    Collection<LanguageMissingProblem> missingLangProblems = findMissingLanguages(modules, maxErrors);
    ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(missingLangProblems));

    maxErrors -= CollectionSequence.fromCollection(missingLangProblems).count();
    if (maxErrors == 0) {
      return result;
    }

    Set<SLanguage> missingLangs = SetSequence.fromSet(new HashSet<SLanguage>());
    SetSequence.fromSet(missingLangs).addSequence(CollectionSequence.fromCollection(missingLangProblems).select(new ISelector<LanguageMissingProblem, SLanguage>() {
      public SLanguage select(LanguageMissingProblem it) {
        return it.getLanguage();
      }
    }));

    // find missing concepts, when language's not missing 
    // find missing concept features when concept's not mising 
    Set<SAbstractConcept> missingConcepts = SetSequence.fromSet(new HashSet<SAbstractConcept>());
    Set<SConceptFeature> missingFeatures = SetSequence.fromSet(new HashSet<SConceptFeature>());

    for (SNode node : Sequence.fromIterable(MigrationCheckUtil.allNodes(modules))) {
      SAbstractConceptAdapter concept = (SAbstractConceptAdapter) node.getConcept();
      if (concept.getConceptDescriptor() == null) {
        if (SetSequence.fromSet(missingLangs).contains(concept.getLanguage()) || SetSequence.fromSet(missingConcepts).contains(concept)) {
          continue;
        }
        SetSequence.fromSet(missingConcepts).addElement(concept);
        ListSequence.fromList(result).addElement(new ConceptMissingProblem(concept, node));

        maxErrors--;
        if (maxErrors == 0) {
          return result;
        }

        continue;
      }

      // in case of props, refs, links, list should be better than set 
      List<SProperty> props = IterableUtil.asList(concept.getProperties());
      for (SProperty p : Sequence.fromIterable(node.getProperties())) {
        if (props.contains(p) || SetSequence.fromSet(missingFeatures).contains(p)) {
          continue;
        }
        SetSequence.fromSet(missingFeatures).addElement(p);
        ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(p, node));

        maxErrors--;
        if (maxErrors == 0) {
          return result;
        }
      }

      List<SContainmentLink> links = IterableUtil.asList(concept.getContainmentLinks());
      for (SNode n : Sequence.fromIterable(node.getChildren())) {
        SContainmentLink l = n.getContainmentLink();
        if (links.contains(l) || SetSequence.fromSet(missingFeatures).contains(l)) {
          continue;
        }
        SetSequence.fromSet(missingFeatures).addElement(l);
        ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(l, node));

        maxErrors--;
        if (maxErrors == 0) {
          return result;
        }
      }

      List<SReferenceLink> refs = IterableUtil.asList(concept.getReferenceLinks());
      for (SReference r : Sequence.fromIterable(node.getReferences())) {
        SReferenceLink l = r.getLink();
        if (refs.contains(l) || SetSequence.fromSet(missingFeatures).contains(l)) {
          continue;
        }
        SetSequence.fromSet(missingFeatures).addElement(l);
        ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(l, node));

        maxErrors--;
        if (maxErrors == 0) {
          return result;
        }
      }
    }

    return result;
  }

  private static Collection<DependencyProblem> findBadModules(Iterable<SModule> modules, int maxErrors) {
    final Map<SModuleReference, SModule> badModule2Dependant = MapSequence.fromMap(new HashMap<SModuleReference, SModule>());

    Sequence.fromIterable(modules).where(new IWhereFilter<SModule>() {
      public boolean accept(SModule it) {
        return (it instanceof ReloadableModule) && ModuleClassLoaderSupport.canCreate(((ReloadableModule) it));
      }
    }).visitAll(new IVisitor<SModule>() {
      public void visit(final SModule module) {
        Iterable<Dependency> deps = ((AbstractModule) module).getUnresolvedDependencies();
        Sequence.fromIterable(deps).where(new IWhereFilter<Dependency>() {
          public boolean accept(Dependency it) {
            return it.getModuleRef().resolve(MPSModuleRepository.getInstance()) == null;
          }
        }).visitAll(new IVisitor<Dependency>() {
          public void visit(Dependency dep) {
            MapSequence.fromMap(badModule2Dependant).put(dep.getModuleRef(), module);
          }
        });
      }
    });

    return MapSequence.fromMap(badModule2Dependant).take(maxErrors).select(new ISelector<IMapping<SModuleReference, SModule>, DependencyProblem>() {
      public DependencyProblem select(IMapping<SModuleReference, SModule> it) {
        return new DependencyProblem(it.value(), "Unresolved dependency in module " + it.value().getModuleName() + ". " + it.key().getModuleName() + " not found in repository");
      }
    }).toListSequence();
  }

  private static Collection<LanguageMissingProblem> findMissingLanguages(Iterable<SModule> modules, int maxErrors) {
    // we can add here an additional chank for "used", "exported", "generated into" languages etc.,  
    // but I'm not sure this is needed. All we need in migration is working concepts. 

    // the node in the map is an example of language use to show it to the user 
    final Map<SLanguage, SNode> problemLangs = MapSequence.fromMap(new HashMap<SLanguage, SNode>());
    Sequence.fromIterable(allNodes(modules)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SLanguage lang = it.getConcept().getLanguage();
        if (((SLanguageAdapter) lang).getLanguageDescriptor() == null) {
          MapSequence.fromMap(problemLangs).put(lang, it);
        }
      }
    });

    final Set<LanguageMissingProblem> problems = SetSequence.fromSet(new HashSet<LanguageMissingProblem>());
    MapSequence.fromMap(problemLangs).take(maxErrors).visitAll(new IVisitor<IMapping<SLanguage, SNode>>() {
      public void visit(IMapping<SLanguage, SNode> it) {
        if (it.key().getSourceModule() == null) {
          SetSequence.fromSet(problems).addElement(new LanguageAbsentInRepoProblem(it.key(), it.value()));
        } else {
          SetSequence.fromSet(problems).addElement(new LanguageNotLoadedProblem(it.key(), it.value()));
        }
      }
    });
    return problems;
  }


  private static Iterable<SNode> allNodes(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {
      public Iterable<SModel> translate(SModule it) {
        return it.getModels();
      }
    }).ofType(SModel.class).translate(new ITranslator2<SModel, SNode>() {
      public Iterable<SNode> translate(SModel it) {
        return SModelOperations.nodes(it, null);
      }
    });
  }
}
