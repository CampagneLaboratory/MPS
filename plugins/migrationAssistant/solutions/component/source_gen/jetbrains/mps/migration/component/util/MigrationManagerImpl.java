package jetbrains.mps.migration.component.util;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.ide.migration.MigrationManager;
import jetbrains.mps.project.Project;
import jetbrains.mps.migration.global.ProjectMigration;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import java.util.Map;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import org.apache.log4j.Level;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.ide.migration.MigrationScriptApplied;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationManagerImpl extends AbstractProjectComponent implements MigrationManager {
  private Project myMpsMproject;
  private ProjectMigration lastProjectMigration = null;
  private MigrationComponent myMigrationComponent;

  public MigrationManagerImpl(com.intellij.openapi.project.Project project, Project mpsProject, MigrationComponent migrationComponent) {
    super(project);
    myMpsMproject = mpsProject;
    myMigrationComponent = migrationComponent;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    myMpsMproject.getRepository().getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(myMpsMproject);
        result.value = isMigrationRequired(myMpsMproject, modules);
      }
    });
    return result.value;
  }

  public static boolean isMigrationRequired(final Project p, Iterable<SModule> modules) {
    List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();
    boolean projectMig = ListSequence.fromList(pMig).any(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(p);
      }
    });
    boolean moduleMig = isModuleMigrationRequired(modules);
    return projectMig || moduleMig;
  }

  public Iterable<ProjectMigration> getProjectMigrationsToApply() {
    List<ProjectMigration> allProjectMigrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    return ListSequence.fromList(allProjectMigrations).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(myMpsMproject);
      }
    }).toListSequence();
  }



  public Iterable<Tuples._2<ScriptApplied, ScriptApplied.ScriptAppliedReference>> getModuleMigrationsToApply(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ScriptApplied.ScriptAppliedReference>() {
      public Iterable<ScriptApplied.ScriptAppliedReference> translate(SModule module) {
        return MigrationsUtil.getAllSteps(module);
      }
    }).select(new ISelector<ScriptApplied.ScriptAppliedReference, Tuples._2<ScriptApplied, ScriptApplied.ScriptAppliedReference>>() {
      public Tuples._2<ScriptApplied, ScriptApplied.ScriptAppliedReference> select(ScriptApplied.ScriptAppliedReference it) {
        return MultiTuple.<ScriptApplied,ScriptApplied.ScriptAppliedReference>from(it.resolve(myMigrationComponent, false), it);
      }
    });
  }

  public List<Tuples._3<SModule, SLanguage, Integer>> getMissingMigrations() {
    final List<Tuples._3<SModule, SLanguage, Integer>> result = ListSequence.fromList(new ArrayList<Tuples._3<SModule, SLanguage, Integer>>());
    myMpsMproject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(myMpsMproject);
        for (SModule module : Sequence.fromIterable(modules)) {
          for (SLanguage lang : SetSequence.fromSet(new SLanguageHierarchy(module.getUsedLanguages()).getExtended())) {
            int currentLangVersion = lang.getLanguageVersion();
            int ver = module.getUsedLanguageVersion(lang);

            ver = Math.max(ver, 0);
            currentLangVersion = Math.max(currentLangVersion, 0);

            if (ver >= currentLangVersion) {
              continue;
            }
            for (int v = ver; v < currentLangVersion; v++) {
              if (myMigrationComponent.fetchMigrationScript(new MigrationScriptReference(lang, v), false) == null) {
                ListSequence.fromList(result).addElement(MultiTuple.<SModule,SLanguage,Integer>from(module, lang, v));
                // next used language, please 
                break;
              }
            }
          }
        }
      }
    });
    return result;
  }

  public static boolean isModuleMigrationRequired(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).any(new IWhereFilter<SModule>() {
      public boolean accept(SModule module) {
        return Sequence.fromIterable(MigrationsUtil.getAllSteps(module)).isNotEmpty();
      }
    });
  }

  public int projectStepsCount(boolean isCleanup) {
    List<ProjectMigration> migrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    int cleanupSize = ListSequence.fromList(migrations).ofType(CleanupProjectMigration.class).count();
    return (isCleanup ? cleanupSize : ListSequence.fromList(migrations).count() - cleanupSize);
  }

  public MigrationManager.MigrationStep nextProjectStep(Map<String, Object> options, boolean cleanup) {
    ProjectMigration current = next(lastProjectMigration, cleanup);

    while (current != null && !(current.shouldBeExecuted(myMpsMproject))) {
      current = next(current, cleanup);
    }

    if (current == null) {
      return null;
    }

    lastProjectMigration = current;
    if (current instanceof ProjectMigrationWithOptions) {
      ((ProjectMigrationWithOptions) current).setOptionValues(options);
    }

    final ProjectMigration cc = current;
    return new MigrationManager.MigrationStep() {
      public String getDescription() {
        return cc.getDescription();
      }
      public boolean execute() {
        try {
          myMpsMproject.getRepository().getModelAccess().executeCommand(new Runnable() {
            public void run() {
              cc.execute(myMpsMproject);
            }
          });
        } catch (Throwable e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Could not execute script", e);
          }
          return false;
        }
        return true;
      }

      public void forceExecutionNextTime() {
        if (!((cc instanceof CleanupProjectMigration))) {
          throw new UnsupportedOperationException("only supported for cleanup project migrations");
        }
        ((CleanupProjectMigration) cc).forceExecutionNextTime(myMpsMproject);
      }
    };
  }

  private ProjectMigration next(ProjectMigration current, final boolean cleanup) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();

    mig = ListSequence.fromList(mig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        boolean isCleanup = it instanceof CleanupProjectMigration;
        // this is xor, which is absent in bl 
        return (cleanup ? isCleanup : !(isCleanup));
      }
    }).toListSequence();

    if (ListSequence.fromList(mig).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(mig).indexOf(current) < 0) {
      // was: cleanup, now: not cleanup 
      current = null;
    }
    if (current == null) {
      return ListSequence.fromList(mig).getElement(0);
    }

    int index = ListSequence.fromList(mig).indexOf(current);
    if (index == ListSequence.fromList(mig).count() - 1) {
      return null;
    }
    return ListSequence.fromList(mig).getElement(index + 1);
  }

  public int moduleStepsCount() {
    final Wrappers._int result = new Wrappers._int();
    myMpsMproject.getRepository().getModelAccess().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Integer>() {
      public Integer invoke() {
        Iterable<Integer> scriptsByModule = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(myMpsMproject)).select(new ISelector<SModule, Integer>() {
          public Integer select(SModule module) {
            int scripts = 0;
            for (SLanguage lang : SetSequence.fromSet(new SLanguageHierarchy(module.getUsedLanguages()).getExtended())) {
              int currentLangVersion = lang.getLanguageVersion();
              int ver = module.getUsedLanguageVersion(lang);

              ver = Math.max(ver, 0);
              currentLangVersion = Math.max(currentLangVersion, 0);

              if (ver < currentLangVersion) {
                scripts += currentLangVersion - ver;
              }
            }
            return scripts;
          }
        });
        return result.value = Sequence.fromIterable(scriptsByModule).foldLeft(0, new ILeftCombinator<Integer, Integer>() {
          public Integer combine(Integer s, Integer it) {
            return s + it;
          }
        });
      }
    }));
    return result.value;
  }

  public MigrationManager.MigrationStep nextModuleStep() {
    final Wrappers._T<MigrationManager.MigrationStep> result = new Wrappers._T<MigrationManager.MigrationStep>(null);

    myMpsMproject.getRepository().getModelAccess().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Boolean>() {
      public Boolean invoke() {
        return Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject))).any(new IWhereFilter<SModule>() {
          public boolean accept(SModule module) {
            return Sequence.fromIterable(MigrationsUtil.getAllSteps(module)).any(new IWhereFilter<ScriptApplied.ScriptAppliedReference>() {
              public boolean accept(ScriptApplied.ScriptAppliedReference it) {
                final ScriptApplied applied = it.resolve(myMigrationComponent, false);
                if (applied == null) {
                  return false;
                }
                if (Sequence.fromIterable(applied.getDependencies()).where(new IWhereFilter<ScriptApplied.ScriptAppliedReference>() {
                  public boolean accept(ScriptApplied.ScriptAppliedReference it) {
                    return !(it.isAlreadyDone());
                  }
                }).isNotEmpty()) {
                  return false;
                }
                if (it instanceof MigrationScriptApplied.MigrationScriptAppliedReference) {
                  if (!(MigrationsUtil.areDepsSatisfied((MigrationScriptApplied) applied))) {
                    throw new IllegalStateException();
                  }
                }
                // todo: execute after for refactorings 
                result.value = new MigrationManager.MigrationStep() {
                  public String getDescription() {
                    return applied.getDescription();
                  }
                  public boolean execute() {
                    final Wrappers._boolean res = new Wrappers._boolean();
                    myMpsMproject.getRepository().getModelAccess().executeCommand(new Runnable() {
                      public void run() {
                        res.value = applied.execute(myMigrationComponent);
                      }
                    });
                    return res.value;
                  }
                  public void forceExecutionNextTime() {
                    throw new UnsupportedOperationException("not supported for module migrations");
                  }
                };
                return true;
              }
            });
          }
        });
      }
    }));

    return result.value;
  }

  protected static Logger LOG = LogManager.getLogger(MigrationManagerImpl.class);
}
