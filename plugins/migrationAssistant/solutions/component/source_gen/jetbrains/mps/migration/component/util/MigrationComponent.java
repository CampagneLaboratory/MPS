package jetbrains.mps.migration.component.util;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.ide.migration.MigrationManager;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.lang.migration.runtime.base.MigrationDescriptor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.migration.global.ProjectMigration;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.apache.log4j.Level;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.lang.migration.runtime.base.RefactoringStep;
import jetbrains.mps.lang.migration.runtime.base.RefactoringStepReference;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.migration.LanguageScriptApplied;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.AbstractModule;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.ArrayList;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.lang.migration.runtime.base.MigrationUnitReference;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.ide.migration.DependencyScriptApplied;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent implements MigrationManager, DataCollector {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());
  private Project mpsProject;
  private SModule dataModule;
  private TempModuleOptions dataModuleOptions;
  private ProjectMigration lastProjectMigration;

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.mpsProject = mpsProject;
    lastProjectMigration = null;
  }

  @Override
  public void initComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        dataModuleOptions = TempModuleOptions.forDefaultModule();
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModule = dataModuleOptions.createModule();
          }
        });
      }
    });
  }

  @Override
  public void disposeComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModuleOptions.disposeModule();
          }
        });
      }
    });
  }

  public MigrationDescriptor loadMigrationDescriptor(final Language module) {
    final Wrappers._T<String> name = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        name.value = getDescriptorFQName(module);
      }
    });
    try {
      Class descriptorClass = module.getClass(name.value);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Exception on migration descriptor instantiation", e);
      }
      return null;
    }
  }

  public String getDescriptorFQName(SModule module) {
    return module.getModuleName() + "." + LanguageAspect.MIGRATION.getName() + "." + ((String) BHReflection.invoke(SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, "jetbrains.mps.lang.migration.structure.MigrationScript").getDeclarationNode()), SMethodTrimmedId.create("getGeneratedClassName", MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, "jetbrains.mps.lang.migration.structure.MigrationScript"), "7w5LXrJJkLe")));
  }

  public MigrationDescriptor getMigrationDescriptor(Language module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }

  public void clearCache() {
    MapSequence.fromMap(loadedDescriptors).clear();
  }

  public MigrationScript fetchLanguageScript(MigrationScriptReference scriptReference, boolean silently) {
    SLanguage depLanguage = scriptReference.getLanguage();
    int current = scriptReference.getFromVersion();
    MigrationDescriptor md = getMigrationDescriptor((Language) depLanguage.getSourceModule());
    if (md == null && !(silently)) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration descriptor for language " + depLanguage + ".");
      }
    }
    MigrationScript script = check_gd1mrb_a0e0u(md, current);
    if (script == null && !(silently)) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration script for language " + depLanguage + ", version " + current + ".");
      }
      return null;
    }
    return script;
  }

  public RefactoringStep fetchModuleScript(RefactoringStepReference scriptReference, boolean silently) {
    SModuleReference depModule = scriptReference.getModule();
    final int current = scriptReference.getFromVersion();
    SModel migrationModel = LanguageAspect.MIGRATION.get((Language) depModule.resolve(MPSModuleRepository.getInstance()));
    SNode script = ListSequence.fromList(SModelOperations.roots(migrationModel, MetaAdapterFactory.getInterfaceConcept(0x9882f4ad195546feL, 0x826994189e5dbbf2L, 0x47bb811da2acc4d6L, "jetbrains.mps.lang.migration.util.structure.IMigrationUnit"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return ((Integer) BHReflection.invoke(it, SMethodTrimmedId.create("fromVersion", null, "4uVwhQyFcnl"))) == current;
      }
    }).first();
    RefactoringStep implementation = ((RefactoringStep) BHReflection.invoke(script, SMethodTrimmedId.create("getImplementation", null, "4yRsQKnslQA")));
    return implementation;
  }

  public static boolean areDepsSatisfied(final LanguageScriptApplied p) {
    Iterable<MigrationScriptReference> requiresData = p.getScript().requiresData();
    boolean dataDeps = Sequence.fromIterable(requiresData).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isAppliedForAllMyDeps(it, p.getModule());
      }
    });
    Iterable<MigrationScriptReference> executeAfter = p.getScript().executeAfter();
    boolean orderDeps = Sequence.fromIterable(executeAfter).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isApplied(it, (AbstractModule) p.getModule());
      }
    });
    if (dataDeps && orderDeps) {
      return true;
    }
    return false;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
        result.value = isMigrationRequired(mpsProject, modules);
      }
    });
    return result.value;
  }

  public static boolean isMigrationRequired(final Project p, Iterable<SModule> modules) {
    List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();
    boolean projectMig = ListSequence.fromList(pMig).any(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(p);
      }
    });
    boolean languageMig = isLanguageMigrationRequired(modules);
    return projectMig || languageMig;
  }

  public Set<String> getProjectMigrationsToApply(final Project p) {
    List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();
    Iterable<String> names = ListSequence.fromList(pMig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(p);
      }
    }).select(new ISelector<ProjectMigration, String>() {
      public String select(ProjectMigration it) {
        return it.getDescription();
      }
    });
    return SetSequence.fromSetWithValues(new HashSet<String>(), names);
  }

  public Set<String> getLanguageMigrationsToApply(Iterable<SModule> modules) {
    Iterable<String> names = Sequence.fromIterable(modules).ofType(AbstractModule.class).translate(new ITranslator2<AbstractModule, MigrationScriptReference>() {
      public Iterable<MigrationScriptReference> translate(AbstractModule module) {
        return MigrationsUtil.getAllScriptsToBeExecuted(module);
      }
    }).select(new ISelector<MigrationScriptReference, String>() {
      public String select(MigrationScriptReference it) {
        MigrationScript script = fetchLanguageScript(it, false);
        String langNameShrinked = NameUtil.compactNamespace(it.getLanguage().getQualifiedName());

        if (script == null) {
          return "<missing script>: language:" + langNameShrinked + ", version:" + it.getFromVersion();
        }

        return script.getCaption() + "  [" + langNameShrinked + "]";
      }
    });
    return SetSequence.fromSetWithValues(new HashSet<String>(), names);
  }

  public List<Tuples._3<SModule, SLanguage, Integer>> getMissingMigrations() {
    final List<Tuples._3<SModule, SLanguage, Integer>> result = ListSequence.fromList(new ArrayList<Tuples._3<SModule, SLanguage, Integer>>());
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject));
        for (SModule module : Sequence.fromIterable(modules)) {
          for (SLanguage lang : SetSequence.fromSet(((AbstractModule) module).getAllUsedLanguages())) {
            int currentLangVersion = lang.getLanguageVersion();
            int ver = ((AbstractModule) module).getUsedLanguageVersion(lang);

            ver = Math.max(ver, 0);
            currentLangVersion = Math.max(currentLangVersion, 0);

            if (ver >= currentLangVersion) {
              continue;
            }
            for (int v = ver; v < currentLangVersion; v++) {
              if (fetchLanguageScript(new MigrationScriptReference(lang, v), false) == null) {
                ListSequence.fromList(result).addElement(MultiTuple.<SModule,SLanguage,Integer>from(module, lang, v));
                // next used language, please 
                break;
              }
            }
          }
        }
      }
    });
    return result;
  }

  public static boolean isLanguageMigrationRequired(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {
      public boolean accept(final AbstractModule module) {
        return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationUnitReference>() {
          public boolean accept(MigrationUnitReference item) {
            if (item instanceof MigrationScriptReference) {
              return MigrationsUtil.isLanguageMigrationNeeded(((MigrationScriptReference) item).getLanguage(), ((MigrationScriptReference) item).getFromVersion(), module);
            }
            if (item instanceof RefactoringStepReference) {
              return MigrationsUtil.isDependencyMigrationNeeded(((RefactoringStepReference) item).getModule().resolve(module.getRepository()), ((RefactoringStepReference) item).getFromVersion(), module);
            }
            throw new IllegalStateException();
          }
        });
      }
    });
  }

  public boolean executeLanguageScript(LanguageScriptApplied sa) {
    MigrationScript script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SLanguage fromLanguage = script.getDescriptor().getLanguage();
    Integer usedVersion = module.getModuleDescriptor().getLanguageVersions().get(fromLanguage);
    usedVersion = Math.max(usedVersion, 0);
    assert usedVersion == script.getDescriptor().getFromVersion();
    try {
      SNode data = script.execute(module, this);
      if (data != null) {
        MigrationDataUtil.addData(module, dataModule, script.getDescriptor(), data);
      }
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = script.getDescriptor().getFromVersion() + 1;
    module.getModuleDescriptor().getLanguageVersions().put(fromLanguage, toVersion);
    module.setChanged();

    for (SModel model : ListSequence.fromList(module.getModels())) {
      if (model.isReadOnly()) {
        continue;
      }
      if (!((model instanceof SModelInternal))) {
        continue;
      }
      if (!(((SModelInternal) model).importedLanguageIds().contains(fromLanguage))) {
        continue;
      }

      ((SModelInternal) model).deleteLanguageId(fromLanguage);
      ((SModelInternal) model).addLanguage(fromLanguage, toVersion);
    }

    return true;
  }

  public boolean executeDependencyScript(DependencyScriptApplied sa) {
    RefactoringStep script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SModuleReference fromModule = script.getDescriptor().getModule();
    Integer importedVersion = module.getModuleDescriptor().getDependencyVersions().get(fromModule);
    importedVersion = Math.max(importedVersion, 0);
    assert importedVersion == script.getDescriptor().getFromVersion();
    try {
      script.execute(module);
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = script.getDescriptor().getFromVersion() + 1;
    module.getModuleDescriptor().getDependencyVersions().put(fromModule, toVersion);
    module.setChanged();

    // todo: versions in models 
    return true;
  }

  public int projectStepsCount(boolean isCleanup) {
    List<ProjectMigration> migrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    int cleanupSize = ListSequence.fromList(migrations).ofType(CleanupProjectMigration.class).count();
    return (isCleanup ? cleanupSize : ListSequence.fromList(migrations).count() - cleanupSize);
  }

  public MigrationManager.MigrationStep nextProjectStep(Map<String, Object> options, boolean cleanup) {
    ProjectMigration current = next(lastProjectMigration, cleanup);

    while (current != null && !(current.shouldBeExecuted(mpsProject))) {
      current = next(current, cleanup);
    }

    if (current == null) {
      return null;
    }

    lastProjectMigration = current;
    if (current instanceof ProjectMigrationWithOptions) {
      ((ProjectMigrationWithOptions) current).setOptionValues(options);
    }

    final ProjectMigration cc = current;
    return new MigrationManager.MigrationStep() {
      public String getDescription() {
        return cc.getDescription();
      }
      public boolean execute() {
        try {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              cc.execute(mpsProject);
            }
          });
        } catch (Throwable e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Could not execute script", e);
          }
          return false;
        }
        return true;
      }

      public void forceExecutionNextTime() {
        if (!((cc instanceof CleanupProjectMigration))) {
          throw new UnsupportedOperationException("only supported for cleanup project migrations");
        }
        ((CleanupProjectMigration) cc).forceExecutionNextTime(mpsProject);
      }
    };
  }

  private ProjectMigration next(ProjectMigration current, final boolean cleanup) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();

    mig = ListSequence.fromList(mig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        boolean isCleanup = it instanceof CleanupProjectMigration;
        // this is xor, which is absent in bl 
        return (cleanup ? isCleanup : !(isCleanup));
      }
    }).toListSequence();

    if (ListSequence.fromList(mig).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(mig).indexOf(current) < 0) {
      // was: cleanup, now: not cleanup 
      current = null;
    }
    if (current == null) {
      return ListSequence.fromList(mig).getElement(0);
    }

    int index = ListSequence.fromList(mig).indexOf(current);
    if (index == ListSequence.fromList(mig).count() - 1) {
      return null;
    }
    return ListSequence.fromList(mig).getElement(index + 1);
  }

  public int languageStepsCount() {
    final Wrappers._int result = new Wrappers._int();
    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Integer>() {
      public Integer invoke() {
        Iterable<Integer> scriptsByModule = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(mpsProject)).ofType(AbstractModule.class).select(new ISelector<AbstractModule, Integer>() {
          public Integer select(AbstractModule module) {
            int scripts = 0;
            for (SLanguage lang : SetSequence.fromSet(new SLanguageHierarchy(module.getUsedLanguages()).getExtended())) {
              int currentLangVersion = lang.getLanguageVersion();
              int ver = module.getUsedLanguageVersion(lang);

              ver = Math.max(ver, 0);
              currentLangVersion = Math.max(currentLangVersion, 0);

              if (ver < currentLangVersion) {
                scripts += currentLangVersion - ver;
              }
            }
            return scripts;
          }
        });
        return result.value = Sequence.fromIterable(scriptsByModule).foldLeft(0, new ILeftCombinator<Integer, Integer>() {
          public Integer combine(Integer s, Integer it) {
            return s + it;
          }
        });
      }
    }));
    return result.value;
  }

  public MigrationManager.MigrationStep nextLanguageStep() {
    final Wrappers._T<MigrationManager.MigrationStep> result = new Wrappers._T<MigrationManager.MigrationStep>(null);

    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Boolean>() {
      public Boolean invoke() {
        Collection<LanguageScriptApplied> scripts = CollectionSequence.fromCollection(new ArrayList<LanguageScriptApplied>());

        return Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject))).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {
          public boolean accept(final AbstractModule module) {
            return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationUnitReference>() {
              public boolean accept(MigrationUnitReference it) {
                if (it instanceof MigrationScriptReference) {
                  if (!(MigrationsUtil.isLanguageMigrationNeeded(((MigrationScriptReference) it).getLanguage(), ((MigrationScriptReference) it).getFromVersion(), module))) {
                    return false;
                  }
                  MigrationScript loaded = fetchLanguageScript(((MigrationScriptReference) it), false);
                  if (loaded == null) {
                    return false;
                  }
                  final LanguageScriptApplied applied = new LanguageScriptApplied(loaded, module);
                  if (!(areDepsSatisfied(applied))) {
                    return false;
                  }
                  result.value = new MigrationManager.MigrationStep() {
                    public String getDescription() {
                      return applied.toString();
                    }
                    public boolean execute() {
                      final Wrappers._boolean res = new Wrappers._boolean();
                      ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                        public void run() {
                          res.value = executeLanguageScript(applied);
                        }
                      });
                      return res.value;
                    }
                    public void forceExecutionNextTime() {
                      throw new UnsupportedOperationException("not supported for language migrations");
                    }
                  };
                  return true;
                }
                if (it instanceof RefactoringStepReference) {
                  if (!(MigrationsUtil.isDependencyMigrationNeeded(((RefactoringStepReference) it).getModule().resolve(ProjectHelper.toMPSProject(myProject).getRepository()), ((RefactoringStepReference) it).getFromVersion(), module))) {
                    return false;
                  }
                  RefactoringStep loaded = fetchModuleScript(((RefactoringStepReference) it), false);
                  if (loaded == null) {
                    return false;
                  }
                  final DependencyScriptApplied applied = new DependencyScriptApplied(loaded, module);
                  // todo: execute after 
                  result.value = new MigrationManager.MigrationStep() {
                    public String getDescription() {
                      return applied.toString();
                    }
                    public boolean execute() {
                      final Wrappers._boolean res = new Wrappers._boolean();
                      ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                        public void run() {
                          res.value = executeDependencyScript(applied);
                        }
                      });
                      return res.value;
                    }
                    public void forceExecutionNextTime() {
                      throw new UnsupportedOperationException("not supported for dependency migrations");
                    }
                  };
                  return true;
                }
                throw new IllegalStateException();
              }
            });
          }
        });
      }
    }));

    return result.value;
  }

  public Map<SModule, SNode> collectData(SModule myModule, final MigrationScriptReference scriptReference) {
    final Map<SModule, SNode> requiredData = MapSequence.fromMap(new HashMap<SModule, SNode>());
    SetSequence.fromSet(MigrationsUtil.getModuleDependencies(myModule)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        SNode dataString = MigrationDataUtil.readData(it, scriptReference);
        if (dataString != null) {
          MapSequence.fromMap(requiredData).put(it, dataString);
        }
      }
    });
    return requiredData;
  }

  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);
  private static MigrationScript check_gd1mrb_a0e0u(MigrationDescriptor checkedDotOperand, int current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
}
