package jetbrains.mps.migration.component.util;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.ide.migration.MigrationManager;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.lang.migration.runtime.base.MigrationDescriptor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.migration.global.ProjectMigration;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.apache.log4j.Level;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent implements MigrationManager, DataCollector {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());
  private Project mpsProject;
  private SModule dataModule;
  private TempModuleOptions dataModuleOptions;
  private ProjectMigration lastProjectMigration;

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.mpsProject = mpsProject;
    lastProjectMigration = null;
  }

  @Override
  public void initComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        dataModuleOptions = TempModuleOptions.forDefaultModule();
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModule = dataModuleOptions.createModule();
          }
        });
      }
    });
  }

  @Override
  public void disposeComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModuleOptions.disposeModule();
          }
        });
      }
    });
  }

  public MigrationDescriptor loadMigrationDescriptor(SModule module) {
    final ClassLoader loader = ClassLoaderManager.getInstance().getClassLoader(module);
    try {
      Class descriptorClass = Class.forName(MigrationsUtil.getDescriptorFQName(module), true, loader);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (IllegalAccessException e) {
      return null;
    } catch (InstantiationException e) {
      return null;
    } catch (Throwable e) {
      return null;
    }
  }

  public MigrationDescriptor getMigrationDescriptor(SModule module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }

  public void clearCache() {
    MapSequence.fromMap(loadedDescriptors).clear();
  }

  public Iterable<MigrationScript> fetchScriptsForModule(AbstractModule module) {
    return Sequence.fromIterable(MigrationsUtil.getDependenciesToMigrate(module)).select(new ISelector<Tuples._3<SModule, Integer, Integer>, MigrationScript>() {
      public MigrationScript select(Tuples._3<SModule, Integer, Integer> dep) {
        SModule depModule = dep._0();
        int current = (int) dep._1();
        MigrationDescriptor md = getMigrationDescriptor(depModule);
        if (md == null) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Could not load migration descriptor for language " + depModule + ".");
          }
        }
        MigrationScript script = check_gd1mrb_a0e0a0a0a0s(md, current);
        if (script == null) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Could not load migration script for language " + depModule + ", version " + current + ".");
          }
          return null;
        }
        return script;
      }
    }).where(new IWhereFilter<MigrationScript>() {
      public boolean accept(MigrationScript script) {
        return script != null;
      }
    });
  }

  public Iterable<ScriptApplied> fetchScripts() {
    Iterable<? extends SModule> projectModules = mpsProject.getModules();
    return Sequence.fromIterable(projectModules).translate(new ITranslator2<SModule, ScriptApplied>() {
      public Iterable<ScriptApplied> translate(final SModule module) {
        AbstractModule abstractModule = (AbstractModule) ((SModule) module);
        return Sequence.fromIterable(fetchScriptsForModule(abstractModule)).select(new ISelector<MigrationScript, ScriptApplied>() {
          public ScriptApplied select(MigrationScript script) {
            return new ScriptApplied(script, module);
          }
        });
      }
    });
  }

  public boolean isAvailable(final ScriptApplied p) {
    if (!(p.getScript().isApplicable(p.getModule()))) {
      return true;
    }
    Iterable<MigrationScriptReference> requiresData = p.getScript().requiresData();
    boolean dataDeps = Sequence.fromIterable(requiresData).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isAppliedForAllMyDeps(it, p.getModule());
      }
    });
    Iterable<MigrationScriptReference> executeAfter = p.getScript().executeAfter();
    boolean orderDeps = Sequence.fromIterable(executeAfter).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isApplied(it, (AbstractModule) p.getModule());
      }
    });
    if (dataDeps && orderDeps) {
      return true;
    }
    return false;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();
        Iterable<? extends SModule> modules = mpsProject.getModules();
        boolean projectMig = ListSequence.fromList(pMig).any(new IWhereFilter<ProjectMigration>() {
          public boolean accept(ProjectMigration it) {
            return it.shouldBeExecuted(mpsProject);
          }
        });
        boolean languageMig = Sequence.fromIterable(modules).any(new IWhereFilter<SModule>() {
          public boolean accept(SModule it) {
            return Sequence.fromIterable(MigrationsUtil.getDependenciesToMigrate((AbstractModule) ((SModule) it))).isNotEmpty();
          }
        });
        result.value = projectMig || languageMig;
      }
    });
    return result.value;
  }
  public boolean executeScript(ScriptApplied sa) {
    MigrationScript script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SLanguage languageId = MetaIdByDeclaration.ref2Id(script.getDescriptor().getModuleReference());
    assert module.getModuleDescriptor().getLanguageVersions().get(languageId) == script.getDescriptor().getFromVersion();
    try {
      SNode data = script.execute(module, this);
      if (data != null) {
        MigrationDataUtil.addData(module, dataModule, script.getDescriptor(), data);
      }
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }
    module.getModuleDescriptor().getLanguageVersions().put(languageId, script.getDescriptor().getFromVersion() + 1);
    module.setChanged();
    return true;
  }

  public MigrationManager.MigrationState nextProjectStep() {
    ProjectMigration current = next(lastProjectMigration);

    while (current != null && !(current.shouldBeExecuted(mpsProject))) {
      current = next(current);
    }

    if (current == null) {
      return new MigrationManager.Finished() {};
    }

    final ProjectMigration cc = current;
    return new MigrationManager.Step() {
      public String getDescription() {
        return cc.getDescription();
      }
      public boolean execute() {
        try {
          cc.execute(mpsProject);
        } catch (Throwable e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Could not execute script", e);
          }
          return false;
        }
        return true;
      }
    };
  }

  private ProjectMigration next(ProjectMigration current) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();
    if (mig.isEmpty()) {
      return null;
    }
    if (current == null) {
      return mig.iterator().next();
    }

    int index = mig.indexOf(current);
    if (index == mig.size() - 1) {
      return null;
    }
    return mig.get(index + 1);
  }

  public MigrationManager.MigrationState nextStep() {
    final Wrappers._T<MigrationManager.MigrationState> lastState = new Wrappers._T<MigrationManager.MigrationState>();
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        final Iterable<ScriptApplied> allStepScripts = Sequence.fromIterable(fetchScripts()).toListSequence();
        final Iterable<ScriptApplied> availableScripts = Sequence.fromIterable(allStepScripts).where(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return isAvailable(it);
          }
        });
        final ScriptApplied scriptToExecute = Sequence.fromIterable(availableScripts).first();
        if (scriptToExecute != null) {
          lastState.value = new MigrationManager.Step() {
            public String getDescription() {
              return scriptToExecute.toString();
            }
            public boolean execute() {
              final Wrappers._boolean res = new Wrappers._boolean();
              ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                public void run() {
                  res.value = executeScript(Sequence.fromIterable(availableScripts).first());
                }
              });
              return res.value;
            }
          };
        } else {
          if (Sequence.fromIterable(allStepScripts).isEmpty()) {
            if (isMigrationRequired()) {
              lastState.value = new MigrationManager.Error() {
                public String getErrorMessage() {
                  return "Some migration scripts are missing";
                }
              };
            } else {
              lastState.value = new MigrationManager.Finished() {};
            }
          } else {
            lastState.value = new MigrationManager.Conflict() {
              public Iterable<ScriptApplied> getConflictingScripts() {
                return allStepScripts;
              }
              public boolean forceExecution(ScriptApplied scriptApplied) {
                final Wrappers._boolean res = new Wrappers._boolean();
                ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                  public void run() {
                    res.value = executeScript(Sequence.fromIterable(availableScripts).first());
                  }
                });
                return res.value;
              }
            };
          }
        }
      }
    });
    return lastState.value;
  }

  public Map<SModule, SNode> collectData(SModule myModule, final MigrationScriptReference scriptReference) {
    MigrationScript script = check_gd1mrb_a0a0hb(getMigrationDescriptor(scriptReference.getModuleReference().resolve(mpsProject.getRepository())), scriptReference, this);
    final Map<SModule, SNode> requiredData = MapSequence.fromMap(new HashMap<SModule, SNode>());
    SetSequence.fromSet(MigrationsUtil.getModuleDependencies(myModule)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        SNode dataString = MigrationDataUtil.readData(it, scriptReference);
        if (dataString != null) {
          MapSequence.fromMap(requiredData).put(it, dataString);
        }
      }
    });
    return requiredData;
  }
  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);
  private static MigrationScript check_gd1mrb_a0e0a0a0a0s(MigrationDescriptor checkedDotOperand, int current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
  private static MigrationScript check_gd1mrb_a0a0hb(MigrationDescriptor checkedDotOperand, MigrationScriptReference scriptReference, MigrationComponent checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(scriptReference.getFromVersion());
    }
    return null;
  }
}
