package jetbrains.mps.migration.component.util;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.ide.migration.MigrationManager;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.lang.migration.runtime.base.MigrationDescriptor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.migration.global.ProjectMigration;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.apache.log4j.Level;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.AbstractModule;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent implements MigrationManager, DataCollector {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());
  private Project mpsProject;
  private SModule dataModule;
  private TempModuleOptions dataModuleOptions;
  private ProjectMigration lastProjectMigration;

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.mpsProject = mpsProject;
    lastProjectMigration = null;
  }

  @Override
  public void initComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        dataModuleOptions = TempModuleOptions.forDefaultModule();
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModule = dataModuleOptions.createModule();
          }
        });
      }
    });
  }

  @Override
  public void disposeComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModuleOptions.disposeModule();
          }
        });
      }
    });
  }

  public MigrationDescriptor loadMigrationDescriptor(final Language module) {
    final Wrappers._T<String> name = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        name.value = MigrationsUtil.getDescriptorFQName(module);
      }
    });
    try {
      Class descriptorClass = module.getClass(name.value);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Exception on migration descriptor instantiation", e);
      }
      return null;
    }
  }

  public MigrationDescriptor getMigrationDescriptor(Language module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }

  public void clearCache() {
    MapSequence.fromMap(loadedDescriptors).clear();
  }

  public MigrationScript fetchScript(MigrationScriptReference scriptReference) {
    SLanguage depLanguage = scriptReference.getLanguage();
    int current = scriptReference.getFromVersion();
    MigrationDescriptor md = getMigrationDescriptor((Language) depLanguage.getSourceModule());
    if (md == null) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration descriptor for language " + depLanguage + ".");
      }
    }
    MigrationScript script = check_gd1mrb_a0e0s(md, current);
    if (script == null) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration script for language " + depLanguage + ", version " + current + ".");
      }
      return null;
    }
    return script;
  }

  public static boolean isAvailable(final ScriptApplied p) {
    Iterable<MigrationScriptReference> requiresData = p.getScript().requiresData();
    boolean dataDeps = Sequence.fromIterable(requiresData).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isAppliedForAllMyDeps(it, p.getModule());
      }
    });
    Iterable<MigrationScriptReference> executeAfter = p.getScript().executeAfter();
    boolean orderDeps = Sequence.fromIterable(executeAfter).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isApplied(it, (AbstractModule) p.getModule());
      }
    });
    if (dataDeps && orderDeps) {
      return true;
    }
    return false;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();
        Iterable<? extends SModule> modules = mpsProject.getModulesWithGenerators();
        Sequence.fromIterable(modules).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
          public void visit(AbstractModule it) {
            it.validateLanguageVersions();
          }
        });
        boolean projectMig = ListSequence.fromList(pMig).any(new IWhereFilter<ProjectMigration>() {
          public boolean accept(ProjectMigration it) {
            return it.shouldBeExecuted(mpsProject);
          }
        });
        boolean languageMig = Sequence.fromIterable(modules).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {
          public boolean accept(final AbstractModule module) {
            return Sequence.fromIterable(MigrationsUtil.getLanguageVersions(module)).any(new IWhereFilter<MigrationScriptReference>() {
              public boolean accept(MigrationScriptReference item) {
                return MigrationsUtil.isMigrationNeeded(item.getLanguage(), item.getFromVersion(), module);
              }
            });
          }
        });
        result.value = projectMig || languageMig;
      }
    });
    return result.value;
  }
  public boolean executeScript(ScriptApplied sa) {
    MigrationScript script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SLanguage language = script.getDescriptor().getLanguage();
    assert module.getModuleDescriptor().getLanguageVersions().get(language) == script.getDescriptor().getFromVersion();
    try {
      SNode data = script.execute(module, this);
      if (data != null) {
        MigrationDataUtil.addData(module, dataModule, script.getDescriptor(), data);
      }
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = script.getDescriptor().getFromVersion() + 1;
    module.getModuleDescriptor().getLanguageVersions().put(language, toVersion);
    module.setChanged();

    for (SModel model : ListSequence.fromList(module.getModels())) {
      if (model.isReadOnly()) {
        continue;
      }
      if (!((model instanceof SModelInternal))) {
        continue;
      }
      if (!(((SModelInternal) model).importedLanguageIds().contains(language))) {
        continue;
      }

      ((SModelInternal) model).deleteLanguageId(language);
      ((SModelInternal) model).addLanguageId(language, toVersion);
    }

    return true;
  }

  public MigrationManager.MigrationState nextProjectStep() {
    ProjectMigration current = next(lastProjectMigration);

    while (current != null && !(current.shouldBeExecuted(mpsProject))) {
      current = next(current);
    }

    if (current == null) {
      return new MigrationManager.Finished() {};
    }

    lastProjectMigration = current;
    final ProjectMigration cc = current;
    return new MigrationManager.Step() {
      public String getDescription() {
        return cc.getDescription();
      }
      public boolean execute() {
        try {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              cc.execute(mpsProject);
            }
          });
        } catch (Throwable e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Could not execute script", e);
          }
          return false;
        }
        return true;
      }
    };
  }

  private ProjectMigration next(ProjectMigration current) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();
    if (mig.isEmpty()) {
      return null;
    }
    if (current == null) {
      return mig.iterator().next();
    }

    int index = mig.indexOf(current);
    if (index == mig.size() - 1) {
      return null;
    }
    return mig.get(index + 1);
  }

  public MigrationManager.MigrationState nextStep() {
    final Wrappers._T<MigrationManager.MigrationState> result = new Wrappers._T<MigrationManager.MigrationState>(null);

    final Map<SModule, Iterable<MigrationScriptReference>> languageVersions = MapSequence.fromMap(new HashMap<SModule, Iterable<MigrationScriptReference>>());
    final Wrappers._T<Iterable<? extends SModule>> projectModules = new Wrappers._T<Iterable<? extends SModule>>();

    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        projectModules.value = mpsProject.getModulesWithGenerators();
      }
    });
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        Sequence.fromIterable(projectModules.value).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
          public void visit(AbstractModule it) {
            MapSequence.fromMap(languageVersions).put(it, MigrationsUtil.getLanguageVersions(it));
          }
        });
      }
    });
    final List<ScriptApplied> allStepScripts = ListSequence.fromList(new ArrayList<ScriptApplied>());
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ListSequence.fromList(allStepScripts).addSequence(Sequence.fromIterable(projectModules.value).ofType(AbstractModule.class).translate(new ITranslator2<AbstractModule, ScriptApplied>() {
          public Iterable<ScriptApplied> translate(final AbstractModule module) {
            return Sequence.fromIterable(MapSequence.fromMap(languageVersions).get(module)).where(new IWhereFilter<MigrationScriptReference>() {
              public boolean accept(MigrationScriptReference it) {
                return MigrationsUtil.isMigrationNeeded(it.getLanguage(), it.getFromVersion(), module);
              }
            }).select(new ISelector<MigrationScriptReference, MigrationScript>() {
              public MigrationScript select(MigrationScriptReference it) {
                return fetchScript(it);
              }
            }).where(new IWhereFilter<MigrationScript>() {
              public boolean accept(MigrationScript script) {
                return script != null;
              }
            }).select(new ISelector<MigrationScript, ScriptApplied>() {
              public ScriptApplied select(MigrationScript script) {
                return new ScriptApplied(script, module);
              }
            });
          }
        }));
      }
    });
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        final ScriptApplied nextScript = ListSequence.fromList(allStepScripts).findFirst(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return isAvailable(it);
          }
        });
        if (nextScript != null) {
          result.value = new MigrationManager.Step() {
            public String getDescription() {
              return nextScript.toString();
            }
            public boolean execute() {
              final Wrappers._boolean res = new Wrappers._boolean();
              ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                public void run() {
                  res.value = executeScript(nextScript);
                }
              });
              return res.value;
            }
          };
        } else {
          result.value = new MigrationManager.Finished() {};
        }
      }
    });

    return result.value;
  }

  public Map<SModule, SNode> collectData(SModule myModule, final MigrationScriptReference scriptReference) {
    final Map<SModule, SNode> requiredData = MapSequence.fromMap(new HashMap<SModule, SNode>());
    SetSequence.fromSet(MigrationsUtil.getModuleDependencies(myModule)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        SNode dataString = MigrationDataUtil.readData(it, scriptReference);
        if (dataString != null) {
          MapSequence.fromMap(requiredData).put(it, dataString);
        }
      }
    });
    return requiredData;
  }
  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);
  private static MigrationScript check_gd1mrb_a0e0s(MigrationDescriptor checkedDotOperand, int current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
}
