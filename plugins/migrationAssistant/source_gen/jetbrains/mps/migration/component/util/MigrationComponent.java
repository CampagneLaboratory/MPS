package jetbrains.mps.migration.component.util;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.openapi.project.Project;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Collections;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IListSequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.ArrayList;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());

  public MigrationComponent(Project project) {
    super(project);
  }

  public MigrationDescriptor loadMigrationDescriptor(SModule module) {
    final ClassLoader loader = ClassLoaderManager.getInstance().getClassLoader(module);
    try {
      Class descriptorClass = Class.forName(MigrationsUtil.getDescriptorFQName(module), true, loader);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (IllegalAccessException e) {
      return null;
    } catch (InstantiationException e) {
      return null;
    }
  }

  public MigrationDescriptor getMigrationDescriptor(SModule module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }

  public Iterable<? extends Iterable<MigrationScript>> fetchPrimaryScripts(final jetbrains.mps.project.Project project, AbstractModule module) {
    Iterable<? extends Iterable<MigrationScript>> scriptSeqs = Sequence.fromIterable(MigrationsUtil.checkDependenciesVersions(module)).select(new ISelector<Tuples._3<SModule, Integer, Integer>, Iterable<MigrationScript>>() {
      public Iterable<MigrationScript> select(Tuples._3<SModule, Integer, Integer> dep) {
        MigrationDescriptor md = getMigrationDescriptor(dep._0());
        int from = (int) dep._1();
        int to = (int) dep._2();
        return check_gd1mrb_a3a0a0a0a4(md, from, to);
      }
    });
    return Sequence.fromIterable(scriptSeqs).select(new ISelector<Iterable<MigrationScript>, Iterable<MigrationScript>>() {
      public Iterable<MigrationScript> select(Iterable<MigrationScript> scripts) {
        while (Sequence.fromIterable(scripts).where(new IWhereFilter<MigrationScript>() {
          public boolean accept(MigrationScript it) {
            return it instanceof SecondaryMigrationScript;
          }
        }).isNotEmpty()) {
          scripts = Sequence.fromIterable(scripts).translate(new ITranslator2<MigrationScript, MigrationScript>() {
            public Iterable<MigrationScript> translate(MigrationScript script) {
              if (script instanceof SecondaryMigrationScript) {
                SModule parentModule = as_gd1mrb_a0a0a0a0a0a0a0a0a0a0a0a0a0b0e(script, SecondaryMigrationScript.class).getPrimaryScriptModule().resolve(project.getRepository());
                if (parentModule != null) {
                  MigrationDescriptor parentDescriptor = getMigrationDescriptor(parentModule);
                  int primaryFromVersion = ((SecondaryMigrationScript) script).primaryFromVersion();
                  int primaryToVersion = ((SecondaryMigrationScript) script).primaryToVersion();
                  return check_gd1mrb_a3a1a0a0a0a0a0a0a0b0e(parentDescriptor, primaryFromVersion, primaryToVersion);
                }
                return Sequence.fromIterable(Collections.<MigrationScript>emptyList());
              } else {
                return Sequence.<MigrationScript>singleton(script);
              }
            }
          });
        }
        return scripts;
      }
    });
  }

  public Iterable<MigrationScript> sortScripts(jetbrains.mps.project.Project project, final AbstractModule module) {
    List<? extends List<MigrationScript>> primaryScripts = Sequence.fromIterable(fetchPrimaryScripts(project, module)).select(new ISelector<Iterable<MigrationScript>, IListSequence<MigrationScript>>() {
      public IListSequence<MigrationScript> select(Iterable<MigrationScript> it) {
        return Sequence.fromIterable(it).where(new IWhereFilter<MigrationScript>() {
          public boolean accept(MigrationScript it) {
            return ((PrimaryMigrationScript) it).applicableToModule(module);
          }
        }).toListSequence();
      }
    }).toListSequence();
    Map<MigrationScript, Set<MigrationScript>> dependencies = MapSequence.fromMap(new HashMap<MigrationScript, Set<MigrationScript>>());
    for (List<MigrationScript> seq : ListSequence.fromList(primaryScripts)) {
      for (int i = 0; i < ListSequence.fromList(seq).count() - 1; i++) {
        if (MapSequence.fromMap(dependencies).get(ListSequence.fromList(seq).getElement(i + 1)) == null) {
          MapSequence.fromMap(dependencies).put(ListSequence.fromList(seq).getElement(i + 1), SetSequence.fromSet(new HashSet<MigrationScript>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(dependencies).get(ListSequence.fromList(seq).getElement(i + 1))).addElement(ListSequence.fromList(seq).getElement(i));
      }
    }
    List<MigrationScript> result = ListSequence.fromList(new ArrayList<MigrationScript>());
    int maxBreak = 0;
    while (ListSequence.fromList(primaryScripts).translate(new ITranslator2<List<MigrationScript>, MigrationScript>() {
      public Iterable<MigrationScript> translate(List<MigrationScript> it) {
        return it;
      }
    }).isNotEmpty()) {
      boolean progress = false;
      for (List<MigrationScript> seq : ListSequence.fromList(primaryScripts)) {
        while (ListSequence.fromList(seq).isNotEmpty() && SetSequence.fromSet(MapSequence.fromMap(dependencies).get(ListSequence.fromList(seq).first())).count() <= maxBreak) {
          for (MigrationScript breaking : SetSequence.fromSet(MapSequence.fromMap(dependencies).get(ListSequence.fromList(seq).first()))) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("Breaking dependency " + ListSequence.fromList(seq).first() + " < " + breaking);
            }
          }
          maxBreak = 0;
          MigrationScript script = ListSequence.fromList(seq).removeElementAt(0);
          if (!(ListSequence.fromList(result).contains(script))) {
            ListSequence.fromList(result).addElement(script);
          }
          progress = true;
        }
      }
      if (progress == false) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Cycle in migration script dependencies");
        }
        maxBreak = 1;
      }
    }
    return result;
  }

  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);

  private static Iterable<MigrationScript> check_gd1mrb_a3a0a0a0a4(MigrationDescriptor checkedDotOperand, int from, int to) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScripts(from, to);
    }
    return null;
  }

  private static Iterable<MigrationScript> check_gd1mrb_a3a1a0a0a0a0a0a0a0b0e(MigrationDescriptor checkedDotOperand, int primaryFromVersion, int primaryToVersion) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScripts(primaryFromVersion, primaryToVersion);
    }
    return null;
  }

  private static <T> T as_gd1mrb_a0a0a0a0a0a0a0a0a0a0a0a0a0b0e(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
