package jetbrains.mps.migration.component.util;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.ide.migration.MigrationManager;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.apache.log4j.Level;
import com.intellij.openapi.util.Pair;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent implements MigrationManager {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());
  private Project mpsProject;

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.mpsProject = mpsProject;
  }

  public MigrationDescriptor loadMigrationDescriptor(SModule module) {
    final ClassLoader loader = ClassLoaderManager.getInstance().getClassLoader(module);
    try {
      Class descriptorClass = Class.forName(MigrationsUtil.getDescriptorFQName(module), true, loader);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (IllegalAccessException e) {
      return null;
    } catch (InstantiationException e) {
      return null;
    }
  }

  public MigrationDescriptor getMigrationDescriptor(SModule module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }

  public void clearCache() {
    MapSequence.fromMap(loadedDescriptors).clear();
  }

  public Iterable<MigrationScript> fetchScriptsForModule(AbstractModule module) {
    return Sequence.fromIterable(MigrationsUtil.getDependenciesToMigrate(module)).select(new ISelector<Tuples._3<SModule, Integer, Integer>, MigrationScript>() {
      public MigrationScript select(Tuples._3<SModule, Integer, Integer> dep) {
        SModule depModule = dep._0();
        int current = (int) dep._1();
        MigrationDescriptor md = getMigrationDescriptor(depModule);
        if (md == null) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Could not load migration descriptor for language " + depModule + ".");
          }
        }
        MigrationScript script = check_gd1mrb_a0e0a0a0a6(md, current);
        if (script == null) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Could not load migration script for language " + depModule + ", version " + current + ".");
          }
          return null;
        }
        return script;
      }
    });
  }

  public Iterable<Pair<MigrationScript, AbstractModule>> fetchScripts() {
    Iterable<? extends SModule> projectModules = mpsProject.getModules();
    return Sequence.fromIterable(projectModules).translate(new ITranslator2<SModule, Pair<MigrationScript, AbstractModule>>() {
      public Iterable<Pair<MigrationScript, AbstractModule>> translate(final SModule module) {
        AbstractModule abstractModule = (AbstractModule) module;
        return Sequence.fromIterable(fetchScriptsForModule(abstractModule)).select(new ISelector<MigrationScript, Pair<MigrationScript, AbstractModule>>() {
          public Pair<MigrationScript, AbstractModule> select(MigrationScript script) {
            return new Pair<MigrationScript, AbstractModule>(script, (AbstractModule) module);
          }
        });
      }
    });
  }

  public boolean isAvailable(Pair<MigrationScript, AbstractModule> p) {
    MigrationScript script = p.first;
    final AbstractModule module = p.second;
    if (!(script.applicableToModule(module))) {
      return true;
    }
    boolean available = Sequence.fromIterable(script.requiresData()).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isAppliedForAllMyDeps(it, module);
      }
    });
    if (available) {
      return true;
    }
    return false;
  }



  private MigrationManager.MigrationState lastState = null;

  public boolean isMigrationRequired() {
    if (mpsProject == null) {
      return false;
    }
    Iterable<? extends SModule> modules = mpsProject.getModules();
    return Sequence.fromIterable(modules).any(new IWhereFilter<SModule>() {
      public boolean accept(SModule it) {
        return Sequence.fromIterable(MigrationsUtil.getDependenciesToMigrate((AbstractModule) it)).isNotEmpty();
      }
    });
  }

  public MigrationManager.MigrationState step() {
    Iterable<Pair<MigrationScript, AbstractModule>> allStepScripts = fetchScripts();
    Iterable<Pair<MigrationScript, AbstractModule>> availableScripts = Sequence.fromIterable(allStepScripts).where(new IWhereFilter<Pair<MigrationScript, AbstractModule>>() {
      public boolean accept(Pair<MigrationScript, AbstractModule> it) {
        return isAvailable(it);
      }
    });
    if (Sequence.fromIterable(allStepScripts).isNotEmpty()) {
      MigrationsUtil.executeScript(Sequence.fromIterable(availableScripts).first().first, Sequence.fromIterable(availableScripts).first().second);
      return MigrationManager.MigrationState.STEP;
    } else {
      if (Sequence.fromIterable(allStepScripts).isEmpty()) {
        return MigrationManager.MigrationState.FINISHED;
      } else {
        lastState = MigrationManager.MigrationState.CONFLICT;
        return MigrationManager.MigrationState.CONFLICT;
      }
    }
  }

  public String currentStep() {
    return Sequence.fromIterable(fetchScripts()).first() + "";
  }

  public Iterable<Pair<MigrationScript, AbstractModule>> getConflictingScripts() {
    if (lastState != MigrationManager.MigrationState.CONFLICT) {
      throw new IllegalStateException();
    }
    return fetchScripts();
  }

  public void forceExecution(Pair<MigrationScript, AbstractModule> p) {
    MigrationsUtil.executeScript(p.first, p.second);
  }


  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);

  private static MigrationScript check_gd1mrb_a0e0a0a0a6(MigrationDescriptor checkedDotOperand, int current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
}
