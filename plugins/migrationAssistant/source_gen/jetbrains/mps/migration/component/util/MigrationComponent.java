package jetbrains.mps.migration.component.util;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.ide.migration.MigrationManager;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.apache.log4j.Level;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent implements MigrationManager {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());
  private Project mpsProject;

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.mpsProject = mpsProject;
  }



  public MigrationDescriptor loadMigrationDescriptor(SModule module) {
    final ClassLoader loader = ClassLoaderManager.getInstance().getClassLoader(module);
    try {
      Class descriptorClass = Class.forName(MigrationsUtil.getDescriptorFQName(module), true, loader);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (IllegalAccessException e) {
      return null;
    } catch (InstantiationException e) {
      return null;
    }
  }



  public MigrationDescriptor getMigrationDescriptor(SModule module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }



  public void clearCache() {
    MapSequence.fromMap(loadedDescriptors).clear();
  }



  public Iterable<MigrationScript> fetchScriptsForModule(AbstractModule module) {
    return Sequence.fromIterable(MigrationsUtil.getDependenciesToMigrate(module)).select(new ISelector<Tuples._3<SModule, Integer, Integer>, MigrationScript>() {
      public MigrationScript select(Tuples._3<SModule, Integer, Integer> dep) {
        SModule depModule = dep._0();
        int current = (int) dep._1();
        MigrationDescriptor md = getMigrationDescriptor(depModule);
        if (md == null) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Could not load migration descriptor for language " + depModule + ".");
          }
        }
        MigrationScript script = check_gd1mrb_a0e0a0a0a0k(md, current);
        if (script == null) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Could not load migration script for language " + depModule + ", version " + current + ".");
          }
          return null;
        }
        return script;
      }
    }).where(new IWhereFilter<MigrationScript>() {
      public boolean accept(MigrationScript script) {
        return script != null;
      }
    });
  }



  public Iterable<ScriptApplied> fetchScripts() {
    Iterable<? extends SModule> projectModules = mpsProject.getModules();
    return Sequence.fromIterable(projectModules).translate(new ITranslator2<SModule, ScriptApplied>() {
      public Iterable<ScriptApplied> translate(final SModule module) {
        AbstractModule abstractModule = (AbstractModule) module;
        return Sequence.fromIterable(fetchScriptsForModule(abstractModule)).select(new ISelector<MigrationScript, ScriptApplied>() {
          public ScriptApplied select(MigrationScript script) {
            return new ScriptApplied(script, module);
          }
        });
      }
    });
  }



  public boolean isAvailable(final ScriptApplied p) {
    if (!(p.getScript().applicableToModule(p.getModule()))) {
      return true;
    }
    boolean available = Sequence.fromIterable(p.getScript().requiresData()).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isAppliedForAllMyDeps(it, p.getModule());
      }
    });
    if (available) {
      return true;
    }
    return false;
  }


  private MigrationManager.MigrationState lastState = null;

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        Iterable<? extends SModule> modules = mpsProject.getModules();
        result.value = Sequence.fromIterable(modules).any(new IWhereFilter<SModule>() {
          public boolean accept(SModule it) {
            return Sequence.fromIterable(MigrationsUtil.getDependenciesToMigrate((AbstractModule) it)).isNotEmpty();
          }
        });
      }
    });
    return result.value;
  }



  public MigrationManager.MigrationState step() {
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        Iterable<ScriptApplied> allStepScripts = fetchScripts();
        Iterable<ScriptApplied> availableScripts = Sequence.fromIterable(allStepScripts).where(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return isAvailable(it);
          }
        });
        if (Sequence.fromIterable(availableScripts).isNotEmpty()) {
          MigrationsUtil.executeScript(Sequence.fromIterable(availableScripts).first());
          lastState = MigrationManager.MigrationState.STEP;
        } else {
          if (Sequence.fromIterable(allStepScripts).isEmpty()) {
            if (isMigrationRequired()) {
              lastState = MigrationManager.MigrationState.FINISHED;
            } else {
              lastState = MigrationManager.MigrationState.ERROR;
            }
          } else {
            lastState = MigrationManager.MigrationState.CONFLICT;
          }
        }
      }
    });
    return lastState;
  }



  public String currentStep() {
    final Wrappers._T<String> result = new Wrappers._T<String>();
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        result.value = Sequence.fromIterable(fetchScripts()).first() + "";
      }
    });
    return result.value;
  }



  public Iterable<ScriptApplied> getConflictingScripts() {
    if (lastState != MigrationManager.MigrationState.CONFLICT) {
      throw new IllegalStateException();
    }
    return fetchScripts();
  }



  public void forceExecution(final ScriptApplied p) {
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        MigrationsUtil.executeScript(p);
      }
    });
  }

  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);

  private static MigrationScript check_gd1mrb_a0e0a0a0a0k(MigrationDescriptor checkedDotOperand, int current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
}
