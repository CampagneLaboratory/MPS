package jetbrains.mps.console.tool;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import java.awt.event.KeyEvent;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.EditorCell_Label;
import jetbrains.mps.workbench.action.BaseAction;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;

public class ConsoleTab extends BaseConsoleTab {



  private SNode myNewCommand = null;
  private SNode myCursor = null;


  public ConsoleTab(ConsoleTool tool, String title, @Nullable String history) {
    super(tool, title, history);
  }




  protected void registerActions(DefaultActionGroup group) {
    super.registerActions(group);
    group.add(registerKeyShortcut(new ConsoleTab.ExecuteAction(), KeyEvent.VK_ENTER));
    group.add(registerKeyShortcut(new ConsoleTab.PrevCmdAction(), KeyEvent.VK_UP));
    group.add(registerKeyShortcut(new ConsoleTab.NextCmdAction(), KeyEvent.VK_DOWN));
    group.add(registerKeyShortcut(new ConsoleTab.ClearAction(), KeyEvent.VK_BACK_SPACE));
  }




  private SNode lastCmd() {
    SNode cur = ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(myRoot, "history", true), "item", true)).last();
    while ((cur != null) && !(SNodeOperations.isInstanceOf(cur, "jetbrains.mps.console.base.structure.CommandHolder"))) {
      cur = SNodeOperations.cast(SNodeOperations.getPrevSibling(cur), "jetbrains.mps.console.base.structure.HistoryItem");
    }
    return SNodeOperations.cast(cur, "jetbrains.mps.console.base.structure.CommandHolder");
  }



  private SNode getPrevCmd(SNode cmd) {
    SNode item = cmd;
    do {
      item = SNodeOperations.cast(SNodeOperations.getPrevSibling(item), "jetbrains.mps.console.base.structure.HistoryItem");
    } while ((item != null) && !(SNodeOperations.isInstanceOf(item, "jetbrains.mps.console.base.structure.CommandHolder")));

    return SNodeOperations.cast(item, "jetbrains.mps.console.base.structure.CommandHolder");
  }

  private SNode getNextCmd(SNode cmd) {
    SNode item = cmd;
    do {
      item = SNodeOperations.cast(SNodeOperations.getNextSibling(item), "jetbrains.mps.console.base.structure.HistoryItem");
    } while ((item != null) && !(SNodeOperations.isInstanceOf(item, "jetbrains.mps.console.base.structure.CommandHolder")));

    return SNodeOperations.cast(item, "jetbrains.mps.console.base.structure.CommandHolder");
  }



  private void setSelection() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            myEditor.selectNode(SLinkOperations.getTarget(myRoot, "commandHolder", true));
            EditorCell lastLeaf = ((EditorCell) myEditor.getSelectedCell()).getLastLeaf();
            myEditor.changeSelection(lastLeaf);
            if (lastLeaf instanceof EditorCell_Label) {
              ((EditorCell_Label) lastLeaf).end();
            }
          }
        });
      }
    });
    myEditor.ensureSelectionVisible();
  }



  private class ExecuteAction extends BaseAction {
    public ExecuteAction() {
      super("Execute", "Execute last command", AllIcons.Actions.Execute);
    }

    @Override
    protected void doExecute(AnActionEvent event, Map<String, Object> arg) {
      ModelAccess.instance().runWriteActionInCommand(new Runnable() {
        public void run() {
          myCursor = null;
          TemporaryModels.getInstance().addMissingImports(myModel);
          final SNode lastCmd = SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, "commandHolder", true), "command", true);
          if ((lastCmd == null)) {
            return;
          }
          execute(null, new Runnable() {
            public void run() {
              myNewCommand = null;
            }
          }, new Runnable() {
            public void run() {
              SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                  setSelection();
                }
              });
            }
          });
        }
      });
    }
  }



  private class ClearAction extends BaseAction {
    public ClearAction() {
      super("Clear", "Clear console window", AllIcons.Actions.Clean);
    }

    protected void doExecute(AnActionEvent event, Map<String, Object> arg) {
      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(myRoot, "history", true), "item", true)).clear();
      validateImports();
      setSelection();
    }
  }



  private class PrevCmdAction extends BaseAction {
    public PrevCmdAction() {
      super("Prev", "Previous command", AllIcons.Actions.PreviousOccurence);
    }

    protected void doExecute(AnActionEvent event, Map<String, Object> arg) {
      SNode lastCmd = lastCmd();
      if ((lastCmd == null)) {
        return;
      }

      SNode newCursor;
      if (myCursor == null) {
        newCursor = lastCmd;
        myNewCommand = SNodeOperations.copyNode(SLinkOperations.getTarget(myRoot, "commandHolder", true));
      } else {
        newCursor = getPrevCmd(myCursor);
        if ((newCursor == null)) {
          return;
        }
        SNode myCursorCommand = SLinkOperations.getTarget(myCursor, "command", true);
        SNode myCursorNew = SConceptOperations.createNewNode("jetbrains.mps.console.base.structure.ModifiedCommandHistoryItem", null);
        SLinkOperations.setTarget(myCursorNew, "command", myCursorCommand, true);
        SLinkOperations.setTarget(myCursorNew, "modifiedCommand", SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, "commandHolder", true), "command", true), true);
        SNodeOperations.replaceWithAnother(myCursor, myCursorNew);
      }
      if ((newCursor == null)) {
        return;
      }
      myCursor = newCursor;
      SLinkOperations.setTarget(SLinkOperations.getTarget(myRoot, "commandHolder", true), "command", SNodeOperations.copyNode(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), myCursor, "virtual_getCommandToEdit_691634242167796942", new Object[]{})), true);
      setSelection();
    }
  }



  private class NextCmdAction extends BaseAction {
    public NextCmdAction() {
      super("Next", "Next command", AllIcons.Actions.NextOccurence);
    }

    protected void doExecute(AnActionEvent event, Map<String, Object> arg) {
      if ((myCursor == null)) {
        return;
      }
      SNode newCursor = getNextCmd(myCursor);

      SNode myCursorCommand = SLinkOperations.getTarget(myCursor, "command", true);
      SNode myCursorNew = SConceptOperations.createNewNode("jetbrains.mps.console.base.structure.ModifiedCommandHistoryItem", null);
      SLinkOperations.setTarget(myCursorNew, "command", myCursorCommand, true);
      SLinkOperations.setTarget(myCursorNew, "modifiedCommand", SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, "commandHolder", true), "command", true), true);
      SNodeOperations.replaceWithAnother(myCursor, myCursorNew);

      if (!((newCursor == null))) {
        myCursor = newCursor;
        SLinkOperations.setTarget(SLinkOperations.getTarget(myRoot, "commandHolder", true), "command", SNodeOperations.copyNode(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), myCursor, "virtual_getCommandToEdit_691634242167796942", new Object[]{})), true);
      } else {
        myCursor = null;
        SLinkOperations.setTarget(SLinkOperations.getTarget(myRoot, "commandHolder", true), "command", SNodeOperations.copyNode(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), myNewCommand, "virtual_getCommandToEdit_691634242167796942", new Object[]{})), true);
      }
      setSelection();
    }
  }



  protected void loadHistory(final String state) {
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        SModel loadedModel = loadHistoryModel(state);
        myRoot = SModelOperations.createNewRootNode(myModel, "jetbrains.mps.console.base.structure.ConsoleRoot", null);
        if (loadedModel == null || ListSequence.fromList(SModelOperations.getRoots(loadedModel, "jetbrains.mps.console.base.structure.ConsoleRoot")).isEmpty()) {
          SLinkOperations.setTarget(myRoot, "history", SConceptOperations.createNewNode("jetbrains.mps.console.base.structure.History", null), true);
        } else {
          SLinkOperations.setTarget(myRoot, "history", SLinkOperations.getTarget(ListSequence.fromList(SModelOperations.getRoots(loadedModel, "jetbrains.mps.console.base.structure.ConsoleRoot")).first(), "history", true), true);
        }
        SLinkOperations.setTarget(myRoot, "commandHolder", SConceptOperations.createNewNode("jetbrains.mps.console.base.structure.CommandHolder", null), true);
        TemporaryModels.getInstance().addMissingImports(myModel);
      }
    });
  }



  public void insertCommand(SNode command) {
    addNodeImports(command);
    SLinkOperations.setTarget(SLinkOperations.getTarget(myRoot, "commandHolder", true), "command", command, true);
  }


}
