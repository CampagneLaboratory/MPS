package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import jetbrains.mps.typesystem.inference.ITypechecking;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.errors.IErrorReporter;
import junit.framework.Assert;
import jetbrains.mps.errors.MessageStatus;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.typesystem.inference.ITypeContextOwner;
import jetbrains.mps.typesystem.inference.DefaultTypecheckingContextOwner;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.lang.pattern.util.MatchingUtil;

public class TypeChecker {
  public static abstract class CheckingAction implements ITypechecking.Action {
    private SNode nodeToCheck;
    private boolean allowErrors;
    private boolean allowWarnings;


    public CheckingAction(final SNode nodeToCheck, boolean allowErrors, boolean allowWarnings) {
      this.nodeToCheck = nodeToCheck;
      this.allowErrors = allowErrors;
      this.allowWarnings = allowWarnings;
    }



    protected void reportError(TypeCheckingContext context) {
      IErrorReporter reporter = context.getTypeMessageDontCheck(nodeToCheck);
      if (reporter != null) {
        String reportError = reporter.reportError();
        if (!(allowErrors)) {
          Assert.assertTrue(reportError, reporter.getMessageStatus() != MessageStatus.ERROR);
        }
        if (!(allowWarnings)) {
          Assert.assertTrue(reportError, reporter.getMessageStatus() != MessageStatus.WARNING);
        }
      }
    }



    public abstract void checkOperation(TypeCheckingContext context, SNode operation);



    public void run(TypeCheckingContext context) {
      Assert.assertFalse("should be false (never used anyway)", allowErrors || allowWarnings);
      context.checkIfNotChecked(nodeToCheck, true);
      SNode container = AttributeOperations.getAttribute(nodeToCheck, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.lang.test.structure.NodeCheckOperationsContainer"));
      assert container != null;

      for (SNode operation : SLinkOperations.getTargets(container, "nodeCheckOperations", true)) {
        checkOperation(context, operation);
      }

      if (isErrorOrWarning()) {
        reportError(context);
      }
    }



    private boolean isErrorOrWarning() {
      return SNodeOperations.isInstanceOf(nodeToCheck, "jetbrains.mps.lang.test.structure.NodeWarningProperty") || SNodeOperations.isInstanceOf(nodeToCheck, "jetbrains.mps.lang.test.structure.NodeErrorProperty");
    }
  }

  public static void checkNodeForErrors(SNode node) {
    checkNodeForErrors(node, false, false);
  }



  private static String nodeWithIdToString(final SNode node) {
    return node + " [" + node.getNodeId() + "]";
  }



  private static void assertTypesAreTheSame(final SNode type1, final SNode type2) {
    Assert.assertNull("nodes '" + nodeWithIdToString(type1) + "' and '" + nodeWithIdToString(type2) + "' do not match!", NodesMatcher.matchNodes(type1, type2));
  }



  public static void checkNodeErrorForErrors(final SNode node, final boolean allowErrors, final boolean allowWarnings) {
    Assert.assertFalse("should be false (never used anyway)", allowErrors || allowWarnings);
    ITypeContextOwner owner = new DefaultTypecheckingContextOwner();
    SNode containingRoot = node.getContainingRoot();
    TypeContextManager.getInstance().runTypeCheckingAction(owner, containingRoot, new TypeChecker.CheckingAction(node, allowErrors, allowWarnings) {


      public void checkOperation(TypeCheckingContext context, SNode operation) {
        if (SNodeOperations.isInstanceOf(operation, "jetbrains.mps.lang.test.structure.NodeErrorProperty")) {
          Assert.assertTrue("node <" + TypeChecker.nodeWithIdToString(node) + "> does not have expected error message", context.getTypeMessageDontCheck(node) != null);
          Assert.assertFalse("node <" + TypeChecker.nodeWithIdToString(node) + "> has warning", context.getTypeMessageDontCheck(node).getMessageStatus() == MessageStatus.WARNING);
        }
      }
    });
  }



  public static void checkNodeWarningForErrors(final SNode node, final boolean allowErrors, final boolean allowWarnings) {
    Assert.assertFalse("should be false (never used anyway)", allowErrors || allowWarnings);
    ITypeContextOwner owner = new DefaultTypecheckingContextOwner();
    SNode containingRoot = node.getContainingRoot();
    TypeContextManager.getInstance().runTypeCheckingAction(owner, containingRoot, new TypeChecker.CheckingAction(node, allowErrors, allowWarnings) {


      public void checkOperation(TypeCheckingContext context, SNode operation) {
        if (SNodeOperations.isInstanceOf(operation, "jetbrains.mps.lang.test.structure.NodeWarningProperty")) {
          Assert.assertTrue("node <" + TypeChecker.nodeWithIdToString(node) + "> does not have expected warning", context.getTypeMessageDontCheck(node).getMessageStatus() == MessageStatus.WARNING);
        }
      }
    });
  }



  public static void checkNodeTypeForErrors(final SNode node, final boolean allowErrors, final boolean allowWarnings) {
    Assert.assertFalse("should be false (never used anyway)", allowErrors || allowWarnings);
    ITypeContextOwner owner = new DefaultTypecheckingContextOwner();
    SNode containingRoot = node.getContainingRoot();
    TypeContextManager.getInstance().runTypeCheckingAction(owner, containingRoot, new TypeChecker.CheckingAction(node, allowErrors, allowWarnings) {


      public void checkOperation(TypeCheckingContext context, SNode operation) {
        if (SNodeOperations.isInstanceOf(operation, "jetbrains.mps.lang.test.structure.NodeTypeProperty")) {
          SNode type1 = context.getTypeDontCheck(node);
          SNode type2 = SLinkOperations.getTarget(SNodeOperations.cast(operation, "jetbrains.mps.lang.test.structure.NodeTypeProperty"), "type", true);
          TypeChecker.assertTypesAreTheSame(type1, type2);
        }
      }
    });
  }



  public static void checkNodeExpectedTypeForErrors(final SNode node, final boolean allowErrors, final boolean allowWarnings) {
    Assert.assertFalse("should be false (never used anyway)", allowErrors || allowWarnings);
    ITypeContextOwner owner = new DefaultTypecheckingContextOwner();
    SNode containingRoot = node.getContainingRoot();
    TypeContextManager.getInstance().runTypeCheckingAction(owner, containingRoot, new TypeChecker.CheckingAction(node, allowErrors, allowWarnings) {


      public void checkOperation(TypeCheckingContext context, SNode operation) {
        if (SNodeOperations.isInstanceOf(operation, "jetbrains.mps.lang.test.structure.NodeExpectedTypeProperty")) {
          SNode type1 = jetbrains.mps.typesystem.inference.TypeChecker.getInstance().getInequalitiesForHole(node, false).getExpectedType();
          SNode type2 = SLinkOperations.getTarget(SNodeOperations.cast(operation, "jetbrains.mps.lang.test.structure.NodeExpectedTypeProperty"), "type", true);
          TypeChecker.assertTypesAreTheSame(type1, type2);
        }
      }
    });
  }



  public static void checkNodeTypeSetForErrors(final SNode node, final boolean allowErrors, final boolean allowWarnings) {
    Assert.assertFalse("should be false (never used anyway)", allowErrors || allowWarnings);
    ITypeContextOwner owner = new DefaultTypecheckingContextOwner();
    SNode containingRoot = node.getContainingRoot();
    TypeContextManager.getInstance().runTypeCheckingAction(owner, containingRoot, new TypeChecker.CheckingAction(node, allowErrors, allowWarnings) {


      public void checkOperation(TypeCheckingContext context, SNode operation) {
        if (SNodeOperations.isInstanceOf(operation, "jetbrains.mps.lang.test.structure.NodeTypeSetProperty")) {
          SNode type1 = context.getTypeDontCheck(node);
          boolean hasType = false;
          for (SNode type2 : SLinkOperations.getTargets(SNodeOperations.cast(operation, "jetbrains.mps.lang.test.structure.NodeTypeSetProperty"), "type", true)) {
            if (MatchingUtil.matchNodes(type1, type2)) {
              hasType = true;
              break;
            }
          }
          Assert.assertTrue("node type <" + TypeChecker.nodeWithIdToString(type1) + "> is not in <" + SLinkOperations.getTargets(SNodeOperations.cast(operation, "jetbrains.mps.lang.test.structure.NodeTypeSetProperty"), "type", true) + ">", hasType);
        }
      }
    });
  }






  public static void checkNodeForErrors(final SNode node, final boolean allowErrors, final boolean allowWarnings) {
    Assert.assertFalse("should be false (never used anyway)", allowErrors || allowWarnings);
    ITypeContextOwner owner = new DefaultTypecheckingContextOwner();
    SNode containingRoot = node.getContainingRoot();
    TypeContextManager.getInstance().runTypeCheckingAction(owner, containingRoot, new ITypechecking.Action() {
      @Override
      public void run(TypeCheckingContext typeCheckingContext) {
        typeCheckingContext.checkIfNotChecked(node, true);
        SNode container = AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.lang.test.structure.NodeCheckOperationsContainer"));
        if (container == null) {
          return;
        }
        // <node> 
        for (SNode operation : SLinkOperations.getTargets(container, "nodeCheckOperations", true)) {
          if (SNodeOperations.isInstanceOf(operation, "jetbrains.mps.lang.test.structure.NodeTypeProperty")) {
            SNode type1 = typeCheckingContext.getTypeDontCheck(node);
            if (SNodeOperations.isInstanceOf(operation, "jetbrains.mps.lang.test.structure.NodeExpectedTypeProperty")) {
              type1 = jetbrains.mps.typesystem.inference.TypeChecker.getInstance().getInequalitiesForHole(node, false).getExpectedType();
            }
            SNode type2 = SLinkOperations.getTarget(SNodeOperations.cast(operation, "jetbrains.mps.lang.test.structure.NodeTypeProperty"), "type", true);
            TypeChecker.assertTypesAreTheSame(type1, type2);
          }
        }
      }
    });
  }


}
