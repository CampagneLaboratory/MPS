package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import jetbrains.mps.typesystem.inference.ITypechecking;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.test.behavior.NodeCheckOperation_Behavior;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import junit.framework.Assert;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import java.util.List;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.errors.MessageStatus;
import jetbrains.mps.typesystem.inference.ITypeContextOwner;
import jetbrains.mps.typesystem.inference.DefaultTypecheckingContextOwner;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public class NodeCheckerUtil {
  public static abstract class CheckingAction implements ITypechecking.Action {
    private SNode operation;


    public CheckingAction(final SNode operation) {
      this.operation = operation;
    }



    public SNode getNodeToCheck() {
      return NodeCheckOperation_Behavior.call_getAnnotatedNode_2912288420882528229(operation);
    }



    public abstract void checkOperation(TypeCheckingContext context);



    public void run(TypeCheckingContext context) {
      SNode nodeToCheck = getNodeToCheck();
      context.checkIfNotChecked(nodeToCheck, true);
      checkOperation(context);
    }
  }



  public static String nodeWithIdToString(final SNode node) {
    return node + " [" + node.getNodeId() + "]";
  }



  public static void assertTypesAreTheSame(SNode node, final SNode type1, final SNode type2) {
    Assert.assertNull("node '" + nodeWithIdToString(node) + "' does not have type '" + nodeWithIdToString(type2) + "'!", NodesMatcher.matchNodes(type1, type2));
  }



  public static boolean nodeHasExpectedTypeSystemMessage(List<IErrorReporter> errorReports) {
    for (IErrorReporter errorReport : errorReports) {
      if (SNodeOperations.isInstanceOf(getRuleNode(errorReport), "jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement")) {
        return true;
      }
    }
    return false;

  }



  public static boolean nodeHasExpectedRuleMessage(List<IErrorReporter> errorReports, SNode operation) {
    SNode ruleNode = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), operation, "virtual_getReferencedRuleNode_5872607264946106205", new Object[]{});
    if (ListSequence.fromList(errorReports).isEmpty()) {
      return false;
    }
    if ((ruleNode == null)) {
      return true;
    }
    String ruleModel = SNodeOperations.getModel(ruleNode).getReference().toString();
    String ruleNodeId = ruleNode.getNodeId().toString();
    for (IErrorReporter errorReport : errorReports) {
      if (errorReport.getRuleId().equals(ruleNodeId) && errorReport.getRuleModel().equals(ruleModel)) {
        return true;
      }
    }
    return false;
  }



  public static SNode getRuleNode(IErrorReporter reporter) {
    SNodePointer ref = new SNodePointer(reporter.getRuleModel(), reporter.getRuleId());
    return SNodeOperations.cast(ref.resolve(MPSModuleRepository.getInstance()), "jetbrains.mps.baseLanguage.structure.Statement");
  }



  public static void checkNodeForErrorMessages(final SNode node, final boolean allowErrors, final boolean allowWarnings) {
    checkNodeWithCheckingAction(node, new ITypechecking.Action() {
      @Override
      public void run(TypeCheckingContext typeCheckingContext) {
        typeCheckingContext.checkIfNotChecked(node, true);
        for (SNode child : SNodeOperations.getDescendants(node, "jetbrains.mps.lang.core.structure.BaseConcept", false, new String[]{})) {
          if (!(NodeCheckerUtil.hasErrorOrWarningCheckOperationTag(child))) {
            IErrorReporter reporter = typeCheckingContext.getTypeMessageDontCheck(child);
            if (reporter != null) {
              String reportError = reporter.reportError() + ". Node '" + NodeCheckerUtil.nodeWithIdToString(child) + "'";
              if (!(allowErrors)) {
                Assert.assertTrue(reportError, reporter.getMessageStatus() != MessageStatus.ERROR);
              }
              if (!(allowWarnings)) {
                Assert.assertTrue(reportError, reporter.getMessageStatus() != MessageStatus.WARNING);
              }
            }
          }
        }
      }
    });
  }



  public static void checkNodeWithCheckingAction(final SNode node, ITypechecking.Action checkingAction) {
    ITypeContextOwner owner = new DefaultTypecheckingContextOwner();
    SNode containingRoot = node.getContainingRoot();
    TypeContextManager.getInstance().runTypeCheckingAction(owner, containingRoot, checkingAction);
  }



  public static boolean hasErrorOrWarningCheckOperationTag(SNode node) {
    if (AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.lang.test.structure.NodeOperationsContainer")) == null) {
      return false;
    }
    SNode container = AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.lang.test.structure.NodeOperationsContainer"));
    for (SNode property : SLinkOperations.getTargets(container, "nodeOperations", true)) {
      if (SNodeOperations.isInstanceOf(property, "jetbrains.mps.lang.test.structure.IAllowsErrors")) {
        return true;
      }
    }
    return false;
  }



}
