package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.checkers.INodeChecker;
import jetbrains.mps.typesystemEngine.checker.TypesystemChecker;
import java.util.Set;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.checkers.LanguageChecker;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.errors.MessageStatus;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.annotations.Nullable;

public class TestsErrorsChecker {
  private SNode node;
  private static TestsErrorsChecker.ErrorsHolder<IErrorReporter> errorsHolder = new TestsErrorsChecker.ErrorsHolder();


  public TestsErrorsChecker(SNode node) {
    this.node = node;
  }



  public Iterable<IErrorReporter> getTypeSystemErrorReporters() {
    INodeChecker checker = new TypesystemChecker();
    final Set<IErrorReporter> errors = checker.getErrors(SNodeOperations.getContainingRoot(node), null);
    return filterReportersByNode(errors, node);
  }



  public Iterable<IErrorReporter> getConstraintsErrorReporters() {
    INodeChecker checker = new LanguageChecker();
    IOperationContext context = null;
    final Set<IErrorReporter> errors = checker.getErrors(node, context);
    return filterReportersByNode(errors, node);
  }



  private Iterable<IErrorReporter> filterReportersByNode(final Set<IErrorReporter> errors, final SNode node) {
    return SetSequence.fromSet(errors).where(new IWhereFilter<IErrorReporter>() {
      public boolean accept(IErrorReporter it) {
        return it.getSNode().equals(node);
      }
    });
  }



  public Iterable<IErrorReporter> getErrorReporters() {
    Set<IErrorReporter> cachedErrors = errorsHolder.get(SNodeOperations.getModel(node));
    if (cachedErrors != null) {
      return SetSequence.fromSet(cachedErrors).toListSequence();
    }
    Set<IErrorReporter> result = SetSequence.fromSet(new HashSet<IErrorReporter>());
    SetSequence.fromSet(result).addSequence(Sequence.fromIterable(getTypeSystemErrorReporters()));
    SetSequence.fromSet(result).addSequence(Sequence.fromIterable(getConstraintsErrorReporters()));
    errorsHolder.set(SNodeOperations.getModel(node), result);
    return result;
  }



  public Iterable<IErrorReporter> getErrorReportersSpecificType(final MessageStatus errorType) {
    Set<IErrorReporter> result = SetSequence.fromSet(new HashSet<IErrorReporter>());
    SetSequence.fromSet(result).addSequence(Sequence.fromIterable(getErrorReporters()).where(new IWhereFilter<IErrorReporter>() {
      public boolean accept(IErrorReporter it) {
        return it.getMessageStatus() == errorType;
      }
    }));
    return result;
  }



  private static class ErrorsHolder<T> {
    private Set<T> cachedErrors;
    private SModel actualModel;


    @Nullable
    public Set<T> get(SModel model) {
      if (cachedErrors != null && model.getModelId() == actualModel.getModelId()) {
        return cachedErrors;
      }
      return null;
    }



    public void set(SModel model, Set<T> errors) {
      actualModel = model;
      cachedErrors = SetSequence.fromSet(new HashSet<T>());
      SetSequence.fromSet(cachedErrors).addSequence(SetSequence.fromSet(errors));
    }
  }


}
