package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import java.awt.datatransfer.StringSelection;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.TestMain;
import jetbrains.mps.testbench.junit.runners.MpsTestsSupport;
import jetbrains.mps.ide.IdeMain;
import com.intellij.openapi.application.ex.ApplicationManagerEx;
import jetbrains.mps.project.Project;
import jetbrains.mps.project.ProjectManager;
import junit.framework.Assert;
import jetbrains.mps.util.MacrosFactory;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import java.util.Arrays;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.classloading.ClassLoaderManager;
import java.awt.GraphicsEnvironment;
import java.awt.Toolkit;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IMapping;
import com.intellij.util.PathUtil;
import java.io.File;
import jetbrains.mps.project.PathMacros;
import jetbrains.mps.project.PathMacrosProvider;
import java.util.Set;
import java.util.Collections;
import org.apache.log4j.Level;
import java.lang.reflect.InvocationTargetException;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class TransformationTestRunner {
  private static StringSelection EMPTY_CLIPBOARD_CONTENT = new StringSelection("");

  public TransformationTestRunner() {
  }

  public void initTest(final TransformationTest test, @NotNull String projectName, final String model) throws Exception {
    initTest(test, projectName, model, false, false);
  }

  public void initTest(final TransformationTest test, @NotNull String projectName, final String model, boolean uiTest, boolean reOpenProject) throws Exception {
    if (reOpenProject) {
      // close all projects before run test 
      TestMain.PROJECT_CONTAINER.clear();
    }
    MpsTestsSupport.initEnv(true);
    //  MpsTestsSupport.initEnv(true) instantiates IdeaEnvironment which set test mode to CORE_TEST, override if needed 
    IdeMain.setTestMode((uiTest ? IdeMain.TestMode.UI_TEST : IdeMain.TestMode.CORE_TEST));
    // we do not want to save our project, see MPS-13352 
    ApplicationManagerEx.getApplicationEx().doNotSave();
    clearSystemClipboard();
    // see MPS-10568 
    readSystemMacro();
    if ((projectName == null || projectName.length() == 0)) {
      for (Project project : ProjectManager.getInstance().getOpenProjects()) {
        if (project != null) {
          test.setProject(project);
          break;
        }
      }
      if (test.getProject() == null) {
        Assert.fail("MPS Project was not specified in test class, no currently open project were found.");
      }
    } else {
      test.setProject(TestMain.PROJECT_CONTAINER.getProject(MacrosFactory.getGlobal().expandPath(projectName)));
    }
    SwingUtilities.invokeAndWait(new Runnable() {
      @Override
      public void run() {
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            SModel modelDescriptor = SModelRepository.getInstance().getModelDescriptor(PersistenceFacade.getInstance().createModelReference(model));
            if (modelDescriptor == null) {
              Assert.fail("Can't find model " + model + " in projects " + Arrays.toString(ProjectManager.getInstance().getOpenProjects()) + ".");
            }

            test.setModelDescriptor(modelDescriptor);
            test.init();
          }
        });
      }
    });
    ModelAccess.instance().flushEventQueue();
  }

  public void runTest(final TransformationTest projectTest, final String className, final String methodName, final boolean runInCommand) throws Throwable {
    final Wrappers._T<Class> clazz = new Wrappers._T<Class>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        clazz.value = ClassLoaderManager.getInstance().getClass(projectTest.getModelDescriptor().getModule(), className);
        String classloader = clazz.value.getClassLoader().toString();
        String module = projectTest.getModelDescriptor().getModule().getModuleName();
        assert classloader.contains(module) : "class: " + clazz.value + "; classloader: " + classloader + "; module: " + module;
      }
    });
    final Object obj = clazz.value.newInstance();
    clazz.value.getField("myModel").set(obj, projectTest.getTransientModelDescriptor());
    clazz.value.getField("myProject").set(obj, projectTest.getProject());
    final Throwable[] exception = new Throwable[1];
    if (runInCommand) {
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              exception[0] = TransformationTestRunner.this.tryToRunTest(clazz.value, methodName, obj);
            }
          });
        }
      });
    } else {
      exception[0] = TransformationTestRunner.this.tryToRunTest(clazz.value, methodName, obj);
    }
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        projectTest.dispose();
      }
    });
    if (exception[0] != null) {
      throw exception[0];
    }
  }

  private void clearSystemClipboard() {
    if (GraphicsEnvironment.isHeadless()) {
      return;
    }
    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(TransformationTestRunner.EMPTY_CLIPBOARD_CONTENT, TransformationTestRunner.EMPTY_CLIPBOARD_CONTENT);
  }

  private void readSystemMacro() {
    final Map<String, String> macros = MapSequence.fromMap(new HashMap<String, String>());
    for (IMapping<Object, Object> property : MapSequence.fromMap(System.getProperties())) {
      if (property.key() instanceof String) {
        String key = (((String) property.key()));
        if ((key != null && key.length() > 0) && key.startsWith(BaseTransformationTest4.PATH_MACRO_PREFIX)) {
          if (property.value() instanceof String) {
            String canonicalPath = PathUtil.getCanonicalPath(((String) property.value()));
            File file = new File(canonicalPath);
            if (file.exists() && file.isDirectory()) {
              MapSequence.fromMap(macros).put(key.substring(BaseTransformationTest4.PATH_MACRO_PREFIX.length()), canonicalPath);
            }
          }
        }
      }
    }
    PathMacros.getInstance().addMacrosProvider(new PathMacrosProvider() {
      @Override
      public Set<String> getNames() {
        return Collections.unmodifiableSet(MapSequence.fromMap(macros).keySet());
      }

      @Override
      public Set<String> getUserNames() {
        return Collections.unmodifiableSet(MapSequence.fromMap(macros).keySet());
      }

      @Override
      public String getValue(String p0) {
        return MapSequence.fromMap(macros).get(p0);
      }

      @Override
      public void report(String macro, String message) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Undefined macro: " + macro + ". " + message);
        }
      }
    });
  }

  private Throwable tryToRunTest(Class clazz, String methodName, Object obj) {
    Throwable exception = null;
    try {
      clazz.getMethod(methodName).invoke(obj);
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    } catch (InvocationTargetException e) {
      exception = e.getTargetException();
    }
    return exception;
  }

  protected static Logger LOG = LogManager.getLogger(TransformationTestRunner.class);
}
