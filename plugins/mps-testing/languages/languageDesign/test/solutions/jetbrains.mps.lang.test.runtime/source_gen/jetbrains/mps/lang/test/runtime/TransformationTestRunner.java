package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import java.awt.datatransfer.StringSelection;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.ide.IdeMain;
import jetbrains.mps.testbench.junit.runners.MpsTestsSupport;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.ModelAccess;
import java.lang.reflect.InvocationTargetException;
import javax.swing.SwingUtilities;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import junit.framework.Assert;
import java.util.Arrays;
import jetbrains.mps.project.ProjectManager;
import jetbrains.mps.tool.environment.ActiveEnvironment;
import org.apache.log4j.Priority;
import jetbrains.mps.util.MacrosFactory;
import java.io.File;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.classloading.ClassLoaderManager;
import java.awt.GraphicsEnvironment;
import java.awt.datatransfer.Clipboard;
import java.awt.Toolkit;
import jetbrains.mps.project.PathMacrosProvider;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.tool.common.util.CanonicalPath;
import jetbrains.mps.tool.builder.util.MapPathMacrosProvider;
import jetbrains.mps.project.PathMacros;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class TransformationTestRunner {
  private static final String PATH_MACRO_PREFIX = "path.macro.";
  private static final StringSelection EMPTY_CLIPBOARD_CONTENT = new StringSelection("");


  public TransformationTestRunner() {
  }



  public void initTest(final TransformationTest test, @NotNull String projectName, final String model) throws Exception {
    initTest(test, projectName, model, false, false);
  }



  public void initTest(final TransformationTest test, @NotNull String projectPath, final String modelName, boolean uiTest, boolean reopenProject) throws Exception {
    IdeMain.setTestMode((uiTest ? IdeMain.TestMode.UI_TEST : IdeMain.TestMode.CORE_TEST));
    MpsTestsSupport.initEnv(true);

    // <node> 
    clearSystemClipboard();
    readSystemMacro();
    final Project testProject = openTestProject(projectPath, reopenProject);
    doInitTest(test, testProject, modelName);
    ModelAccess.instance().flushEventQueue();
  }



  private void doInitTest(final TransformationTest test, final Project testProject, final String modelName) throws InterruptedException, InvocationTargetException {
    test.setProject(testProject);
    SwingUtilities.invokeAndWait(new Runnable() {
      @Override
      public void run() {
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            SModel modelDescriptor = findModel(modelName);
            test.setModelDescriptor(modelDescriptor);
            test.init();
          }
        }, testProject);
      }



      private SModel findModel(final String modelName) {
        SModel modelDescriptor = SModelRepository.getInstance().getModelDescriptor(PersistenceFacade.getInstance().createModelReference(modelName));

        if (modelDescriptor == null) {
          Assert.fail("Can't find model " + modelName + " in projects " + Arrays.toString(ProjectManager.getInstance().getOpenProjects()) + ".");
        }
        return modelDescriptor;
      }
    });
  }



  private Project openTestProject(String projectPathName, boolean reopenProject) {
    // <node> 
    // <node> 
    if (reopenProject) {
      for (final Project project : ActiveEnvironment.get().openedProjects()) {
        try {
          SwingUtilities.invokeAndWait(new Runnable() {
            public void run() {
              project.dispose();
            }
          });
        } catch (Exception e) {
          if (LOG.isEnabledFor(Priority.ERROR)) {
            LOG.error("", e);
          }
        }
      }
    }
    if ((projectPathName == null || projectPathName.length() == 0)) {
      if (LOG.isEnabledFor(Priority.WARN)) {
        LOG.warn("Project path is empty");
      }
      return anyOpenedProject();
    } else {
      String expandedProjectPath = MacrosFactory.getGlobal().expandPath(projectPathName);
      File projectPath = new File(expandedProjectPath);

      Project project = ActiveEnvironment.get().openProject(projectPath);
      return project;
    }
  }



  private Project anyOpenedProject() {
    for (Project project : ProjectManager.getInstance().getOpenProjects()) {
      if (project != null) {
        return project;
      }
    }
    Assert.fail("MPS Project was not specified in the test class, no opened project was found.");
    return null;
  }



  public void runTest(final TransformationTest projectTest, final String className, final String methodName, final boolean runInCommand) throws Throwable {
    if (LOG.isInfoEnabled()) {
      LOG.info("Running test " + className);
    }
    final Wrappers._T<Class> clazz = new Wrappers._T<Class>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        clazz.value = ClassLoaderManager.getInstance().getClass(projectTest.getModelDescriptor().getModule(), className);
        String classloader = clazz.value.getClassLoader().toString();
        String module = projectTest.getModelDescriptor().getModule().getModuleName();
        assert classloader.contains(module) : "class: " + clazz.value + "; classloader: " + classloader + "; module: " + module;
      }
    });
    final Object obj = clazz.value.newInstance();
    clazz.value.getField("myModel").set(obj, projectTest.getTransientModelDescriptor());
    clazz.value.getField("myProject").set(obj, projectTest.getProject());
    final Throwable[] exception = new Throwable[1];
    if (runInCommand) {
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              exception[0] = TransformationTestRunner.this.tryToRunTest(clazz.value, methodName, obj);
            }
          }, projectTest.getProject());
        }
      });
    } else {
      exception[0] = TransformationTestRunner.this.tryToRunTest(clazz.value, methodName, obj);
    }
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        projectTest.dispose();
      }
    });
    if (exception[0] != null) {
      throw exception[0];
    }
  }



  private static void clearSystemClipboard() {
    if (GraphicsEnvironment.isHeadless()) {
      return;
    }
    Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
    clipboard.setContents(EMPTY_CLIPBOARD_CONTENT, EMPTY_CLIPBOARD_CONTENT);
  }



  /**
   * to enable such macros as ${charisma}; see MPS-10568
   */
  private static PathMacrosProvider readSystemMacro() {
    final Map<String, String> macros = MapSequence.fromMap(new HashMap<String, String>());
    for (IMapping<Object, Object> property : MapSequence.fromMap(System.getProperties())) {
      if (property.key() instanceof String && property.value() instanceof String) {
        String key = (String) property.key();
        String value = (String) property.value();
        if ((key != null && key.length() > 0) && key.startsWith(PATH_MACRO_PREFIX)) {
          CanonicalPath path = new CanonicalPath(value);
          if (path.isValidDirectory()) {
            MapSequence.fromMap(macros).put(key.substring(PATH_MACRO_PREFIX.length()), path.getValue());
          }
        }
      }
    }
    MapPathMacrosProvider provider = new MapPathMacrosProvider(macros);
    PathMacros.getInstance().addMacrosProvider(provider);
    return provider;
  }



  private Throwable tryToRunTest(Class clazz, String methodName, Object obj) {
    Throwable exception = null;
    try {
      clazz.getMethod(methodName).invoke(obj);
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    } catch (InvocationTargetException e) {
      exception = e.getTargetException();
    }
    return exception;
  }

  protected static Logger LOG = LogManager.getLogger(TransformationTestRunner.class);
}
