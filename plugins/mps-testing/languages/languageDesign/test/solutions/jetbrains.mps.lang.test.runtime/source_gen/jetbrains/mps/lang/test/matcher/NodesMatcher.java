package jetbrains.mps.lang.test.matcher;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;
import java.util.HashSet;
import jetbrains.mps.util.SNodeOperations;
import org.jetbrains.mps.openapi.model.SReference;

public class NodesMatcher {
  public NodesMatcher() {
  }

  public static NodeDifference matchNodes(SNode a, SNode b) {
    ArrayList<SNode> aList = new ArrayList<SNode>();
    aList.add(a);
    ArrayList<SNode> bList = new ArrayList<SNode>();
    bList.add(b);
    ArrayList<NodeDifference> diffs = NodesMatcher.matchNodes(aList, bList);
    if (diffs != null) {
      return diffs.get(0);
    } else {
      return null;
    }
  }

  public static ArrayList<NodeDifference> matchNodes(List<SNode> a, List<SNode> b) {
    HashMap<SNode, SNode> map = new HashMap<SNode, SNode>();
    return NodesMatcher.matchNodes(a, b, map);
  }

  public static ArrayList<NodeDifference> matchNodes(List<SNode> a, List<SNode> b, Map<SNode, SNode> map) {
    Iterator<SNode> iteratorA = a.iterator();
    Iterator<SNode> iteratorB = b.iterator();
    while (iteratorA.hasNext() && iteratorB.hasNext()) {
      NodesMatcher.match(iteratorA.next(), iteratorB.next(), map);
    }
    ArrayList<NodeDifference> ret = null;
    iteratorA = a.iterator();
    iteratorB = b.iterator();
    while (iteratorA.hasNext() && iteratorB.hasNext()) {
      NodeDifference diff = NodesMatcher.matchNodes(iteratorA.next(), iteratorB.next(), map);
      if (diff != null) {
        if (ret == null) {
          ret = new ArrayList<NodeDifference>();
        }
        ret.add(diff);
      }
    }
    return ret;
  }

  private static void match(SNode a, SNode b, Map<SNode, SNode> map) {
    if (!(a.getConcept().getQualifiedName().equals(b.getConcept().getQualifiedName()))) {
      return;
    }
    HashSet<String> roles = new HashSet<String>();
    roles.addAll(SNodeOperations.getChildRoles(a));
    roles.addAll(SNodeOperations.getChildRoles(b));
    for (String role : roles) {
      Iterator<? extends SNode> iterator1 = a.getChildren(role).iterator();
      Iterator<? extends SNode> iterator2 = b.getChildren(role).iterator();
      while (iterator1.hasNext() && iterator2.hasNext()) {
        NodesMatcher.match(iterator1.next(), iterator2.next(), map);
      }
    }
    map.put(a, b);
  }

  public static NodeDifference matchNodes(SNode a, SNode b, Map<SNode, SNode> map) {
    ArrayList<DifferanceItem> difference = new ArrayList<DifferanceItem>();
    if (NodesMatcher.matchConcepts(a, b, difference)) {
      return new NodeDifference(a.getPresentation(), difference);
    }
    NodesMatcher.matchProperties(a, b, difference);
    NodesMatcher.matchChildren(a, b, map, difference);
    NodesMatcher.matchReferences(a, b, map, difference);
    if (difference.size() != 0) {
      return new NodeDifference(a.getPresentation(), difference);
    }
    return null;
  }

  private static boolean matchConcepts(SNode a, SNode b, ArrayList<DifferanceItem> difference) {
    if (!(a.getConcept().getQualifiedName().equals(b.getConcept().getQualifiedName()))) {
      difference.add(new ConceptDifference(a.getConcept().getQualifiedName(), b.getConcept().getQualifiedName()));
      return true;
    }
    return false;
  }

  private static Map<String, SReference> getReferencesMap(SNode node) {
    HashMap<String, SReference> references = new HashMap<String, SReference>();
    for (SReference nextReference : node.getReferences()) {
      references.put(nextReference.getRole(), nextReference);
    }
    return references;
  }

  private static void matchReferences(SNode a, SNode b, Map<SNode, SNode> map, ArrayList<DifferanceItem> difference) {
    Map<String, SReference> references1 = getReferencesMap(a);
    Map<String, SReference> references2 = getReferencesMap(b);

    HashSet<String> roles = new HashSet<String>();
    roles.addAll(references1.keySet());
    roles.addAll(references2.keySet());
    for (String role : roles) {
      SReference reference1 = references1.get(role);
      SNode referenceTarget1 = null;
      if (reference1 != null) {
        referenceTarget1 = reference1.getTargetNode();
      }

      SReference reference2 = references2.get(role);
      SNode referenceTarget2 = null;
      if (reference2 != null) {
        referenceTarget2 = reference2.getTargetNode();
      }

      if (map.containsKey(referenceTarget1)) {
        if (map.get(referenceTarget1) != referenceTarget2) {
          difference.add(new ReferenceDifferense(role, true));
        }
      } else {
        if (referenceTarget1 != referenceTarget2) {
          difference.add(new ReferenceDifferense(role, false));
        }
      }
    }
  }

  private static int countElements(Iterator it) {
    int counter = 0;
    while (it.hasNext()) {
      it.next();
      counter++;
    }
    return counter;
  }

  private static void matchChildren(SNode a, SNode b, Map<SNode, SNode> map, ArrayList<DifferanceItem> difference) {
    HashSet<String> roles = new HashSet<String>();
    roles.addAll(SNodeOperations.getChildRoles(a));
    roles.addAll(SNodeOperations.getChildRoles(b));
    for (String role : roles) {
      Iterable<? extends SNode> children1 = a.getChildren(role);
      Iterable<? extends SNode> children2 = b.getChildren(role);
      int size1 = countElements(children1.iterator());
      int size2 = countElements(children2.iterator());
      if (size1 != size2) {
        difference.add(new ChildrenCountDifference(role, size1, size2));
        continue;
      }

      Iterator<? extends SNode> iterator1 = children1.iterator();
      Iterator<? extends SNode> iterator2 = children2.iterator();
      while (iterator1.hasNext() && iterator2.hasNext()) {
        NodeDifference d = NodesMatcher.matchNodes(iterator1.next(), iterator2.next(), map);
        if (d != null) {
          difference.add(d);
        }
      }
    }
  }

  private static void matchProperties(SNode a, SNode b, ArrayList<DifferanceItem> difference) {
    HashSet<String> propertes = new HashSet<String>();
    Map<String, String> properties1 = SNodeOperations.getProperties(a);
    Map<String, String> properties2 = SNodeOperations.getProperties(b);
    propertes.addAll(properties1.keySet());
    propertes.addAll(properties2.keySet());
    for (String key : propertes) {
      String p1 = properties1.get(key);
      String p2 = properties2.get(key);
      if (p1 == null && "false".equals(p2)) {
        continue;
      }
      if (p2 == null && "false".equals(p1)) {
        continue;
      }
      if (p1 == null || p2 == null || !(p1.equals(p2))) {
        difference.add(new PropertyDifferense(key, p1, p2));
      }
    }
  }
}
