package jetbrains.mps.lang.test.runtime;

/*Generated by MPS */

import com.intellij.ide.DataManager;
import com.intellij.ide.impl.DataManagerImpl;
import jetbrains.mps.openapi.editor.Editor;
import org.jetbrains.mps.openapi.model.SNode;
import javax.swing.SwingUtilities;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SNodePointer;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import junit.framework.Assert;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import java.util.ArrayList;
import com.intellij.openapi.command.impl.UndoManagerImpl;
import com.intellij.openapi.command.undo.UndoManager;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.workbench.nodesFs.MPSNodeVirtualFile;
import jetbrains.mps.workbench.nodesFs.MPSNodesVirtualFileSystem;
import jetbrains.mps.ide.editor.MPSFileNodeEditor;
import java.lang.reflect.InvocationTargetException;
import java.awt.Component;
import jetbrains.mps.intentions.IntentionsManager;
import java.util.Collection;
import jetbrains.mps.util.Pair;
import jetbrains.mps.intentions.IntentionExecutable;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.AnActionEvent;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.ActionPlaces;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public abstract class BaseEditorTestBody extends BaseTestBody {
  private static DataManager DATA_MANAGER = new DataManagerImpl();
  public Editor myEditor;
  private SNode myBefore;
  private SNode myResult;
  protected CellReference myStart;
  protected CellReference myFinish;

  public BaseEditorTestBody() {
  }

  protected Editor initEditor(final String before, final String after) throws Exception {
    if (LOG.isInfoEnabled()) {
      LOG.info("Initializing editor");
    }
    final Exception[] exception = new Exception[1];
    SwingUtilities.invokeAndWait(new Runnable() {
      @Override
      public void run() {
        try {
          BaseEditorTestBody.this.doInitEditor(before, after);
        } catch (Exception e) {
          exception[0] = e;
        }
      }
    });
    if (exception[0] != null) {
      throw exception[0];
    }
    return this.myEditor;
  }

  private void doInitEditor(final String before, final String after) throws Exception {
    this.addNodeById(before);
    if (!(after.equals(""))) {
      this.addNodeById(after);
    }
    myProject.getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        BaseEditorTestBody.this.myBefore = BaseEditorTestBody.this.getNodeById(before);
        BaseEditorTestBody.this.myStart = BaseEditorTestBody.this.findCellReference(BaseEditorTestBody.this.getRealNodeById(before));
        if (BaseEditorTestBody.this.myStart == null) {
          throw new IllegalStateException("Cannot find cell reference in the test case 'before'");
        }
        if (!(after.equals(""))) {
          BaseEditorTestBody.this.myResult = BaseEditorTestBody.this.getNodeById(after);
          BaseEditorTestBody.this.myFinish = BaseEditorTestBody.this.findCellReference(BaseEditorTestBody.this.getRealNodeById(after));
        }
        BaseEditorTestBody.this.myEditor = BaseEditorTestBody.this.openEditor();
        if (BaseEditorTestBody.this.myEditor.getCurrentEditorComponent() instanceof EditorComponent) {
          EditorComponent component = ((EditorComponent) BaseEditorTestBody.this.myEditor.getCurrentEditorComponent());
          component.addNotify();
          component.validate();
        }
        BaseEditorTestBody.this.myStart.setupSelection(BaseEditorTestBody.this.myEditor);
      }
    });
  }

  private CellReference findCellReference(SNode node) {
    List<SNode> annotations = SNodeOperations.getDescendants(node, "jetbrains.mps.lang.test.structure.AnonymousCellAnnotation", false, new String[]{});
    if (ListSequence.fromList(annotations).isEmpty()) {
      return null;
    }
    return new CellReference(this.getNodeById(SNodeOperations.getParent(ListSequence.fromList(annotations).first()).getNodeId().toString()), ListSequence.fromList(annotations).first(), this.myMap);
  }

  protected void checkAssertion() throws Throwable {
    final Wrappers._T<Throwable> throwable = new Wrappers._T<Throwable>(null);
    // <node> 
    ModelAccess.instance().runWriteInEDT(new Runnable() {
      public void run() {
        if (BaseEditorTestBody.this.myResult != null) {
          try {
            SNode editedNode = ((SNodePointer) BaseEditorTestBody.this.myEditor.getCurrentlyEditedNode()).resolve(myProject.getRepository());
            Map<SNode, SNode> map = MapSequence.fromMap(new HashMap<SNode, SNode>());
            Assert.assertEquals(null, NodesMatcher.matchNodes(ListSequence.fromListAndArray(new ArrayList<SNode>(), editedNode), ListSequence.fromListAndArray(new ArrayList<SNode>(), BaseEditorTestBody.this.myResult), (Map) map));
            if (BaseEditorTestBody.this.myFinish != null) {
              BaseEditorTestBody.this.myFinish.assertEditor(BaseEditorTestBody.this.myEditor, map);
            }
          } catch (Throwable t) {
            throwable.value = t;
          }
        }
      }
    });
    ModelAccess.instance().flushEventQueue();
    if (throwable.value != null) {
      throw throwable.value;
    }
  }

  public void testMethod() throws Throwable {
    try {
      this.testMethodImpl();
      this.checkAssertion();
    } finally {
      myProject.getModelAccess().runWriteInEDT(new Runnable() {
        public void run() {
          UndoManagerImpl undoManager = (UndoManagerImpl) UndoManager.getInstance(ProjectHelper.toIdeaProject(myProject));
          MPSNodeVirtualFile file = MPSNodesVirtualFileSystem.getInstance().getFileFor(BaseEditorTestBody.this.myBefore);
          undoManager.clearUndoRedoQueueInTests(file);
        }
      });
    }
  }

  public abstract void testMethodImpl() throws Exception;

  private Editor openEditor() {
    assert ModelAccess.instance().isInEDT();
    MPSNodeVirtualFile file = MPSNodesVirtualFileSystem.getInstance().getFileFor(this.myBefore);
    return new MPSFileNodeEditor(ProjectHelper.toIdeaProject(myProject), file).getNodeEditor();
  }

  protected EditorComponent getEditorComponent() {
    return (EditorComponent) myEditor.getCurrentEditorComponent();
  }

  protected void typeString(final String text) throws InterruptedException, InvocationTargetException {
    new KeyEventsDispatcher(myProject, getEditorComponent()).typeString(text);
  }

  protected void pressKeys(final List<String> keyStrokes) throws InterruptedException, InvocationTargetException {
    new KeyEventsDispatcher(myProject, getEditorComponent()).pressKeys(keyStrokes);
  }

  protected Component processMouseEvent(int x, int y, int eventType) throws InvocationTargetException, InterruptedException {
    return new MouseEventsDispatcher(myProject, getEditorComponent()).processMouseEvent(x, y, eventType);
  }

  protected void processSecondaryMouseEvent(final Component targetComponent, int x, int y, int eventType) throws InvocationTargetException, InterruptedException {
    new MouseEventsDispatcher(myProject, getEditorComponent()).processSecondaryMouseEvent(targetComponent, x, y, eventType);
  }

  protected void invokeIntention(final String name, final SNode node) throws InterruptedException, InvocationTargetException {
    UndoHelper undoHelper = new UndoHelper(myProject, getEditorComponent());
    undoHelper.runUndoableInEDTAndWait(new Runnable() {
      public void run() {
        myProject.getModelAccess().executeCommand(new Runnable() {
          public void run() {
            myEditor.getEditorContext().select(node);
            IntentionsManager.QueryDescriptor query = new IntentionsManager.QueryDescriptor();
            query.setCurrentNodeOnly(true);
            Collection<Pair<IntentionExecutable, SNode>> intentions = IntentionsManager.getInstance().getAvailableIntentions(query, node, myEditor.getEditorContext());
            for (Pair<IntentionExecutable, SNode> intention : intentions) {
              if (intention.o1.getDescriptor().getPersistentStateKey().equals(name)) {
                intention.o1.execute(intention.o2, myEditor.getEditorContext());
              }
            }
          }
        });
      }
    });
  }

  protected void invokeAction(final String actionId) throws InvocationTargetException, InterruptedException {
    UndoHelper undoHelper = new UndoHelper(myProject, getEditorComponent());
    final AnAction action = ActionManager.getInstance().getAction(actionId);
    final AnActionEvent event = ActionUtils.createEvent(ActionPlaces.MAIN_MENU, DATA_MANAGER.getDataContext(getEditorComponent()));
    undoHelper.runUndoableInEDTAndWait(new Runnable() {
      public void run() {
        if (actionId.equals("$Undo")) {
          myEditor.getCurrentEditorComponent().rebuildEditorContent();
        }
        action.actionPerformed(event);
      }
    });
    flushEventQueueAfterAction();
  }

  private static void flushEventQueueAfterAction() throws InvocationTargetException, InterruptedException {
    // flush queue 
    SwingUtilities.invokeAndWait(new Runnable() {
      @Override
      public void run() {
        // empty task 
      }
    });
    ModelAccess.instance().flushEventQueue();

    // some actions (Copy/Paste) are runing one more command later 
    SwingUtilities.invokeAndWait(new Runnable() {
      @Override
      public void run() {
        // empty task 
      }
    });
    ModelAccess.instance().flushEventQueue();
  }
  protected static Logger LOG = LogManager.getLogger(BaseEditorTestBody.class);
}
