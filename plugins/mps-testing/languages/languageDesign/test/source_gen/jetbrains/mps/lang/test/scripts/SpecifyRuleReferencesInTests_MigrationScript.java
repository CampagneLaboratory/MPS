package jetbrains.mps.lang.test.scripts;

/*Generated by MPS */

import jetbrains.mps.lang.script.runtime.BaseMigrationScript;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.lang.script.runtime.AbstractMigrationRefactoring;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.ITypeContextOwner;
import jetbrains.mps.typesystem.inference.DefaultTypecheckingContextOwner;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.typesystem.inference.ITypechecking;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.kernel.model.MissingDependenciesFixer;

public class SpecifyRuleReferencesInTests_MigrationScript extends BaseMigrationScript {
  public SpecifyRuleReferencesInTests_MigrationScript(IOperationContext operationContext) {
    super("Specify rule references in tests for tags 'has error' and 'has warning'");
    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {
      public String getName() {
        return "Specify Rule References";
      }

      public String getAdditionalInfo() {
        return "Specify Rule References";
      }

      public String getFqNameOfConceptToSearchInstances() {
        return "jetbrains.mps.lang.test.structure.NodeRuleCheckOperation";
      }

      public boolean isApplicableInstanceNode(SNode node) {
        return true;
      }

      public void doUpdateInstanceNode(SNode node) {
        ITypeContextOwner owner = new DefaultTypecheckingContextOwner();
        SNode root = SNodeOperations.getContainingRoot(node);
        final SNode nodeToCheck = SNodeOperations.getParent(SNodeOperations.getParent(node));
        final SNode nodeFinalCopy = node;
        TypeContextManager.getInstance().runTypeCheckingAction(owner, root, new ITypechecking.Action() {
          public void run(TypeCheckingContext p0) {
            p0.checkIfNotChecked(nodeToCheck, true);
            IErrorReporter reporter = p0.getTypeMessageDontCheck(nodeToCheck);
            SNodePointer ref = new SNodePointer(reporter.getRuleModel(), reporter.getRuleId());
            SNode message = SNodeOperations.cast(ref.resolve(MPSModuleRepository.getInstance()), "jetbrains.mps.lang.typesystem.structure.MessageStatement");
            if ((AttributeOperations.getAttribute(message, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.lang.typesystem.structure.MessageStatementAnnotation")) == null)) {
              BehaviorReflection.invokeVirtual(Void.class, message, "virtual_attachNewMessageAnnotation_8489045168661849665", new Object[]{});
            }
            SNode msgStatementAnnotation = AttributeOperations.getAttribute(message, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.lang.typesystem.structure.MessageStatementAnnotation"));
            BehaviorReflection.invokeVirtual(Void.class, nodeFinalCopy, "virtual_attachDeclaration_8489045168660953479", new Object[]{msgStatementAnnotation});
            ((SModelBase) SNodeOperations.getModel(nodeFinalCopy)).addModelImport(SNodeOperations.getModel(msgStatementAnnotation).getReference(), false);
            MissingDependenciesFixer.fixDependencies(SNodeOperations.getModel(nodeFinalCopy), true);
          }
        });
      }

      public boolean isShowAsIntention() {
        return true;
      }
    });
  }
}
