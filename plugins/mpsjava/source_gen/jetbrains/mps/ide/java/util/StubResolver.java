package jetbrains.mps.ide.java.util;

/*Generated by MPS */

import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.LanguageID;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.IOperationContext;
import java.util.List;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.search.ISearchScope;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import com.intellij.openapi.util.Computable;
import jetbrains.mps.util.Condition;
import jetbrains.mps.smodel.MissingDependenciesFixer;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.reloading.ClassLoaderManager;
import com.intellij.openapi.progress.EmptyProgressIndicator;

public class StubResolver {
  private static final String JAVA_STUB = SModelStereotype.getStubStereotypeForId(LanguageID.JAVA);
  protected static Log log = LogFactory.getLog(StubResolver.class);

  public StubResolver() {
  }

  public static void resolveInModel(final SModel model, IOperationContext context) {
    List<SReference> toResolve = ListSequence.fromList(new ArrayList<SReference>());
    Map<SModelReference, SModelReference> models = MapSequence.fromMap(new HashMap<SModelReference, SModelReference>());
    for (SNode node : ListSequence.fromList(SModelOperations.getNodes(model, null))) {
      for (SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(node))) {
        SModelReference targetModelRef = ref.getTargetSModelReference();
        if (targetModelRef == null || !(JAVA_STUB.equals(targetModelRef.getStereotype()))) {
          continue;
        }
        // trying to find correspondent nonstub model 
        SModelFqName modelName = new SModelFqName(targetModelRef.getLongName(), null);
        SModelDescriptor modelDescr = SModelRepository.getInstance().getModelDescriptor(modelName);
        if (modelDescr == null) {
          continue;
        }
        MapSequence.fromMap(models).put(targetModelRef, modelDescr.getSModelReference());
        ListSequence.fromList(toResolve).addElement(ref);
      }
    }
    Iterable<SModelReference> modelsToAdd = Sequence.fromIterable(MapSequence.fromMap(models).values()).where(new IWhereFilter<SModelReference>() {
      public boolean accept(SModelReference it) {
        return !(jetbrains.mps.smodel.SModelOperations.getImportedModelUIDs(model).contains(it));
      }
    });
    Sequence.fromIterable(modelsToAdd).visitAll(new IVisitor<SModelReference>() {
      public void visit(SModelReference it) {
        model.addModelImport(it, false);
      }
    });
    final Map<SModelReference, Boolean> modelsUsed = MapSequence.fromMap(new HashMap<SModelReference, Boolean>());

    int cnt = 0;
    int delta = 0;
    do {
      cnt += delta;
      delta = 0;
      for (SReference ref : ListSequence.fromList(toResolve).toGenericArray(SReference.class)) {
        SNode node = ref.getSourceNode();
        final SModelReference modelRef = MapSequence.fromMap(models).get(ref.getTargetSModelReference());
        final String resolveInfo = SLinkOperations.getResolveInfo(ref);
        if (modelRef == null || resolveInfo == null) {
          continue;
        }
        final ISearchScope scope = SNodeOperations.getReferentSearchScope(node, SLinkOperations.getRole(ref), context);
        if (scope == null) {
          continue;
        }
        List<SNode> resolved = TypeContextManager.getInstance().runResolveAction(new Computable<List<SNode>>() {
          public List<SNode> compute() {
            return scope.getNodes(new Condition<SNode>() {
              public boolean met(SNode n) {
                return modelRef.equals(SNodeOperations.getModel(n).getSModelReference()) && resolveInfo.equals(n.getResolveInfo());
              }
            });
          }
        });
        if (ListSequence.fromList(resolved).count() > 1) {
          if (log.isErrorEnabled()) {
            log.error("more than 1 possible resolution for " + SLinkOperations.getResolveInfo(ref));
          }
        }
        if (ListSequence.fromList(resolved).count() > 0) {
          node.setReferent(SLinkOperations.getRole(ref), ListSequence.fromList(resolved).first());
          MapSequence.fromMap(modelsUsed).put(ref.getTargetSModelReference(), true);
          ListSequence.fromList(toResolve).removeElement(ref);
          ++delta;
        }
      }
      if (log.isErrorEnabled()) {
        log.error("delta=" + delta);
      }
    } while (delta > 0);

    Sequence.fromIterable(modelsToAdd).where(new IWhereFilter<SModelReference>() {
      public boolean accept(SModelReference it) {
        return MapSequence.fromMap(modelsUsed).get(it);
      }
    }).visitAll(new IVisitor<SModelReference>() {
      public void visit(SModelReference it) {
        if (log.isWarnEnabled()) {
          log.warn("import of model " + it.getLongName() + " added");
        }
      }
    });
    // <node> 
    Sequence.fromIterable(modelsToAdd).visitAll(new IVisitor<SModelReference>() {
      public void visit(SModelReference it) {
        model.deleteModelImport(it);
      }
    });
    new MissingDependenciesFixer(null, model.getModelDescriptor()).fix(false);

    if (log.isInfoEnabled()) {
      log.info(cnt + " stub references were re-resolved. " + " (" + ListSequence.fromList(toResolve).count() + ")");
    }
  }

  public static void resolveInModels(List<SModelDescriptor> models, IOperationContext context) {
    for (SModelDescriptor model : ListSequence.fromList(models)) {
      if (log.isInfoEnabled()) {
        log.info("resolving " + model.getLongName());
      }
      resolveInModel(model.getSModel(), context);
    }
  }

  public static void resolveInProject(MPSProject project, IOperationContext context) {
    for (IModule module : ListSequence.fromList(project.getModules())) {
      if (module.isPackaged()) {
        continue;
      }
      for (SModelDescriptor model : ListSequence.fromList(module.getOwnModelDescriptors())) {
        if (!(SModelStereotype.isUserModel(model))) {
          continue;
        }
        if (!(model instanceof EditableSModelDescriptor)) {
          continue;
        }

        StubResolver.resolveInModel(model.getSModel(), context);
      }
    }
    ClassLoaderManager.getInstance().reloadAll(new EmptyProgressIndicator());
  }
}
