package jetbrains.mps.ide.java.parser;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SModel;
import java.util.Map;
import jetbrains.mps.baseLanguage.structure.Classifier;
import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
import jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration;
import jetbrains.mps.baseLanguage.structure.Expression;
import org.eclipse.jdt.internal.compiler.ast.Literal;
import org.eclipse.jdt.internal.compiler.impl.Constant;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import jetbrains.mps.baseLanguage.structure.ParenthesizedExpression;
import jetbrains.mps.baseLanguage.structure.Statement;
import jetbrains.mps.baseLanguage.structure.ExpressionStatement;
import jetbrains.mps.smodel.INodeAdapter;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.structure.BooleanConstant;
import jetbrains.mps.baseLanguage.structure.IntegerConstant;
import org.eclipse.jdt.internal.compiler.impl.ByteConstant;
import jetbrains.mps.baseLanguage.structure.CharConstant;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.baseLanguage.structure.FloatingPointConstant;
import org.eclipse.jdt.internal.compiler.impl.DoubleConstant;
import jetbrains.mps.baseLanguage.structure.FloatingPointFloatConstant;
import org.eclipse.jdt.internal.compiler.impl.FloatConstant;
import org.eclipse.jdt.internal.compiler.impl.IntConstant;
import jetbrains.mps.baseLanguage.structure.LongLiteral;
import org.eclipse.jdt.internal.compiler.impl.LongConstant;
import org.eclipse.jdt.internal.compiler.impl.ShortConstant;
import jetbrains.mps.baseLanguage.structure.StringLiteral;
import org.eclipse.jdt.internal.compiler.impl.StringConstant;
import jetbrains.mps.baseLanguage.structure.BinaryOperation;
import org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression;
import jetbrains.mps.baseLanguage.structure.AndExpression;
import org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression;
import jetbrains.mps.baseLanguage.structure.OrExpression;
import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
import jetbrains.mps.baseLanguage.structure.Type;
import jetbrains.mps.baseLanguage.structure.ArrayType;
import jetbrains.mps.baseLanguage.structure.ArrayCreatorWithInitializer;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.baseLanguage.structure.GenericNewExpression;
import jetbrains.mps.baseLanguage.structure.ArrayCreator;
import jetbrains.mps.baseLanguage.structure.DimensionExpression;
import jetbrains.mps.baseLanguage.structure.ArrayLiteral;
import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
import org.eclipse.jdt.internal.compiler.ast.ArrayReference;
import jetbrains.mps.baseLanguage.structure.ArrayAccessExpression;
import org.eclipse.jdt.internal.compiler.ast.Assignment;
import jetbrains.mps.baseLanguage.structure.AssignmentExpression;
import org.eclipse.jdt.internal.compiler.ast.BinaryExpression;
import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
import jetbrains.mps.baseLanguage.structure.ShiftLeftExpression;
import jetbrains.mps.baseLanguage.structure.ShiftRightExpression;
import jetbrains.mps.baseLanguage.structure.PlusExpression;
import jetbrains.mps.baseLanguage.structure.MinusExpression;
import jetbrains.mps.baseLanguage.structure.RemExpression;
import jetbrains.mps.baseLanguage.structure.BitwiseXorExpression;
import jetbrains.mps.baseLanguage.structure.BitwiseAndExpression;
import jetbrains.mps.baseLanguage.structure.MulExpression;
import jetbrains.mps.baseLanguage.structure.BitwiseOrExpression;
import jetbrains.mps.baseLanguage.structure.DivExpression;
import jetbrains.mps.baseLanguage.structure.LessThanOrEqualsExpression;
import jetbrains.mps.baseLanguage.structure.GreaterThanOrEqualsExpression;
import jetbrains.mps.baseLanguage.structure.GreaterThanExpression;
import jetbrains.mps.baseLanguage.structure.LessThanExpression;
import org.eclipse.jdt.internal.compiler.ast.CombinedBinaryExpression;
import org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;
import jetbrains.mps.baseLanguage.structure.BaseAssignmentExpression;
import jetbrains.mps.baseLanguage.structure.PlusAssignmentExpression;
import jetbrains.mps.baseLanguage.structure.MinusAssignmentExpression;
import jetbrains.mps.baseLanguage.structure.MulAssignmentExpression;
import jetbrains.mps.baseLanguage.structure.DivAssignmentExpression;
import jetbrains.mps.baseLanguage.structure.AndAssignmentExpression;
import jetbrains.mps.baseLanguage.structure.OrAssignmentExpression;
import jetbrains.mps.baseLanguage.structure.XorAssignmentExpression;
import jetbrains.mps.baseLanguage.structure.RemAssignmentExpression;
import jetbrains.mps.baseLanguage.structure.LeftShiftAssignmentExpression;
import jetbrains.mps.baseLanguage.structure.RightShiftAssignmentExpression;
import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
import jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression;
import org.eclipse.jdt.internal.compiler.ast.EqualExpression;
import jetbrains.mps.baseLanguage.structure.EqualsExpression;
import jetbrains.mps.baseLanguage.structure.NotEqualsExpression;
import jetbrains.mps.baseLanguage.structure.ConstructorInvocationStatement;
import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
import jetbrains.mps.baseLanguage.structure.SuperConstructorInvocation;
import jetbrains.mps.baseLanguage.structure.ThisConstructorInvocation;
import jetbrains.mps.smodel.SReference;
import org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression;
import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
import org.eclipse.jdt.internal.compiler.ast.PostfixExpression;
import jetbrains.mps.baseLanguage.structure.AbstractUnaryNumberOperation;
import jetbrains.mps.baseLanguage.structure.PostfixDecrementExpression;
import jetbrains.mps.baseLanguage.structure.PostfixIncrementExpression;
import org.eclipse.jdt.internal.compiler.ast.PrefixExpression;
import jetbrains.mps.baseLanguage.structure.PrefixDecrementExpression;
import jetbrains.mps.baseLanguage.structure.PrefixIncrementExpression;
import org.eclipse.jdt.internal.compiler.ast.CastExpression;
import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
import org.eclipse.jdt.internal.compiler.ast.SuperReference;
import org.eclipse.jdt.internal.compiler.ast.ThisReference;
import jetbrains.mps.baseLanguage.structure.ThisExpression;
import org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;
import jetbrains.mps.baseLanguage.structure.AnnotationInstance;
import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
import jetbrains.mps.baseLanguage.structure.AnnotationInstanceValue;
import jetbrains.mps.smodel.SNode;
import org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;
import org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;
import jetbrains.mps.baseLanguage.structure.ImplicitAnnotationInstanceValue;
import org.eclipse.jdt.internal.compiler.ast.Annotation;
import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;
import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
import org.eclipse.jdt.internal.compiler.ast.FieldReference;
import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
import org.eclipse.jdt.internal.compiler.lookup.ParameterizedFieldBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;
import jetbrains.mps.baseLanguage.structure.StaticFieldReference;
import jetbrains.mps.baseLanguage.structure.VariableReference;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.BaseAdapter;
import jetbrains.mps.baseLanguage.structure.EnumClass;
import jetbrains.mps.baseLanguage.structure.EnumConstantReference;
import jetbrains.mps.baseLanguage.structure.LocalStaticFieldReference;
import jetbrains.mps.baseLanguage.structure.LocalInstanceFieldReference;
import jetbrains.mps.baseLanguage.structure.FieldReferenceOperation;
import jetbrains.mps.baseLanguage.structure.DotExpression;
import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.NestedTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding;
import jetbrains.mps.baseLanguage.structure.EnumValuesExpression;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import jetbrains.mps.baseLanguage.structure.EnumValueOfExpression;
import jetbrains.mps.baseLanguage.structure.IMethodCall;
import jetbrains.mps.baseLanguage.structure.StaticMethodCall;
import org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference;
import jetbrains.mps.baseLanguage.structure.SuperMethodCall;
import jetbrains.mps.baseLanguage.structure.LocalInstanceMethodCall;
import jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation;
import jetbrains.mps.baseLanguage.structure.BaseMethodCall;
import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import jetbrains.mps.baseLanguage.structure.ClassCreator;
import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
import jetbrains.mps.baseLanguage.structure.AbstractCreator;
import jetbrains.mps.baseLanguage.structure.AnonymousClassCreator;
import jetbrains.mps.baseLanguage.structure.AnonymousClass;
import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
import jetbrains.mps.baseLanguage.structure.ClassifierClassExpression;
import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
import jetbrains.mps.baseLanguage.structure.PrimitiveClassExpression;
import jetbrains.mps.baseLanguage.structure.PrimitiveType;
import org.eclipse.jdt.internal.compiler.ast.UnaryExpression;
import jetbrains.mps.baseLanguage.structure.UnaryMinus;
import jetbrains.mps.baseLanguage.structure.NotExpression;
import jetbrains.mps.baseLanguage.structure.BitwiseNotExpression;
import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
import org.eclipse.jdt.internal.compiler.lookup.Binding;
import jetbrains.mps.baseLanguage.structure.UnresolvedNameReference;
import jetbrains.mps.baseLanguage.structure.VariableDeclaration;
import jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration;
import jetbrains.mps.baseLanguage.structure.LocalVariableReference;
import jetbrains.mps.baseLanguage.structure.ParameterDeclaration;
import jetbrains.mps.baseLanguage.structure.ParameterReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
import jetbrains.mps.baseLanguage.structure.ArrayLengthOperation;
import org.eclipse.jdt.internal.compiler.ast.AssertStatement;
import jetbrains.mps.baseLanguage.structure.BlockStatement;
import org.eclipse.jdt.internal.compiler.ast.Block;
import jetbrains.mps.baseLanguage.structure.StatementList;
import org.eclipse.jdt.internal.compiler.ast.BreakStatement;
import jetbrains.mps.baseLanguage.structure.SwitchCase;
import org.eclipse.jdt.internal.compiler.ast.CaseStatement;
import org.eclipse.jdt.internal.compiler.ast.ContinueStatement;
import org.eclipse.jdt.internal.compiler.ast.DoStatement;
import jetbrains.mps.baseLanguage.structure.DoWhileStatement;
import org.eclipse.jdt.internal.compiler.ast.EmptyStatement;
import jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement;
import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ReturnStatement;
import org.eclipse.jdt.internal.compiler.ast.ForeachStatement;
import org.eclipse.jdt.internal.compiler.ast.ForStatement;
import jetbrains.mps.baseLanguage.structure.AdditionalForLoopVariable;
import org.eclipse.jdt.internal.compiler.ast.IfStatement;
import org.eclipse.jdt.internal.compiler.ast.LabeledStatement;
import jetbrains.mps.baseLanguage.structure.AbstractLoopStatement;
import jetbrains.mps.baseLanguage.structure.SwitchStatement;
import org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;
import org.eclipse.jdt.internal.compiler.ast.ThrowStatement;
import org.eclipse.jdt.internal.compiler.ast.TryStatement;
import jetbrains.mps.baseLanguage.structure.CatchClause;
import jetbrains.mps.baseLanguage.structure.TryCatchStatement;
import org.eclipse.jdt.internal.compiler.ast.WhileStatement;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Initializer;
import jetbrains.mps.baseLanguage.structure.ClassConcept;
import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
import jetbrains.mps.baseLanguage.structure.ClassifierType;
import org.eclipse.jdt.internal.compiler.ast.Argument;
import jetbrains.mps.baseLanguage.structure.StaticInitializer;
import jetbrains.mps.baseLanguage.structure.InstanceInitializer;
import jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration;
import jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration;
import jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
import jetbrains.mps.baseLanguage.structure.HasAnnotation;

public class JavaConverterTreeBuilder {
  private static final Logger LOG = Logger.getLogger(JavaConverterTreeBuilder.class);

  private SModel myCurrentModel;
  private Map<String, SModel> myModelMap;
  private boolean myIsolated = false;
  private Classifier myCurrentClass;
  private TypeDeclaration myCurrentTypeDeclaration;
  private BaseMethodDeclaration myCurrentMethod;
  private TypesProvider myTypesProvider;

  public JavaConverterTreeBuilder() {
  }

  public Expression processExpressionRefl(org.eclipse.jdt.internal.compiler.ast.Expression expression) {
    Expression result = null;
    if (expression instanceof Literal && expression.constant != null && expression.constant != Constant.NotAConstant) {
      result = (Expression) dispatchRefl("processConstant", expression.constant);
    }
    if (result == null) {
      result = (Expression) dispatchRefl("processExpression", expression);
    }
    if (expression != null) {
      int parenthesisCount = (expression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;
      for (int parenthsCreated = 0; parenthsCreated < parenthesisCount; parenthsCreated++) {
        ParenthesizedExpression parenthesizedExpression = ParenthesizedExpression.newInstance(myCurrentModel);
        parenthesizedExpression.setExpression(result);
        result = parenthesizedExpression;
      }
    }
    return result;
  }

  public Statement processStatementRefl(org.eclipse.jdt.internal.compiler.ast.Statement x) {
    Statement statement;
    if (x instanceof org.eclipse.jdt.internal.compiler.ast.Expression) {
      Expression expr = processExpressionRefl((org.eclipse.jdt.internal.compiler.ast.Expression) x);
      if (expr == null) {
        return null;
      }
      ExpressionStatement expressionStatement = ExpressionStatement.newInstance(myCurrentModel);
      expressionStatement.setExpression(expr);
      statement = expressionStatement;
    } else {
      statement = (Statement) dispatchRefl("processStatement", x);
    }
    return statement;
  }

  protected INodeAdapter dispatchRefl(String name, Object child) {
    if (child == null) {
      return null;
    }
    try {
      Method method = getClass().getDeclaredMethod(name, child.getClass());
      return (INodeAdapter) method.invoke(this, child);
    } catch (Throwable e) {
      if (e instanceof InvocationTargetException) {
        e = ((InvocationTargetException) e).getTargetException();
      }
      throw new JavaConverterException(e);
    }
  }

  /*package*/ List<ExpressionStatement> processExpressionStatements(org.eclipse.jdt.internal.compiler.ast.Statement[] statements) {
    List<ExpressionStatement> expressionStatements = new ArrayList<ExpressionStatement>();
    if (statements != null) {
      for (int i = 0, n = statements.length; i < n; ++i) {
        Statement statement = processStatementRefl(statements[i]);
        if (statement != null) {
          expressionStatements.add((ExpressionStatement) statement);
        }
      }
    }
    return expressionStatements;
  }

  /*package*/ BooleanConstant processConstant(org.eclipse.jdt.internal.compiler.impl.BooleanConstant x) {
    BooleanConstant result = BooleanConstant.newInstance(myCurrentModel);
    result.setValue(x.booleanValue());
    return result;
  }

  /*package*/ IntegerConstant processConstant(ByteConstant x) {
    IntegerConstant result = IntegerConstant.newInstance(myCurrentModel);
    result.setValue(x.byteValue());
    return result;
  }

  /*package*/ CharConstant processConstant(org.eclipse.jdt.internal.compiler.impl.CharConstant x) {
    CharConstant result = CharConstant.newInstance(myCurrentModel);
    String value = NameUtil.escapeChar(x.charValue());
    result.setCharConstant(value);
    return result;
  }

  /*package*/ FloatingPointConstant processConstant(DoubleConstant x) {
    FloatingPointConstant result = FloatingPointConstant.newInstance(myCurrentModel);
    result.setValue(x.doubleValue() + "");
    return result;
  }

  /*package*/ FloatingPointFloatConstant processConstant(FloatConstant x) {
    FloatingPointFloatConstant result = FloatingPointFloatConstant.newInstance(myCurrentModel);
    result.setValue(x.floatValue() + "f");
    return result;
  }

  /*package*/ IntegerConstant processConstant(IntConstant x) {
    IntegerConstant result = IntegerConstant.newInstance(myCurrentModel);
    result.setValue(x.intValue());
    return result;
  }

  /*package*/ LongLiteral processConstant(LongConstant x) {
    LongLiteral result = LongLiteral.newInstance(myCurrentModel);
    result.setValue(x.longValue() + "L");
    return result;
  }

  /*package*/ IntegerConstant processConstant(ShortConstant x) {
    IntegerConstant result = IntegerConstant.newInstance(myCurrentModel);
    result.setValue(x.shortValue());
    return result;
  }

  /*package*/ StringLiteral processConstant(StringConstant x) {
    StringLiteral result = StringLiteral.newInstance(myCurrentModel);
    result.setValue(NameUtil.escapeString(x.stringValue()));
    return result;
  }

  /*package*/ BinaryOperation processBinaryOperation(org.eclipse.jdt.internal.compiler.ast.Expression left, org.eclipse.jdt.internal.compiler.ast.Expression right, BinaryOperation binaryOperation) {
    binaryOperation.setLeftExpression(processExpressionRefl(left));
    binaryOperation.setRightExpression(processExpressionRefl(right));
    return binaryOperation;
  }

  /*package*/ Expression processExpression(AND_AND_Expression x) {
    AndExpression andExpression = AndExpression.newInstance(myCurrentModel);
    return processBinaryOperation(x.left, x.right, andExpression);
  }

  /*package*/ Expression processExpression(OR_OR_Expression x) {
    OrExpression orExpression = OrExpression.newInstance(myCurrentModel);
    return processBinaryOperation(x.left, x.right, orExpression);
  }

  /*package*/ Expression processExpression(ArrayAllocationExpression x) {
    Type type = createType(x.resolvedType);
    if (!((type instanceof ArrayType))) {
      throw new JavaConverterException("a type of array allocation should be an array type");
    }
    ArrayType arrayType = (ArrayType) type;
    if (x.initializer != null) {
      List<Expression> initializers = new ArrayList<Expression>();
      if (x.initializer.expressions != null) {
        for (org.eclipse.jdt.internal.compiler.ast.Expression expression : x.initializer.expressions) {
          initializers.add(processExpressionRefl(expression));
        }
      }
      ArrayCreatorWithInitializer arrayCreator = ArrayCreatorWithInitializer.newInstance(myCurrentModel);
      for (Expression initializer : initializers) {
        arrayCreator.addInitValue(initializer);
      }
      arrayCreator.setComponentType(CopyUtil.copy(arrayType.getComponentType()));
      GenericNewExpression genericNewExpression = GenericNewExpression.newInstance(myCurrentModel);
      genericNewExpression.setCreator(arrayCreator);
      return genericNewExpression;
    } else {
      List<Expression> dims = new ArrayList<Expression>();
      for (org.eclipse.jdt.internal.compiler.ast.Expression dimension : x.dimensions) {
        if (dimension == null) {
          dims.add(null);
        } else {
          dims.add(processExpressionRefl(dimension));
        }
      }
      ArrayCreator arrayCreator = ArrayCreator.newInstance(myCurrentModel);
      for (Expression dim : dims) {
        DimensionExpression dimensionExpression = DimensionExpression.newInstance(myCurrentModel);
        arrayCreator.addDimensionExpression(dimensionExpression);
        if (dim != null) {
          dimensionExpression.setExpression(dim);
        }
      }
      Type deepestComponentType = arrayType.getComponentType();
      while (deepestComponentType instanceof ArrayType) {
        deepestComponentType = ((ArrayType) deepestComponentType).getComponentType();
      }
      arrayCreator.setComponentType(CopyUtil.copy(deepestComponentType));
      GenericNewExpression genericNewExpression = GenericNewExpression.newInstance(myCurrentModel);
      genericNewExpression.setCreator(arrayCreator);
      return genericNewExpression;
    }
  }

  /*package*/ ArrayLiteral processExpression(ArrayInitializer x) {
    List<Expression> initializers = new ArrayList<Expression>();
    if (x.expressions != null) {
      for (org.eclipse.jdt.internal.compiler.ast.Expression expression : x.expressions) {
        initializers.add(processExpressionRefl(expression));
      }
    }
    ArrayLiteral arrayLiteral = ArrayLiteral.newInstance(myCurrentModel);
    for (Expression initializer : initializers) {
      arrayLiteral.addItem(initializer);
    }
    return arrayLiteral;
  }

  /*package*/ Expression processExpression(ArrayReference x) {
    ArrayAccessExpression accessExpression = ArrayAccessExpression.newInstance(myCurrentModel);
    accessExpression.setArray(processExpressionRefl(x.receiver));
    accessExpression.setIndex(processExpressionRefl(x.position));
    return accessExpression;
  }

  /*package*/ Expression processExpression(Assignment x) {
    AssignmentExpression assignmentExpression = AssignmentExpression.newInstance(myCurrentModel);
    assignmentExpression.setLValue(processExpressionRefl(x.lhs));
    assignmentExpression.setRValue(processExpressionRefl(x.expression));
    return assignmentExpression;
  }

  /*package*/ Expression processExpression(BinaryExpression x) {
    BinaryOperation op;
    int binOp = (x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT;
    switch (binOp) {
      case OperatorIds.LEFT_SHIFT:
        op = ShiftLeftExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.RIGHT_SHIFT:
        op = ShiftRightExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.PLUS:
        op = PlusExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.MINUS:
        op = MinusExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.REMAINDER:
        op = RemExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.XOR:
        op = BitwiseXorExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.AND:
        op = BitwiseAndExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.MULTIPLY:
        op = MulExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.OR:
        op = BitwiseOrExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.DIVIDE:
        op = DivExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.LESS_EQUAL:
        op = LessThanOrEqualsExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.GREATER_EQUAL:
        op = GreaterThanOrEqualsExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.GREATER:
        op = GreaterThanExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.LESS:
        op = LessThanExpression.newInstance(myCurrentModel);
        break;
      default:
        throw new JavaConverterException("Unsupported operator for BinaryExpression");
    }
    return processBinaryOperation(x.left, x.right, op);
  }

  /*package*/ Expression processExpression(CombinedBinaryExpression x) {
    return processExpression((BinaryExpression) x);
  }

  /*package*/ Expression processExpression(CompoundAssignment x) {
    BaseAssignmentExpression op;
    switch (x.operator) {
      case OperatorIds.PLUS:
        op = PlusAssignmentExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.MINUS:
        op = MinusAssignmentExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.MULTIPLY:
        op = MulAssignmentExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.DIVIDE:
        op = DivAssignmentExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.AND:
        op = AndAssignmentExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.OR:
        op = OrAssignmentExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.XOR:
        op = XorAssignmentExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.REMAINDER:
        op = RemAssignmentExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.LEFT_SHIFT:
        op = LeftShiftAssignmentExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.RIGHT_SHIFT:
        op = RightShiftAssignmentExpression.newInstance(myCurrentModel);
        break;
      default:
        throw new JavaConverterException("Unsupported operator for CompoundAssignment");
    }
    op.setLValue(processExpressionRefl(x.lhs));
    op.setRValue(processExpressionRefl(x.expression));
    return op;
  }

  /*package*/ Expression processExpression(ConditionalExpression x) {
    Expression ifTest = processExpressionRefl(x.condition);
    Expression thenExpr = processExpressionRefl(x.valueIfTrue);
    Expression elseExpr = processExpressionRefl(x.valueIfFalse);
    TernaryOperatorExpression tOp = TernaryOperatorExpression.newInstance(myCurrentModel);
    tOp.setCondition(ifTest);
    tOp.setIfTrue(thenExpr);
    tOp.setIfFalse(elseExpr);
    return tOp;
  }

  /*package*/ Expression processExpression(EqualExpression x) {
    BinaryOperation op;
    switch ((x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) {
      case OperatorIds.EQUAL_EQUAL:
        op = EqualsExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.NOT_EQUAL:
        op = NotEqualsExpression.newInstance(myCurrentModel);
        break;
      default:
        throw new JavaConverterException("Unexpected operator for EqualExpression");
    }
    return processBinaryOperation(x.left, x.right, op);
  }

  /*package*/ ConstructorInvocationStatement processExpression(ExplicitConstructorCall x) {
    if (x.isImplicitSuper()) {
      return null;
    }
    ConstructorInvocationStatement result = (x.isSuperAccess() ?
      SuperConstructorInvocation.newInstance(myCurrentModel) :
      ThisConstructorInvocation.newInstance(myCurrentModel)
    );
    addCallArgs(x.arguments, result);
    SReference methodReference = myTypesProvider.createMethodReference(x.binding, ConstructorInvocationStatement.BASE_METHOD_DECLARATION, result.getNode());
    if (methodReference != null) {
      result.getNode().addReference(methodReference);
    }
    return result;
  }

  /*package*/ Expression processExpression(InstanceOfExpression x) {
    Expression expr = processExpressionRefl(x.expression);
    Type testType = createType(x.type.resolvedType);
    jetbrains.mps.baseLanguage.structure.InstanceOfExpression instanceOfExpression = jetbrains.mps.baseLanguage.structure.InstanceOfExpression.newInstance(myCurrentModel);
    instanceOfExpression.setLeftExpression(expr);
    instanceOfExpression.setClassType(testType);
    return instanceOfExpression;
  }

  private Type createType(TypeBinding binding) {
    return myTypesProvider.createType(binding);
  }

  /*package*/ Expression processExpression(PostfixExpression x) {
    AbstractUnaryNumberOperation op;
    switch (x.operator) {
      case OperatorIds.MINUS:
        op = PostfixDecrementExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.PLUS:
        op = PostfixIncrementExpression.newInstance(myCurrentModel);
        break;
      default:
        throw new JavaConverterException("Unexpected postfix operator");
    }
    op.setExpression(processExpressionRefl(x.lhs));
    return op;
  }

  /*package*/ Expression processExpression(PrefixExpression x) {
    AbstractUnaryNumberOperation op;
    switch (x.operator) {
      case OperatorIds.MINUS:
        op = PrefixDecrementExpression.newInstance(myCurrentModel);
        break;
      case OperatorIds.PLUS:
        op = PrefixIncrementExpression.newInstance(myCurrentModel);
        break;
      default:
        throw new JavaConverterException("Unexpected prefix operator");
    }
    op.setExpression(processExpressionRefl(x.lhs));
    return op;
  }

  /*package*/ Expression processExpression(CastExpression x) {
    jetbrains.mps.baseLanguage.structure.CastExpression result = jetbrains.mps.baseLanguage.structure.CastExpression.newInstance(myCurrentModel);
    result.setExpression(processExpressionRefl(x.expression));
    if (x.type instanceof org.eclipse.jdt.internal.compiler.ast.Expression) {
      result.setType(createType(((org.eclipse.jdt.internal.compiler.ast.Expression) x.type).resolvedType));
    }
    return result;
  }

  /*package*/ Expression processExpression(NullLiteral x) {
    return jetbrains.mps.baseLanguage.structure.NullLiteral.newInstance(myCurrentModel);
  }

  /*package*/ Expression processExpression(SuperReference x) {
    throw new JavaConverterException("we have no super-references; this case should be analyzed as method call");
  }

  /*package*/ Expression processExpression(ThisReference x) {
    return ThisExpression.newInstance(myCurrentModel);
  }

  /*package*/ Expression processExpression(NormalAnnotation x) {
    AnnotationInstance annotationInstance = prepareAnnotationInstance(x);
    MemberValuePair[] pairs = x.memberValuePairs();
    if (pairs != null) {
      for (MemberValuePair pair : pairs) {
        AnnotationInstanceValue value = AnnotationInstanceValue.newInstance(myCurrentModel);
        value.setValue(processExpressionRefl(pair.value));
        SNode valueNode = value.getNode();
        if (pair.binding == null) {
          valueNode.addReference(myTypesProvider.createErrorReference(AnnotationInstanceValue.KEY, new String(pair.name), valueNode));
        } else {
          valueNode.addReference(myTypesProvider.createMethodReference(pair.binding, AnnotationInstanceValue.KEY, valueNode));
        }
        annotationInstance.addValue(value);
      }
    }
    return annotationInstance;
  }

  /*package*/ Expression processExpression(MarkerAnnotation x) {
    return prepareAnnotationInstance(x);
  }

  /*package*/ Expression processExpression(SingleMemberAnnotation x) {
    AnnotationInstance annotationInstance = prepareAnnotationInstance(x);
    ImplicitAnnotationInstanceValue value = ImplicitAnnotationInstanceValue.newInstance(myCurrentModel);
    MemberValuePair[] pairs = x.memberValuePairs();
    if (pairs != null) {
      MemberValuePair pair = pairs[0];
      value.setValue(processExpressionRefl(pair.value));
      SNode valueNode = value.getNode();
      if (pair.binding == null) {
        valueNode.addReference(myTypesProvider.createErrorReference(AnnotationInstanceValue.KEY, new String(pair.name), valueNode));
      } else {
        valueNode.addReference(myTypesProvider.createMethodReference(pair.binding, AnnotationInstanceValue.KEY, valueNode));
      }
      annotationInstance.addValue(value);
    }
    return annotationInstance;
  }

  /*package*/ AnnotationInstance prepareAnnotationInstance(Annotation annotation) {
    AnnotationInstance annotationInstance = AnnotationInstance.newInstance(myCurrentModel);
    SNode sourceNode = annotationInstance.getNode();
    AnnotationBinding annotationBinding = annotation.getCompilerAnnotation();
    SReference classifierReference;
    if (annotationBinding == null) {
      TypeReference type = annotation.type;
      classifierReference = myTypesProvider.createErrorClassifierReference(AnnotationInstance.ANNOTATION, type.resolvedType, sourceNode);
    } else {
      classifierReference = myTypesProvider.createClassifierReference(annotationBinding.getAnnotationType(), AnnotationInstance.ANNOTATION, sourceNode);
    }
    if (classifierReference != null) {
      sourceNode.addReference(classifierReference);
    }
    return annotationInstance;
  }

  /*package*/ Expression processExpression(QualifiedThisReference x) {
    ThisExpression thisRef = ThisExpression.newInstance(myCurrentModel);
    TypeBinding typeBinding = x.qualification.resolvedType;
    thisRef.getNode().addReference(myTypesProvider.createClassifierReference((ReferenceBinding) typeBinding, ThisExpression.CLASS_CONCEPT, thisRef.getNode()));
    return thisRef;
  }

  /*package*/ Expression processExpression(FieldReference x) {
    FieldBinding fieldBinding = x.binding;
    return expressionFromFieldBinding(fieldBinding, processExpressionRefl(x.receiver));
  }

  private ReferenceBinding getDeclaredClassBinding(FieldBinding fieldBinding) {
    if (fieldBinding instanceof ParameterizedFieldBinding) {
      return ((ParameterizedFieldBinding) fieldBinding).originalField.declaringClass;
    } else {
      return fieldBinding.declaringClass;
    }
  }

  private Expression fieldReferenceFromProblem(ProblemBinding binding, String firstName, String secondName) {
    StaticFieldReference sfr = StaticFieldReference.newInstance(myCurrentModel);
    SNode sourceNode = sfr.getNode();
    sourceNode.addReference(myTypesProvider.createErrorReference(StaticFieldReference.CLASSIFIER, firstName, sourceNode));
    sourceNode.addReference(myTypesProvider.createErrorReference(VariableReference.VARIABLE_DECLARATION, secondName, sourceNode));
    return sfr;
  }

  private Expression expressionFromFieldBinding(FieldBinding fieldBinding, Expression instanceExpression) {
    String role;
    SNode sourceNode;
    Expression result;
    ReferenceBinding declaredClassBinding = getDeclaredClassBinding(fieldBinding);
    if (fieldBinding.isStatic()) {
      SNodePointer classifierPointer = myTypesProvider.createClassifierPointer(declaredClassBinding);
      if (BaseAdapter.isInstance(classifierPointer.getNode(), EnumClass.class)) {
        EnumConstantReference enumConstantReference = EnumConstantReference.newInstance(myCurrentModel);
        role = EnumConstantReference.ENUM_CONSTANT_DECLARATION;
        sourceNode = enumConstantReference.getNode();
        enumConstantReference.getNode().addReference(SReference.create(EnumConstantReference.ENUM_CLASS, sourceNode, classifierPointer));
        result = enumConstantReference;
      } else
      if (myCurrentClass == myTypesProvider.getRaw(declaredClassBinding)) {
        role = VariableReference.VARIABLE_DECLARATION;
        LocalStaticFieldReference lsfr = LocalStaticFieldReference.newInstance(myCurrentModel);
        sourceNode = lsfr.getNode();
        result = lsfr;
      } else {
        StaticFieldReference sfr = StaticFieldReference.newInstance(myCurrentModel);
        sourceNode = sfr.getNode();
        role = VariableReference.VARIABLE_DECLARATION;
        sfr.getNode().addReference(SReference.create(StaticFieldReference.CLASSIFIER, sourceNode, classifierPointer));
        result = sfr;
      }
    } else {
      if (instanceExpression == null) {
        role = VariableReference.VARIABLE_DECLARATION;
        LocalInstanceFieldReference lifr = LocalInstanceFieldReference.newInstance(myCurrentModel);
        sourceNode = lifr.getNode();
        result = lifr;
      } else {
        role = FieldReferenceOperation.FIELD_DECLARATION;
        Expression instance;
        instance = instanceExpression;
        if (declaredClassBinding == null) {
          return createArrayLengthExpression(instance, fieldBinding);
        }
        FieldReferenceOperation fieldRef = FieldReferenceOperation.newInstance(myCurrentModel);
        DotExpression dotExpression = DotExpression.newInstance(myCurrentModel);
        dotExpression.setOperation(fieldRef);
        dotExpression.setOperand(instance);
        sourceNode = fieldRef.getNode();
        result = dotExpression;
      }
    }
    SReference fieldReference = myTypesProvider.createFieldReference(fieldBinding, role, sourceNode);
    sourceNode.addReference(fieldReference);
    return result;
  }

  private boolean isSubtype(ReferenceBinding subtype, TypeBinding supertype) {
    if (subtype instanceof ParameterizedTypeBinding) {
      subtype = ((ParameterizedTypeBinding) subtype).genericType();
    }
    if (supertype == subtype) {
      return true;
    }
    if (subtype.superclass() != null) {
      if (isSubtype(subtype.superclass(), supertype)) {
        return true;
      }
    }
    if (subtype.superInterfaces() != null) {
      for (ReferenceBinding infc : subtype.superInterfaces()) {
        if (isSubtype(infc, supertype)) {
          return true;
        }
      }
    }
    return false;
  }

  private ThisExpression createThisExpression(MethodBinding binding, org.eclipse.jdt.internal.compiler.ast.Expression receiver) {
    ReferenceBinding methodDeclaringClass = binding.declaringClass;
    SourceTypeBinding currentClass = myCurrentTypeDeclaration.binding;
    ThisExpression thisExpression = ThisExpression.newInstance(myCurrentModel);
    if (currentClass == methodDeclaringClass) {
      return thisExpression;
    }
    if (isSubtype(currentClass, methodDeclaringClass)) {
      return thisExpression;
    }
    while (!(currentClass.isStatic()) && currentClass.isNestedType()) {
      currentClass = ((NestedTypeBinding) currentClass).enclosingType;
      if (isSubtype(currentClass, methodDeclaringClass)) {
        break;
      }
    }
    thisExpression.getNode().addReference(myTypesProvider.createClassifierReference((ReferenceBinding) currentClass, ThisExpression.CLASS_CONCEPT, thisExpression.getNode()));
    return thisExpression;
  }

  /*package*/ Expression processValuesExpression(SyntheticMethodBinding binding) {
    EnumValuesExpression expression = EnumValuesExpression.newInstance(myCurrentModel);
    SReference classifierReference = myTypesProvider.createClassifierReference(binding.declaringClass, EnumValuesExpression.ENUM_CLASS, expression.getNode());
    expression.getNode().addReference(classifierReference);
    return expression;
  }

  /*package*/ Expression processValueOfExpression(SyntheticMethodBinding binding, MessageSend x) {
    EnumValueOfExpression expression = EnumValueOfExpression.newInstance(myCurrentModel);
    SReference classifierReference = myTypesProvider.createClassifierReference(binding.declaringClass, EnumValueOfExpression.ENUM_CLASS, expression.getNode());
    expression.getNode().addReference(classifierReference);
    if (x.arguments != null) {
      expression.setValue(processExpressionRefl(x.arguments[0]));
    }
    return expression;
  }

  /*package*/ Expression processExpression(MessageSend x) {
    if (x.binding instanceof SyntheticMethodBinding) {
      SyntheticMethodBinding syntheticMethodBinding = (SyntheticMethodBinding) x.binding;
      if (syntheticMethodBinding.purpose == SyntheticMethodBinding.EnumValues) {
        return processValuesExpression(syntheticMethodBinding);
      }
      if (syntheticMethodBinding.purpose == SyntheticMethodBinding.EnumValueOf) {
        return processValueOfExpression(syntheticMethodBinding, x);
      }
    }
    IMethodCall methodCall = null;
    Expression result;
    if (x.binding != null && x.binding.isStatic()) {
      StaticMethodCall smc = StaticMethodCall.newInstance(myCurrentModel);
      methodCall = smc;
      result = smc;
      SReference classifierReference = myTypesProvider.createClassifierReference(x.binding.declaringClass, StaticMethodCall.CLASS_CONCEPT, smc.getNode());
      smc.getNode().addReference(classifierReference);
    } else
    if (x.receiver instanceof SuperReference || x.receiver instanceof QualifiedSuperReference) {
      SuperMethodCall smc = SuperMethodCall.newInstance(myCurrentModel);
      methodCall = smc;
      result = smc;
    } else {
      if (x.receiver instanceof ThisReference && x.receiver.isImplicitThis()) {
        LocalInstanceMethodCall limc = LocalInstanceMethodCall.newInstance(myCurrentModel);
        methodCall = limc;
        result = limc;
      } else {
        Expression qualifier;
        InstanceMethodCallOperation imco = InstanceMethodCallOperation.newInstance(myCurrentModel);
        methodCall = imco;
        qualifier = processExpressionRefl(x.receiver);
        DotExpression dotExpression = DotExpression.newInstance(myCurrentModel);
        dotExpression.setOperand(qualifier);
        dotExpression.setOperation(imco);
        result = dotExpression;
      }
    }
    SReference methodReference;
    if (x.binding == null) {
      methodReference = myTypesProvider.createErrorReference(BaseMethodCall.BASE_METHOD_DECLARATION, new String(x.selector), methodCall.getNode());
    } else
    if (x.binding instanceof ProblemMethodBinding) {
      ProblemMethodBinding problemMethodBinding = (ProblemMethodBinding) x.binding;
      methodReference = myTypesProvider.createErrorReference(BaseMethodCall.BASE_METHOD_DECLARATION, new String(problemMethodBinding.selector), methodCall.getNode());
    } else {
      methodReference = myTypesProvider.createMethodReference(x.binding, BaseMethodCall.BASE_METHOD_DECLARATION, methodCall.getNode());
    }
    if (methodReference != null) {
      methodCall.getNode().addReference(methodReference);
    }
    addMethodTypeArgs(x.typeArguments, methodCall);
    addCallArgs(x.arguments, methodCall);
    return result;
  }

  /*package*/ Expression processExpression(AllocationExpression x) {
    MethodBinding b = x.binding;
    ClassCreator classCreator = ClassCreator.newInstance(myCurrentModel);
    SReference methodReference = myTypesProvider.createMethodReference(b, ClassCreator.BASE_METHOD_DECLARATION, classCreator.getNode());
    if (methodReference != null) {
      classCreator.getNode().addReference(methodReference);
    }
    if (x.enumConstant != null) {
      throw new JavaConverterException("unexpected enum constant creation");
    }
    if (x.resolvedType instanceof ParameterizedTypeBinding) {
      ParameterizedTypeBinding ptb = (ParameterizedTypeBinding) x.resolvedType;
      TypeBinding[] typeArguments = ptb.arguments;
      if (typeArguments != null) {
        for (TypeBinding typeBinding : typeArguments) {
          classCreator.addTypeParameter(createType(typeBinding));
        }
      }
    }
    addMethodTypeArgs(x.typeArguments, classCreator);
    addCallArgs(x.arguments, classCreator);
    GenericNewExpression result = GenericNewExpression.newInstance(myCurrentModel);
    result.setCreator(classCreator);
    return result;
  }

  /*package*/ Expression processExpression(QualifiedAllocationExpression x) {
    MethodBinding b = x.binding;
    AbstractCreator creator = null;
    if (x.anonymousType != null) {
      AnonymousClassCreator anonymousClassCreator = AnonymousClassCreator.newInstance(myCurrentModel);
      creator = anonymousClassCreator;
      AnonymousClass anonymousClass = (AnonymousClass) myTypesProvider.getRaw(x.anonymousType.binding);
      MethodBinding superConstructorBinding = ((ConstructorDeclaration) x.anonymousType.methods[0]).constructorCall.binding;
      SReference methodReference = myTypesProvider.createMethodReference(superConstructorBinding, AnonymousClass.BASE_METHOD_DECLARATION, anonymousClass.getNode());
      anonymousClass.getNode().addReference(methodReference);
      addCallArgs(x.arguments, anonymousClass);
      anonymousClassCreator.setCls(anonymousClass);
    } else {
      if (x.enclosingInstance() == null) {
        return processExpression((AllocationExpression) x);
      }
    }
    GenericNewExpression result = GenericNewExpression.newInstance(myCurrentModel);
    result.setCreator(creator);
    return result;
  }

  private void addMethodTypeArgs(TypeReference[] typeArgs, IMethodCall call) {
    if (typeArgs == null) {
      return;
    }
    for (TypeReference typeArg : typeArgs) {
      Type type = myTypesProvider.createType(typeArg.resolvedType);
      call.addChild(IMethodCall.TYPE_ARGUMENT, type);
    }
  }

  private void addCallArgs(org.eclipse.jdt.internal.compiler.ast.Expression[] args, IMethodCall call) {
    if (args == null) {
      args = new org.eclipse.jdt.internal.compiler.ast.Expression[0];
    }
    for (org.eclipse.jdt.internal.compiler.ast.Expression arg : args) {
      Expression expression = processExpressionRefl(arg);
      call.addActualArgument(expression);
    }
  }

  /*package*/ Expression processExpression(ClassLiteralAccess x) {
    if (x.targetType instanceof ReferenceBinding) {
      ClassifierClassExpression classExpression = ClassifierClassExpression.newInstance(myCurrentModel);
      SReference classifierReference = myTypesProvider.createClassifierReference((ReferenceBinding) x.targetType, ClassifierClassExpression.CLASSIFIER, classExpression.getNode());
      classExpression.getNode().addReference(classifierReference);
      return classExpression;
    }
    if (x.targetType instanceof BaseTypeBinding) {
      PrimitiveClassExpression classExpression = PrimitiveClassExpression.newInstance(myCurrentModel);
      classExpression.setPrimitiveType((PrimitiveType) myTypesProvider.createType(x.targetType));
      return classExpression;
    }
    LOG.error("unknown class expression type");
    return null;
  }

  /*package*/ Expression processExpression(UnaryExpression x) {
    int operator = ((x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT);
    switch (operator) {
      case OperatorIds.MINUS:
        UnaryMinus unaryMinus = UnaryMinus.newInstance(myCurrentModel);
        unaryMinus.setExpression(processExpressionRefl(x.expression));
        return unaryMinus;
      case OperatorIds.NOT:
        NotExpression notExpression = NotExpression.newInstance(myCurrentModel);
        notExpression.setExpression(processExpressionRefl(x.expression));
        return notExpression;
      case OperatorIds.PLUS:
        return processExpressionRefl(x.expression);
      case OperatorIds.TWIDDLE:
        BitwiseNotExpression twiddle = BitwiseNotExpression.newInstance(myCurrentModel);
        twiddle.setExpression(processExpressionRefl(x.expression));
        return twiddle;
      default:
        throw new JavaConverterException("Unexpected operator for unary expression");
    }
  }

  /*package*/ Expression processExpression(SingleNameReference x) {
    Binding binding = x.binding;
    if (binding instanceof FieldBinding) {
      return expressionFromFieldBinding((FieldBinding) binding, null);
    } else {
      return varFromVariableBinding(binding);
    }
  }

  private Expression varFromVariableBinding(Binding binding) {
    if (binding instanceof ProblemBinding) {
      UnresolvedNameReference varReference = UnresolvedNameReference.newInstance(myCurrentModel);
      varReference.setResolveName(new String(((ProblemBinding) binding).name));
      return varReference;
    }
    INodeAdapter target = myTypesProvider.getRaw(binding);
    if (!((target instanceof VariableDeclaration))) {
      return null;
    }
    VariableDeclaration variable = (VariableDeclaration) target;
    Expression result;
    if (variable instanceof LocalVariableDeclaration) {
      LocalVariableReference reference = LocalVariableReference.newInstance(myCurrentModel);
      reference.setLocalVariableDeclaration((LocalVariableDeclaration) variable);
      result = reference;
    } else
    if (variable instanceof ParameterDeclaration) {
      ParameterReference parameterReference = ParameterReference.newInstance(myCurrentModel);
      parameterReference.setParameterDeclaration((ParameterDeclaration) variable);
      result = parameterReference;
    } else {
      throw new JavaConverterException("Unknown VariableDeclaration subclass.");
    }
    return result;
  }

  /*package*/ Expression processExpression(QualifiedNameReference x) {
    Binding binding = x.binding;
    Expression result;
    if (binding instanceof ProblemBinding) {
      result = fieldReferenceFromProblem((ProblemBinding) binding, new String(x.tokens[0]), new String(x.tokens[1]));
    } else
    if (binding instanceof FieldBinding) {
      result = expressionFromFieldBinding((FieldBinding) binding, null);
    } else {
      result = varFromVariableBinding(binding);
    }
    if (x.otherBindings != null) {
      for (int i = 0; i < x.otherBindings.length; ++i) {
        FieldBinding fieldBinding = x.otherBindings[i];
        result = expressionFromFieldBinding(fieldBinding, result);
      }
    }
    return result;
  }

  private Expression createArrayLengthExpression(Expression operand, FieldBinding fieldBinding) {
    if ("length".equals(new String(fieldBinding.name))) {
      DotExpression dotExpression = DotExpression.newInstance(myCurrentModel);
      dotExpression.setOperand(operand);
      dotExpression.setOperation(ArrayLengthOperation.newInstance(myCurrentModel));
      return dotExpression;
    } else {
      throw new JavaConverterException("error matching field binding");
    }
  }

  /*package*/ List<Statement> processStatements(org.eclipse.jdt.internal.compiler.ast.Statement[] statements) {
    List<Statement> result = new ArrayList<Statement>();
    if (statements != null) {
      for (org.eclipse.jdt.internal.compiler.ast.Statement stmt : statements) {
        Statement statement = processStatementRefl(stmt);
        if (statement != null) {
          result.add(statement);
        }
      }
    }
    return result;
  }

  /*package*/ Statement processStatement(AssertStatement x) {
    Expression expr = processExpressionRefl(x.assertExpression);
    Expression arg = processExpressionRefl(x.exceptionArgument);
    jetbrains.mps.baseLanguage.structure.AssertStatement result = jetbrains.mps.baseLanguage.structure.AssertStatement.newInstance(myCurrentModel);
    result.setCondition(expr);
    result.setMessage(arg);
    return result;
  }

  /*package*/ BlockStatement processStatement(Block x) {
    if (x == null) {
      return null;
    }
    BlockStatement blockStatement = BlockStatement.newInstance(myCurrentModel);
    StatementList statementList = StatementList.newInstance(myCurrentModel);
    blockStatement.setStatements(statementList);
    for (Statement statement : processStatements(x.statements)) {
      statementList.addStatement(statement);
    }
    return blockStatement;
  }

  /*package*/ Statement processStatement(BreakStatement x) {
    jetbrains.mps.baseLanguage.structure.BreakStatement result = jetbrains.mps.baseLanguage.structure.BreakStatement.newInstance(myCurrentModel);
    if (x.label != null) {
      result.setLabel(new String(x.label));
    }
    return result;
  }

  /*package*/ SwitchCase processCaseStatement(CaseStatement x) {
    Expression expression = processExpressionRefl(x.constantExpression);
    SwitchCase switchCase = SwitchCase.newInstance(myCurrentModel);
    switchCase.setExpression(expression);
    switchCase.setBody(StatementList.newInstance(myCurrentModel));
    return switchCase;
  }

  /*package*/ Statement processStatement(ContinueStatement x) {
    jetbrains.mps.baseLanguage.structure.ContinueStatement result = jetbrains.mps.baseLanguage.structure.ContinueStatement.newInstance(myCurrentModel);
    if (x.label != null) {
      result.setLabel(new String(x.label));
    }
    return result;
  }

  /*package*/ Statement processStatement(DoStatement x) {
    Expression loopTest = processExpressionRefl(x.condition);
    Statement loopBody = processStatementRefl(x.action);
    DoWhileStatement doWhileStatement = DoWhileStatement.newInstance(myCurrentModel);
    doWhileStatement.setCondition(loopTest);
    StatementList body = getStatementListFromStatement(loopBody);
    doWhileStatement.setBody(body);
    return doWhileStatement;
  }

  /*package*/ Statement processStatement(EmptyStatement x) {
    return Statement.newInstance(myCurrentModel);
  }

  /*package*/ LocalVariableDeclarationStatement processStatement(LocalDeclaration x) {
    LocalVariableDeclaration localVariableDeclaration = getLocalVariableDeclaration(x);
    LocalVariableDeclarationStatement result = LocalVariableDeclarationStatement.newInstance(myCurrentModel);
    result.setLocalVariableDeclaration(localVariableDeclaration);
    return result;
  }

  private LocalVariableDeclaration getLocalVariableDeclaration(LocalDeclaration x) {
    LocalVariableDeclaration local = (LocalVariableDeclaration) myTypesProvider.getRaw(x.binding);
    if (local == null) {
      return null;
    }
    Expression initializer = processExpressionRefl(x.initialization);
    local.setInitializer(initializer);
    addVariableAnnotations(local, x);
    return local;
  }

  /*package*/ Statement processStatement(ReturnStatement x) {
    jetbrains.mps.baseLanguage.structure.ReturnStatement result = jetbrains.mps.baseLanguage.structure.ReturnStatement.newInstance(myCurrentModel);
    result.setExpression(processExpressionRefl(x.expression));
    return result;
  }

  /*package*/ Statement processStatement(ForeachStatement x) {
    jetbrains.mps.baseLanguage.structure.ForeachStatement result = jetbrains.mps.baseLanguage.structure.ForeachStatement.newInstance(myCurrentModel);
    Statement action = processStatementRefl(x.action);
    StatementList body = getStatementListFromStatement(action);
    LocalVariableDeclaration elementVar = (LocalVariableDeclaration) myTypesProvider.getRaw(x.elementVariable.binding);
    Expression iterable = processExpressionRefl(x.collection);
    result.setIterable(iterable);
    result.setVariable(elementVar);
    result.setBody(body);
    return result;
  }

  /*package*/ Statement processStatement(ForStatement x) {
    List<Statement> init = processStatements(x.initializations);
    Expression expr = processExpressionRefl(x.condition);
    jetbrains.mps.baseLanguage.structure.ForStatement forStatement = jetbrains.mps.baseLanguage.structure.ForStatement.newInstance(myCurrentModel);
    forStatement.setCondition(expr);
    if (!(init.isEmpty())) {
      boolean first = true;
      for (Statement statement : init) {
        if (statement instanceof LocalVariableDeclarationStatement) {
          LocalVariableDeclarationStatement lvds = (LocalVariableDeclarationStatement) statement;
          LocalVariableDeclaration variableDeclaration = lvds.getLocalVariableDeclaration();
          lvds.removeChild(variableDeclaration);
          if (first) {
            forStatement.setVariable(variableDeclaration);
            first = false;
          } else {
            AdditionalForLoopVariable additionalForLoopVariable = AdditionalForLoopVariable.newInstance(myCurrentModel);
            myTypesProvider.replaceUnsafe(variableDeclaration, additionalForLoopVariable);
            additionalForLoopVariable.setName(variableDeclaration.getName());
            Expression inititalizer = variableDeclaration.getInitializer();
            if (inititalizer != null) {
              inititalizer.getParent().removeChild(inititalizer);
              additionalForLoopVariable.setInitializer(inititalizer);
            }
            forStatement.addAdditionalVar(additionalForLoopVariable);
          }
        }
      }
    }
    List<ExpressionStatement> incr = processExpressionStatements(x.increments);
    if (!(incr.isEmpty())) {
      for (ExpressionStatement expressionStatement : incr) {
        Expression expression = expressionStatement.getExpression();
        expression.getParent().removeChild(expression);
        forStatement.addIteration(expression);
      }
    }
    Statement loopBody = processStatementRefl(x.action);
    StatementList body = getStatementListFromStatement(loopBody);
    forStatement.setBody(body);
    return forStatement;
  }

  /*package*/ Statement processStatement(IfStatement x) {
    Expression expr = processExpressionRefl(x.condition);
    Statement thenStmt = processStatementRefl(x.thenStatement);
    Statement elseStmt = processStatementRefl(x.elseStatement);
    jetbrains.mps.baseLanguage.structure.IfStatement result = jetbrains.mps.baseLanguage.structure.IfStatement.newInstance(myCurrentModel);
    result.setCondition(expr);
    if (elseStmt != null) {
      result.setIfFalseStatement(elseStmt);
    }
    StatementList ifTrue = getStatementListFromStatement(thenStmt);
    result.setIfTrue(ifTrue);
    return result;
  }

  /*package*/ Statement processStatement(LabeledStatement x) {
    Statement statement = processStatementRefl(x.statement);
    if (statement == null) {
      return null;
    }
    if (statement instanceof AbstractLoopStatement) {
      AbstractLoopStatement loopStatement = (AbstractLoopStatement) statement;
      loopStatement.setLabel(new String(x.label));
    } else
    if (statement instanceof SwitchStatement) {
      SwitchStatement switchStatement = (SwitchStatement) statement;
      switchStatement.setLabel(new String(x.label));
    }
    return statement;
  }

  /*package*/ Statement processStatement(org.eclipse.jdt.internal.compiler.ast.SwitchStatement x) {
    Expression expression = processExpressionRefl(x.expression);
    SwitchStatement result = SwitchStatement.newInstance(myCurrentModel);
    result.setExpression(expression);
    result.setDefaultBlock(StatementList.newInstance(myCurrentModel));
    if (x.statements != null) {
      StatementList currentSwitchCase = null;
      for (org.eclipse.jdt.internal.compiler.ast.Statement stmt : x.statements) {
        if (stmt instanceof CaseStatement) {
          CaseStatement caseStatement = (CaseStatement) stmt;
          if (caseStatement.constantExpression == null) {
            currentSwitchCase = result.getDefaultBlock();
          } else {
            SwitchCase switchCase = processCaseStatement((CaseStatement) stmt);
            if (switchCase != null) {
              result.addCase(switchCase);
            }
            currentSwitchCase = (switchCase == null ?
              null :
              switchCase.getBody()
            );
          }
        } else
        if (currentSwitchCase != null) {
          currentSwitchCase.addStatement(processStatementRefl(stmt));
        }
      }
    }
    return result;
  }

  /*package*/ Statement processStatement(SynchronizedStatement x) {
    jetbrains.mps.baseLanguage.structure.SynchronizedStatement result = jetbrains.mps.baseLanguage.structure.SynchronizedStatement.newInstance(myCurrentModel);
    Statement block = processStatementRefl(x.block);
    Expression expr = processExpressionRefl(x.expression);
    result.setExpression(expr);
    result.setBlock(getStatementListFromStatement(block));
    return result;
  }

  /*package*/ Statement processStatement(ThrowStatement x) {
    Expression toThrow = processExpressionRefl(x.exception);
    jetbrains.mps.baseLanguage.structure.ThrowStatement throwStatement = jetbrains.mps.baseLanguage.structure.ThrowStatement.newInstance(myCurrentModel);
    throwStatement.setThrowable(toThrow);
    return throwStatement;
  }

  /*package*/ Statement processStatement(TryStatement x) {
    Statement tryBlock = processStatementRefl(x.tryBlock);
    List<LocalVariableDeclaration> catchArgs = new ArrayList<LocalVariableDeclaration>();
    List<Statement> catchBlocks = new ArrayList<Statement>();
    Statement finallyBlock = processStatementRefl(x.finallyBlock);
    if (x.catchBlocks != null) {
      for (int i = 0, c = x.catchArguments.length; i < c; ++i) {
        LocalVariableDeclaration local = (LocalVariableDeclaration) myTypesProvider.getRaw(x.catchArguments[i].binding);
        catchArgs.add(local);
      }
      for (int i = 0, c = x.catchBlocks.length; i < c; ++i) {
        catchBlocks.add(processStatementRefl(x.catchBlocks[i]));
      }
    }
    if (finallyBlock != null) {
      jetbrains.mps.baseLanguage.structure.TryStatement tryStatement = jetbrains.mps.baseLanguage.structure.TryStatement.newInstance(myCurrentModel);
      for (int i = 0; i < catchBlocks.size(); i++) {
        Statement catchBlock = catchBlocks.get(i);
        LocalVariableDeclaration lvd = catchArgs.get(i);
        CatchClause catchClause = CatchClause.newInstance(myCurrentModel);
        tryStatement.addCatchClause(catchClause);
        catchClause.setCatchBody(getStatementListFromStatement(catchBlock));
        catchClause.setThrowable(lvd);
      }
      tryStatement.setFinallyBody(getStatementListFromStatement(finallyBlock));
      tryStatement.setBody(getStatementListFromStatement(tryBlock));
      return tryStatement;
    } else {
      TryCatchStatement tryCatchStatement = TryCatchStatement.newInstance(myCurrentModel);
      for (int i = 0; i < catchBlocks.size(); i++) {
        Statement catchBlock = catchBlocks.get(i);
        LocalVariableDeclaration lvd = catchArgs.get(i);
        CatchClause catchClause = CatchClause.newInstance(myCurrentModel);
        tryCatchStatement.addCatchClause(catchClause);
        catchClause.setCatchBody(getStatementListFromStatement(catchBlock));
        catchClause.setThrowable(lvd);
      }
      tryCatchStatement.setBody(getStatementListFromStatement(tryBlock));
      return tryCatchStatement;
    }
  }

  /*package*/ Statement processStatement(WhileStatement x) {
    Expression loopTest = processExpressionRefl(x.condition);
    Statement loopBody = processStatementRefl(x.action);
    jetbrains.mps.baseLanguage.structure.WhileStatement result = jetbrains.mps.baseLanguage.structure.WhileStatement.newInstance(myCurrentModel);
    result.setCondition(loopTest);
    result.setBody(getStatementListFromStatement(loopBody));
    return result;
  }

  public Classifier processType(TypeDeclaration x) {
    Classifier classifier = (Classifier) myTypesProvider.getRaw(x.binding);
    if (x.binding.isAnnotationType()) {
      if (x.methods != null) {
        for (AbstractMethodDeclaration method : x.methods) {
          processAnnotationMethod((AnnotationMethodDeclaration) method);
        }
      }
      return classifier;
    }
    myCurrentTypeDeclaration = x;
    myCurrentClass = classifier;
    try {
      if (x.fields != null) {
        for (FieldDeclaration fieldDeclaration : x.fields) {
          if (fieldDeclaration instanceof Initializer) {
            assert (classifier instanceof ClassConcept);
            processInitializer((Initializer) fieldDeclaration, (ClassConcept) classifier);
          } else {
            processField(fieldDeclaration);
          }
        }
      }
      if (x.methods != null) {
        for (AbstractMethodDeclaration method : x.methods) {
          if (method.isConstructor()) {
            assert (myCurrentClass instanceof ClassConcept);
            if (x.binding instanceof LocalTypeBinding) {
            } else {
              processConstructor((ConstructorDeclaration) method);
            }
          } else
          if (method.isClinit()) {
            continue;
          } else {
            processMethod(method);
          }
          addExceptionsToMethod(method);
        }
      }
      myCurrentClass = null;
      myCurrentTypeDeclaration = null;
      addClassifierAnnotations(classifier, x);
    } catch (Throwable e) {
      throw new JavaConverterException(e);
    }
    return classifier;
  }

  /*package*/ void addExceptionsToMethod(AbstractMethodDeclaration x) {
    MethodBinding b = x.binding;
    if (b == null) {
      return;
    }
    BaseMethodDeclaration method = (BaseMethodDeclaration) myTypesProvider.getRaw(b);
    for (ReferenceBinding referenceBinding : b.thrownExceptions) {
      ClassifierType exceptionType = (ClassifierType) myTypesProvider.createType(referenceBinding);
      method.addThrowsItem(exceptionType);
    }
  }

  /*package*/ void addMethodParametersAnnotations(AbstractMethodDeclaration x) {
    if (x.arguments != null) {
      for (Argument argument : x.arguments) {
        ParameterDeclaration parameterDeclaration = (ParameterDeclaration) myTypesProvider.getRaw(argument.binding);
        addVariableAnnotations(parameterDeclaration, argument);
      }
    }
  }

  /*package*/ void processAnnotationMethod(AnnotationMethodDeclaration x) {
    MethodBinding b = x.binding;
    jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration method = (jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration) myTypesProvider.getRaw(b);
    try {
      myCurrentMethod = method;
      if (x.defaultValue != null) {
        method.setDefaultValue(processExpressionRefl(x.defaultValue));
      }
      addMethodAnnotations(method, x);
      myCurrentMethod = null;
    } catch (Throwable t) {
      throw new JavaConverterException(t);
    }
  }

  /*package*/ void processMethod(AbstractMethodDeclaration x) {
    MethodBinding b = x.binding;
    BaseMethodDeclaration method = (BaseMethodDeclaration) myTypesProvider.getRaw(b);
    if (method == null) {
      return;
    }
    try {
      if (x.isNative()) {
        throw new JavaConverterException("Native methods not supported");
      }
      myCurrentMethod = method;
      StatementList methodBody = method.getBody();
      if (methodBody == null) {
        methodBody = StatementList.newInstance(myCurrentModel);
        method.setBody(methodBody);
      }
      for (Statement statement : processStatements(x.statements)) {
        methodBody.addStatement(statement);
      }
      addMethodParametersAnnotations(x);
      addMethodAnnotations(method, x);
      myCurrentMethod = null;
    } catch (Throwable e) {
      throw new JavaConverterException(e);
    }
  }

  /*package*/ void processConstructor(ConstructorDeclaration x) {
    jetbrains.mps.baseLanguage.structure.ConstructorDeclaration ctor = (jetbrains.mps.baseLanguage.structure.ConstructorDeclaration) myTypesProvider.getRaw(x.binding);
    try {
      myCurrentMethod = ctor;
      ConstructorInvocationStatement superOrThisCall = null;
      ExplicitConstructorCall ctorCall = x.constructorCall;
      if (ctorCall != null) {
        superOrThisCall = processExpression(ctorCall);
      }
      StatementList body = ctor.getBody();
      if (body == null) {
        body = StatementList.newInstance(myCurrentModel);
        ctor.setBody(body);
      }
      if (superOrThisCall != null) {
        body.addStatement(superOrThisCall);
      }
      for (Statement statement : processStatements(x.statements)) {
        body.addStatement(statement);
      }
      addMethodParametersAnnotations(x);
      addMethodAnnotations(ctor, x);
      myCurrentMethod = null;
    } catch (Throwable e) {
      throw new JavaConverterException(e);
    }
  }

  /*package*/ void processInitializer(Initializer initializer, ClassConcept classConcept) {
    StatementList body;
    if (initializer.isStatic()) {
      StaticInitializer staticInitializer = StaticInitializer.newInstance(myCurrentModel);
      classConcept.setClassInitializer(staticInitializer);
      staticInitializer.setStatementList(StatementList.newInstance(myCurrentModel));
      body = staticInitializer.getStatementList();
    } else {
      InstanceInitializer instanceInitializer = InstanceInitializer.newInstance(myCurrentModel);
      classConcept.setInstanceInitializer(instanceInitializer);
      instanceInitializer.setStatementList(StatementList.newInstance(myCurrentModel));
      body = instanceInitializer.getStatementList();
    }
    if (initializer.block != null && initializer.block.statements != null) {
      List<Statement> stmts = processStatements(initializer.block.statements);
      for (Statement statement : stmts) {
        body.addStatement(statement);
      }
    }
  }

  /*package*/ void processField(FieldDeclaration declaration) {
    INodeAdapter adapter = myTypesProvider.getRaw(declaration.binding);
    if (adapter == null) {
      return;
    }
    if (adapter instanceof jetbrains.mps.baseLanguage.structure.FieldDeclaration || adapter instanceof StaticFieldDeclaration) {
      VariableDeclaration field = (VariableDeclaration) adapter;
      try {
        Expression initializer = null;
        if (declaration.initialization != null) {
          initializer = processExpressionRefl(declaration.initialization);
        }
        if (initializer != null) {
          field.setInitializer(initializer);
        }
        addVariableAnnotations(field, declaration);
      } catch (Throwable e) {
        throw new JavaConverterException(e);
      }
    }
    if (adapter instanceof EnumConstantDeclaration) {
      try {
        EnumConstantDeclaration enumConstant = (EnumConstantDeclaration) adapter;
        assert (myCurrentClass instanceof EnumClass);
        AllocationExpression initializer = (AllocationExpression) declaration.initialization;
        MethodBinding constructorBinding;
        if (initializer instanceof QualifiedAllocationExpression) {
          TypeDeclaration anonymousEnumClass = ((QualifiedAllocationExpression) initializer).anonymousType;
          constructorBinding = ((ConstructorDeclaration) anonymousEnumClass.methods[0]).constructorCall.binding;
          EnumClass enumClassConstantBody = (EnumClass) myTypesProvider.getRaw(anonymousEnumClass.binding);
          for (InstanceMethodDeclaration imd : enumClassConstantBody.getMethods()) {
            enumClassConstantBody.removeChild(imd);
            enumConstant.addMethod(imd);
          }
          for (AbstractMethodDeclaration m : anonymousEnumClass.methods) {
            if (m instanceof ConstructorDeclaration) {
              continue;
            }
            processMethod(m);
          }
        } else {
          constructorBinding = initializer.binding;
        }
        jetbrains.mps.baseLanguage.structure.ConstructorDeclaration constructor = (jetbrains.mps.baseLanguage.structure.ConstructorDeclaration) myTypesProvider.getRaw(constructorBinding.original());
        enumConstant.setConstructor(constructor);
        org.eclipse.jdt.internal.compiler.ast.Expression[] arguments = initializer.arguments;
        if (arguments != null) {
          for (org.eclipse.jdt.internal.compiler.ast.Expression arg : arguments) {
            enumConstant.addActualArgument(processExpressionRefl(arg));
          }
        }
        addEnumConstAnnotations(enumConstant, declaration);
      } catch (Throwable t) {
        throw new JavaConverterException(t);
      }
    }
  }

  private void addVariableAnnotations(VariableDeclaration variableDeclaration, AbstractVariableDeclaration var) {
    if (var.annotations != null) {
      for (Annotation annotation : var.annotations) {
        addAnnotation(variableDeclaration, annotation);
      }
    }
  }

  private void addEnumConstAnnotations(EnumConstantDeclaration enumConst, FieldDeclaration field) {
    if (field.annotations != null) {
      for (Annotation annotation : field.annotations) {
        addAnnotation(enumConst, annotation);
      }
    }
  }

  private void addMethodAnnotations(BaseMethodDeclaration methodDeclaration, AbstractMethodDeclaration method) {
    if (method.annotations != null) {
      for (Annotation annotation : method.annotations) {
        addAnnotation(methodDeclaration, annotation);
      }
    }
  }

  private void addClassifierAnnotations(Classifier classifier, TypeDeclaration typeDeclaration) {
    if (typeDeclaration.annotations != null) {
      for (Annotation annotation : typeDeclaration.annotations) {
        addAnnotation(classifier, annotation);
      }
    }
  }

  private void addAnnotation(HasAnnotation hasAnnotation, Annotation annotation) {
    AnnotationInstance annotationInstance = (AnnotationInstance) processExpressionRefl(annotation);
    hasAnnotation.addAnnotation(annotationInstance);
  }

  public List<Classifier> exec(ReferentsCreator referentsCreator, Map<String, SModel> modelMap, boolean isolated) {
    List<Classifier> result = new ArrayList<Classifier>();
    myTypesProvider = referentsCreator.getTypesProvider();
    myModelMap = modelMap;
    myCurrentClass = null;
    myCurrentMethod = null;
    myCurrentModel = null;
    myIsolated = isolated;
    for (TypeDeclaration type : referentsCreator.getClassifierTypeDecls()) {
      myCurrentModel = getModelByTypeDeclaration(type.binding);
      if (myCurrentModel != null) {
        Classifier classifier = processType(type);
        if (referentsCreator.isTopLevelClassifier(type)) {
          if (!(myIsolated)) {
            myCurrentModel.addRoot(classifier.getNode());
          }
          result.add(classifier);
        }
      }
      myCurrentModel = null;
    }
    return result;
  }

  public SModel getModelByTypeDeclaration(SourceTypeBinding typeBinding) {
    if (typeBinding instanceof NestedTypeBinding) {
      return getModelByTypeDeclaration(((NestedTypeBinding) typeBinding).enclosingType);
    }
    if (myIsolated) {
      return myModelMap.values().iterator().next();
    }
    String packageName = JavaCompiler.packageNameFromCompoundName(typeBinding.compoundName);
    SModel sModel = myModelMap.get(packageName);
    if (sModel == null) {
      LOG.error("can't find a model for Type Declaration " + new String(typeBinding.sourceName) + " : package name is " + packageName);
    }
    return sModel;
  }

  private StatementList getStatementListFromStatement(Statement possibleBlock) {
    StatementList result;
    if (possibleBlock instanceof BlockStatement) {
      result = ((BlockStatement) possibleBlock).getStatements();
      possibleBlock.removeChild(result);
    } else {
      result = StatementList.newInstance(myCurrentModel);
      if (possibleBlock != null) {
        result.addStatement(possibleBlock);
      }
    }
    return result;
  }
}
