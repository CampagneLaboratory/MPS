package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.reloading.CompositeClassPathItem;
import java.util.Map;
import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.io.File;
import jetbrains.mps.project.IModule;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.util.NameUtil;

public class DirParser {
  private static final Logger LOG = Logger.getLogger(DirParser.class);
  private CompositeClassPathItem myClassPathItem;
  private Map<String, CompilationUnit> myCompilationUnits = new HashMap<String, CompilationUnit>();
  private List<SModel> myAffectedModels = ListSequence.fromList(new ArrayList<SModel>());
  private List<File> mySourceDirs;
  private IModule myModule;
  private SModel myBaseModelToAddSource;
  private String myPrefix = null;
  private Map<String, SModel> myPackageFQNamesToModels = new HashMap<String, SModel>();
  private Set<String> myModelsToCreate = new HashSet<String>();
  private JavaParser myJavaParser = new JavaParser();

  public DirParser(IModule mod, SModel baseModel, File sourceDir) {
    myModule = mod;
    myBaseModelToAddSource = baseModel;
    mySourceDirs = ListSequence.fromListAndArray(new ArrayList<File>(), sourceDir);
  }

  public List<SNode> parseDir(JavaParser parser, File dir) throws JavaParseException {
    List<SNode> result = new ArrayList<SNode>();

    if (dir == null || !(dir.exists()) || !(dir.isDirectory())) {
      throw new IllegalArgumentException("Bad directory");
    }

    for (File file : dir.listFiles()) {
      if (!(file.isDirectory()) && file.getName().endsWith(".java")) {
        String code = FileUtil.read(file);
        List<SNode> oneFileRoots = parser.parse(code, "", FeatureKind.CLASS, true).getNodes();
        ListSequence.fromList(result).addSequence(ListSequence.fromList(oneFileRoots));
      }
    }
    // <node> 
    return result;
  }

  public void parseDirs() throws JavaParseException {
    // <node> 
    for (File sourceDir : ListSequence.fromList(mySourceDirs)) {
      myPrefix = null;
      addSourceFromDirectory(sourceDir);
    }

    for (SModel m : ListSequence.fromList(myAffectedModels)) {
      System.out.println("DEBUG:  model " + SModelOperations.getModelName(m));
      myJavaParser.tryResolveRoots(SModelOperations.getRoots(m, null));
    }

  }

  public void addSourceFromDirectory(File dir) throws JavaParseException {
    assert dir.isDirectory();

    // packages which match the directory 
    // in the proper case: there should be only one 
    String pkg = null;
    boolean wasDefaultPkg = false;
    final List<SNode> roots = new ArrayList<SNode>();

    for (File file : dir.listFiles()) {
      if (file.isDirectory()) {
        addSourceFromDirectory(file);

      } else if (file.getName().endsWith(".java")) {

        JavaParser.JavaParseResult parseRes = parseFile(file);
        String p = parseRes.getPackage();

        if (p == null) {
          // default package (i.e. none), bad 
          if (!(wasDefaultPkg)) {
            LOG.error("default package is not supported in java source directory input (first such file in dir: " + file.getName() + ")");
            wasDefaultPkg = true;
          }
          continue;
        }
        if (pkg == null) {
          if (DirParser.checkPackageMatchesSourceDirectory(p, dir)) {
            pkg = p;
          } else {
            LOG.error("package " + p + " doesn't match directory " + dir.getAbsolutePath() + " (in file " + file.getName() + ")");
            continue;
          }

        } else if (!(pkg.equals(p))) {
          LOG.error("different packages in directory " + dir.getAbsolutePath() + ", namely " + pkg + " and " + p);
          continue;
        }
        ListSequence.fromList(roots).addSequence(ListSequence.fromList(parseRes.getNodes()));
      }
    }

    // do model stuff 
    final String finalPkg = pkg;
    if (pkg != null && ListSequence.fromList(roots).count() > 0) {
      ModelAccess.instance().runWriteActionInCommand(new Runnable() {
        public void run() {
          SModel mdl = registerModelForPackage(finalPkg);

          if (mdl != null) {
            mdl.addLanguage(ModuleRepositoryFacade.getInstance().getModule("jetbrains.mps.baseLanguage", Language.class).getModuleReference());
            for (SNode r : ListSequence.fromList(roots)) {
              SModelOperations.addRootNode(mdl, r);
            }
            ListSequence.fromList(myAffectedModels).addElement(mdl);
          }
        }
      });
    } else {
      LOG.info("skipping directory " + dir.getAbsolutePath());
    }
  }

  private JavaParser.JavaParseResult parseFile(File file) throws JavaParseException {
    String contents = FileUtil.read(file);
    return myJavaParser.parseCompilationUnit(contents);
  }

  private SModel registerModelForPackage(String fqName) {
    SModelFqName sModelFqName = SModelFqName.fromString(fqName);
    SModelDescriptor modelDescriptor = SModelRepository.getInstance().getModelDescriptor(sModelFqName);
    if (modelDescriptor != null) {
      if (!(myModule.getOwnModelDescriptors().contains(modelDescriptor))) {
        LOG.error("model with fq name " + fqName + " is not owned by module " + myModule.getModuleFqName());
        return null;
      }
      // package is already present... 
      // maybe we shouldn't touch it then, maybe it should be an option 
      return modelDescriptor.getSModel();
    } else {
      return createModel(fqName);
    }
  }

  private SModel createModel(String packageName) {
    // first check if it is possible 
    if (getRootToCreateModel(packageName) == null) {
      LOG.error("Cannot create model " + packageName + " in module " + myModule.getModuleFqName());
      return null;
    }

    SModelDescriptor modelDescr = myModule.createModel(packageName, getRootToCreateModel(packageName), null);
    assert modelDescr != null;

    return modelDescr.getSModel();
  }

  @Nullable
  private ModelRoot getRootToCreateModel(String packageName) {
    for (ModelRoot root : Sequence.fromIterable(myModule.getModelRoots())) {
      if (root.canCreateModel(packageName)) {
        return root;
      }
    }
    return null;
  }

  public static boolean checkPackageMatchesSourceDirectory(String pkg, File sourceDir) {
    String pathPostfix = NameUtil.pathFromNamespace(pkg);
    return sourceDir.getAbsolutePath().endsWith(pathPostfix);
  }
}
