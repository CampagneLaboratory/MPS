package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.annotations.NotNull;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
import jetbrains.mps.smodel.SNodeId;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Iterator;
import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
import java.util.ArrayList;
import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
import org.eclipse.jdt.internal.compiler.ast.Annotation;
import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.DynamicReference;
import org.jetbrains.annotations.Nullable;
import org.eclipse.jdt.internal.compiler.ast.Argument;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.Wildcard;
import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.lang.typesystem.runtime.HUtil;

/**
 * Convert eclipse AST into BaseLanguage nodes.
 */
public class ASTConverter {
  private static final Logger LOG = Logger.getLogger(ASTConverter.class);
  @NotNull
  protected final TypeNameResolver myTypeResolver;
  private boolean myOnlyStubs = false;
  private Map<Integer, SNode> myJavadocs = MapSequence.fromMap(new HashMap<Integer, SNode>());

  public ASTConverter(@NotNull TypeNameResolver typeResolver, boolean onlyStubs) {
    myTypeResolver = typeResolver;
    myOnlyStubs = onlyStubs;
  }

  protected ASTConverter(ASTConverter base) {
    myTypeResolver = base.myTypeResolver;
    myOnlyStubs = base.myOnlyStubs;
  }

  public SNode convertRoot(ASTNode node) throws JavaParseException {

    if (node instanceof TypeDeclaration) {
      TypeDeclaration decl = (TypeDeclaration) node;
      String name = new String(decl.name);
      myTypeResolver.addTypeName(name);
      myTypeResolver.enterType(name);
      try {
        return convertTypeDecl(decl);
      } finally {
        myTypeResolver.leaveType();
      }
    } else {
      throw new JavaParseException("Root is not type decl");
    }
  }

  public SNode convertTypeDecl(TypeDeclaration x) throws JavaParseException {

    SNode cls;

    final Map<SNode, Integer> memberStartPositions = MapSequence.fromMap(new HashMap<SNode, Integer>());
    SNode defaultConstructor = null;

    boolean isAnonymous = x.allocation != null;

    if (isAnonymous) {
      cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnonymousClass", null);

    } else {
      switch (TypeDeclaration.kind(x.modifiers)) {
        case TypeDeclaration.CLASS_DECL:
          cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassConcept", null);
          break;

        case TypeDeclaration.INTERFACE_DECL:
          cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Interface", null);
          break;

        case TypeDeclaration.ENUM_DECL:
          cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumClass", null);
          break;

        case TypeDeclaration.ANNOTATION_TYPE_DECL:
          cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Annotation", null);
          break;
        default:
          throw new JavaParseException("Unknown type declaration type");
      }
    }

    ASTConverter childConverter = this;


    if (!(isAnonymous)) {
      SPropertyOperations.set(cls, "name", new String(x.name));
      SLinkOperations.setTarget(cls, "visibility", convertVisibility(x.modifiers), true);
      // <node> 
      // FIXME work around. what's with interface here 
      if (!(SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface")) && flagSet(x.modifiers, ClassFileConstants.AccStatic)) {
        // setting nonStatic only if static keyword is present 
        SPropertyOperations.set(cls, "nonStatic", "" + (false));
      }

      if (myOnlyStubs) {
        String nodeId = getState().getIdPrefix() + SPropertyOperations.getString(cls, "name");
        cls.setId(new SNodeId.Foreign(nodeId));
        childConverter = withNewState(new ASTConverter.State(nodeId + "."));
      }
    }

    // handling type params 
    myTypeResolver.newTypeVarFrame();
    convertTypeVars(x.typeParameters, cls);

    // handling nested classes 
    if (x.memberTypes != null) {

      //  putting them into resolver's scope 
      for (TypeDeclaration innerTyp : x.memberTypes) {
        myTypeResolver.addTypeName(new String(innerTyp.name));
      }

      // now actually processing them 
      for (TypeDeclaration innerTyp : x.memberTypes) {
        myTypeResolver.enterType(new String(innerTyp.name));

        try {
          SNode nested = childConverter.convertTypeDecl(innerTyp);
          SLinkOperations.getTargets(cls, "member", true).add(nested);
          MapSequence.fromMap(memberStartPositions).put(nested, innerTyp.sourceStart);
        } finally {
          // maintaining valid state of ClassNameResolver 
          myTypeResolver.leaveType();
        }
      }
    }

    convertAnnotations(x.annotations, cls);

    {
      SNode claz = cls;
      if (SNodeOperations.isInstanceOf(claz, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        // we're either class or enum 
        SLinkOperations.setTarget(claz, "superclass", SNodeOperations.cast(convertTypeRef(x.superclass), "jetbrains.mps.baseLanguage.structure.ClassifierType"), true);
        if (x.superInterfaces != null) {
          for (TypeReference i : x.superInterfaces) {
            ListSequence.fromList(SLinkOperations.getTargets(claz, "implementedInterface", true)).addElement(SNodeOperations.cast(convertTypeRef(i), "jetbrains.mps.baseLanguage.structure.ClassifierType"));
          }
        }
        SPropertyOperations.set(claz, "abstractClass", "" + (flagSet(x.modifiers, ClassFileConstants.AccAbstract)));
        SPropertyOperations.set(claz, "isFinal", "" + (flagSet(x.modifiers, ClassFileConstants.AccFinal)));
      }
    }

    {
      SNode iface = cls;
      if (SNodeOperations.isInstanceOf(iface, "jetbrains.mps.baseLanguage.structure.Interface")) {
        // <node> 
        if (x.superInterfaces != null) {
          for (TypeReference i : x.superInterfaces) {
            ListSequence.fromList(SLinkOperations.getTargets(iface, "extendedInterface", true)).addElement(SNodeOperations.cast(convertTypeRef(i), "jetbrains.mps.baseLanguage.structure.ClassifierType"));
          }
        }
      }
    }

    {
      SNode enm = cls;
      if (SNodeOperations.isInstanceOf(enm, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
        if (x.fields != null) {
          for (FieldDeclaration f : x.fields) {
            if (!(isEnumConstant(f))) {
              continue;
            }
            SNode constr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", null);
            // TODO 
            SNode item = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration", null);
            SPropertyOperations.set(item, "name", enumConstantName(f));
            // <node> 
            SLinkOperations.getTargets(enm, "enumConstant", true).add(item);
          }
        }
      }
    }

    // handle class fields 
    if (x.fields != null) {
      for (FieldDeclaration f : x.fields) {
        SNode mem = convertField(cls, f, true);
        MapSequence.fromMap(memberStartPositions).put(SNodeOperations.cast(mem, "jetbrains.mps.baseLanguage.structure.ClassifierMember"), f.sourceStart);
      }
    }

    // handling methods 
    if (x.methods != null) {
      for (AbstractMethodDeclaration method : x.methods) {
        SNode mem = convertMethod(cls, method, true);
        MapSequence.fromMap(memberStartPositions).put(SNodeOperations.cast(mem, "jetbrains.mps.baseLanguage.structure.ClassifierMember"), method.sourceStart);
        if (method instanceof ConstructorDeclaration && method.isDefaultConstructor()) {
          defaultConstructor = SNodeOperations.cast(mem, "jetbrains.mps.baseLanguage.structure.ClassifierMember");
        }
      }

    }

    myTypeResolver.leaveTypeVarFrame();

    if (x.javadoc != null) {
      AttributeOperations.createAndSetAttrbiute(cls, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.ClassifierDocComment")), "jetbrains.mps.baseLanguage.javadoc.structure.ClassifierDocComment");
      MapSequence.fromMap(myJavadocs).put(x.javadoc.sourceStart, AttributeOperations.getAttribute(cls, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.ClassifierDocComment"))));
    }

    // sort classifier members according to their start positions 
    List<SNode> sortedMembers = ListSequence.fromList(SLinkOperations.getTargets(cls, "member", true)).sort(new ISelector<SNode, Integer>() {
      public Integer select(SNode it) {
        return MapSequence.fromMap(memberStartPositions).get(it);
      }
    }, true).toListSequence();
    // now handle the default (implicit) constructor; let's put him after first fields section 
    if ((defaultConstructor != null)) {
      ListSequence.fromList(sortedMembers).removeElement(defaultConstructor);
      int firstNonField = 0;
      {
        Iterator<SNode> m_it = ListSequence.fromList(sortedMembers).iterator();
        SNode m_var;
        while (m_it.hasNext()) {
          m_var = m_it.next();
          if (!(SNodeOperations.isInstanceOf(m_var, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"))) {
            break;
          }
          firstNonField++;
        }
      }
      ListSequence.fromList(sortedMembers).insertElement(firstNonField, defaultConstructor);
    }
    ListSequence.fromList(SLinkOperations.getTargets(cls, "member", true)).clear();
    ListSequence.fromList(SLinkOperations.getTargets(cls, "member", true)).addSequence(ListSequence.fromList(sortedMembers));

    return cls;
  }

  public SNode convertField(FieldDeclaration x, SNode context) throws JavaParseException {
    return convertField(context, x, false);
  }

  private SNode convertField(SNode cls, FieldDeclaration f, boolean attach) throws JavaParseException {
    if (f.name == null || isEnumConstant(f)) {
      return null;
    }

    SNode fDecl = null;

    if (flagSet(f.modifiers, ClassFileConstants.AccStatic) || SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface")) {
      // interfaces in java can have fields not declared as static, but they are static 
      SNode staticDecl = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration", null);
      fDecl = staticDecl;
    } else {
      assert SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept");

      SNode fieldDecl = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldDeclaration", null);

      SPropertyOperations.set(fieldDecl, "isVolatile", "" + (flagSet(f.modifiers, ClassFileConstants.AccVolatile)));
      SPropertyOperations.set(fieldDecl, "isTransient", "" + (flagSet(f.modifiers, ClassFileConstants.AccTransient)));

      fDecl = fieldDecl;
    }

    if ((fDecl != null)) {
      convertAnnotations(f.annotations, fDecl);

      SPropertyOperations.set(fDecl, "name", new String(f.name));
      SLinkOperations.setTarget(fDecl, "type", convertTypeRef(f.type), true);

      SLinkOperations.setTarget(SNodeOperations.cast(fDecl, "jetbrains.mps.baseLanguage.structure.IVisible"), "visibility", convertVisibility(f.modifiers), true);
      SPropertyOperations.set(fDecl, "isFinal", "" + (flagSet(f.modifiers, ClassFileConstants.AccFinal)));

      if (!(SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) && myOnlyStubs) {
        SNodeId nodeId = new SNodeId.Foreign(SNodeId.Foreign.ID_PREFIX + SPropertyOperations.getString(cls, "name") + "." + SPropertyOperations.getString(fDecl, "name"));
        fDecl.setId(nodeId);
      }

      if (attach) {
        ListSequence.fromList(SLinkOperations.getTargets(cls, "member", true)).addElement(SNodeOperations.cast(fDecl, "jetbrains.mps.baseLanguage.structure.ClassifierMember"));
      }
    }

    if (f.javadoc != null) {
      int start = f.javadoc.sourceStart;
      SNode doc = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment", null);
      if (SNodeOperations.isInstanceOf(fDecl, "jetbrains.mps.baseLanguage.structure.FieldDeclaration")) {
        AttributeOperations.setAttribute(SNodeOperations.cast(fDecl, "jetbrains.mps.baseLanguage.structure.FieldDeclaration"), new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment")), doc);
      } else if (SNodeOperations.isInstanceOf(fDecl, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")) {
        AttributeOperations.setAttribute(SNodeOperations.cast(fDecl, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration"), new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment")), doc);
      }
      MapSequence.fromMap(myJavadocs).put(start, doc);
    }

    return fDecl;
  }

  public SNode convertMethod(AbstractMethodDeclaration x, SNode container) throws JavaParseException {
    // false = we don't attach the method to the container for external clients 
    // they'll do it themselves 
    return convertMethod(container, x, false);
  }

  private SNode convertMethod(SNode cls, AbstractMethodDeclaration method, boolean attach) throws JavaParseException {
    SNode result = null;

    SNodeId sNodeId = cls.getSNodeId();
    // FIXME 
    String clsStringId = (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.AnonymousClass") || sNodeId instanceof SNodeId.Regular ?
      null :
      cls.getSNodeId().toString()
    );

    if (method instanceof MethodDeclaration) {
      if (flagSet(method.modifiers, ClassFileConstants.AccStatic) && SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration", null);
      } else if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Annotation")) {
        result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration", null);
      } else {
        result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration", null);
      }

      if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface")) {
        SPropertyOperations.set(SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"), "isAbstract", "" + (true));
        SLinkOperations.setTarget(SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"), "visibility", _quotation_createNode_rbndtb_a0b0c0g0l(), true);
      }

      convertMethodGuts((MethodDeclaration) method, clsStringId, result);

      if (attach) {
        ListSequence.fromList(SLinkOperations.getTargets(cls, "member", true)).addElement(SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.ClassifierMember"));
      }
    } else if (method instanceof ConstructorDeclaration) {

      result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", null);
      SLinkOperations.setTarget(result, "returnType", _quotation_createNode_rbndtb_a0c0a6a11(), true);

      convertMethodGuts(method, clsStringId, result);

      if (attach) {
        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "member", true)).addElement(SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration"));
      }
    }

    if (method.javadoc != null) {
      AttributeOperations.createAndSetAttrbiute(result, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.MethodDocComment")), "jetbrains.mps.baseLanguage.javadoc.structure.MethodDocComment");
      // <node> 
    }

    return result;
  }

  public List<SNode> convertClassContents(ASTNode[] astNodes, SNode container) throws JavaParseException {
    List<SNode> result = new ArrayList<SNode>();
    SNode node;

    for (ASTNode astNode : astNodes) {
      if (astNode instanceof TypeDeclaration) {
        node = convertTypeDecl((TypeDeclaration) astNode);

      } else if (astNode instanceof FieldDeclaration) {
        node = convertField((FieldDeclaration) astNode, container);

      } else if (astNode instanceof AbstractMethodDeclaration) {
        node = convertMethod((AbstractMethodDeclaration) astNode, container);

      } else {
        throw new IllegalArgumentException("Unexpected kind of eclipse ast node");
      }

      if ((node != null)) {
        ListSequence.fromList(result).addElement(node);
      }
    }
    return result;
  }

  public void convertTypeVars(TypeParameter[] pars, SNode result) throws JavaParseException {
    if (pars != null) {
      for (TypeParameter par : pars) {
        SNode typeVar = convertTypeVar(par);
        ListSequence.fromList(SLinkOperations.getTargets(result, "typeVariableDeclaration", true)).addElement(typeVar);
        myTypeResolver.addTypeVar(typeVar);
      }
    }
  }

  public SNode convertTypeVar(TypeParameter par) throws JavaParseException {
    SNode tvar = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration", null);
    SPropertyOperations.set(tvar, "name", new String(par.name));
    // TODO constraints like extends, super ... 
    if (par.type != null) {
      SLinkOperations.setTarget(tvar, "bound", convertTypeRef(par.type), true);
    }
    if (par.bounds != null) {
      for (TypeReference b : par.bounds) {
        // FIXME report or tolerate error if it's not a classifier type 
        ListSequence.fromList(SLinkOperations.getTargets(tvar, "auxBounds", true)).addElement(SNodeOperations.cast(convertTypeRef(b), "jetbrains.mps.baseLanguage.structure.ClassifierType"));
      }
    }
    return tvar;
  }

  public void convertAnnotations(Annotation[] annos, SNode result) throws JavaParseException {
    if (annos != null) {
      for (Annotation anno : annos) {
        SLinkOperations.getTargets(result, "annotation", true).add(convertAnnotation(anno));
      }
    }
  }

  public SNode convertAnnotation(Annotation anno) throws JavaParseException {
    TypeReference typRef = anno.type;

    String name;
    if (typRef instanceof SingleTypeReference) {
      name = new String(((SingleTypeReference) typRef).token);
    } else if (typRef instanceof QualifiedTypeReference) {
      StringBuffer sb = new StringBuffer();
      name = ((QualifiedTypeReference) typRef).print(0, sb).toString();
    } else {
      throw new RuntimeException("FIXME");
    }

    SNode node = myTypeResolver.resolveAnnotaion(name);
    for (MemberValuePair pair : anno.memberValuePairs()) {
      SNode val = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationInstanceValue", null);
      SReference ref = new DynamicReference("key", val, null, new String(pair.name));
      val.addReference(ref);
      // FIXME this will be convertExpressionRefl when I implement enum conversion there 
      SLinkOperations.setTarget(val, "value", convertExpression(pair.value), true);
      ListSequence.fromList(SLinkOperations.getTargets(node, "value", true)).addElement(val);
    }
    return node;
  }

  private SNode convertMethodGuts(@NotNull AbstractMethodDeclaration x, @Nullable String idPrefix, @NotNull SNode result) throws JavaParseException {

    StringBuilder idBuilder = (idPrefix == null ?
      null :
      new StringBuilder(idPrefix)
    );

    convertAnnotations(x.annotations, result);

    if (!(x instanceof ConstructorDeclaration)) {
      SPropertyOperations.set(result, "name", new String(x.selector));
    }
    // using eclipse selector because result.name is not set for constructors 
    check_rbndtb_a7a71(idBuilder, x);

    {
      SNode imd = result;
      if (SNodeOperations.isInstanceOf(imd, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
        if (flagSet(x.modifiers, ClassFileConstants.AccAbstract)) {
          SPropertyOperations.set(imd, "isAbstract", "" + (true));
        }
      }
    }

    myTypeResolver.newTypeVarFrame();
    convertTypeVars(x.typeParameters(), result);

    if (x.arguments != null) {
      for (Argument arg : x.arguments) {
        SNode par = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParameterDeclaration", null);
        convertAnnotations(arg.annotations, par);
        SPropertyOperations.set(par, "name", new String(arg.name));
        SLinkOperations.setTarget(par, "type", convertTypeRef(arg.type), true);
        ListSequence.fromList(SLinkOperations.getTargets(result, "parameter", true)).addElement(par);

        // <node> 
        check_rbndtb_a7a0a41a71(idBuilder, arg, this);
        check_rbndtb_a8a0a41a71(idBuilder);
      }
      // delete the last comma 
      if (x.arguments.length > 0) {
        check_rbndtb_a0a2a41a71(idBuilder, idBuilder);
      }
    }
    check_rbndtb_a51a71(idBuilder);

    if (x.thrownExceptions != null) {
      for (TypeReference exc : x.thrownExceptions) {
        ListSequence.fromList(SLinkOperations.getTargets(result, "throwsItem", true)).addElement(convertTypeRef(exc));
      }
    }

    if (!(myOnlyStubs)) {
      SLinkOperations.setTarget(result, "body", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null), true);
      handleMethodBody(result, x);

    } else {
      // make a different stub statement list 'source code' ? 
      SLinkOperations.setTarget(result, "body", _quotation_createNode_rbndtb_a0b0a91a71(), true);
    }

    {
      SNode mem = result;
      if (SNodeOperations.isInstanceOf(mem, "jetbrains.mps.baseLanguage.structure.ClassifierMember")) {
        if ((SLinkOperations.getTarget(mem, "visibility", true) == null)) {
          SLinkOperations.setTarget(mem, "visibility", convertVisibility(x.modifiers), true);
        }
      }
    }

    // doesn't make sense for constructor, but it's how it's done in baseLanguage.structure 
    SPropertyOperations.set(result, "isFinal", "" + (flagSet(x.modifiers, ClassFileConstants.AccFinal)));
    SPropertyOperations.set(result, "isSynchronized", "" + (flagSet(x.modifiers, ClassFileConstants.AccSynchronized)));

    if (x instanceof MethodDeclaration) {
      // Not a constructor 

      MethodDeclaration mDecl = (MethodDeclaration) x;
      SLinkOperations.setTarget(result, "returnType", convertTypeRef(mDecl.returnType), true);
    }

    if (idBuilder != null) {
      result.setId(new SNodeId.Foreign(idBuilder.toString()));
    }

    myTypeResolver.leaveTypeVarFrame();

    return result;
  }

  public SNode convertVisibility(int astModifiers) {
    // Bad code ? 
    return (flagSet(astModifiers, ClassFileConstants.AccPublic) ?
      _quotation_createNode_rbndtb_a0b0s() :
      (flagSet(astModifiers, ClassFileConstants.AccProtected) ?
        _quotation_createNode_rbndtb_a0a1a81() :
        (flagSet(astModifiers, ClassFileConstants.AccPrivate) ?
          _quotation_createNode_rbndtb_a0a0b0s() :
          null
        )
      )
    );
  }

  public SNode convertTypeRef(TypeReference typRef) throws JavaParseException {

    if (typRef == null) {
      return null;
    }

    SNode res;
    if (typRef instanceof SingleTypeReference) {
      res = convertUnqualTypeRef((SingleTypeReference) typRef);

    } else if (typRef instanceof QualifiedTypeReference) {
      res = convertQualifiedTypeRef((QualifiedTypeReference) typRef);

    } else {
      throw new JavaParseException("Unknown type reference kind in parsed java AST tree");
    }

    {
      SNode cls = res;
      if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
        TypeReference[] typeArgs = null;
        if (typRef instanceof ParameterizedQualifiedTypeReference) {
          // FIXME hack 
          ParameterizedQualifiedTypeReference parQRef = (ParameterizedQualifiedTypeReference) typRef;
          int last = parQRef.typeArguments.length - 1;
          typeArgs = parQRef.typeArguments[last];

        } else if (typRef instanceof ParameterizedSingleTypeReference) {
          typeArgs = ((ParameterizedSingleTypeReference) typRef).typeArguments;
        }
        if (typeArgs != null) {
          for (TypeReference typArg : typeArgs) {
            SNode argType = null;

            if (typArg instanceof Wildcard) {
              // it's a wildcard type of the form ? or ? extends ... or ? super ... 

              Wildcard wc = ((Wildcard) typArg);
              switch (wc.kind) {
                case Wildcard.UNBOUND:
                  argType = _quotation_createNode_rbndtb_a0a0a3a2a0a2a6a91();
                  break;

                case Wildcard.EXTENDS:
                  SNode upperBound = convertTypeRef(wc.bound);
                  argType = _quotation_createNode_rbndtb_a0b0b3a2a0a2a6a91(upperBound);
                  break;

                case Wildcard.SUPER:
                  SNode lowerBound = convertTypeRef(wc.bound);
                  argType = _quotation_createNode_rbndtb_a0b0c3a2a0a2a6a91(lowerBound);
                  break;

                default:
              }
            } else {
              // it's a normal type reference 
              argType = convertTypeRef(typArg);
            }

            if (argType != null) {
              ListSequence.fromList(SLinkOperations.getTargets(cls, "parameter", true)).addElement(argType);
            }
          }
        }
      }
    }
    return res;
  }

  public SNode convertUnqualTypeRef(SingleTypeReference typRef) {
    String unqualTyp = new String(typRef.token);
    SNode base = myTypeResolver.resolveShortTypeName(unqualTyp);
    if (typRef instanceof ArrayTypeReference && !(typRef instanceof ParameterizedSingleTypeReference)) {
      // it turns out this is an array, wrap base type in arraytype 
      // (in elicpse ParamSingleTypRef is subclass of ArrayTypRef) 
      return _quotation_createNode_rbndtb_a2a2a02(base);
    } else {
      return base;
    }
  }

  public SNode convertQualifiedTypeRef(QualifiedTypeReference typRef) {

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < typRef.tokens.length; i++) {
      if (i > 0) {
        sb.append(".");
      }
      sb.append(new String(typRef.tokens[i]));
    }
    String qname = sb.toString();

    SNode base = myTypeResolver.resolveQualifiedTypeName(qname);
    if (typRef instanceof ArrayQualifiedTypeReference && !(typRef instanceof ParameterizedQualifiedTypeReference)) {
      return _quotation_createNode_rbndtb_a0a6a12(base);
    } else {
      return base;
    }
  }

  public String typeReferenceId(TypeReference typ) {
    if (typ == null) {
      return null;
    }

    char[][] tokens = typ.getTypeName();
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < tokens.length; i++) {
      if (i > 0) {
        sb.append(".");
      }
      sb.append(new String(tokens[i]));
    }

    if (typ instanceof ArrayTypeReference && !(typ instanceof ParameterizedSingleTypeReference) || typ instanceof ArrayQualifiedTypeReference && !(typ instanceof ParameterizedQualifiedTypeReference)) {
      sb.append("[]");
    }

    return sb.toString();
  }

  public void addTypeArgs(TypeReference[] from, List<SNode> into) throws JavaParseException {
    if (from == null || from.length == 0) {
      return;
    }
    for (TypeReference typeRef : from) {
      ListSequence.fromList(into).addElement(convertTypeRef(typeRef));
    }
  }

  private boolean isEnumConstant(FieldDeclaration x) {
    return x.initialization != null && x.initialization instanceof AllocationExpression && ((AllocationExpression) x.initialization).enumConstant != null;
  }

  private String enumConstantName(FieldDeclaration x) {
    // Unsafe. supposed to be used after isEnumConstant 
    return new String(((AllocationExpression) x.initialization).enumConstant.name);
  }

  protected boolean flagSet(int bitmap, int flag) {
    return (bitmap & flag) != 0;
  }

  public String getTypeName(SNode type) {
    if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.PrimitiveType")) {
      // <node> 
      // <node> 
      return SPropertyOperations.getString(SNodeOperations.getConceptDeclaration(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.PrimitiveType")), "conceptAlias");
    } else if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
      // <node> 
      //  we'll do assert later when parser always returns dynamic refs 
      // <node> 
      if (SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ClassifierType").getReference("classifier") instanceof DynamicReference) {
        DynamicReference dynRef = (DynamicReference) SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ClassifierType").getReference("classifier");
        return dynRef.getResolveInfo();
      } else {
        return SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", false), "name");
      }
    } else if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
      return "Tv:" + SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.TypeVariableReference"), "typeVariableDeclaration", false), "name");
    } else {
      return "unk";
    }
  }

  public Map<Integer, SNode> getJavadocs() {
    return myJavadocs;
  }

  protected void handleMethodBody(SNode result, AbstractMethodDeclaration method) throws JavaParseException {
    // ignore by default: only stub structure 
    SLinkOperations.setTarget(result, "body", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null), true);
  }

  public SNode convertExpression(Expression x) throws JavaParseException {
    // maybe only something for annotations 
    return null;
  }

  protected ASTConverter withNewState(ASTConverter.State state) {
    return new ASTConverter.ASTConverterWithState(this, state);
  }

  protected ASTConverter.State getState() {
    return new ASTConverter.State(SNodeId.Foreign.ID_PREFIX);
  }

  protected static class State {
    private String myIdPrefix;

    public State(String idPrefix) {
      myIdPrefix = idPrefix;
    }

    public String getIdPrefix() {
      return myIdPrefix;
    }
  }

  private class ASTConverterWithState extends ASTConverter {
    private ASTConverter.State myState;

    private ASTConverterWithState(ASTConverter base, ASTConverter.State state) {
      super(base);
      myState = state;
    }

    public ASTConverter.State getState() {
      return myState;
    }
  }

  private static SNode _quotation_createNode_rbndtb_a0b0c0g0l() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PublicVisibility", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_rbndtb_a0c0a6a11() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.VoidType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static StringBuilder check_rbndtb_a7a71(StringBuilder checkedDotOperand, AbstractMethodDeclaration x) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.append("." + new String(x.selector) + "(");
    }
    return null;
  }

  private static StringBuilder check_rbndtb_a0a6a0a41a71(StringBuilder checkedDotOperand, SNode par, ASTConverter checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.append(checkedDotThisExpression.getTypeName(SLinkOperations.getTarget(par, "type", true)));
    }
    return null;
  }

  private static StringBuilder check_rbndtb_a7a0a41a71(StringBuilder checkedDotOperand, Argument arg, ASTConverter checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.append(checkedDotThisExpression.typeReferenceId(arg.type));
    }
    return null;
  }

  private static StringBuilder check_rbndtb_a8a0a41a71(StringBuilder checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.append(",");
    }
    return null;
  }

  private static StringBuilder check_rbndtb_a0a2a41a71(StringBuilder checkedDotOperand, StringBuilder idBuilder) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.deleteCharAt(check_rbndtb_a0a0a0c0o0r(idBuilder) - 1);
    }
    return null;
  }

  private static int check_rbndtb_a0a0a0c0o0r(StringBuilder checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.length();
    }
    return 0;
  }

  private static StringBuilder check_rbndtb_a51a71(StringBuilder checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.append(")");
    }
    return null;
  }

  private static SNode _quotation_createNode_rbndtb_a0b0a91a71() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StubStatementList", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_rbndtb_a0b0s() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PublicVisibility", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_rbndtb_a0a1a81() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ProtectedVisibility", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_rbndtb_a0a0b0s() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PrivateVisibility", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_rbndtb_a0a0a3a2a0a2a6a91() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.WildCardType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_rbndtb_a0b0b3a2a0a2a6a91(Object parameter_1) {
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.UpperBoundType", null, null, GlobalScope.getInstance(), false);
    quotedNode_3 = (SNode) parameter_1;
    if (quotedNode_3 != null) {
      quotedNode_2.addChild("bound", HUtil.copyIfNecessary(quotedNode_3));
    }
    return quotedNode_2;
  }

  private static SNode _quotation_createNode_rbndtb_a0b0c3a2a0a2a6a91(Object parameter_1) {
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.LowerBoundType", null, null, GlobalScope.getInstance(), false);
    quotedNode_3 = (SNode) parameter_1;
    if (quotedNode_3 != null) {
      quotedNode_2.addChild("bound", HUtil.copyIfNecessary(quotedNode_3));
    }
    return quotedNode_2;
  }

  private static SNode _quotation_createNode_rbndtb_a2a2a02(Object parameter_1) {
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ArrayType", null, null, GlobalScope.getInstance(), false);
    quotedNode_3 = (SNode) parameter_1;
    if (quotedNode_3 != null) {
      quotedNode_2.addChild("componentType", HUtil.copyIfNecessary(quotedNode_3));
    }
    return quotedNode_2;
  }

  private static SNode _quotation_createNode_rbndtb_a0a6a12(Object parameter_1) {
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ArrayType", null, null, GlobalScope.getInstance(), false);
    quotedNode_3 = (SNode) parameter_1;
    if (quotedNode_3 != null) {
      quotedNode_2.addChild("componentType", HUtil.copyIfNecessary(quotedNode_3));
    }
    return quotedNode_2;
  }
}
