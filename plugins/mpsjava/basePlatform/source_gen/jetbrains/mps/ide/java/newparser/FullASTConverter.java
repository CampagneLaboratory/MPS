package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.eclipse.jdt.internal.compiler.ast.Statement;
import org.eclipse.jdt.internal.compiler.ast.AssertStatement;
import org.eclipse.jdt.internal.compiler.ast.Block;
import org.eclipse.jdt.internal.compiler.ast.BreakStatement;
import org.eclipse.jdt.internal.compiler.ast.ContinueStatement;
import org.eclipse.jdt.internal.compiler.ast.DoStatement;
import org.eclipse.jdt.internal.compiler.ast.EmptyStatement;
import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.ForStatement;
import org.eclipse.jdt.internal.compiler.ast.ForeachStatement;
import org.eclipse.jdt.internal.compiler.ast.IfStatement;
import org.eclipse.jdt.internal.compiler.ast.LabeledStatement;
import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ReturnStatement;
import org.eclipse.jdt.internal.compiler.ast.SwitchStatement;
import org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;
import org.eclipse.jdt.internal.compiler.ast.ThrowStatement;
import org.eclipse.jdt.internal.compiler.ast.TryStatement;
import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
import org.eclipse.jdt.internal.compiler.ast.WhileStatement;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.UUID;
import org.eclipse.jdt.internal.compiler.ast.Initializer;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
import org.eclipse.jdt.internal.compiler.ast.ArrayReference;
import org.eclipse.jdt.internal.compiler.ast.Assignment;
import org.eclipse.jdt.internal.compiler.ast.BinaryExpression;
import org.eclipse.jdt.internal.compiler.ast.CastExpression;
import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
import org.eclipse.jdt.internal.compiler.ast.FieldReference;
import org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression;
import org.eclipse.jdt.internal.compiler.ast.Literal;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
import org.eclipse.jdt.internal.compiler.ast.ThisReference;
import org.eclipse.jdt.internal.compiler.ast.UnaryExpression;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.eclipse.jdt.internal.compiler.ast.CaseStatement;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression;
import org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression;
import org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;
import org.eclipse.jdt.internal.compiler.ast.EqualExpression;
import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
import org.eclipse.jdt.internal.compiler.ast.PostfixExpression;
import org.eclipse.jdt.internal.compiler.ast.PrefixExpression;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
import org.eclipse.jdt.internal.compiler.ast.SuperReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.DynamicReference;
import org.eclipse.jdt.internal.compiler.ast.NameReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
import jetbrains.mps.smodel.StaticReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.SModelUtil_new;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import jetbrains.mps.lang.typesystem.runtime.HUtil;

public class FullASTConverter extends ASTConverter {
  private Logger LOG = LogManager.getLogger(FullASTConverter.class);

  private CompilationUnitDeclaration myCud;
  private List<FullASTConverter.CodeBlock> myBlocks = ListSequence.fromList(new ArrayList<FullASTConverter.CodeBlock>());
  private Map<SNode, Integer> myPositions = MapSequence.fromMap(new HashMap<SNode, Integer>());

  public FullASTConverter(CompilationUnitDeclaration cud) {
    super(false);
  }
  private FullASTConverter(FullASTConverter base) {
    super(base);
  }
  public SNode convertStatementWrap(Statement x) throws JavaParseException {
    SNode stmt = convertStatement(x);
    if ((stmt != null)) {
      MapSequence.fromMap(myPositions).put(stmt, x.sourceEnd());
    }
    return stmt;
  }
  public SNode convertStatement(Statement x) throws JavaParseException {
    if (x instanceof AssertStatement) {
      return convertStatement((AssertStatement) x);
    } else if (x instanceof Block) {
      return convertStatement((Block) x);
    } else if (x instanceof BreakStatement) {
      return convertStatement((BreakStatement) x);
    } else if (x instanceof ContinueStatement) {
      return convertStatement((ContinueStatement) x);
    } else if (x instanceof DoStatement) {
      return convertStatement((DoStatement) x);
    } else if (x instanceof EmptyStatement) {
      return convertStatement((EmptyStatement) x);
    } else if (x instanceof ExplicitConstructorCall) {
      return convertStatement((ExplicitConstructorCall) x);
    } else if (x instanceof Expression) {
      return convertStatement((Expression) x);
    } else if (x instanceof ForStatement) {
      return convertStatement((ForStatement) x);
    } else if (x instanceof ForeachStatement) {
      return convertStatement((ForeachStatement) x);
    } else if (x instanceof IfStatement) {
      return convertStatement((IfStatement) x);
    } else if (x instanceof LabeledStatement) {
      return convertStatement((LabeledStatement) x);
    } else if (x instanceof LocalDeclaration) {
      return convertStatement((LocalDeclaration) x);
    } else if (x instanceof ReturnStatement) {
      return convertStatement((ReturnStatement) x);
    } else if (x instanceof SwitchStatement) {
      return convertStatement((SwitchStatement) x);
    } else if (x instanceof SynchronizedStatement) {
      return convertStatement((SynchronizedStatement) x);
    } else if (x instanceof ThrowStatement) {
      return convertStatement((ThrowStatement) x);
    } else if (x instanceof TryStatement) {
      return convertStatement((TryStatement) x);
    } else if (x instanceof TypeDeclaration) {
      return convertStatement((TypeDeclaration) x);
    } else if (x instanceof WhileStatement) {
      return convertStatement((WhileStatement) x);
    } else {
      return null;
    }

  }
  @Override
  protected void handleMethodBody(SNode result, AbstractMethodDeclaration x) throws JavaParseException {
    // <node> 
    convertStatementsInto(x, SLinkOperations.getTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123135l, "body")));
  }

  @Override
  public SNode convertInitializer(Initializer x) throws JavaParseException {

    SNode block = convertStatement(x.block);
    if (block == null) {
      return null;
    }

    SNode result;
    if (flagSet(x.modifiers, ClassFileConstants.AccStatic)) {
      SNode initCode = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticInitializer", null);
      SLinkOperations.setTarget(initCode, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1221737317277l, 1221737317278l, "statementList"), SLinkOperations.getTarget(block, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1082485599095l, 1082485599096l, "statements")));
      result = initCode;

    } else {
      SNode initCode = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceInitializer", null);
      SLinkOperations.setTarget(initCode, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1206629501431l, 1206629521979l, "statementList"), SLinkOperations.getTarget(block, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1082485599095l, 1082485599096l, "statements")));
      result = initCode;
    }

    return result;
  }

  @Override
  protected SNode convertEnumConst(FieldDeclaration x) throws JavaParseException {
    SNode constr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", null);
    // TODO 
    SNode enm = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration", null);
    SPropertyOperations.set(enm, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name"), enumConstantName(x));
    // <node> 
    // arguments of enum constant 
    Expression[] args = ((AllocationExpression) x.initialization).arguments;
    if (args != null) {
      for (Expression arg : args) {
        ListSequence.fromList(SLinkOperations.getChildren(enm, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1204053956946l, 1068499141038l, "actualArgument"))).addElement(convertExpression(arg));
      }
    }

    return enm;
  }

  public List<SNode> convertStatements(Statement[] ss) throws JavaParseException {
    List<SNode> result = new ArrayList<SNode>();
    if (ss != null) {
      for (Statement stmt : ss) {
        SNode statement = convertStatementWrap(stmt);
        if (statement != null) {
          result.add(statement);
        }
      }
    }
    return result;
  }
  public void convertStatementsInto(AbstractMethodDeclaration x, SNode bodyInto) throws JavaParseException {
    addBlock(bodyInto, x.declarationSourceStart, x.declarationSourceEnd);

    List<SNode> stmts = convertStatements(x.statements);

    if (x instanceof ConstructorDeclaration) {
      ExplicitConstructorCall cntrCall = ((ConstructorDeclaration) x).constructorCall;
      if (cntrCall != null) {
        SNode firstCntrCall = convertStatement(cntrCall);
        if (firstCntrCall != null) {
          ListSequence.fromList(stmts).insertElement(0, firstCntrCall);
        }
      }
    }

    ListSequence.fromList(SLinkOperations.getChildren(bodyInto, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, "statement"))).addSequence(ListSequence.fromList(stmts));
    // <node> 
  }
  public SNode convertExpressionWrap(Expression expression) throws JavaParseException {
    SNode result = convertExpression(expression);
    if (expression != null) {
      int parenthesisCount = (expression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;
      for (int parenthsCreated = 0; parenthsCreated < parenthesisCount; parenthsCreated++) {
        SNode parenthesizedExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
        SLinkOperations.setTarget(parenthesizedExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1079359253375l, 1079359253376l, "expression"), result);
        result = parenthesizedExpression;
      }
    }
    return result;
  }
  @Override
  public SNode convertExpression(Expression x) throws JavaParseException {
    if (x instanceof AllocationExpression) {
      return convertExpression((AllocationExpression) x);
    } else if (x instanceof ArrayAllocationExpression) {
      return convertExpression((ArrayAllocationExpression) x);
    } else if (x instanceof ArrayInitializer) {
      return convertExpression((ArrayInitializer) x);
    } else if (x instanceof ArrayReference) {
      return convertExpression((ArrayReference) x);
    } else if (x instanceof Assignment) {
      return convertExpression((Assignment) x);
    } else if (x instanceof BinaryExpression) {
      return convertExpression((BinaryExpression) x);
    } else if (x instanceof CastExpression) {
      return convertExpression((CastExpression) x);
    } else if (x instanceof ClassLiteralAccess) {
      return convertExpression((ClassLiteralAccess) x);
    } else if (x instanceof ConditionalExpression) {
      return convertExpression((ConditionalExpression) x);
    } else if (x instanceof FieldReference) {
      return convertExpression((FieldReference) x);
    } else if (x instanceof InstanceOfExpression) {
      return convertExpression((InstanceOfExpression) x);
    } else if (x instanceof Literal) {
      return convertExpression((Literal) x);
    } else if (x instanceof MessageSend) {
      return convertExpression((MessageSend) x);
    } else if (x instanceof QualifiedNameReference) {
      return convertExpression((QualifiedNameReference) x);
    } else if (x instanceof SingleNameReference) {
      return convertExpression((SingleNameReference) x);
    } else if (x instanceof ThisReference) {
      return convertExpression((ThisReference) x);
    } else if (x instanceof UnaryExpression) {
      return convertExpression((UnaryExpression) x);
    } else {
      if (x != null) {
        LOG.error("Unknown expression type: " + x.getClass().getName());
      }
      return null;
    }

  }
  /*package*/ List<SNode> convertExpressionStatements(Statement[] statements) throws JavaParseException {
    List<SNode> expressionStatements = new ArrayList<SNode>();
    if (statements != null) {
      for (int i = 0, n = statements.length; i < n; ++i) {
        SNode statement = convertStatementWrap(statements[i]);
        if ((statement != null)) {
          ListSequence.fromList(expressionStatements).addElement(SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.ExpressionStatement"));
        }
      }
    }
    return expressionStatements;
  }
  /*package*/ SNode convertStatement(Expression x) throws JavaParseException {
    SNode stmt = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ExpressionStatement", null);
    SLinkOperations.setTarget(stmt, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123155l, 1068580123156l, "expression"), convertExpressionWrap(x));
    return stmt;
  }
  /*package*/ SNode convertStatement(AssertStatement x) throws JavaParseException {
    SNode expr = convertExpressionWrap(x.assertExpression);
    SNode arg = convertExpressionWrap(x.exceptionArgument);
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AssertStatement", null);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1160998861373l, 1160998896846l, "condition"), expr);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1160998861373l, 1160998916832l, "message"), arg);
    return result;
  }
  /*package*/ SNode convertStatement(Block x) throws JavaParseException {
    if (x == null) {
      return null;
    }
    SNode blockStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BlockStatement", null);
    SNode statementList = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null);
    SLinkOperations.setTarget(blockStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1082485599095l, 1082485599096l, "statements"), statementList);
    addBlock(statementList, x.sourceStart(), x.sourceEnd());
    ListSequence.fromList(SLinkOperations.getChildren(statementList, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, "statement"))).addSequence(ListSequence.fromList(convertStatements(x.statements)));
    return blockStatement;
  }
  /*package*/ SNode convertStatement(BreakStatement x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BreakStatement", null);
    if (x.label != null) {
      SPropertyOperations.set(result, MetaAdapterFactory.getProperty(new UUID(-935030926396207931l, -6610165693999523818l), 1081855346303l, 1199466066648l, "label"), new String(x.label));
    }
    return result;
  }
  /*package*/ SNode convertStatement(SwitchStatement x) throws JavaParseException {
    SNode expression = convertExpressionWrap(x.expression);
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SwitchStatement", null);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163670490218l, 1163670766145l, "expression"), expression);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163670490218l, 1163670592366l, "defaultBlock"), SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null));
    // defaultCase is not set for me. Maybe eclipse sets it after resolving work 
    // <node> 
    if (x.statements != null) {
      SNode currentSwitchCase = null;
      for (Statement stmt : x.statements) {
        if (stmt instanceof CaseStatement) {
          // advance end of previous case block 
          if ((currentSwitchCase != null)) {
            getBlock(currentSwitchCase).setEndPos(stmt.sourceStart);
          }
          CaseStatement caseStatement = (CaseStatement) stmt;
          if (caseStatement.constantExpression == null) {
            currentSwitchCase = SLinkOperations.getTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163670490218l, 1163670592366l, "defaultBlock"));
            addBlock(SLinkOperations.getTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163670490218l, 1163670592366l, "defaultBlock")), caseStatement.sourceStart, caseStatement.sourceEnd);
          } else {
            SNode switchCase = convertCaseStatement((CaseStatement) stmt);
            if ((switchCase != null)) {
              ListSequence.fromList(SLinkOperations.getChildren(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163670490218l, 1163670772911l, "case"))).addElement(switchCase);
            }
            currentSwitchCase = ((switchCase == null) ? null : SLinkOperations.getTarget(switchCase, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163670641947l, 1163670683720l, "body")));
          }
        } else
        if ((currentSwitchCase != null)) {
          // advance end of case block 
          getBlock(currentSwitchCase).setEndPos(stmt.sourceEnd);
          ListSequence.fromList(SLinkOperations.getChildren(currentSwitchCase, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, "statement"))).addElement(convertStatementWrap(stmt));
        }
      }
      // adjust end of last case block up to the end of switch statement 
      if ((currentSwitchCase != null)) {
        getBlock(currentSwitchCase).setEndPos(x.sourceEnd);
      }
    }
    return result;
  }
  /*package*/ SNode convertCaseStatement(CaseStatement x) throws JavaParseException {
    SNode expression = convertExpressionWrap(x.constantExpression);
    SNode switchCase = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SwitchCase", null);
    SLinkOperations.setTarget(switchCase, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163670641947l, 1163670677455l, "expression"), expression);
    SLinkOperations.setTarget(switchCase, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163670641947l, 1163670683720l, "body"), SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null));
    addBlock(SLinkOperations.getTarget(switchCase, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163670641947l, 1163670683720l, "body")), x.sourceStart(), x.sourceEnd());
    return switchCase;
  }
  /*package*/ SNode convertStatement(ContinueStatement x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ContinueStatement", null);
    if (x.label != null) {
      // using new labels is commented out for now, something seems to be wrong with their scopes 
      // <node> 
      // <node> 
      SPropertyOperations.set(result, MetaAdapterFactory.getProperty(new UUID(-935030926396207931l, -6610165693999523818l), 1082113931046l, 1199470060942l, "label"), new String(x.label));
    }
    return result;
  }
  /*package*/ SNode convertStatement(DoStatement x) throws JavaParseException {
    SNode loopTest = convertExpressionWrap(x.condition);
    SNode loopBody = convertStatementWrap(x.action);
    SNode doWhileStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DoWhileStatement", null);
    SLinkOperations.setTarget(doWhileStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1177666668936l, 1177666688034l, "condition"), loopTest);
    SNode body = getStatementListFromStatement(loopBody, x.action);
    SLinkOperations.setTarget(doWhileStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1154032098014l, 1154032183016l, "body"), body);
    return doWhileStatement;
  }
  /*package*/ SNode convertStatement(EmptyStatement x) {
    return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Statement", null);
  }
  /*package*/ SNode convertStatement(LocalDeclaration x) throws JavaParseException {
    SNode decl = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", null);
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement", null);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068581242864l, 1068581242865l, "localVariableDeclaration"), decl);

    SPropertyOperations.set(decl, MetaAdapterFactory.getProperty(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, 1176718929932l, "isFinal"), "" + (flagSet(x.modifiers, ClassFileConstants.AccFinal)));
    SLinkOperations.setTarget(decl, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4972933694980447171l, 5680397130376446158l, "type"), convertTypeReference(x.type));
    SPropertyOperations.set(decl, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name"), new String(x.name));
    SLinkOperations.setTarget(decl, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, 1068431790190l, "initializer"), convertExpressionWrap(x.initialization));

    return result;
  }
  /*package*/ SNode convertStatement(ReturnStatement x) throws JavaParseException {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ReturnStatement", null);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068581242878l, 1068581517676l, "expression"), convertExpressionWrap(x.expression));
    return result;
  }
  /*package*/ SNode convertStatement(ExplicitConstructorCall x) throws JavaParseException {
    if (x.isImplicitSuper()) {
      return null;
    }

    SNode unkCall = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.UnknownConsCall", null);
    addCallArgs(unkCall, x.arguments);
    SPropertyOperations.set(unkCall, MetaAdapterFactory.getProperty(new UUID(-935030926396207931l, -6610165693999523818l), 9100188248702352244l, 9100188248702352610l, "isSuper"), "" + (x.isSuperAccess()));
    if (1 == 1) {
      return unkCall;
    }

    return unkCall;
  }
  /*package*/ SNode convertStatement(ForeachStatement x) throws JavaParseException {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ForeachStatement", null);
    SNode action = convertStatementWrap(x.action);
    SNode body = getStatementListFromStatement(action, x.action);


    SNode elementVar = SLinkOperations.getTarget(SNodeOperations.cast(convertStatement(x.elementVariable), "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement"), MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068581242864l, 1068581242865l, "localVariableDeclaration"));


    SNode iterable = convertExpressionWrap(x.collection);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1144226303539l, 1144226360166l, "iterable"), iterable);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1144230876926l, 1144230900587l, "variable"), elementVar);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1154032098014l, 1154032183016l, "body"), body);
    return result;
  }
  /*package*/ SNode convertStatement(ForStatement x) throws JavaParseException {
    SNode forStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ForStatement", null);
    List<SNode> init = convertStatements(x.initializations);
    SNode result = forStatement;
    if (ListSequence.fromList(init).any(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.ExpressionStatement");
      }
    })) {
      // we don't support for ( a=5, b=6; ...) {} in baseLanguage, workaround here 
      result = _quotation_createNode_f46ocm_a0b0d0ib(init, forStatement);
    } else if (!(init.isEmpty())) {
      boolean first = true;
      for (SNode statement : init) {
        if (SNodeOperations.isInstanceOf(statement, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement")) {
          SNode lvds = SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement");
          SNode variableDeclaration = SLinkOperations.getTarget(lvds, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068581242864l, 1068581242865l, "localVariableDeclaration"));
          if (first) {
            SLinkOperations.setTarget(forStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1144230876926l, 1144230900587l, "variable"), variableDeclaration);
            first = false;
          } else {
            SNode additionalForLoopVariable = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AdditionalForLoopVariable", null);
            SPropertyOperations.set(additionalForLoopVariable, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name"), SPropertyOperations.getString(variableDeclaration, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name")));
            SNode inititalizer = SLinkOperations.getTarget(variableDeclaration, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, 1068431790190l, "initializer"));
            if ((inititalizer != null)) {
              SLinkOperations.setTarget(additionalForLoopVariable, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068431474542l, 1068431790190l, "initializer"), inititalizer);
            }
            ListSequence.fromList(SLinkOperations.getChildren(forStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1144231330558l, 1032195626824963089l, "additionalVar"))).addElement(additionalForLoopVariable);
          }
        }
      }
    }
    SNode expr = convertExpressionWrap(x.condition);
    SLinkOperations.setTarget(forStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1144231330558l, 1144231399730l, "condition"), expr);
    List<SNode> incr = convertExpressionStatements(x.increments);
    if (!(incr.isEmpty())) {
      for (SNode expressionStatement : incr) {
        SNode expression = SLinkOperations.getTarget(expressionStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123155l, 1068580123156l, "expression"));
        SNodeOperations.detachNode(expression);
        ListSequence.fromList(SLinkOperations.getChildren(forStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1144231330558l, 1144231408325l, "iteration"))).addElement(expression);
      }
    }
    SNode loopBody = convertStatementWrap(x.action);
    SNode body = getStatementListFromStatement(loopBody, x.action);
    SLinkOperations.setTarget(forStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1154032098014l, 1154032183016l, "body"), body);
    return result;
  }
  /*package*/ SNode convertStatement(IfStatement x) throws JavaParseException {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IfStatement", null);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123159l, 1068580123160l, "condition"), convertExpressionWrap(x.condition));
    SNode thenStmt = convertStatementWrap(x.thenStatement);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123159l, 1082485599094l, "ifFalseStatement"), convertStatementWrap(x.elseStatement));
    SNode ifTrue = getStatementListFromStatement(thenStmt, x.thenStatement);
    // adjust start of the "if" statement list block to get comments from "if (...)" there 
    getBlock(ifTrue).setStartPos(x.sourceStart);
    // replacing the ifTrue node 
    // <node> 
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123159l, 1068580123161l, "ifTrue"), ifTrue);
    return result;
  }
  /*package*/ SNode convertStatement(LabeledStatement x) throws JavaParseException {
    SNode statement = convertStatementWrap(x.statement);
    if ((statement == null)) {
      return null;
    }

    if (x.statement instanceof ForStatement) {
      // we do a trick to get our resulting mps LoopStatement here 
      // because it could be converted into BlockStatement with the real loop inside 
      SNode loopStatement = ListSequence.fromList(SNodeOperations.getDescendants(statement, "jetbrains.mps.baseLanguage.structure.AbstractLoopStatement", true, new String[]{})).first();
      if ((loopStatement == null)) {
        return null;
      }
      SNode label = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LoopLabel", null);
      SPropertyOperations.set(label, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name"), new String(x.label));
      SLinkOperations.setTarget(loopStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1154032098014l, 363746191845183793l, "loopLabel"), label);

    } else
    if (SNodeOperations.isInstanceOf(statement, "jetbrains.mps.baseLanguage.structure.SwitchStatement")) {
      SNode switchStatement = SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.SwitchStatement");
      SNode label = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LoopLabel", null);
      SPropertyOperations.set(label, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name"), new String(x.label));
      SLinkOperations.setTarget(switchStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163670490218l, 4652593672361747214l, "switchLabel"), label);
    }

    return statement;
  }
  /*package*/ SNode convertStatement(SynchronizedStatement x) throws JavaParseException {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SynchronizedStatement", null);
    SNode block = convertStatement(x.block);
    SNode expr = convertExpressionWrap(x.expression);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1170075670744l, 1170075728144l, "expression"), expr);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1170075670744l, 1170075736412l, "block"), getStatementListFromStatement(block, x.block));
    return result;
  }
  /*package*/ SNode convertStatement(ThrowStatement x) throws JavaParseException {
    SNode toThrow = convertExpressionWrap(x.exception);
    SNode throwStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ThrowStatement", null);
    SLinkOperations.setTarget(throwStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1164991038168l, 1164991057263l, "throwable"), toThrow);
    return throwStatement;
  }
  /*package*/ SNode convertStatement(TryStatement x) throws JavaParseException {
    SNode tryBlock = convertStatement(x.tryBlock);
    List<SNode> catchArgs = new ArrayList<SNode>();
    List<SNode> catchBlocks = new ArrayList<SNode>();
    SNode finallyBlock = convertStatement(x.finallyBlock);
    if (x.catchBlocks != null) {
      for (int i = 0, c = x.catchArguments.length; i < c; ++i) {



        SNode local = SLinkOperations.getTarget(SNodeOperations.cast(convertStatement(x.catchArguments[i]), "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement"), MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068581242864l, 1068581242865l, "localVariableDeclaration"));



        ListSequence.fromList(catchArgs).addElement(local);
      }
      for (int i = 0, c = x.catchBlocks.length; i < c; ++i) {
        ListSequence.fromList(catchBlocks).addElement(convertStatement(x.catchBlocks[i]));
      }
    }
    if ((finallyBlock != null)) {
      SNode tryStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TryStatement", null);
      for (int i = 0; i < catchBlocks.size(); i++) {
        SNode catchBlock = ListSequence.fromList(catchBlocks).getElement(i);
        SNode lvd = ListSequence.fromList(catchArgs).getElement(i);
        SNode catchClause = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.CatchClause", null);
        ListSequence.fromList(SLinkOperations.getChildren(tryStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1153952380246l, 1164903700860l, "catchClause"))).addElement(catchClause);
        SLinkOperations.setTarget(catchClause, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1164903280175l, 1164903359218l, "catchBody"), getStatementListFromStatement(catchBlock, x.catchBlocks[i]));
        SLinkOperations.setTarget(catchClause, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1164903280175l, 1164903359217l, "throwable"), lvd);
      }
      SLinkOperations.setTarget(tryStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1153952380246l, 1153952429843l, "finallyBody"), getStatementListFromStatement(finallyBlock, x.finallyBlock));
      SLinkOperations.setTarget(tryStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1153952380246l, 1153952416686l, "body"), getStatementListFromStatement(tryBlock, x.tryBlock));
      return tryStatement;
    } else {
      SNode tryCatchStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TryCatchStatement", null);
      for (int i = 0; i < catchBlocks.size(); i++) {
        SNode catchBlock = ListSequence.fromList(catchBlocks).getElement(i);
        SNode lvd = ListSequence.fromList(catchArgs).getElement(i);
        SNode catchClause = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.CatchClause", null);
        ListSequence.fromList(SLinkOperations.getChildren(tryCatchStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1164879751025l, 1164903496223l, "catchClause"))).addElement(catchClause);
        SLinkOperations.setTarget(catchClause, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1164903280175l, 1164903359218l, "catchBody"), getStatementListFromStatement(catchBlock, x.catchBlocks[i]));
        SLinkOperations.setTarget(catchClause, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1164903280175l, 1164903359217l, "throwable"), lvd);
      }
      SLinkOperations.setTarget(tryCatchStatement, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1164879751025l, 1164879758292l, "body"), getStatementListFromStatement(tryBlock, x.tryBlock));
      return tryCatchStatement;
    }
  }
  /*package*/ SNode convertStatement(WhileStatement x) throws JavaParseException {
    SNode loopTest = convertExpressionWrap(x.condition);
    SNode loopBody = convertStatementWrap(x.action);
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.WhileStatement", null);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1076505808687l, 1076505808688l, "condition"), loopTest);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1154032098014l, 1154032183016l, "body"), getStatementListFromStatement(loopBody, x.action));
    return result;
  }
  /*package*/ SNode convertStatement(TypeDeclaration x) {
    LOG.error("Local type declarations are not supported");
    return null;
  }
  /*package*/ SNode convertBinaryOperation(Expression left, Expression right, SNode binaryOperation) throws JavaParseException {
    SLinkOperations.setTarget(binaryOperation, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1081773326031l, 1081773367580l, "leftExpression"), convertExpressionWrap(left));
    SLinkOperations.setTarget(binaryOperation, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1081773326031l, 1081773367579l, "rightExpression"), convertExpressionWrap(right));
    return binaryOperation;
  }
  /*package*/ SNode convertExpression(AND_AND_Expression x) throws JavaParseException {
    SNode andExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AndExpression", null);
    return convertBinaryOperation(x.left, x.right, andExpression);
  }
  /*package*/ SNode convertExpression(OR_OR_Expression x) throws JavaParseException {
    SNode orExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.OrExpression", null);
    return convertBinaryOperation(x.left, x.right, orExpression);
  }
  /*package*/ SNode convertExpression(ArrayAllocationExpression x) throws JavaParseException {
    SNode compType = convertTypeReference(x.type);
    if (x.initializer != null) {

      if (x.dimensions.length > 1) {
        compType = buildArrayType(compType, x.dimensions.length - 1, false);
      }

      List<SNode> initializers = new ArrayList<SNode>();
      if (x.initializer.expressions != null) {
        for (Expression expression : x.initializer.expressions) {
          ListSequence.fromList(initializers).addElement(convertExpressionWrap(expression));
        }
      }
      SNode arrayCreator = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayCreatorWithInitializer", null);
      for (SNode initializer : initializers) {
        ListSequence.fromList(SLinkOperations.getChildren(arrayCreator, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1154542696413l, 1154542803372l, "initValue"))).addElement(initializer);
      }
      SLinkOperations.setTarget(arrayCreator, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1154542696413l, 1154542793668l, "componentType"), compType);
      SNode genericNewExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
      SLinkOperations.setTarget(genericNewExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1145552977093l, 1145553007750l, "creator"), arrayCreator);
      return genericNewExpression;
    } else {
      List<SNode> dims = new ArrayList<SNode>();
      for (Expression dimension : x.dimensions) {
        if (dimension == null) {
          ListSequence.fromList(dims).addElement(null);
        } else {
          ListSequence.fromList(dims).addElement(convertExpressionWrap(dimension));
        }
      }
      SNode arrayCreator = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayCreator", null);
      for (SNode dim : dims) {
        SNode dimensionExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DimensionExpression", null);
        ListSequence.fromList(SLinkOperations.getChildren(arrayCreator, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1184950988562l, 1184952969026l, "dimensionExpression"))).addElement(dimensionExpression);
        if (dim != null) {
          SLinkOperations.setTarget(dimensionExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1184952934362l, 1184953288404l, "expression"), dim);
        }
      }
      SNode deepestComponentType = compType;
      while (SNodeOperations.isInstanceOf(deepestComponentType, "jetbrains.mps.baseLanguage.structure.ArrayType")) {
        deepestComponentType = SLinkOperations.getTarget(SNodeOperations.cast(deepestComponentType, "jetbrains.mps.baseLanguage.structure.ArrayType"), MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1070534760951l, 1070534760952l, "componentType"));
      }
      SLinkOperations.setTarget(arrayCreator, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1184950988562l, 1184951007469l, "componentType"), deepestComponentType);
      SNode genericNewExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
      SLinkOperations.setTarget(genericNewExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1145552977093l, 1145553007750l, "creator"), arrayCreator);
      return genericNewExpression;
    }
  }
  /*package*/ SNode convertExpression(ArrayInitializer x) throws JavaParseException {
    List<SNode> initializers = new ArrayList<SNode>();
    if (x.expressions != null) {
      for (Expression expression : x.expressions) {
        ListSequence.fromList(initializers).addElement(convertExpressionWrap(expression));
      }
    }
    SNode arrayLiteral = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayLiteral", null);
    for (SNode initializer : initializers) {
      ListSequence.fromList(SLinkOperations.getChildren(arrayLiteral, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1188220165133l, 1188220173759l, "item"))).addElement(initializer);
    }
    return arrayLiteral;
  }
  /*package*/ SNode convertExpression(ArrayReference x) throws JavaParseException {
    SNode accessExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayAccessExpression", null);
    SLinkOperations.setTarget(accessExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1173175405605l, 1173175590490l, "array"), convertExpressionWrap(x.receiver));
    SLinkOperations.setTarget(accessExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1173175405605l, 1173175577737l, "index"), convertExpressionWrap(x.position));
    return accessExpression;
  }
  /*package*/ SNode convertExpression(Assignment x) throws JavaParseException {
    if (x instanceof CompoundAssignment) {
      return convertExpression((CompoundAssignment) x);
    } else {
      SNode assignmentExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AssignmentExpression", null);
      SLinkOperations.setTarget(assignmentExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886295l, "lValue"), convertExpressionWrap(x.lhs));
      SLinkOperations.setTarget(assignmentExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886297l, "rValue"), convertExpressionWrap(x.expression));
      return assignmentExpression;
    }

  }
  /*package*/ SNode convertExpression(BinaryExpression x) throws JavaParseException {
    if (x instanceof AND_AND_Expression) {
      return convertExpression((AND_AND_Expression) x);
    } else if (x instanceof EqualExpression) {
      return convertExpression((EqualExpression) x);
    } else if (x instanceof OR_OR_Expression) {
      return convertExpression((OR_OR_Expression) x);
    } else {
      SNode op;
      int binOp = (x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT;
      switch (binOp) {
        case OperatorIds.LEFT_SHIFT:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShiftLeftExpression", null);
          break;
        case OperatorIds.RIGHT_SHIFT:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShiftRightExpression", null);
          break;
        case OperatorIds.UNSIGNED_RIGHT_SHIFT:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShiftRightUnsignedExpression", null);
          break;
        case OperatorIds.PLUS:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PlusExpression", null);
          break;
        case OperatorIds.MINUS:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.MinusExpression", null);
          break;
        case OperatorIds.REMAINDER:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.RemExpression", null);
          break;
        case OperatorIds.XOR:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseXorExpression", null);
          break;
        case OperatorIds.AND:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseAndExpression", null);
          break;
        case OperatorIds.MULTIPLY:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.MulExpression", null);
          break;
        case OperatorIds.OR:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseOrExpression", null);
          break;
        case OperatorIds.DIVIDE:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DivExpression", null);
          break;
        case OperatorIds.LESS_EQUAL:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LessThanOrEqualsExpression", null);
          break;
        case OperatorIds.GREATER_EQUAL:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GreaterThanOrEqualsExpression", null);
          break;
        case OperatorIds.GREATER:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GreaterThanExpression", null);
          break;
        case OperatorIds.LESS:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LessThanExpression", null);
          break;
        default:
          throw new JavaParseException("Unsupported operator for BinaryExpression");
      }
      return convertBinaryOperation(x.left, x.right, op);
    }

  }
  /*package*/ SNode convertExpression(CompoundAssignment x) throws JavaParseException {
    if (x instanceof PostfixExpression) {
      return convertExpression((PostfixExpression) x);
    } else if (x instanceof PrefixExpression) {
      return convertExpression((PrefixExpression) x);
    } else {
      SNode op;
      switch (x.operator) {
        case OperatorIds.PLUS:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PlusAssignmentExpression", null);
          break;
        case OperatorIds.MINUS:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.MinusAssignmentExpression", null);
          break;
        case OperatorIds.MULTIPLY:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.MulAssignmentExpression", null);
          break;
        case OperatorIds.DIVIDE:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DivAssignmentExpression", null);
          break;
        case OperatorIds.AND:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AndAssignmentExpression", null);
          break;
        case OperatorIds.OR:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.OrAssignmentExpression", null);
          break;
        case OperatorIds.XOR:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.XorAssignmentExpression", null);
          break;
        case OperatorIds.REMAINDER:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.RemAssignmentExpression", null);
          break;
        case OperatorIds.LEFT_SHIFT:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LeftShiftAssignmentExpression", null);
          break;
        case OperatorIds.RIGHT_SHIFT:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.RightShiftAssignmentExpression", null);
          break;
        case OperatorIds.UNSIGNED_RIGHT_SHIFT:
          op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.UnsignedRightShiftAssignmentExpression", null);
          break;
        default:
          throw new JavaParseException("Unsupported operator for CompoundAssignment");
      }
      SLinkOperations.setTarget(op, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886295l, "lValue"), convertExpressionWrap(x.lhs));
      SLinkOperations.setTarget(op, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1215693861676l, 1068498886297l, "rValue"), convertExpressionWrap(x.expression));
      return op;
    }

  }
  /*package*/ SNode convertExpression(ConditionalExpression x) throws JavaParseException {
    SNode ifTest = convertExpressionWrap(x.condition);
    SNode thenExpr = convertExpressionWrap(x.valueIfTrue);
    SNode elseExpr = convertExpressionWrap(x.valueIfFalse);
    SNode tOp = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression", null);
    SLinkOperations.setTarget(tOp, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163668896201l, 1163668914799l, "condition"), ifTest);
    SLinkOperations.setTarget(tOp, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163668896201l, 1163668922816l, "ifTrue"), thenExpr);
    SLinkOperations.setTarget(tOp, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1163668896201l, 1163668934364l, "ifFalse"), elseExpr);
    return tOp;
  }
  /*package*/ SNode convertExpression(EqualExpression x) throws JavaParseException {
    SNode op;
    switch ((x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) {
      case OperatorIds.EQUAL_EQUAL:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EqualsExpression", null);
        break;
      case OperatorIds.NOT_EQUAL:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.NotEqualsExpression", null);
        break;
      default:
        throw new JavaParseException("Unexpected operator for EqualExpression");
    }
    return convertBinaryOperation(x.left, x.right, op);
  }
  /*package*/ SNode convertExpression(InstanceOfExpression x) throws JavaParseException {
    SNode expr = convertExpressionWrap(x.expression);
    SNode testType = convertTypeReference(x.type);
    SNode instanceOfExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceOfExpression", null);
    SLinkOperations.setTarget(instanceOfExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1081256982272l, 1081256993304l, "leftExpression"), expr);
    SLinkOperations.setTarget(instanceOfExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1081256982272l, 1081256993305l, "classType"), testType);
    return instanceOfExpression;
  }
  /*package*/ SNode convertExpression(PostfixExpression x) throws JavaParseException {
    SNode op;
    switch (x.operator) {
      case OperatorIds.MINUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PostfixDecrementExpression", null);
        break;
      case OperatorIds.PLUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PostfixIncrementExpression", null);
        break;
      default:
        throw new JavaParseException("Unexpected postfix operator");
    }
    SLinkOperations.setTarget(op, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1239714755177l, 1239714902950l, "expression"), convertExpressionWrap(x.lhs));
    return op;
  }
  /*package*/ SNode convertExpression(PrefixExpression x) throws JavaParseException {
    SNode op;
    switch (x.operator) {
      case OperatorIds.MINUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PrefixDecrementExpression", null);
        break;
      case OperatorIds.PLUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PrefixIncrementExpression", null);
        break;
      default:
        throw new JavaParseException("Unexpected prefix operator");
    }
    SLinkOperations.setTarget(op, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1239714755177l, 1239714902950l, "expression"), convertExpressionWrap(x.lhs));
    return op;
  }
  /*package*/ SNode convertExpression(CastExpression x) throws JavaParseException {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.CastExpression", null);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1070534934090l, 1070534934092l, "expression"), convertExpressionWrap(x.expression));

    // x.type is expression, not type reference 
    // we're making TypeReference out of NameReference 
    // <node> 
    // <node> 

    // in idea 12's eclipse parser seems to give us type reference right away 
    if (!(x.type instanceof TypeReference)) {
      LOG.error("Class in class cast expession is not a type reference. Class name: " + x.type.toString());
      return null;
    }

    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1070534934090l, 1070534934091l, "type"), convertTypeReference(x.type));
    return result;
  }
  /*package*/ SNode convertExpression(NullLiteral x) {
    return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.NullLiteral", null);
  }
  /*package*/ SNode convertExpression(SuperReference x) throws JavaParseException {
    // <node> 
    return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Expression", null);
  }
  /*package*/ SNode convertExpression(ThisReference x) throws JavaParseException {
    if (x instanceof QualifiedThisReference) {
      return convertExpression((QualifiedThisReference) x);
    } else if (x instanceof SuperReference) {
      return convertExpression((SuperReference) x);
    } else {
      return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ThisExpression", null);
    }

  }
  /*package*/ SNode convertExpression(QualifiedThisReference x) throws JavaParseException {
    SNode thisRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ThisExpression", null);
    SNode type = convertTypeReference(x.qualification);
    if (!(SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.ClassifierType"))) {
      throw new JavaParseException("Type should be class in qualified this reference");
    }
    SReference sref = adjustClassReference(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ClassifierType"), thisRef, "classConcept");
    thisRef.setReference(sref.getRole(), sref);
    return thisRef;
  }
  /*package*/ SNode convertExpression(SingleNameReference x) {
    SNode varRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.VariableReference", null);
    SReference sref = new DynamicReference("variableDeclaration", varRef, null, new String(x.token));
    varRef.setReference(sref.getRole(), sref);
    return varRef;
  }
  /*package*/ SNode convertExpression(QualifiedNameReference x) {
    String[] tokens = new String[x.tokens.length];
    if (tokens.length == 0) {
      return null;
    }

    SNode unkName = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.UnknownNameRef", null);
    StringBuilder sb = new StringBuilder();

    for (int i = 0; i < tokens.length; i++) {
      sb.append(x.tokens[i]);
      sb.append('.');
    }
    sb.deleteCharAt(sb.length() - 1);

    SPropertyOperations.set(unkName, MetaAdapterFactory.getProperty(new UUID(-935030926396207931l, -6610165693999523818l), 6528213125912070246l, 1843920760191311250l, "tokens"), sb.toString());
    return unkName;
  }
  /*package*/ SNode convertExpression(MessageSend x) throws JavaParseException {
    // it's a method call 
    //  results in either LocalStaticMethodCall, LocalInstanceMethodCall, StaticMethodCall 
    //  or DotExpression with MethodCallOperation 

    String methodName = new String(x.selector);
    SNode result = null;
    SNode call = null;

    if (x.receiver instanceof ThisReference && ((ThisReference) x.receiver).isImplicitThis()) {
      // it's a local call, f() 

      // <node> 
      // <node> 

      SNode lmc = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LocalMethodCall", null);
      org.jetbrains.mps.openapi.model.SReference ref = new DynamicReference("baseMethodDeclaration", lmc, null, methodName);
      lmc.setReference("baseMethodDeclaration", ref);

      result = lmc;
      call = lmc;

    } else {
      // it's something.method(...) 
      // let's see if 'something' is SingleNameRef or QualifiedNameRef; if yes let's see if it's a class 
      // if either it's not a name ref or not a class then handle it just as some random expression 

      Expression receiver = x.receiver;

      if (receiver instanceof NameReference) {
        // handle this special case 

        SNode unkDotCall = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.UnknownDotCall", null);
        SPropertyOperations.set(unkDotCall, MetaAdapterFactory.getProperty(new UUID(-935030926396207931l, -6610165693999523818l), 2621000434129553333l, 4872723285943177972l, "callee"), methodName);

        String[] tokens;

        if (x.receiver instanceof SingleNameReference) {
          tokens = new String[1];
          tokens[0] = new String(((SingleNameReference) x.receiver).token);

        } else if (x.receiver instanceof QualifiedNameReference) {
          QualifiedNameReference nameRef = ((QualifiedNameReference) x.receiver);
          tokens = new String[nameRef.tokens.length];
          for (int i = 0; i < tokens.length; i++) {
            tokens[i] = new String(nameRef.tokens[i]);
          }

        } else {
          // TODO report error 
          return null;
        }

        StringBuilder sb = new StringBuilder();
        for (String tok : tokens) {
          sb.append(tok);
          sb.append('.');
        }
        sb.deleteCharAt(sb.length() - 1);

        SPropertyOperations.set(unkDotCall, MetaAdapterFactory.getProperty(new UUID(-935030926396207931l, -6610165693999523818l), 6528213125912070246l, 1843920760191311250l, "tokens"), sb.toString());

        result = unkDotCall;
        call = unkDotCall;

      } else if (x.receiver instanceof SuperReference) {
        SNode smc = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SuperMethodCall", null);
        org.jetbrains.mps.openapi.model.SReference ref = new DynamicReference("baseMethodDeclaration", smc, null, methodName);
        smc.setReference(ref.getRole(), ref);

        result = smc;
        call = smc;

      } else {
        // we can already know that it should be an InstanceMethodCall 

        SNode dotExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DotExpression", null);
        SLinkOperations.setTarget(dotExpr, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1197027756228l, 1197027771414l, "operand"), convertExpressionWrap(x.receiver));

        SNode instCall = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation", null);
        SLinkOperations.setTarget(dotExpr, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1197027756228l, 1197027833540l, "operation"), instCall);

        org.jetbrains.mps.openapi.model.SReference sref = new DynamicReference("baseMethodDeclaration", instCall, null, methodName);
        instCall.setReference(sref.getRole(), sref);

        result = dotExpr;
        call = instCall;
      }
    }

    if ((call != null)) {
      addCallArgs(call, x.arguments);
      addTypeArgs(x.typeArguments, SLinkOperations.getChildren(call, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1204053956946l, 4972241301747169160l, "typeArgument")));
    }
    return result;
  }
  public void addCallArgs(SNode call, Expression[] args) throws JavaParseException {
    if (args == null) {
      return;
    }
    for (Expression arg : args) {
      ListSequence.fromList(SLinkOperations.getChildren(call, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1204053956946l, 1068499141038l, "actualArgument"))).addElement(convertExpressionWrap(arg));
    }
  }
  /*package*/ SNode convertExpression(FieldReference x) throws JavaParseException {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DotExpression", null);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1197027756228l, 1197027771414l, "operand"), convertExpressionWrap(x.receiver));
    SNode fieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldReferenceOperation", null);
    SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1197027756228l, 1197027833540l, "operation"), fieldRef);
    SReference sref = new DynamicReference("fieldDeclaration", fieldRef, null, new String(x.token));
    fieldRef.setReference(sref.getRole(), sref);
    return result;
  }
  /*package*/ SNode convertExpression(AllocationExpression x) throws JavaParseException {
    if (x instanceof QualifiedAllocationExpression) {
      return convertExpression((QualifiedAllocationExpression) x);
    } else {

      SNode unkNew = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.UnknownNew", null);
      addCallArgs(unkNew, x.arguments);
      addTypeArgs(typeArguments(x.type), SLinkOperations.getChildren(unkNew, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1204053956946l, 4972241301747169160l, "typeArgument")));
      SPropertyOperations.set(unkNew, MetaAdapterFactory.getProperty(new UUID(-935030926396207931l, -6610165693999523818l), 3304084122476667220l, 3304084122476721463l, "className"), typeName(x.type));

      return unkNew;
    }

  }
  private SNode findConstructor(SNode claz, Expression[] args) {
    SNode result;
    Iterable<SNode> conss = BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), claz, "jetbrains.mps.baseLanguage.structure.ClassConcept", "call_constructors_5292274854859503373", new Object[]{});
    if (Sequence.fromIterable(conss).isEmpty()) {
      result = null;
    } else if (Sequence.fromIterable(conss).count() == 1) {
      result = Sequence.fromIterable(conss).first();
    } else {
      final int argCount = args.length;
      Iterable<SNode> subset = Sequence.fromIterable(conss).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return ListSequence.fromList(SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123132l, 1068580123134l, "parameter"))).count() == argCount;
        }
      });
      result = Sequence.fromIterable(subset).first();
    }
    return result;
  }
  /*package*/ SNode convertExpression(QualifiedAllocationExpression x) throws JavaParseException {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
    SNode create = null;
    if (x.anonymousType != null) {
      SNode anonCreate = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnonymousClassCreator", null);
      create = anonCreate;
      SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1145552977093l, 1145553007750l, "creator"), anonCreate);
      SNode cls = SNodeOperations.cast(convertTypeDecl(x.anonymousType), "jetbrains.mps.baseLanguage.structure.AnonymousClass");
      SLinkOperations.setTarget(anonCreate, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1182160077978l, 1182160096073l, "cls"), cls);
      addReference(x.type, cls, "classifier");
      addCallArgs(cls, x.arguments);
      addTypeArgs(typeArguments(x.type), SLinkOperations.getChildren(cls, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1170345865475l, 1201186121363l, "typeParameter")));
    } else {
      // TODO what is enclosing instance? handle it 
      if (x.enclosingInstance() == null) {
        return convertExpression((AllocationExpression) x);
      }
    }

    return result;
  }
  public int addReference(TypeReference typeRef, SNode source, String role) {
    if (typeRef instanceof QualifiedTypeReference) {
      return addReference((QualifiedTypeReference) typeRef, source, role);
    } else if (typeRef instanceof SingleTypeReference) {
      return addReference((SingleTypeReference) typeRef, source, role);
    } else {
      LOG.error("Unexpected kind of type reference: " + typeRef.getClass().getName());
      return 0;
    }

  }
  public int addReference(SingleTypeReference typeRef, SNode source, String role) {
    org.jetbrains.mps.openapi.model.SReference ref = new DynamicReference(role, source, null, new String(typeRef.token));
    source.setReference(role, ref);
    return 1;
  }
  public int addReference(QualifiedTypeReference typeRef, SNode source, String role) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < typeRef.tokens.length; i++) {
      if (i > 0) {
        sb.append(".");
      }
      sb.append(new String(typeRef.tokens[i]));
    }
    String qname = sb.toString();

    org.jetbrains.mps.openapi.model.SReference ref = new DynamicReference(role, source, null, qname);
    source.setReference(role, ref);
    return 2;
  }

  /*package*/ SNode convertExpression(ClassLiteralAccess x) throws JavaParseException {
    SNode argType = convertTypeReference(x.type);

    if (SNodeOperations.isInstanceOf(argType, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
      SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierClassExpression", null);
      SReference sref = adjustClassReference(SNodeOperations.cast(argType, "jetbrains.mps.baseLanguage.structure.ClassifierType"), result, "classifier");
      result.setReference(sref.getRole(), sref);
      return result;

    } else if (SNodeOperations.isInstanceOf(argType, "jetbrains.mps.baseLanguage.structure.ArrayType")) {
      SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayClassExpression", null);
      SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1251851371723515367l, 1251851371723515368l, "arrayType"), argType);
      return result;
    } else if (SNodeOperations.isInstanceOf(argType, "jetbrains.mps.baseLanguage.structure.PrimitiveType")) {
      SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PrimitiveClassExpression", null);
      SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 4564374268190696673l, 4564374268190696674l, "primitiveType"), argType);
      return result;
    } else {
      throw new JavaParseException("Type in class literal access is expected to be classifier or array type");
    }
  }
  /*package*/ SNode convertExpression(UnaryExpression x) throws JavaParseException {
    int operator = ((x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT);
    switch (operator) {
      case OperatorIds.MINUS:
        SNode unaryMinus = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.UnaryMinus", null);
        SLinkOperations.setTarget(unaryMinus, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1239714755177l, 1239714902950l, "expression"), convertExpressionWrap(x.expression));
        return unaryMinus;
      case OperatorIds.NOT:
        SNode notExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.NotExpression", null);
        SLinkOperations.setTarget(notExpression, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1081516740877l, 1081516765348l, "expression"), convertExpressionWrap(x.expression));
        return notExpression;
      case OperatorIds.PLUS:
        return convertExpressionWrap(x.expression);
      case OperatorIds.TWIDDLE:
        SNode twiddle = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseNotExpression", null);
        SLinkOperations.setTarget(twiddle, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1225894555487l, 1225894555490l, "expression"), convertExpressionWrap(x.expression));
        return twiddle;
      default:
        throw new JavaParseException("Unexpected operator for unary expression");
    }
  }

  private SReference adjustClassReference(SNode clsType, SNode source, String role) {
    org.jetbrains.mps.openapi.model.SReference sref = clsType.getReference("classifier");
    if (sref instanceof DynamicReference) {
      return new DynamicReference(role, source, null, ((DynamicReference) sref).getResolveInfo());
    } else if (sref instanceof StaticReference) {
      return new StaticReference(role, source, ((StaticReference) sref).getTargetNode());
    } else {
      throw new RuntimeException("Unknown type of reference: " + sref.getClass().getName());
    }
  }
  private SNode getStatementListFromStatement(SNode possibleBlock, Statement x) {
    SNode result;
    if (SNodeOperations.isInstanceOf(possibleBlock, "jetbrains.mps.baseLanguage.structure.BlockStatement")) {
      result = SLinkOperations.getTarget(SNodeOperations.cast(possibleBlock, "jetbrains.mps.baseLanguage.structure.BlockStatement"), MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1082485599095l, 1082485599096l, "statements"));
      // FIXME should detach be called here? it depends on whether we're already in a model... 
      // <node> 
    } else {
      result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null);
      addBlock(result, x.sourceStart(), x.sourceEnd());
      if ((possibleBlock != null)) {
        ListSequence.fromList(SLinkOperations.getChildren(result, MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l, -6610165693999523818l), 1068580123136l, 1068581517665l, "statement"))).addElement(possibleBlock);
      }
    }
    return result;
  }
  public TypeReference nameRefToTypeRef(Expression x) {
    TypeReference myTypeRef = null;
    if (x instanceof SingleNameReference) {
      myTypeRef = new SingleTypeReference(((SingleNameReference) x).token, -1);
    } else if (x instanceof QualifiedNameReference) {
      myTypeRef = new QualifiedTypeReference(((QualifiedNameReference) x).tokens, new long[]{-1});
    }
    return myTypeRef;
  }
  private String typeName(TypeReference typeRef) {
    char[][] tokens = typeRef.getTypeName();
    if (tokens == null || tokens.length == 0) {
      return null;
    }

    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < tokens.length; i++) {
      if (i > 0) {
        sb.append('.');
      }
      sb.append(tokens[i]);
    }
    return sb.toString();
  }
  public TypeReference[] typeArguments(TypeReference typeRef) {
    if (typeRef instanceof ParameterizedSingleTypeReference) {
      return ((ParameterizedSingleTypeReference) typeRef).typeArguments;
    } else if (typeRef instanceof ParameterizedQualifiedTypeReference) {
      // ignoring type arguments in not last components, e.g. Class1<T>.Class2 
      TypeReference[][] allArgs = ((ParameterizedQualifiedTypeReference) typeRef).typeArguments;
      // return only type arguments of the last component 
      return allArgs[allArgs.length - 1];
    } else {
      return new TypeReference[0];
    }
  }
  public Map<SNode, Integer> getPositions() {
    return myPositions;
  }
  public Iterable<FullASTConverter.CodeBlock> getCodeBlocks() {
    return myBlocks;
  }
  private void addBlock(SNode node, int start, int end) {
    ListSequence.fromList(myBlocks).addElement(new FullASTConverter.CodeBlock(node, myCud, Math.abs(start), Math.abs(end)));
  }
  private FullASTConverter.CodeBlock getBlock(final SNode node) {
    return ListSequence.fromList(myBlocks).findFirst(new IWhereFilter<FullASTConverter.CodeBlock>() {
      public boolean accept(FullASTConverter.CodeBlock it) {
        return it.getStatementList() == node;
      }
    });
  }
  private SNode findBlock(final int sourcePos) {
    long min = Long.MAX_VALUE;
    SNode stmt = null;

    // we could maintain the stack of blocks 
    // then we would just take the topmost element from the stack 
    for (FullASTConverter.CodeBlock block : ListSequence.fromList(myBlocks).where(new IWhereFilter<FullASTConverter.CodeBlock>() {
      public boolean accept(FullASTConverter.CodeBlock it) {
        return it.getStartPos() <= sourcePos && sourcePos <= it.getEndPos();
      }
    })) {
      long w = block.getEndPos() - block.getStartPos();
      if (w < min) {
        min = w;
        stmt = block.getStatementList();
      }
    }

    return stmt;
  }
  public class CodeBlock {
    private CompilationUnitDeclaration cud;
    public CodeBlock(SNode n, CompilationUnitDeclaration d, int s, int e) {
      setStatementList(n);
      cud = d;
      setStartPos(s);
      setEndPos(e);
    }
    private SNode myStatementList;
    public SNode getStatementList() {
      return this.myStatementList;
    }
    private void setStatementList(SNode value) {
      this.myStatementList = value;
    }
    private int myStartPos;
    public int getStartPos() {
      return this.myStartPos;
    }
    private void setStartPos(int value) {
      this.myStartPos = value;
    }
    private int myEndPos;
    public int getEndPos() {
      return this.myEndPos;
    }
    private void setEndPos(int value) {
      this.myEndPos = value;
    }
  }
  @Override
  protected FullASTConverter withNewState(ASTConverter.State state) {
    return new FullASTConverter.FullASTConverterWithState(this, state);
  }
  private class FullASTConverterWithState extends FullASTConverter {
    private ASTConverter.State myState;
    private FullASTConverterWithState(FullASTConverter base, ASTConverter.State state) {
      super(base);
      myState = state;
    }
    @Override
    public ASTConverter.State getState() {
      return myState;
    }
  }
  private static SNode _quotation_createNode_f46ocm_a0b0d0ib(Object parameter_1, Object parameter_2) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode quotedNode_3 = null;
    SNode quotedNode_4 = null;
    SNode quotedNode_5 = null;
    SNode quotedNode_6 = null;
    SNode quotedNode_7 = null;
    SNode quotedNode_8 = null;
    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.BlockStatement", null, null, false);
    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StatementList", null, null, false);
    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.SingleLineComment", null, null, false);
    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.TextCommentPart", null, null, false);
    SNodeAccessUtil.setProperty(quotedNode_8, MetaAdapterFactory.getProperty(new UUID(-935030926396207931l, -6610165693999523818l), 6329021646629104957l, 6329021646629104958l, "text"), "converted:  for ( expr; ...) {}  ->  { expr; for ( ; ...) {} }");
    quotedNode_5.addChild("commentPart", quotedNode_8);
    quotedNode_4.addChild("statement", quotedNode_5);
    {
      List<SNode> nodes = (List<SNode>) parameter_1;
      for (SNode child : nodes) {
        quotedNode_4.addChild("statement", HUtil.copyIfNecessary(child));
      }
    }
    quotedNode_7 = (SNode) parameter_2;
    if (quotedNode_7 != null) {
      quotedNode_4.addChild("statement", HUtil.copyIfNecessary(quotedNode_7));
    }
    quotedNode_3.addChild("statements", quotedNode_4);
    return quotedNode_3;
  }
}
