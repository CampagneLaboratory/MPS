package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;

public class TypeNameResolver {
  private String myPackage;
  private SModel myJavaLangModel;
  private List<TypeNameResolver.Import> myImports;
  private TypeNameResolver.NestNamespace myNestNamespace;
  private TypeNameResolver.TypeVarNamespace myTVarNamespace;

  public TypeNameResolver(String pkg) {
    myPackage = pkg;
    myImports = ListSequence.fromList(new ArrayList<TypeNameResolver.Import>());
    myNestNamespace = new TypeNameResolver.NestNamespace();

    myTVarNamespace = new TypeNameResolver.TypeVarNamespace(null);


    List<SModelDescriptor> mDescs = SModelRepository.getInstance().getModelDescriptorsByModelName("java.lang");
    if (mDescs == null || ListSequence.fromList(mDescs).count() != 1) {
      // TODO use log 
      System.err.println("No java.lang in model repository");
      myJavaLangModel = null;
    } else {
      myJavaLangModel = ListSequence.fromList(mDescs).getElement(0).getSModel();
    }
  }

  public void addImport(TypeNameResolver.Import imp) {
    myImports.add(imp);
  }

  public void addImports(List<TypeNameResolver.Import> imps) {
    ListSequence.fromList(myImports).addSequence(ListSequence.fromList(imps));
  }

  /**
   * Adds a classifier name to scope. Either current root class or its nested class
   */
  public void addTypeName(@NotNull String name) {
    myNestNamespace.addTypeName(name);
  }

  /**
   * Signifies that parsing is going to happen inside this class.
   */
  public void enterType(String name) {
    myNestNamespace = new TypeNameResolver.NestNamespace(myNestNamespace, name);
  }

  /**
   * Going one level up (back) in class nesting.
   * Names from previous level are removed from the scope.
   */
  public void leaveType() {
    myNestNamespace = myNestNamespace.myParent;
  }

  /**
   * Clears all nested types, including the root class.
   */
  public void eraseNestedTypes() {
    myNestNamespace = new TypeNameResolver.NestNamespace();
  }

  public void newTypeVarFrame() {
    myTVarNamespace = new TypeNameResolver.TypeVarNamespace(myTVarNamespace);
  }

  public void addTypeVar(SNode typeVar) {
    myTVarNamespace.addTypeVar(typeVar);
  }

  public void leaveTypeVarFrame() {
    myTVarNamespace = myTVarNamespace.myParent;
  }

  public SNode resolveShortTypeName(String name) {

    if ("void".equals(name)) {
      return _quotation_createNode_lmecd1_a0a1a51();
    } else if ("int".equals(name)) {
      return _quotation_createNode_lmecd1_a0a0b0p();
    } else if ("long".equals(name)) {
      return _quotation_createNode_lmecd1_a0a1b0p();
    } else if ("short".equals(name)) {
      return _quotation_createNode_lmecd1_a0a2b0p();
    } else if ("byte".equals(name)) {
      return _quotation_createNode_lmecd1_a0a3b0p();
    } else if ("float".equals(name)) {
      return _quotation_createNode_lmecd1_a0a4b0p();
    } else if ("double".equals(name)) {
      return _quotation_createNode_lmecd1_a0a5b0p();
    } else if ("boolean".equals(name)) {
      return _quotation_createNode_lmecd1_a0a6b0p();
    } else if ("char".equals(name)) {
      return _quotation_createNode_lmecd1_a0a7b0p();
    }

    // see if it's a type variable 
    SNode typeVarRef = myTVarNamespace.resolve(name);
    if ((typeVarRef != null)) {
      return typeVarRef;
    }

    SNode classType = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierType", null);

    SReference sref = resolveShortClassName(name, classType, "classifier");
    classType.addReference(sref);
    return classType;
  }

  public SNode resolveQualifiedTypeName(String qname) {
    SNode classType = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierType", null);
    SReference sref = resolveQualifiedClassName(qname, classType, "classifier");
    classType.addReference(sref);
    return classType;
  }

  public SNode resolveAnnotaion(String name) {
    SNode annoInst = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationInstance", null);
    SReference ref = resolveShortClassName(name, annoInst, "annotation");
    annoInst.addReference(ref);
    return annoInst;
  }

  public SReference resolveShortClassName(@NotNull String unqualName, SNode source, String role) {

    // FIXME -- HACK to work around inherited nested classes in guava while classifier scope doesn't work 
    if ("Entry".equals(unqualName)) {
      return new DynamicReference(role, source, null, "java.util.Map.Entry");
    }

    // nested class case 
    String nestedTyp = myNestNamespace.resolve(unqualName);
    if (nestedTyp != null) {
      String fqname = myPackage + "." + nestedTyp;
      return new DynamicReference(role, source, null, fqname);
    }

    int k = 0;

    for (int i = ListSequence.fromList(myImports).count() - 1; i >= 0; i--) {
      TypeNameResolver.Import imp = ListSequence.fromList(myImports).getElement(i);
      if (!(imp.isOnDemand())) {
        k++;
        if (imp.myClass.equals(unqualName)) {
          String fqname = imp.myPackage + "." + imp.myClass;
          return new DynamicReference(role, source, null, fqname);
        }

      }
    }

    if (k == (int) ListSequence.fromList(myImports).count()) {
      // all imports are single type and we still haven't found our type 
      // So, it's either java.lang, or current package or inside this compilation unit 

      //  FIXME current packages has priority over java.lang 

      SNode javaLangNode = findInJavaLang(unqualName);
      if (javaLangNode != null) {
        // <node> 
        // <node> 
        return SReference.create(role, source, javaLangNode);
      }

      // using short name, as it must be accessible 
      String fqname = myPackage + "." + unqualName;
      return new DynamicReference(role, source, null, unqualName);

      // <node> 


    } else {
      //  there are import pkg.* 

      List<String> pkgs = ListSequence.fromList(new ArrayList<String>());

      // current package first 
      pkgs.add(myPackage);
      //  then java.lang 
      ListSequence.fromList(pkgs).addElement("java.lang");

      // and then imports 
      for (TypeNameResolver.Import imp : ListSequence.fromList(myImports)) {
        if (imp.isOnDemand()) {
          pkgs.add(imp.myPackage);
        }
      }

      return new JavaPackagesDynReferece(role, source, unqualName, pkgs);
    }

  }

  public SReference resolveQualifiedClassName(String qname, SNode source, String role) {
    // qname is either a fully qualified name pkg.Class 
    // or a qualified nested class name Class1.Class2 

    int k = qname.indexOf(".");
    assert k > 0;
    String fst = qname.substring(0, k);

    String fqname;

    String nestedTyp = myNestNamespace.resolve(fst);
    if (nestedTyp != null) {
      // it's a nested class qname 
      // reamining part of qname (like .B.C ) 
      String remn = qname.substring(k);
      fqname = myPackage + "." + nestedTyp + remn;
    } else {
      // it must be a fully qualified name 
      fqname = qname;
    }

    return new DynamicReference(role, source, null, fqname);
  }

  private SNode findInJavaLang(@NotNull String name) {
    for (SNode node : ListSequence.fromList(SModelOperations.getRoots(myJavaLangModel, null))) {
      if (name.equals(node.getName())) {
        return node;
      }
    }
    return null;
  }

  public static class Import {
    private boolean myIsStatic = false;
    private String myPackage;
    /**
     * myClass is null if it's on demand import (i.e. import pkg.*)
     */
    private String myClass;

    public Import(@NotNull String pkg, String clas, boolean isStatic) {
      myPackage = pkg;
      myClass = clas;
      myIsStatic = isStatic;
    }

    public boolean isOnDemand() {
      return myClass == null;
    }
  }

  private class NestNamespace {
    private TypeNameResolver.NestNamespace myParent;
    /**
     * Either empty string or has the form A.B.C.  (with the dot at the end)
     */
    private String myQualifier;
    /**
     * has entries of the form DeeplyNested --> RootClass.NestedClass.DeeplyNested
     */
    private Map<String, String> myTypes = MapSequence.fromMap(new HashMap<String, String>());

    public NestNamespace() {
      myQualifier = "";
    }

    public NestNamespace(TypeNameResolver.NestNamespace parentNs, String parentTypeName) {
      myParent = parentNs;
      myQualifier = parentNs.myQualifier + parentTypeName + ".";
    }

    private void addTypeName(String name) {
      MapSequence.fromMap(myTypes).put(name, myQualifier + name);
    }

    private String resolve(String typeName) {
      String res = MapSequence.fromMap(myTypes).get(typeName);
      if (res == null && myParent != null) {
        res = myParent.resolve(typeName);
      }
      return res;
    }
  }

  public class TypeVarNamespace {
    private TypeNameResolver.TypeVarNamespace myParent;
    private Map<String, SNode> myTypeVars;

    public TypeVarNamespace(TypeNameResolver.TypeVarNamespace parent) {
      myParent = parent;
      myTypeVars = MapSequence.fromMap(new HashMap<String, SNode>());
    }

    public void addTypeVar(SNode typeVar) {
      MapSequence.fromMap(myTypeVars).put(SPropertyOperations.getString(typeVar, "name"), typeVar);
    }

    public SNode resolve(String name) {
      SNode typeVar = MapSequence.fromMap(myTypeVars).get(name);

      if ((typeVar == null)) {
        return (myParent == null ?
          null :
          myParent.resolve(name)
        );
      } else {
        SNode typeVarRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TypeVariableReference", null);
        SReference ref = new StaticReference("typeVariableDeclaration", typeVarRef, typeVar);
        typeVarRef.addReference(ref);
        return typeVarRef;
      }
    }
  }

  private static SNode _quotation_createNode_lmecd1_a0a1a51() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.VoidType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_lmecd1_a0a0b0p() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.IntegerType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_lmecd1_a0a1b0p() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.LongType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_lmecd1_a0a2b0p() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ShortType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_lmecd1_a0a3b0p() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ByteType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_lmecd1_a0a4b0p() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.FloatType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_lmecd1_a0a5b0p() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.DoubleType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_lmecd1_a0a6b0p() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.BooleanType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }

  private static SNode _quotation_createNode_lmecd1_a0a7b0p() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.CharType", null, null, GlobalScope.getInstance(), false);
    return quotedNode_1;
  }
}
