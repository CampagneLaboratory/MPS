package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.annotations.NotNull;
import org.eclipse.jdt.internal.core.util.CodeSnippetParsingUtil;
import java.util.Map;
import java.util.HashMap;
import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.ArrayList;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Statement;
import org.eclipse.jdt.internal.core.util.RecordedParsingInformation;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Comparator;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import org.eclipse.jdt.internal.compiler.ast.ImportReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.backports.Deque;
import jetbrains.mps.internal.collections.runtime.DequeSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.DynamicReference;

public class JavaParser {
  private static Logger LOG = Logger.getLogger(JavaParser.class);

  public JavaParser() {
  }

  @NotNull
  public JavaParser.JavaParseResult parseCompilationUnit(String code) throws JavaParseException {
    // temp thing: peek at the package name 
    String pkg = peekPackage(code);
    return parse(code, pkg, FeatureKind.CLASS, true);
  }

  @NotNull
  public JavaParser.JavaParseResult parse(String code, String pkg, FeatureKind what, boolean recovery) throws JavaParseException {
    // in eclipse there is full recovery and statement recovery 
    // TODO use full recovery 

    boolean stubsMode = FeatureKind.CLASS_STUB.equals(what);
    CodeSnippetParsingUtil util = new CodeSnippetParsingUtil(stubsMode);
    Map<String, String> settings = new HashMap<String, String>();
    settings.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);
    settings.put(CompilerOptions.OPTION_DocCommentSupport, "enabled");
    TypeNameResolver typeResolver = new TypeNameResolver(pkg);
    ASTConverter converter = (FeatureKind.CLASS_STUB.equals(what) ?
      new ASTConverter(typeResolver, stubsMode) :
      new FullASTConverter(null, typeResolver)
    );

    List<SNode> resultNodes = new ArrayList<SNode>();
    String resultPackageName = null;

    char[] source = code.toCharArray();


    switch (what) {
      case CLASS:
        // fall-through 
      case CLASS_STUB:

        CompilationUnitDeclaration compRes = util.parseCompilationUnit(source, settings, true);
        if (compRes == null) {
          return JavaParser.JavaParseResult.UNKNOWN_ERROR;
        }

        ASTNode[] astTypes = compRes.types;

        if (astTypes != null && astTypes.length > 0) {
          List<SNode> roots = new ArrayList<SNode>();
          for (ASTNode astNode : astTypes) {
            SNode root = converter.convertRoot(astNode);
            annotateWithmports(compRes, root);
            ListSequence.fromList(roots).addElement(root);
          }
          resultNodes = roots;
        }

        // there may be no types and still no compilation errors 
        // e.g. package-info.java only includes 'package pkg'; 

        // getting package out of the parsed source code 
        if (compRes.currentPackage != null) {
          StringBuffer sb = new StringBuffer();
          compRes.currentPackage.print(0, sb, false);
          resultPackageName = sb.toString();
        }

        break;

      case CLASS_CONTENT:

        ASTNode[] astNodes = util.parseClassBodyDeclarations(source, 0, source.length, settings, true, recovery);
        // type decl (inner), field, method 
        if (astNodes != null && astNodes.length > 0) {
          resultNodes = converter.convertClassContents(astNodes, SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassConcept", null));
        }

        break;

      case STATEMENTS:

        AbstractMethodDeclaration absMethod = util.parseStatements(source, settings, true, recovery);
        if (absMethod == null) {
          return JavaParser.JavaParseResult.UNKNOWN_ERROR;
        }

        Statement[] stmts = absMethod.statements;
        // <node> 

        if (stmts != null && stmts.length > 0) {
          // TODO construct typeResolver from parent node context 
          SNode stmtList = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null);
          resultNodes = ((FullASTConverter) converter).convertStatementsOf(absMethod, stmtList);
        }

        break;

      default:
        throw new IllegalArgumentException("Parsing other than class and statements is not supported yet ");
    }

    // now insert comments 
    attachComments(source, converter, util.recordedParsingInformation);


    return new JavaParser.JavaParseResult(resultNodes, resultPackageName, problemDescription(util.recordedParsingInformation));
  }

  public void attachComments(char[] source, ASTConverter converter, RecordedParsingInformation parseInfo) {

    char[] content = source;
    int[][] comments = parseInfo.commentPositions;
    int[] lineends = parseInfo.lineEnds;

    final Wrappers._T<Map<SNode, Integer>> positions = new Wrappers._T<Map<SNode, Integer>>(MapSequence.fromMap(new HashMap<SNode, Integer>()));
    Iterable<FullASTConverter.CodeBlock> blocks = ListSequence.fromList(new ArrayList<FullASTConverter.CodeBlock>());
    Map<Integer, SNode> javadocs = converter.getJavadocs();

    if (converter instanceof FullASTConverter) {
      blocks = ((FullASTConverter) converter).getCodeBlocks();
      positions.value = ((FullASTConverter) converter).getPositions();
    }

    Iterable<FullASTConverter.CodeBlock> blcks = Sequence.fromIterable(blocks).sort(new Comparator<FullASTConverter.CodeBlock>() {
      public int compare(FullASTConverter.CodeBlock a, FullASTConverter.CodeBlock b) {
        return a.getEndPos() - b.getEndPos();
      }
    }, true);
    for (int[] comment : comments) {
      if (comment[1] > 0) {
        // javadoc 
        SNode doc = MapSequence.fromMap(javadocs).get(comment[0]);

        List<String> lines = CommentHelper.processJavadoc(CommentHelper.splitString(content, lineends, comment[0], comment[1] + 1));
        for (String text : ListSequence.fromList(lines)) {
          SNode commentLine = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.javadoc.structure.CommentLine", null);
          SPropertyOperations.set(SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(commentLine, "part", true)).getElement(0), "jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart"), "text", text);
          ListSequence.fromList(SLinkOperations.getTargets(doc, "body", true)).addElement(commentLine);
        }

        continue;
      }

      final int linestart = Math.abs(comment[0]);
      // find appropriate block 
      SNode block = null;
      for (FullASTConverter.CodeBlock blk : Sequence.fromIterable(blcks)) {
        if (blk.getStartPos() <= linestart && linestart <= blk.getEndPos()) {
          block = blk.getStatementList();
          break;
        }
      }
      if ((block != null)) {
        int pos = ListSequence.fromList(SLinkOperations.getTargets(block, "statement", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return !(MapSequence.fromMap(positions.value).containsKey(it)) || Math.abs(MapSequence.fromMap(positions.value).get(it)) <= linestart;
          }
        }).count();
        for (String line : ListSequence.fromList(CommentHelper.processComment(CommentHelper.splitString(content, lineends, linestart, Math.abs(comment[1]))))) {
          SNode commentText = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TextCommentPart", null);
          SPropertyOperations.set(commentText, "text", line);
          SNode commentLine = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SingleLineComment", null);
          ListSequence.fromList(SLinkOperations.getTargets(commentLine, "commentPart", true)).addElement(commentText);
          ListSequence.fromList(SLinkOperations.getTargets(block, "statement", true)).insertElement(pos++, commentLine);
        }
      } else {
        // FIXME 
        LOG.warning("cannot find a place to import comment from " + "<Main type name>" + ":\n" + new String(content, linestart, Math.abs(comment[1]) - linestart));
      }
    }
  }

  public void annotateWithmports(CompilationUnitDeclaration compResult, SNode clas) {
    // <node> 
    AttributeOperations.createAndSetAttrbiute(clas, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.JavaImports")), "jetbrains.mps.baseLanguage.structure.JavaImports");
    if (compResult.imports != null) {
      for (ImportReference imprt : compResult.imports) {
        // <node> 
        ListSequence.fromList(SLinkOperations.getTargets(AttributeOperations.getAttribute(clas, new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.JavaImports"))), "entries", true)).addElement(makeImport(imprt));
      }
    }
    // <node> 
  }

  private SNode makeImport(ImportReference impRef) {
    SNode imp = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.JavaImport", null);

    boolean onDemand = (impRef.bits & ASTNode.OnDemand) != 0;
    boolean isStatic = impRef.isStatic();

    SPropertyOperations.set(imp, "onDemand", "" + (onDemand));

    char[][] toks = impRef.getImportName();
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < toks.length; i++) {
      String tok = new String(toks[i]);
      SNode token = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StringToken", null);
      SPropertyOperations.set(token, "value", tok);
      ListSequence.fromList(SLinkOperations.getTargets(imp, "token", true)).addElement(token);
    }

    return imp;
  }

  private String problemDescription(RecordedParsingInformation info) {
    if (info == null) {
      return null;
    }
    if (info.problems != null && info.problems.length > 0) {
      return "There were some problems";
    } else {
      return null;
    }
  }

  private String peekPackage(String source) {
    // WILL GO AWAY COMPLETELY 
    final String str = "package ";
    StringBuilder packageName = new StringBuilder();
    for (int i = source.indexOf(str) + str.length(); i < source.length(); i++) {
      char c = source.charAt(i);
      if (Character.isWhitespace(c) || c == ';') {
        break;
      }
      packageName.append(c);
    }
    return packageName.toString();
  }

  public static class JavaParseResult {
    public static final JavaParser.JavaParseResult UNKNOWN_ERROR = new JavaParser.JavaParseResult(new ArrayList<SNode>(), "Parse failed and return no errors");
    @NotNull
    private List<SNode> nodes;
    private String pakage;
    private String errorMsg;

    public JavaParseResult(List<SNode> ns, String error) {
      nodes = ns;
      errorMsg = error;
    }

    public JavaParseResult(List<SNode> ns, String pkg, String error) {
      this(ns, error);
      pakage = pkg;
    }

    @NotNull
    public List<SNode> getNodes() {
      return nodes;
    }

    public String getPackage() {
      return pakage;
    }

    public String getErrorMsg() {
      return errorMsg;
    }
  }

  public static void tryResolveRoots(List<SNode> roots) {
    for (SNode node : ListSequence.fromList(roots)) {
      List<SNode> unknowns = SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.IYetUnresolved", false, new String[]{});
      for (SNode unk : ListSequence.fromList(unknowns)) {

        final SNode unkNode = unk;
        final _FunctionTypes._return_P0_E0<? extends SNode> subst = BehaviorReflection.invokeVirtual((Class<_FunctionTypes._return_P0_E0<? extends SNode>>) ((Class) Object.class), unk, "virtual_evaluateSubst_8136348407761606764", new Object[]{});
        if (subst == null) {
          continue;
        }

        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            SNode theRightNode = subst.invoke();
            SNodeOperations.replaceWithAnother(unkNode, theRightNode);
          }
        });

      }
    }
  }

  public static void tryResolveDynamicRefs(Iterable<SNode> nodes) {
    Deque<SNode> stack = DequeSequence.fromDeque(new LinkedList<SNode>());
    DequeSequence.fromDeque(stack).addSequence(Sequence.fromIterable(nodes));

    while (DequeSequence.fromDeque(stack).isNotEmpty()) {
      SNode node = DequeSequence.fromDeque(stack).popElement();
      DequeSequence.fromDeque(stack).addSequence(ListSequence.fromList(SNodeOperations.getChildren(node)));

      Iterable<SReference> refs = node.getReferences();
      for (SReference ref : Sequence.fromIterable(refs)) {
        if (!(ref instanceof DynamicReference)) {
          continue;
        }

        SNode target = ref.getTargetNode();
        if (target == null) {
          continue;
        }
        node.setReferenceTarget(ref.getRole(), target);
      }
    }
  }
}
