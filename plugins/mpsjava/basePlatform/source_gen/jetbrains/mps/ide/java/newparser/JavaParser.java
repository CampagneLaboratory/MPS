package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import org.eclipse.jdt.internal.core.util.CodeSnippetParsingUtil;
import java.util.Map;
import java.util.HashMap;
import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
import java.util.List;
import java.util.ArrayList;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Statement;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.eclipse.jdt.internal.core.util.RecordedParsingInformation;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Comparator;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.eclipse.jdt.internal.compiler.ast.ImportReference;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.backports.Deque;
import jetbrains.mps.internal.collections.runtime.DequeSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.DynamicReference;

public class JavaParser {
  private static Logger LOG = LogManager.getLogger(JavaParser.class);
  public JavaParser() {
  }
  @NotNull
  public JavaParser.JavaParseResult parseCompilationUnit(String code) throws JavaParseException {
    return parse(code, FeatureKind.CLASS, null, true);
  }
  @NotNull
  public JavaParser.JavaParseResult parse(String code, FeatureKind what, SNode context, boolean recovery) throws JavaParseException {
    // in eclipse there is full recovery and statement recovery 
    // TODO use full recovery 

    boolean stubsMode = FeatureKind.CLASS_STUB.equals(what);
    CodeSnippetParsingUtil util = new CodeSnippetParsingUtil(stubsMode);
    Map<String, String> settings = new HashMap<String, String>();
    settings.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);
    settings.put(CompilerOptions.OPTION_DocCommentSupport, "enabled");
    ASTConverter converter = (FeatureKind.CLASS_STUB.equals(what) ? new ASTConverter(stubsMode) : new FullASTConverter(null));

    List<SNode> resultNodes = new ArrayList<SNode>();
    String resultPackageName = null;

    char[] source = code.toCharArray();


    switch (what) {
      case CLASS:
        // fall-through 
      case CLASS_STUB:

        CompilationUnitDeclaration compRes = util.parseCompilationUnit(source, settings, true);
        if (compRes == null) {
          return JavaParser.JavaParseResult.UNKNOWN_ERROR;
        }

        ASTNode[] astTypes = compRes.types;

        if (astTypes != null && astTypes.length > 0) {
          List<SNode> roots = new ArrayList<SNode>();
          for (ASTNode astNode : astTypes) {
            SNode root = converter.convertRoot(astNode);
            annotateWithmports(compRes, root);
            ListSequence.fromList(roots).addElement(root);
          }
          resultNodes = roots;
        }

        // there may be no types and still no compilation errors 
        // e.g. package-info.java only includes 'package pkg'; 

        // getting package out of the parsed source code 
        if (compRes.currentPackage != null) {
          StringBuffer sb = new StringBuffer();
          compRes.currentPackage.print(0, sb, false);
          resultPackageName = sb.toString();
        }

        break;

      case CLASS_CONTENT:

        ASTNode[] astNodes = util.parseClassBodyDeclarations(source, 0, source.length, settings, true, recovery);
        // type decl (inner), field, method 
        if (astNodes != null && astNodes.length > 0) {
          resultNodes = converter.convertClassContents(astNodes, context);
        }

        break;

      case STATEMENTS:

        AbstractMethodDeclaration absMethod = util.parseStatements(source, settings, true, recovery);
        if (absMethod == null) {
          return JavaParser.JavaParseResult.UNKNOWN_ERROR;
        }

        Statement[] stmts = absMethod.statements;
        // <node> 

        if (stmts != null && stmts.length > 0) {
          // TODO construct typeResolver from parent node context 
          SNode stmtList = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null);
          resultNodes = ((FullASTConverter) converter).convertStatementsOf(absMethod, stmtList);
        }

        break;

      default:
        throw new IllegalArgumentException("Parsing other than class and statements is not supported yet ");
    }

    // now insert comments 
    attachComments(source, converter, util.recordedParsingInformation);

    return new JavaParser.JavaParseResult(resultNodes, resultPackageName, problemDescription(util.recordedParsingInformation));
  }
  public void attachComments(char[] source, ASTConverter converter, RecordedParsingInformation parseInfo) {

    char[] content = source;
    int[][] comments = parseInfo.commentPositions;
    int[] lineends = parseInfo.lineEnds;

    final Wrappers._T<Map<SNode, Integer>> positions = new Wrappers._T<Map<SNode, Integer>>(MapSequence.fromMap(new HashMap<SNode, Integer>()));
    Iterable<FullASTConverter.CodeBlock> blocks = ListSequence.fromList(new ArrayList<FullASTConverter.CodeBlock>());
    Map<Integer, SNode> javadocs = converter.getJavadocs();

    if (converter instanceof FullASTConverter) {
      blocks = ((FullASTConverter) converter).getCodeBlocks();
      positions.value = ((FullASTConverter) converter).getPositions();
    }

    Iterable<FullASTConverter.CodeBlock> blcks = Sequence.fromIterable(blocks).sort(new Comparator<FullASTConverter.CodeBlock>() {
      public int compare(FullASTConverter.CodeBlock a, FullASTConverter.CodeBlock b) {
        return a.getEndPos() - b.getEndPos();
      }
    }, true);
    for (int[] comment : comments) {
      if (comment[1] > 0) {
        // javadoc 
        SNode doc = MapSequence.fromMap(javadocs).get(comment[0]);
        if (doc == null) {
          continue;
        }

        List<String> lines = CommentHelper.processJavadoc(CommentHelper.splitString(content, lineends, comment[0], comment[1]));
        for (String text : lines) {
          SNode commentLine = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.javadoc.structure.CommentLine", null);
          SNode part = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart", null);
          SPropertyOperations.set(part, "text", text);
          ListSequence.fromList(SLinkOperations.getTargets(commentLine, "part", true)).addElement(part);
          ListSequence.fromList(SLinkOperations.getTargets(doc, "body", true)).addElement(commentLine);
        }

        continue;
      }

      final int linestart = Math.abs(comment[0]);
      // find appropriate block 
      SNode block = null;
      for (FullASTConverter.CodeBlock blk : Sequence.fromIterable(blcks)) {
        if (blk.getStartPos() <= linestart && linestart <= blk.getEndPos()) {
          block = blk.getStatementList();
          break;
        }
      }
      if ((block != null)) {
        int pos = ListSequence.fromList(SLinkOperations.getTargets(block, "statement", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return !(MapSequence.fromMap(positions.value).containsKey(it)) || Math.abs(MapSequence.fromMap(positions.value).get(it)) <= linestart;
          }
        }).count();
        for (String line : CommentHelper.processComment(CommentHelper.splitString(content, lineends, linestart, Math.abs(comment[1])))) {
          String line_ = line;
          if (line.startsWith(" ")) {
            line_ = line.substring(1);
          }
          SNode commentText = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TextCommentPart", null);
          SPropertyOperations.set(commentText, "text", line_);
          SNode commentLine = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SingleLineComment", null);
          ListSequence.fromList(SLinkOperations.getTargets(commentLine, "commentPart", true)).addElement(commentText);
          ListSequence.fromList(SLinkOperations.getTargets(block, "statement", true)).insertElement(pos++, commentLine);
        }
      } else {
        // no place to insert comment 
        // this is most likely because the comment is not a javadoc and is between declarations 
        // (not inside statement list) 
        // we could issue a warning... 
      }
    }
  }
  public void annotateWithmports(CompilationUnitDeclaration compResult, SNode clas) {
    SNode imports = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.JavaImports", null);

    // putting first: current package in terms of source code 
    if (compResult.currentPackage != null) {
      SNode currPkg = makeImport(compResult.currentPackage);
      SPropertyOperations.set(currPkg, "onDemand", "" + (true));
      ListSequence.fromList(SLinkOperations.getTargets(imports, "entries", true)).addElement(currPkg);
    }

    if (compResult.imports != null) {
      for (ImportReference imprt : compResult.imports) {
        ListSequence.fromList(SLinkOperations.getTargets(imports, "entries", true)).addElement(makeImport(imprt));
      }
    }

    // inserting it in the beginning 
    clas.addChild("smodelAttribute", imports);

    // we want to insert imports section before any javadoc 
    // because javadoc is data while imports section is meta-data for assisting class resolving 

    // <node> 
    // <node> 
  }
  private SNode makeImport(ImportReference impRef) {
    SNode imp = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.JavaImport", null);

    boolean onDemand = (impRef.bits & ASTNode.OnDemand) != 0;
    boolean isStatic = impRef.isStatic();

    SPropertyOperations.set(imp, "onDemand", "" + (onDemand));
    SPropertyOperations.set(imp, "static", "" + (isStatic));

    char[][] toks = impRef.getImportName();
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < toks.length; i++) {
      sb.append(toks[i]);
      sb.append('.');
    }
    sb.deleteCharAt(sb.length() - 1);
    SPropertyOperations.set(imp, "tokens", sb.toString());
    return imp;
  }
  private String problemDescription(RecordedParsingInformation info) {
    if (info == null) {
      return null;
    }
    if (info.problems != null && info.problems.length > 0) {
      return "There were some problems";
    } else {
      return null;
    }
  }
  @Nullable
  public static String peekPackage(String source) {
    // WILL GO AWAY COMPLETELY 
    final String str = "package ";
    StringBuilder packageName = new StringBuilder();
    for (int i = source.indexOf(str) + str.length(); i < source.length(); i++) {
      char c = source.charAt(i);
      if (Character.isWhitespace(c) || c == ';') {
        break;
      }
      packageName.append(c);
    }
    return (packageName.length() == 0 ? null : packageName.toString());
  }
  public static class JavaParseResult {
    public static final JavaParser.JavaParseResult UNKNOWN_ERROR = new JavaParser.JavaParseResult(new ArrayList<SNode>(), "Parse failed and return no errors");
    @NotNull
    private List<SNode> nodes;
    private String pakage;
    private String errorMsg;
    public JavaParseResult(List<SNode> ns, String error) {
      nodes = ns;
      errorMsg = error;
    }
    public JavaParseResult(List<SNode> ns, String pkg, String error) {
      this(ns, error);
      pakage = pkg;
    }
    @NotNull
    public List<SNode> getNodes() {
      return nodes;
    }
    public String getPackage() {
      return pakage;
    }
    public String getErrorMsg() {
      return errorMsg;
    }
  }
  public static void tryResolveUnknowns(Iterable<SNode> roots) {
    for (SNode node : Sequence.fromIterable(roots)) {
      List<SNode> unknowns = SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.IYetUnresolved", false, new String[]{});
      for (SNode unk : ListSequence.fromList(unknowns)) {

        final SNode unkNode = unk;
        final _FunctionTypes._return_P0_E0<? extends SNode> subst = BehaviorReflection.invokeVirtual((Class<_FunctionTypes._return_P0_E0<? extends SNode>>) ((Class) Object.class), unk, "virtual_evaluateSubst_8136348407761606764", new Object[]{});
        if (subst == null) {
          continue;
        }

        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          @Override
          public void run() {
            final SNode theRightNode = subst.invoke();
            SNodeOperations.replaceWithAnother(unkNode, theRightNode);

            // FIXME maybe it's better to re-use auto model import 
            Sequence.fromIterable(JavaToMpsConverter.deepReferences(theRightNode)).where(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return (SReference) it instanceof StaticReference;
              }
            }).visitAll(new IVisitor<SReference>() {
              public void visit(SReference it) {
                SModelReference targetModel = ((StaticReference) it).getTargetSModelReference();
                ((SModelInternal) theRightNode.getModel()).addModelImport(targetModel, true);

              }
            });
          }
        });

      }
    }
  }
  public static void tryResolveDynamicRefs(Iterable<SNode> nodes) {
    Deque<SNode> stack = DequeSequence.fromDeque(new LinkedList<SNode>());
    DequeSequence.fromDeque(stack).addSequence(Sequence.fromIterable(nodes));

    while (DequeSequence.fromDeque(stack).isNotEmpty()) {
      SNode node = DequeSequence.fromDeque(stack).popElement();
      SModel ourModel = node.getModel();
      DequeSequence.fromDeque(stack).addSequence(ListSequence.fromList(SNodeOperations.getChildren(node)));

      Iterable<? extends SReference> refs = node.getReferences();
      for (SReference ref : Sequence.fromIterable(refs)) {
        if (!(ref instanceof DynamicReference)) {
          continue;
        }
        // FIXME temp hack around typesystem looping when resolving certain dyn.references 
        // <node> 
        // <node> 

        SNode target = ref.getTargetNode();
        if (target == null) {
          continue;
        }
        node.setReferenceTarget(ref.getRole(), target);

        SModel targetModel = target.getModel();
        if (targetModel != null) {
          ((SModelInternal) ourModel).addModelImport(targetModel.getReference(), true);
        }
      }
    }
  }
}
