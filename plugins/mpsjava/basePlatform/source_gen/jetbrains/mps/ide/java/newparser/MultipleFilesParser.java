package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.project.Project;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.vfs.IFile;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import java.io.IOException;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import javax.swing.SwingUtilities;
import java.lang.reflect.InvocationTargetException;
import jetbrains.mps.vfs.IFileUtils;
import java.util.HashSet;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.project.SModuleOperations;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.persistence.ModelRoot;

public class MultipleFilesParser {
  private static final Logger LOG = LogManager.getLogger(MultipleFilesParser.class);

  private SModule myModule;
  private ModelAccess myModelAccess;

  private Project myProject;

  private JavaParser myJavaParser = new JavaParser();
  private Map<String, Set<SNode>> classesPerPackage = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private List<SModel> myModels = ListSequence.fromList(new ArrayList<SModel>());
  private List<IFile> mySuccessfulFiles = ListSequence.fromList(new ArrayList<IFile>());

  private boolean wasDefaultPkg = false;


  public MultipleFilesParser(SModule module, ModelAccess modelAccess, Project project) {
    myModule = module;
    myModelAccess = modelAccess;
    myProject = project;
  }



  public void convertToMps(final List<IFile> files, final ProgressMonitor progress) throws JavaParseException, IOException {
    // first we build AST 
    final ProgressMonitor parseProgress = progress.subTask(ListSequence.fromList(files).count());
    parseProgress.start("Parsing...", ListSequence.fromList(files).count());

    // read action needed only because java parser does new node<Concept> 

    myModelAccess.runReadAction(new Runnable() {
      public void run() {
        for (IFile file : ListSequence.fromList(files)) {
          try {
            parseFile(file);
            parseProgress.advance(1);

            ListSequence.fromList(mySuccessfulFiles).addElement(file);

          } catch (JavaParseException e) {
          } catch (IOException e) {
          }
        }
      }
    });

    parseProgress.done();


    // now we attach the models and try to resolve      
    final _FunctionTypes._void_P0_E0 resolveWork = new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        int rootCount = 0;
        for (String pakage : SetSequence.fromSet(MapSequence.fromMap(classesPerPackage).keySet())) {
          final SModel model = registerModelForPackage(pakage);

          Set<SNode> roots = MapSequence.fromMap(classesPerPackage).get(pakage);
          SetSequence.fromSet(roots).visitAll(new IVisitor<SNode>() {
            public void visit(SNode it) {
              model.addRootNode(it);
            }
          });
          rootCount = rootCount + SetSequence.fromSet(roots).count();
        }

        ProgressMonitor resolveProgress = progress.subTask(rootCount);
        resolveProgress.start("Resolving...", rootCount);

        for (String pakage : SetSequence.fromSet(MapSequence.fromMap(classesPerPackage).keySet())) {
          final SModel model = registerModelForPackage(pakage);

          Set<SNode> roots = MapSequence.fromMap(classesPerPackage).get(pakage);
          SetSequence.fromSet(roots).visitAll(new IVisitor<SNode>() {
            public void visit(SNode it) {
              model.addRootNode(it);
            }
          });

          rootCount = rootCount + SetSequence.fromSet(roots).count();
          ListSequence.fromList(myModels).addElement(model);

        }

        for (SModel model : ListSequence.fromList(myModels)) {
          for (SNode root : ListSequence.fromList(SModelOperations.getRoots(model, null))) {
            // FIXME change tryResolve to accept one node 
            JavaParser.tryResolveUnknowns(Sequence.<SNode>singleton(root));
            JavaParser.tryResolveDynamicRefs(Sequence.<SNode>singleton(root));
            resolveProgress.advance(1);
          }
        }

        resolveProgress.done();
      }
    };

    if (myModelAccess.isCommandAction()) {
      resolveWork.invoke();
    } else {
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
            myModelAccess.executeCommandInEDT(new Runnable() {
              public void run() {
                resolveWork.invoke();
              }
            });
          }
        });

      } catch (InterruptedException e) {
        LOG.error("Reference resolving pass was interrupted", e);
      } catch (InvocationTargetException e) {
        LOG.error("Exception in reference resolving pass", e.getCause());
      }
    }

  }



  public List<IFile> getSuccessfulFiles() {
    return mySuccessfulFiles;
  }



  public List<SModel> getModels() {
    return myModels;
  }



  private void parseFile(IFile file) throws JavaParseException, IOException {
    String contents = IFileUtils.getTextContents(file);
    JavaParser.JavaParseResult parseResult = myJavaParser.parseCompilationUnit(contents);
    String pkg = parseResult.getPackage();

    if (pkg == null) {
      // default package (i.e. none), bad 
      if (!(wasDefaultPkg)) {
        LOG.error("default package is not supported in java source directory input (first such file in dir: " + file.getName() + ")");
        wasDefaultPkg = true;
      }
      return;
    }

    IFile dir = file.getParent();
    if (!(DirParser.checkPackageMatchesSourceDirectory(pkg, dir))) {
      LOG.error("package " + pkg + " doesn't match directory " + dir.getPath() + " (in file " + file.getName() + ")");
      return;
    }

    Iterable<SNode> roots = parseResult.getNodes();
    Set<SNode> classesInPackage = MapSequence.fromMap(classesPerPackage).get(pkg);
    if (classesInPackage == null) {
      classesInPackage = SetSequence.fromSet(new HashSet<SNode>(Sequence.fromIterable(roots).count()));
      MapSequence.fromMap(classesPerPackage).put(pkg, classesInPackage);
    }
    SetSequence.fromSet(classesInPackage).addSequence(Sequence.fromIterable(roots));

  }




  private SModel registerModelForPackage(String fqName) {
    SModel modelDescriptor = SModelRepository.getInstance().getModelDescriptor(fqName);
    if (modelDescriptor != null) {
      if (!(Sequence.fromIterable(((Iterable<SModel>) myModule.getModels())).contains(modelDescriptor))) {
        LOG.error("model with fq name " + fqName + " is not owned by module " + myModule.getModuleName());
        return null;
      }
      // package is already present... 
      // maybe we shouldn't touch it then, maybe it should be an option 
      return modelDescriptor;
    } else {
      return createModel(fqName);
    }
  }

  private SModel createModel(String packageName) {
    // first check if it is possible 
    if (getRootToCreateModel(packageName) == null) {
      LOG.error("Cannot create model " + packageName + " in module " + myModule.getModuleName());
      return null;
    }

    SModel modelDescr = SModuleOperations.createModelWithAdjustments(packageName, getRootToCreateModel(packageName));
    assert modelDescr != null;

    return modelDescr;
  }

  @Nullable
  private ModelRoot getRootToCreateModel(String packageName) {
    for (ModelRoot root : Sequence.fromIterable(myModule.getModelRoots())) {
      if (root.canCreateModel(packageName)) {
        return root;
      }
    }
    return null;
  }


}
