package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.ModelAccess;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.vfs.IFile;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import java.io.IOException;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ISequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.vfs.IFileUtils;
import java.util.HashSet;
import javax.swing.SwingUtilities;
import java.lang.reflect.InvocationTargetException;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.StaticReference;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.project.SModuleOperations;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.persistence.ModelRoot;

public class MultipleFilesParser {
  private static final Logger LOG = LogManager.getLogger(MultipleFilesParser.class);

  private SModule myModule;
  private SRepository myRepository;
  private ModelAccess myModelAccess;


  private JavaParser myJavaParser = new JavaParser();
  private Map<String, Set<SNode>> classesPerPackage = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private List<SModel> myModels = ListSequence.fromList(new ArrayList<SModel>());
  private List<SNode> myRoots = ListSequence.fromList(new ArrayList<SNode>());
  private List<IFile> mySuccessfulFiles = ListSequence.fromList(new ArrayList<IFile>());

  private boolean wasDefaultPkg = false;
  private int myRootCount = 0;


  public MultipleFilesParser(SModule module, SRepository repository) {
    myModule = module;
    myRepository = repository;
    myModelAccess = repository.getModelAccess();
  }



  public void convertToMps(final List<IFile> files, ProgressMonitor progress) throws JavaParseException, IOException {

    progress.start("Converting...", 31);

    // first we build AST 
    final ProgressMonitor parseProgress = progress.subTask(1);
    parseProgress.start("Parsing...", ListSequence.fromList(files).count());

    // read action needed only because java parser does new node<Concept> 

    myModelAccess.runReadAction(new Runnable() {
      public void run() {
        for (IFile file : ListSequence.fromList(files)) {
          try {
            parseFile(file);
            parseProgress.advance(1);

            ListSequence.fromList(mySuccessfulFiles).addElement(file);

          } catch (JavaParseException e) {
          } catch (IOException e) {
          }
        }
      }
    });

    parseProgress.done();


    final Wrappers._int rootCount = new Wrappers._int(0);

    // now we attach the models and try to resolve      

    runCommand("model creation pass", new Runnable() {
      public void run() {
        ((AbstractModule) myModule).addDependency(PersistenceFacade.getInstance().createModuleReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065(JDK)"), false);

        for (String pakage : SetSequence.fromSet(MapSequence.fromMap(classesPerPackage).keySet())) {
          final SModel model = registerModelForPackage(pakage);

          if (model == null) {
            continue;
          }

          ((SModelInternal) model).addLanguage(PersistenceFacade.getInstance().createModuleReference("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)"));

          Set<SNode> roots = MapSequence.fromMap(classesPerPackage).get(pakage);
          SetSequence.fromSet(roots).visitAll(new IVisitor<SNode>() {
            public void visit(SNode it) {
              model.addRootNode(it);
            }
          });

          rootCount.value = rootCount.value + SetSequence.fromSet(roots).count();
          ListSequence.fromList(myRoots).addSequence(SetSequence.fromSet(roots));
          ListSequence.fromList(myModels).addElement(model);


        }

        // should be cheap 
        for (SModel model : ListSequence.fromList(myModels)) {
          JavaParser.tryResolveUnknowns(SModelOperations.getRoots(model, null));
        }

      }
    });

    myRootCount = rootCount.value;

    ProgressMonitor resolveProgress = progress.subTask(30);

    tryResolveRefs(myRoots, FeatureKind.CLASS, resolveProgress);

    progress.done();
  }



  public void tryResolveRefs(Iterable<SNode> nodes, FeatureKind level, ProgressMonitor progress) {
    progress.start("Resolving...", 10);

    if (FeatureKind.CLASS.equals(level)) {
      nodesResolveUpdatePass("top level refs", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
        public Iterable<SReference> invoke(SNode node) {
          return getTopLevelRefs(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier"));
        }
      }, progress.subTask(1));
    }

    if (FeatureKind.CLASS_CONTENT.equals(level) || FeatureKind.CLASS.equals(level)) {
      nodesResolveUpdatePass("field/method type refs", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
        public Iterable<SReference> invoke(SNode node) {
          return getFieldAndMethodTypeRefs(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassifierMember"));
        }
      }, progress.subTask(1));
    }

    nodesResolveUpdatePass("all type refs", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return getVarTypeRefs(node);
      }
    }, progress.subTask(2));

    nodesResolveUpdatePass("all variable refs", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return getVariableRefs(node);
      }
    }, progress.subTask(2));

    nodesResolveUpdatePass("all operands", nodes, new _FunctionTypes._return_P1_E0<ISequence<SReference>, SNode>() {
      public ISequence<SReference> invoke(SNode node) {
        return ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.DotExpression", false, new String[]{})).translate(new ITranslator2<SNode, SReference>() {
          public Iterable<SReference> translate(SNode it) {
            return deepReferences(SLinkOperations.getTarget(it, "operand", true));
          }
        });
      }
    }, progress.subTask(2));

    nodesResolveUpdatePass("all operations", nodes, new _FunctionTypes._return_P1_E0<ISequence<SReference>, SNode>() {
      public ISequence<SReference> invoke(SNode node) {
        return ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.DotExpression", false, new String[]{})).translate(new ITranslator2<SNode, SReference>() {
          public Iterable<SReference> translate(SNode it) {
            if (Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(it, "operand", true))).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return (SReference) it instanceof DynamicReference;
              }
            })) {
              return ListSequence.fromList(new ArrayList<SReference>());
            } else {
              if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "operation", true), "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation")) {
                return Sequence.<SReference>singleton(SNodeOperations.getReference(SNodeOperations.cast(SLinkOperations.getTarget(it, "operation", true), "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation"), SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.FieldReferenceOperation", "fieldDeclaration")));
              } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "operation", true), "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation")) {
                return Sequence.<SReference>singleton(SNodeOperations.getReference(SNodeOperations.cast(SLinkOperations.getTarget(it, "operation", true), "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation"), SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation", "instanceMethodDeclaration")));
              } else {
                return ListSequence.fromList(new ArrayList<SReference>());
              }
            }
          }
        });
      }
    }, progress.subTask(2));

    nodesResolveUpdatePass("classifiers in static", nodes, new _FunctionTypes._return_P1_E0<List<SReference>, SNode>() {
      public List<SReference> invoke(SNode node) {
        List<SReference> result = ListSequence.fromList(new ArrayList<SReference>());

        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.StaticMethodCall", false, new String[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.StaticMethodCall", "classConcept"));
          }
        }));
        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.StaticFieldReference", false, new String[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.StaticFieldReference", "classifier"));
          }
        }));

        return result;
      }
    }, progress.subTask(2));

    nodesResolveUpdatePass("static member references", nodes, new _FunctionTypes._return_P1_E0<List<SReference>, SNode>() {
      public List<SReference> invoke(SNode node) {
        List<SReference> result = ListSequence.fromList(new ArrayList<SReference>());

        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.StaticMethodCall", false, new String[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.StaticMethodCall", "staticMethodDeclaration"));
          }
        }));
        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.StaticFieldReference", false, new String[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.StaticFieldReference", "staticFieldDeclaration"));
          }
        }));

        return result;
      }
    }, progress.subTask(2));

    nodesResolveUpdatePass("remaining references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return deepReferences(node);
      }
    }, progress.subTask(2));

    codeTransformPass(nodes, progress.subTask(2));

    progress.done();
  }



  public List<IFile> getSuccessfulFiles() {
    return mySuccessfulFiles;
  }



  public List<SModel> getModels() {
    return myModels;
  }



  private void parseFile(IFile file) throws JavaParseException, IOException {
    String contents = IFileUtils.getTextContents(file);
    JavaParser.JavaParseResult parseResult = myJavaParser.parseCompilationUnit(contents);
    String pkg = parseResult.getPackage();

    if (pkg == null) {
      // default package (i.e. none), bad 
      if (!(wasDefaultPkg)) {
        LOG.error("default package is not supported in java source directory input (first such file in dir: " + file.getName() + ")");
        wasDefaultPkg = true;
      }
      return;
    }

    IFile dir = file.getParent();
    if (!(DirParser.checkPackageMatchesSourceDirectory(pkg, dir))) {
      LOG.error("package " + pkg + " doesn't match directory " + dir.getPath() + " (in file " + file.getName() + ")");
      return;
    }

    Iterable<SNode> roots = parseResult.getNodes();
    Set<SNode> classesInPackage = MapSequence.fromMap(classesPerPackage).get(pkg);
    if (classesInPackage == null) {
      classesInPackage = SetSequence.fromSet(new HashSet<SNode>(Sequence.fromIterable(roots).count()));
      MapSequence.fromMap(classesPerPackage).put(pkg, classesInPackage);
    }
    SetSequence.fromSet(classesInPackage).addSequence(Sequence.fromIterable(roots));

  }



  private void runCommand(String name, final Runnable runnable) {
    if (SwingUtilities.isEventDispatchThread()) {
      myModelAccess.executeCommand(runnable);

    } else {
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
            myModelAccess.executeCommand(runnable);
          }
        });

      } catch (InterruptedException e) {
        LOG.error(name + " was interrupted", e);
      } catch (InvocationTargetException e) {
        LOG.error("Exception in " + name, e.getCause());
      }
    }
  }


  private Set<SReference> myVisitedRefs = SetSequence.fromSet(new HashSet<SReference>());


  private void resolveUpdatePass(String stepName, Iterable<SNode> nodes, final _FunctionTypes._return_P1_E0<? extends Iterable<SReference>, ? super SNode> extractor, final ProgressMonitor progress) {
    final Map<SNodeReference, List<SReference>> resolveMap = MapSequence.fromMap(new HashMap<SNodeReference, List<SReference>>());

    progress.start(stepName, myRootCount + 1);

    myModelAccess.runReadAction(new Runnable() {
      public void run() {

        for (SModel model : ListSequence.fromList(myModels)) {
          for (SNode claz : ListSequence.fromList(SModelOperations.getRoots(model, "jetbrains.mps.baseLanguage.structure.Classifier"))) {

            progress.step(SPropertyOperations.getString(claz, "name"));

            Iterable<SReference> refs = extractor.invoke(claz);
            resolveRefs(refs, resolveMap);

            SetSequence.fromSet(myVisitedRefs).addSequence(Sequence.fromIterable(refs));
            progress.advance(1);
          }
        }
      }
    });

    runCommand(stepName, new Runnable() {
      public void run() {
        updateReference(resolveMap);
      }
    });

    progress.advance(1);
    progress.done();
  }



  private void nodesResolveUpdatePass(String name, final Iterable<SNode> nodes, final _FunctionTypes._return_P1_E0<? extends Iterable<SReference>, ? super SNode> extractor, final ProgressMonitor progress) {
    final Map<SNodeReference, List<SReference>> resolveMap = MapSequence.fromMap(new HashMap<SNodeReference, List<SReference>>());
    progress.start(name, Sequence.fromIterable(nodes).count() + 1);

    myModelAccess.runReadAction(new Runnable() {
      public void run() {

        for (SNode node : Sequence.fromIterable(nodes)) {

          if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.lang.core.structure.INamedConcept")) {
            progress.step(SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.lang.core.structure.INamedConcept"), "name"));
          }

          Iterable<SReference> refs = extractor.invoke(node);
          resolveRefs(refs, resolveMap);

          SetSequence.fromSet(myVisitedRefs).addSequence(Sequence.fromIterable(refs));
          progress.advance(1);
        }

      }
    });

    runCommand(name, new Runnable() {
      public void run() {
        updateReference(resolveMap);
      }
    });

    progress.advance(1);
    progress.done();
  }



  private void codeTransformPass(final Iterable<SNode> nodes, final ProgressMonitor progress) {
    progress.start("Code transforms", Sequence.fromIterable(nodes).count() + 1);
    final TypeChecker typeChecker = TypeChecker.getInstance();

    final List<SNode> toReplaceWithArrayLength = ListSequence.fromList(new ArrayList<SNode>());

    myModelAccess.runReadAction(new Runnable() {
      public void run() {
        for (SNode node : Sequence.fromIterable(nodes)) {

          for (SNode fieldRefOp : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation", false, new String[]{}))) {

            SReference fieldRef = SNodeOperations.getReference(fieldRefOp, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.FieldReferenceOperation", "fieldDeclaration"));
            if (!(fieldRef instanceof DynamicReference && "length".equals((((DynamicReference) fieldRef).getResolveInfo())))) {
              continue;
            }

            SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(fieldRefOp), "jetbrains.mps.baseLanguage.structure.DotExpression"), "operand", true);

            Iterable<SReference> operandRefs = SNodeOperations.getReferences(operand);
            if (Sequence.fromIterable(operandRefs).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return it instanceof DynamicReference;
              }
            })) {
              continue;
            }

            SNode operandType = typeChecker.getTypeOf(operand);
            if (SNodeOperations.isInstanceOf(operandType, "jetbrains.mps.baseLanguage.structure.ArrayType")) {
              ListSequence.fromList(toReplaceWithArrayLength).addElement(fieldRefOp);
            }
          }

          progress.advance(1);
        }

      }
    });

    runCommand("Code transforms", new Runnable() {
      public void run() {
        for (SNode fieldRefOp : ListSequence.fromList(toReplaceWithArrayLength)) {
          SNodeOperations.replaceWithNewChild(fieldRefOp, "jetbrains.mps.baseLanguage.structure.ArrayLengthOperation");
        }
      }
    });

    progress.advance(1);
    progress.done();
  }



  private Iterable<SReference> getTopLevelRefs(SNode node) {
    final List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());

    if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(SLinkOperations.getTarget(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "superclass", true))));
      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "implementedInterface", true)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(it)));
        }
      });

    } else if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Interface")) {
      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Interface"), "extendedInterface", true)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(it)));
        }
      });
    }

    for (SNode inner : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.Classifier", false, new String[]{}))) {
      if (SNodeOperations.isInstanceOf(inner, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
        continue;
      }
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getTopLevelRefs(inner)));
    }

    return refs;
  }



  private Iterable<SReference> getFieldAndMethodTypeRefs(SNode node) {
    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());
    Iterable<SNode> members = (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.Classifier") ?
      SLinkOperations.getTargets(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier"), "member", true) :
      Sequence.<SNode>singleton(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.ClassifierMember"))
    );

    for (SNode member : Sequence.fromIterable(members)) {
      if (SNodeOperations.isInstanceOf(member, "jetbrains.mps.baseLanguage.structure.VariableDeclaration")) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"), "type", true))));

      } else if (SNodeOperations.isInstanceOf(member, "jetbrains.mps.baseLanguage.structure.MethodDeclaration")) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "returnType", true))));
        for (SNode param : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(member, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "parameter", true))) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(param, "type", true))));
        }
        for (SNode thrws : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(member, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "throwsItem", true))) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(thrws)));
        }

      } else if (SNodeOperations.isInstanceOf(member, "jetbrains.mps.baseLanguage.structure.Classifier")) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getFieldAndMethodTypeRefs(member)));
      }
    }

    return refs;
  }



  private Iterable<SReference> getVarTypeRefs(SNode node) {
    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());

    for (SNode block : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.StatementList", false, new String[]{}))) {

      for (SNode varDecl : ListSequence.fromList(SNodeOperations.getDescendants(block, "jetbrains.mps.baseLanguage.structure.VariableDeclaration", false, new String[]{}))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(varDecl, "type", true))));
      }
    }

    return refs;
  }



  private Iterable<SReference> getVariableRefs(SNode node) {
    return ListSequence.fromList(SNodeOperations.getDescendantsWhereConceptInList(node, new String[]{"jetbrains.mps.baseLanguage.structure.LocalVariableReference", "jetbrains.mps.baseLanguage.structure.ParameterReference"}, false, new String[]{})).select(new ISelector<SNode, SReference>() {
      public SReference select(SNode it) {
        return SNodeOperations.getReference(it, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.VariableReference", "variableDeclaration"));
      }
    });
  }



  private Iterable<SReference> getDotExpLeftParts(SNode node) {
    return ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.DotExpression", false, new String[]{})).translate(new ITranslator2<SNode, SReference>() {
      public Iterable<SReference> translate(SNode it) {
        return deepReferences(SLinkOperations.getTarget(it, "operand", true));
      }
    });
  }



  private void resolveRefs(Iterable<SReference> refs, Map<SNodeReference, List<SReference>> result) {
    for (SReference ref : refs) {
      if (!(ref instanceof DynamicReference)) {
        continue;
      }
      if (SetSequence.fromSet(myVisitedRefs).contains((SReference) ref)) {
        continue;
      }

      SNode target = ref.getTargetNode();
      if (target == null) {
        continue;
      }

      SNode source = ref.getSourceNode();
      SModelReference targetModel = target.getModel().getReference();

      SReference staticRef = StaticReference.create(ref.getRole(), source, targetModel, target.getNodeId());

      List<SReference> nodeRefs = MapSequence.fromMap(result).get(source.getReference());
      if (nodeRefs == null) {
        nodeRefs = ListSequence.fromList(new ArrayList<SReference>());
        MapSequence.fromMap(result).put(source.getReference(), nodeRefs);
      }
      ListSequence.fromList(nodeRefs).addElement((SReference) staticRef);
    }
  }



  private void resolveReferences(SNode startNode, Map<SNodeReference, List<SReference>> result, int pass) {
    final Queue<SNode> stack = QueueSequence.fromQueue(new LinkedList<SNode>());
    QueueSequence.fromQueue(stack).addLastElement(startNode);

    while (QueueSequence.fromQueue(stack).isNotEmpty()) {
      SNode node = QueueSequence.fromQueue(stack).removeFirstElement();
      SModel ourModel = node.getModel();
      ListSequence.fromList(SNodeOperations.getChildren(node)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          QueueSequence.fromQueue(stack).addLastElement(it);
        }
      });

      Iterable<? extends SReference> refs = node.getReferences();
      List<SReference> newRefs = ListSequence.fromList(new ArrayList<SReference>());

      for (final SReference ref : Sequence.fromIterable(refs)) {
        if (!(ref instanceof DynamicReference)) {
          continue;
        }
        // FIXME temp hack around typesystem looping when resolving certain dyn.references 

        if (pass == 0) {
          if (ref.getRole().equals("baseMethodDeclaration")) {
            continue;
          }
          if (ref.getRole().equals("fieldDeclaration") || ref.getRole().equals("variableDeclaration")) {
            continue;
          }

        } else if (SNodeOperations.getConceptDeclaration(node) == SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.DotExpression")) {
          if (Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.DotExpression"), "operand", true))).any(new IWhereFilter<SReference>() {
            public boolean accept(SReference it) {
              SReference ref = it;
              return ref instanceof DynamicReference;
            }
          })) {

            continue;
          }
        }

        SNode target = null;

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<SNode> future = executor.submit(new Callable<SNode>() {
          public SNode call() throws Exception {
            final Wrappers._T<SNode> result = new Wrappers._T<SNode>();
            myModelAccess.runReadAction(new Runnable() {
              public void run() {
                result.value = ref.getTargetNode();
              }
            });
            return result.value;
          }
        });

        try {
          target = future.get(1000, TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
          System.out.println("Reference resolve timeout");
          future.cancel(true);
        } catch (Exception e) {
          future.cancel(true);
        }

        if (target == null) {
          continue;
        }

        SModelReference targetModel = target.getModel().getReference();

        SReference staticRef = StaticReference.create(ref.getRole(), node, target.getModel().getReference(), target.getNodeId());
        ListSequence.fromList(newRefs).addElement(staticRef);
      }

      if (ListSequence.fromList(newRefs).isNotEmpty()) {
        MapSequence.fromMap(result).put(node.getReference(), newRefs);
      }
    }
  }



  private void updateReference(Map<SNodeReference, List<SReference>> refMap) {
    for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(refMap).keySet())) {
      final SNode node = nodeRef.resolve(myRepository);
      if (node == null) {
        continue;
      }
      ListSequence.fromList(MapSequence.fromMap(refMap).get(nodeRef)).visitAll(new IVisitor<SReference>() {
        public void visit(SReference it) {

          SModelReference targetModelRef = it.getTargetSModelReference();
          ((SModelInternal) node.getModel()).addModelImport(targetModelRef, true);

          node.setReference(it.getRole(), it);
        }
      });
    }
  }



  private Iterable<SReference> deepReferences(SNode node) {

    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());
    ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(node)));
    for (SNode child : ListSequence.fromList(SNodeOperations.getChildren(node))) {
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(child)));
    }

    return refs;

    // generator for yield broken? 
  }



  private SModel registerModelForPackage(String fqName) {

    // FIXME uses not our myRepository (SRepository doesn't have getModelsByName) 
    SModel modelDescriptor = SModelRepository.getInstance().getModelDescriptor(fqName);
    if (modelDescriptor != null) {
      if (!(Sequence.fromIterable(((Iterable<SModel>) myModule.getModels())).contains(modelDescriptor))) {
        // <node> 
        // <node> 
        return createModel(fqName);
      }
      // package is already present... 
      // maybe we shouldn't touch it then, maybe it should be an option 
      return modelDescriptor;
    } else {
      return createModel(fqName);
    }
  }

  private SModel createModel(String packageName) {
    // first check if it is possible 
    if (getRootToCreateModel(packageName) == null) {
      LOG.error("Cannot create model " + packageName + " in module " + myModule.getModuleName());
      return null;
    }

    SModel modelDescr = SModuleOperations.createModelWithAdjustments(packageName, getRootToCreateModel(packageName));
    assert modelDescr != null;

    ((EditableSModel) modelDescr).save();
    return modelDescr;
  }

  @Nullable
  private ModelRoot getRootToCreateModel(String packageName) {
    for (ModelRoot root : Sequence.fromIterable(myModule.getModelRoots())) {
      if (root.canCreateModel(packageName)) {
        return root;
      }
    }
    return null;
  }


}
