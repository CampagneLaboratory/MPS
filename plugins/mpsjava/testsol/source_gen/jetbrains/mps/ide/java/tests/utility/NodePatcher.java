package jetbrains.mps.ide.java.tests.utility;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.SNodeId;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;

public class NodePatcher {
  public NodePatcher() {
  }

  public static void removeStatements(SNode node) {
    for (SNode method : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration", false, new String[]{}))) {
      SLinkOperations.setTarget(method, "body", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StubStatementList", null), true);
    }
  }

  /**
   * Sometimes editor doesn't set nonStatic to true, sometimes it does.
   * It makes node matching hard, as we don't know whether to set this property in
   * in the parser or not.
   * This method normalises classifier in this respect.
   */
  public static void fixNonStatic(SNode node) {
    for (SNode cls : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{}))) {
      if (SNodeAccessUtil.getProperty(cls, "nonStatic") == null) {
        SPropertyOperations.set(cls, "nonStatic", "" + (true));
      }
    }
  }

  public static void removeInitializers(SNode node) {
    for (SNode field : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.VariableDeclaration", false, new String[]{}))) {
      SLinkOperations.setTarget(field, "initializer", null, true);
    }
  }

  public static void removeConstructorName(SNode node) {
    for (SNode constr : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", false, new String[]{}))) {
      SPropertyOperations.set(constr, "name", null);
    }
  }

  public static void removeExtendsObject(SNode node) {
    for (SNode cls : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.ClassConcept", true, new String[]{}))) {
      if ((SLinkOperations.getTarget(cls, "superclass", true) != null) && (SLinkOperations.getTarget(SLinkOperations.getTarget(cls, "superclass", true), "classifier", false) != null) && SPropertyOperations.getString(SLinkOperations.getTarget(SLinkOperations.getTarget(cls, "superclass", true), "classifier", false), "name").equals("Object")) {
        SLinkOperations.setTarget(cls, "superclass", null, true);
      }
    }
  }

  public static void removeSourceLevelAnnotations(SNode node) {
    final SNode retentionAnno = ListSequence.fromList(SModelOperations.getRoots(SModelRepository.getInstance().getModelDescriptor(new SModelReference("java.lang.annotation", "java_stub")).getSModel(), "jetbrains.mps.baseLanguage.structure.Annotation")).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SPropertyOperations.getString(it, "name").equals("Retention");
      }
    });

    for (SNode thisAnnoInst : ListSequence.fromList(SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.AnnotationInstance", false, new String[]{}))) {
      // getting value of retention annotation for this annotation 
      SNode retensionExp = SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(thisAnnoInst, "annotation", false), "annotation", true)).findFirst(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SLinkOperations.getTarget(it, "annotation", false) == retentionAnno;
        }
      }), "value", true)).findFirst(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SPropertyOperations.getString(SLinkOperations.getTarget(it, "key", false), "name").equals("value");
        }
      }), "value", true);

      if ((retensionExp == null) || !(SNodeOperations.isInstanceOf(retensionExp, "jetbrains.mps.baseLanguage.structure.EnumConstantReference"))) {
        continue;
      }

      SNodeId sourceConst = new SNodeId.Foreign(SNodeId.Foreign.ID_PREFIX + "RetentionPolicy.SOURCE");
      SNodeId nodeId = retensionExp.getReference("enumConstantDeclaration").getTargetNodeId();

      boolean isSourceRetention = sourceConst.equals(nodeId);

      if (isSourceRetention) {
        SNodeOperations.deleteNode(thisAnnoInst);
      }
    }
  }

  public static void sortNestedClass(SNode node) {
    List<SNode> nested = new ArrayList<SNode>();
    ListSequence.fromList(nested).addSequence(Sequence.fromIterable(Classifier_Behavior.call_nestedClassifiers_5292274854859193142(node)).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(it, "name");
      }
    }, true));
    ListSequence.fromList(SLinkOperations.getTargets(node, "member", true)).removeWhere(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.Classifier");
      }
    });
    ListSequence.fromList(SLinkOperations.getTargets(node, "member", true)).addSequence(ListSequence.fromList(nested));
  }

  public static void removeSModelAttrs(SNode node) {
    for (SNode attr : ListSequence.fromList(AttributeOperations.getAttributeList(node, new IAttributeDescriptor.AllAttributes()))) {
      SNodeOperations.detachNode(attr);
      SNodeOperations.deleteNode(attr);
    }
  }
}
