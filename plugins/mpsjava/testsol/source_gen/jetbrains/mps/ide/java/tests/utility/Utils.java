package jetbrains.mps.ide.java.tests.utility;

/*Generated by MPS */

import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.textGen.TextGenerationResult;
import jetbrains.mps.textGen.TextGenerationUtil;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.build.ant.FileMPSProject;
import java.io.File;
import jetbrains.mps.util.PathManager;
import jetbrains.mps.ide.java.newparser.JavaParser;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelReference;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.ide.java.parser.FeatureKind;
import junit.framework.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.test.matcher.NodeDifference;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.ide.java.newparser.JavaParseException;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.stubs.javastub.classpath.StubHelper;
import jetbrains.mps.smodel.LanguageID;
import jetbrains.mps.stubs.BaseStubModelDescriptor;
import jetbrains.mps.ide.java.stubManagers.JavaSourceStubModelDS;
import java.util.ArrayList;
import jetbrains.mps.ide.java.stubManagers.JavaSourceStubs;
import java.util.Collection;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.project.SModelRoot;
import jetbrains.mps.project.structure.model.ModelRoot;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.ide.java.newparser.DirParser;
import jetbrains.mps.baseLanguage.stubs.JavaStubs;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public class Utils {
  private static IModule ourModule = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("c3786d2b-aba2-45e5-8de0-1124fd14259b"));

  public Utils() {
  }

  public static String generateCode(SNode node) {
    TextGenerationResult res = TextGenerationUtil.generateText(new ProjectOperationContext(new FileMPSProject(new File(PathManager.getHomePath()))), node);
    return (String) res.getResult();
  }

  /**
   * Currently doesn't work very well: DynamicReference resolving doesn't seem to happen.
   */
  public static void checkString(String code, SNode expected) {
    try {
      JavaParser parser = new JavaParser();
      SModel mdl;
      mdl = SModelRepository.getInstance().getModelDescriptor(new SModelReference("jetbrains.mps.ide.java.testMaterial.placeholder", "")).getSModel();
      List<SNode> res = parser.parse(code, SModelOperations.getModelName(mdl), FeatureKind.CLASS_STUB, true).getNodes();
      Assert.assertSame(ListSequence.fromList(res).count(), 1);

      SNode result = SNodeOperations.cast(res.get(0), "jetbrains.mps.baseLanguage.structure.Classifier");
      SModelOperations.addRootNode(mdl, result);

      NodePatcher.removeStatements(expected);
      NodePatcher.fixNonStatic(expected);
      NodePatcher.fixNonStatic(result);

      Map<SNode, SNode> nodeMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      buildClassifierNodeMap(result, expected, nodeMap);
      NodeDifference diff = NodesMatcher.matchNodes(result, expected, nodeMap);

      Assert.assertEquals(null, diff);

    } catch (JavaParseException e) {
      throw new RuntimeException(e);
    }
  }

  public static void checkFileAsString(File source, SNode expected) {
    String code = FileUtil.read(source);
    checkString(code, expected);
  }

  public static void checkFile(String path, SNode expected) {

    SModelReference modRef = StubHelper.uidForPackageInStubs("unused", LanguageID.JAVA, ourModule.getModuleReference());

    BaseStubModelDescriptor smd;
    smd = new BaseStubModelDescriptor(modRef, new JavaSourceStubModelDS(ourModule.getModuleReference(), null), ourModule);
    ((JavaSourceStubModelDS) smd.getSource()).addPath(path);
    SModel mdl = smd.getSModel();

    Assert.assertTrue(mdl.rootsIterator().hasNext());
    SNode result = SNodeOperations.cast(mdl.rootsIterator().next(), "jetbrains.mps.baseLanguage.structure.Classifier");

    NodePatcher.removeStatements(expected);
    NodePatcher.fixNonStatic(expected);
    NodePatcher.fixNonStatic(result);
    // <node> 
    // <node> 

    Assert.assertEquals(null, NodesMatcher.matchNodes(ListSequence.fromListAndArray(new ArrayList<SNode>(), expected), ListSequence.fromListAndArray(new ArrayList<SNode>(), result)));
  }

  public static void checkStubModel(String dirPath, SModel expected) {
    checkStubModels(dirPath, ListSequence.fromListAndArray(new ArrayList<SModel>(), expected));
  }

  public static void checkStubModels(String dirPath, List<SModel> expected) {
    try {
      JavaSourceStubs stubMgr = new JavaSourceStubs();

      Collection<SModelDescriptor> mds = stubMgr.load(new SModelRoot(ourModule, new ModelRoot(dirPath)));
      List<SModel> models = ListSequence.fromList(new ArrayList<SModel>());
      for (SModelDescriptor md : CollectionSequence.fromCollection(mds)) {
        SModel m = md.getSModel();
        ListSequence.fromList(models).addElement(m);
      }

      for (SModel m : ListSequence.fromList(expected)) {
        for (SNode root : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
          NodePatcher.removeStatements(SNodeOperations.cast(root, "jetbrains.mps.baseLanguage.structure.Classifier"));
          // <node> 
        }
      }

      compare(models, expected);

    } catch (SModelRoot.ManagerNotFoundException e) {
      throw new RuntimeException(e);
    }
  }

  public static void checkSourceModel(String dirPath, SModel expected) {
    try {
      // FIXME  
      JavaParser parser = new JavaParser();
      DirParser dirParser = new DirParser(ourModule, null, null);
      SModel result = SModelRepository.getInstance().getModelDescriptor(new SModelReference("jetbrains.mps.ide.java.testMaterial.placeholder", "")).getSModel();
      List<SNode> nodes = dirParser.parseDir(parser, new File(dirPath));

      for (SNode n : ListSequence.fromList(nodes)) {
        SModelOperations.addRootNode(result, n);
      }
      parser.tryResolveRoots(nodes);

      Map<SNode, SNode> referentMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      buildModelNodeMap(result, expected, referentMap);

      boolean wereErrors = compare2models(result, expected, referentMap);
      Assert.assertFalse(wereErrors);

    } catch (JavaParseException e) {
      throw new RuntimeException(e);
    }
  }

  public static void compareBinAndSrcStubs(String binPath, String sourcePath) {
    try {
      JavaStubs bin = new JavaStubs();
      JavaSourceStubs src = new JavaSourceStubs();

      // just 2 distinct modules 
      IModule mod1 = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("c3786d2b-aba2-45e5-8de0-1124fd14259b"));
      IModule mod2 = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("49166c31-952a-46f6-8970-ea45964379d0"));

      List<SModel> binModels = ListSequence.fromList(new ArrayList<SModel>());
      Collection<SModelDescriptor> binStubModels = bin.load(new SModelRoot(mod1, new ModelRoot(binPath)));
      for (SModelDescriptor md : CollectionSequence.fromCollection(binStubModels)) {
        SModel m = md.getSModel();
        ListSequence.fromList(binModels).addElement(m);

        for (SNode binRoot : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
          NodePatcher.fixNonStatic(binRoot);
          NodePatcher.removeConstructorName(binRoot);
          NodePatcher.removeExtendsObject(binRoot);
          NodePatcher.removeInitializers(binRoot);

          NodePatcher.sortNestedClass(SNodeOperations.cast(binRoot, "jetbrains.mps.baseLanguage.structure.Classifier"));

          // FIXME should be fixed in java source stubs 
          NodePatcher.removeStatements(binRoot);
        }
      }

      List<SModel> srcModels = ListSequence.fromList(new ArrayList<SModel>());
      Collection<SModelDescriptor> srcStubModels;
      srcStubModels = src.load(new SModelRoot(mod2, new ModelRoot(sourcePath)));
      for (SModelDescriptor md : CollectionSequence.fromCollection(srcStubModels)) {
        SModel m = md.getSModel();
        ListSequence.fromList(srcModels).addElement(m);
        // <node> 

        for (SNode srcRoot : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
          NodePatcher.fixNonStatic(srcRoot);
          NodePatcher.removeSourceLevelAnnotations(srcRoot);

          NodePatcher.sortNestedClass(SNodeOperations.cast(srcRoot, "jetbrains.mps.baseLanguage.structure.Classifier"));
        }
      }

      compare(binModels, srcModels);
      // <node> 

    } catch (SModelRoot.ManagerNotFoundException e) {
      throw new RuntimeException(e);
    }
  }

  public static void compare(Iterable<SModel> leftModels, Iterable<SModel> rightModels) {

    Map<String, SModel> leftModelMap = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel m : Sequence.fromIterable(leftModels)) {
      MapSequence.fromMap(leftModelMap).put(m.getLongName(), m);
    }

    Map<String, SModel> rightModelMap = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel m : Sequence.fromIterable(rightModels)) {
      MapSequence.fromMap(rightModelMap).put(m.getLongName(), m);
    }

    Assert.assertTrue(SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet()).containsSequence(SetSequence.fromSet(MapSequence.fromMap(rightModelMap).keySet())) && SetSequence.fromSet(MapSequence.fromMap(rightModelMap).keySet()).containsSequence(SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())));

    // constructing the map of corresponding nodes 
    Map<SNode, SNode> classMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    for (String name : SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())) {
      SModel binModel = MapSequence.fromMap(leftModelMap).get(name);
      SModel srcModel = MapSequence.fromMap(rightModelMap).get(name);

      buildModelNodeMap(binModel, srcModel, classMap);
    }

    // <node> 

    boolean errors = false;

    for (String name : SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())) {
      SModel binModel = MapSequence.fromMap(leftModelMap).get(name);
      SModel srcModel = MapSequence.fromMap(rightModelMap).get(name);

      errors = compare2models(binModel, srcModel, classMap);
    }

    Assert.assertFalse(errors);
  }

  public static boolean compare2models(SModel left, SModel right, Map<SNode, SNode> nodeMap) {
    boolean wereErrors = false;
    List<SNode> binRoots = SModelOperations.getRoots(left, null);
    List<SNode> srcRoots = SModelOperations.getRoots(right, null);

    binRoots = ListSequence.fromList(binRoots).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.Classifier"), "name");
      }
    }, true).toListSequence();
    srcRoots = ListSequence.fromList(srcRoots).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.Classifier"), "name");
      }
    }, true).toListSequence();

    // <node> 
    List<NodeDifference> diff = NodesMatcher.matchNodes(binRoots, srcRoots, nodeMap);
    if (diff != null) {
      wereErrors = true;
      // <node> 
    }
    return wereErrors;
  }

  public static void buildModelNodeMap(SModel left, SModel right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightRootIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightRoot : ListSequence.fromList(SModelOperations.getRoots(right, null))) {
      MapSequence.fromMap(rightRootIndex).put(SPropertyOperations.getString(SNodeOperations.cast(rightRoot, "jetbrains.mps.baseLanguage.structure.IValidIdentifier"), "name"), rightRoot);
    }

    for (SNode leftRoot : ListSequence.fromList(SModelOperations.getRoots(left, null))) {
      SNode rightBrother = MapSequence.fromMap(rightRootIndex).get(SPropertyOperations.getString(SNodeOperations.cast(leftRoot, "jetbrains.mps.baseLanguage.structure.IValidIdentifier"), "name"));
      buildClassifierNodeMap(SNodeOperations.cast(leftRoot, "jetbrains.mps.baseLanguage.structure.Classifier"), SNodeOperations.cast(rightBrother, "jetbrains.mps.baseLanguage.structure.Classifier"), nodeMap);
      // <node> 
    }
  }

  public static void buildClassifierNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {
    // handling this class and nested classes 
    Map<String, SNode> rightNestedIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode cl : ListSequence.fromList(SNodeOperations.getDescendants(right, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{}))) {
      MapSequence.fromMap(rightNestedIndex).put(SPropertyOperations.getString(cl, "name"), cl);
    }

    for (SNode cl : ListSequence.fromList(SNodeOperations.getDescendants(left, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{}))) {
      SNode rightBrother = SNodeOperations.cast(MapSequence.fromMap(rightNestedIndex).get(SPropertyOperations.getString(cl, "name")), "jetbrains.mps.baseLanguage.structure.Classifier");

      // <node> 

      Assert.assertNull(MapSequence.fromMap(nodeMap).get(cl));
      MapSequence.fromMap(nodeMap).put(cl, rightBrother);

      buildJustNodeMap(SLinkOperations.getTargets(left, "typeVariableDeclaration", true), SLinkOperations.getTargets(right, "typeVariableDeclaration", true), nodeMap);
      buildMethodsNodeMap(left, right, nodeMap);

    }

    if (SNodeOperations.isInstanceOf(left, "jetbrains.mps.baseLanguage.structure.Annotation") && SNodeOperations.isInstanceOf(right, "jetbrains.mps.baseLanguage.structure.Annotation")) {
      Map<String, SNode> rightMethodIndex = MapSequence.fromMap(new HashMap<String, SNode>());
      for (SNode mthd : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(right, "jetbrains.mps.baseLanguage.structure.Annotation"), "method", true))) {
        MapSequence.fromMap(rightMethodIndex).put(SPropertyOperations.getString(mthd, "name"), mthd);
      }

      for (SNode mthd : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(left, "jetbrains.mps.baseLanguage.structure.Annotation"), "method", true))) {
        Assert.assertNull(MapSequence.fromMap(nodeMap).get(mthd));
        MapSequence.fromMap(nodeMap).put(mthd, MapSequence.fromMap(rightMethodIndex).get(SPropertyOperations.getString(mthd, "name")));
      }
    }
  }

  public static void buildMethodsNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {
    List<SNode> leftMethods = new ArrayList<SNode>();
    List<SNode> rightMethods = new ArrayList<SNode>();
    ListSequence.fromList(leftMethods).addSequence(ListSequence.fromList(SLinkOperations.getTargets(left, "method", true)));
    ListSequence.fromList(rightMethods).addSequence(ListSequence.fromList(SLinkOperations.getTargets(right, "method", true)));

    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightMthd : ListSequence.fromList(rightMethods)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightMthd, "name"), rightMthd);
    }

    for (SNode leftMthd : ListSequence.fromList(leftMethods)) {
      buildMethodBodyNodeMap(leftMthd, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftMthd, "name")), nodeMap);
      // <node> 
    }
  }

  public static void buildMethodBodyNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {

    //  type vars 
    buildJustNodeMap(SLinkOperations.getTargets(left, "typeVariableDeclaration", true), SLinkOperations.getTargets(right, "typeVariableDeclaration", true), nodeMap);

    // local vars and params 
    List<SNode> leftVars = new ArrayList<SNode>();
    ListSequence.fromList(leftVars).addSequence(ListSequence.fromList(SLinkOperations.getTargets(left, "parameter", true)));
    ListSequence.fromList(leftVars).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(left, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", false, new String[]{"jetbrains.mps.baseLanguage.structure.AnonymousClass"})));

    List<SNode> rightVars = new ArrayList<SNode>();
    ListSequence.fromList(rightVars).addSequence(ListSequence.fromList(SLinkOperations.getTargets(right, "parameter", true)));
    ListSequence.fromList(rightVars).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(right, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", false, new String[]{"jetbrains.mps.baseLanguage.structure.AnonymousClass"})));

    buildJustNodeMap(leftVars, rightVars, nodeMap);

    // anonymous classes and their insides 


  }

  public static void buildJustNodeMap(List<SNode> left, List<SNode> right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightNode : ListSequence.fromList(right)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightNode, "name"), rightNode);
    }

    for (SNode leftNode : ListSequence.fromList(left)) {
      // <node> 
      MapSequence.fromMap(nodeMap).put(leftNode, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftNode, "name")));
    }
  }
}
