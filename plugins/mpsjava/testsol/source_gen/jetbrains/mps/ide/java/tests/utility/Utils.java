package jetbrains.mps.ide.java.tests.utility;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.textGen.TextGenerationResult;
import jetbrains.mps.textGen.TextGenerationUtil;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.build.ant.FileMPSProject;
import java.io.File;
import jetbrains.mps.util.PathManager;
import jetbrains.mps.ide.java.newparser.JavaParser;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.stubs.javastub.classpath.StubHelper;
import jetbrains.mps.smodel.LanguageID;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.smodel.SModel;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.ide.java.parser.FeatureKind;
import junit.framework.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.test.matcher.NodeDifference;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.project.IModule;
import jetbrains.mps.stubs.BaseStubModelDescriptor;
import jetbrains.mps.ide.java.stubManagers.JavaSourceStubModelDS;
import java.util.ArrayList;
import jetbrains.mps.ide.java.stubManagers.JavaSourceStubs;
import java.util.Collection;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.project.structure.model.ModelRoot;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.baseLanguage.stubs.JavaStubs;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public class Utils {
  public Utils() {
  }

  public static String generateCode(SNode node) {
    TextGenerationResult res = TextGenerationUtil.generateText(new ProjectOperationContext(new FileMPSProject(new File(PathManager.getHomePath()))), node);
    return (String) res.getResult();
  }

  /**
   * Currently doesn't work very well: DynamicReference resolving doesn't seem to happen.
   */
  public static void checkString(String code, SNode expected) {
    JavaParser parser = new JavaParser();
    ModuleReference mref = new ModuleReference("jetbrains.mps.ide.java.tests");
    SModelReference modRef = StubHelper.uidForPackageInStubs("unused", LanguageID.JAVA, MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("c3786d2b-aba2-45e5-8de0-1124fd14259b")).getModuleReference());

    SModel mdl = new SModel(modRef);
    List<SNode> res = parser.parse(code, SModelOperations.getModelName(mdl), FeatureKind.CLASS_STUB, true);
    Assert.assertSame(ListSequence.fromList(res).count(), 1);

    SNode result = SNodeOperations.cast(res.get(0), "jetbrains.mps.baseLanguage.structure.Classifier");

    System.out.println("Non static: " + SPropertyOperations.getBoolean(result, "nonStatic"));

    NodePatcher.removeStatements(expected);
    NodePatcher.fixNonStatic(expected);
    NodePatcher.fixNonStatic(result);

    Map<SNode, SNode> nodeMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    buildNodeMap(result, expected, nodeMap);
    NodeDifference diff = NodesMatcher.matchNodes(result, expected, nodeMap);

    Assert.assertEquals(null, diff);
  }

  public static void checkFileAsString(File source, SNode expected) {
    String code = FileUtil.read(source);
    checkString(code, expected);
  }

  public static void checkFile(String path, SNode expected) {

    IModule mod = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("c3786d2b-aba2-45e5-8de0-1124fd14259b"));
    SModelReference modRef = StubHelper.uidForPackageInStubs("unused", LanguageID.JAVA, mod.getModuleReference());

    BaseStubModelDescriptor smd;
    smd = new BaseStubModelDescriptor(modRef, new JavaSourceStubModelDS(mod.getModuleReference(), null), mod);
    ((JavaSourceStubModelDS) smd.getSource()).addPath(path);
    SModel mdl = smd.getSModel();

    Assert.assertTrue(mdl.rootsIterator().hasNext());
    SNode result = SNodeOperations.cast(mdl.rootsIterator().next(), "jetbrains.mps.baseLanguage.structure.Classifier");

    NodePatcher.removeStatements(expected);
    NodePatcher.fixNonStatic(expected);
    NodePatcher.fixNonStatic(result);
    // <node> 
    // <node> 

    Assert.assertEquals(null, NodesMatcher.matchNodes(ListSequence.fromListAndArray(new ArrayList<SNode>(), expected), ListSequence.fromListAndArray(new ArrayList<SNode>(), result)));
  }

  public static void checkModel(String dirPath, SModel expected) {
    checkModels(dirPath, ListSequence.fromListAndArray(new ArrayList<SModel>(), expected));
  }

  public static void checkModels(String dirPath, List<SModel> expected) {
    JavaSourceStubs stubMgr = new JavaSourceStubs();
    IModule mod = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("c3786d2b-aba2-45e5-8de0-1124fd14259b"));

    Collection<SModelDescriptor> mds = stubMgr.load(new ModelRoot(dirPath), mod);
    List<SModel> models = ListSequence.fromList(new ArrayList<SModel>());
    for (SModelDescriptor md : CollectionSequence.fromCollection(mds)) {
      SModel m = md.getSModel();
      ListSequence.fromList(models).addElement(m);
      // <node> 
    }

    for (SModel m : ListSequence.fromList(expected)) {
      for (SNode root : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
        NodePatcher.removeStatements(SNodeOperations.cast(root, "jetbrains.mps.baseLanguage.structure.Classifier"));
        // <node> 
      }
    }

    compare(models, expected);
  }

  public static void compareBinAndSrcStubs(String binPath, String sourcePath) {
    JavaStubs bin = new JavaStubs();
    JavaSourceStubs src = new JavaSourceStubs();

    // just 2 distinct modules 
    IModule mod1 = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("c3786d2b-aba2-45e5-8de0-1124fd14259b"));
    IModule mod2 = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("49166c31-952a-46f6-8970-ea45964379d0"));

    List<SModel> binModels = ListSequence.fromList(new ArrayList<SModel>());
    Collection<SModelDescriptor> binStubModels = bin.load(new ModelRoot(binPath), mod1);
    for (SModelDescriptor md : CollectionSequence.fromCollection(binStubModels)) {
      SModel m = md.getSModel();
      ListSequence.fromList(binModels).addElement(m);
      System.out.println(m.getLongName());

      for (SNode binRoot : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
        NodePatcher.fixNonStatic(binRoot);
        NodePatcher.removeConstructorName(binRoot);
        NodePatcher.removeExtendsObject(binRoot);
        NodePatcher.removeInitializers(binRoot);

        NodePatcher.sortNestedClass(SNodeOperations.cast(binRoot, "jetbrains.mps.baseLanguage.structure.Classifier"));

        // FIXME should be fixed in java source stubs 
        NodePatcher.removeStatements(binRoot);
      }
    }

    System.out.println("-------------------------");

    List<SModel> srcModels = ListSequence.fromList(new ArrayList<SModel>());
    Collection<SModelDescriptor> srcStubModels;
    srcStubModels = src.load(new ModelRoot(sourcePath), mod2);
    for (SModelDescriptor md : CollectionSequence.fromCollection(srcStubModels)) {
      SModel m = md.getSModel();
      ListSequence.fromList(srcModels).addElement(m);
      System.out.println(m.getLongName());

      for (SNode srcRoot : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
        NodePatcher.fixNonStatic(srcRoot);
        NodePatcher.removeSourceLevelAnnotations(srcRoot);

        NodePatcher.sortNestedClass(SNodeOperations.cast(srcRoot, "jetbrains.mps.baseLanguage.structure.Classifier"));
      }
    }

    compare(binModels, srcModels);
    // <node> 
  }

  public static void compare(List<SModel> leftModels, List<SModel> rightModels) {

    Map<String, SModel> leftModelMap = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel m : ListSequence.fromList(leftModels)) {
      MapSequence.fromMap(leftModelMap).put(m.getLongName(), m);
    }

    Map<String, SModel> rightModelMap = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel m : ListSequence.fromList(rightModels)) {
      MapSequence.fromMap(rightModelMap).put(m.getLongName(), m);
    }

    Assert.assertTrue(SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet()).containsSequence(SetSequence.fromSet(MapSequence.fromMap(rightModelMap).keySet())) && SetSequence.fromSet(MapSequence.fromMap(rightModelMap).keySet()).containsSequence(SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())));

    // constructing the map of corresponding nodes 
    Map<SNode, SNode> classMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    for (String name : SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())) {
      SModel binModel = MapSequence.fromMap(leftModelMap).get(name);
      SModel srcModel = MapSequence.fromMap(rightModelMap).get(name);

      buildNodeMap(binModel, srcModel, classMap);
    }

    System.out.println("-------------------------");

    boolean errors = false;

    for (String name : SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())) {
      SModel binModel = MapSequence.fromMap(leftModelMap).get(name);
      SModel srcModel = MapSequence.fromMap(rightModelMap).get(name);

      List<SNode> binRoots = SModelOperations.getRoots(binModel, null);
      List<SNode> srcRoots = SModelOperations.getRoots(srcModel, null);

      binRoots = ListSequence.fromList(binRoots).sort(new ISelector<SNode, String>() {
        public String select(SNode it) {
          return SPropertyOperations.getString(SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.Classifier"), "name");
        }
      }, true).toListSequence();
      srcRoots = ListSequence.fromList(srcRoots).sort(new ISelector<SNode, String>() {
        public String select(SNode it) {
          return SPropertyOperations.getString(SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.Classifier"), "name");
        }
      }, true).toListSequence();

      System.out.println("Checking " + name);
      List<NodeDifference> diff = NodesMatcher.matchNodes(binRoots, srcRoots, classMap);
      if (diff != null) {
        errors = true;
        System.err.println("Diff: " + diff);
      }
    }

    Assert.assertFalse(errors);
  }

  public static void buildNodeMap(SModel left, SModel right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightRootIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightRoot : ListSequence.fromList(SModelOperations.getRoots(right, null))) {
      MapSequence.fromMap(rightRootIndex).put(SPropertyOperations.getString(SNodeOperations.cast(rightRoot, "jetbrains.mps.baseLanguage.structure.IValidIdentifier"), "name"), rightRoot);
    }

    for (SNode leftRoot : ListSequence.fromList(SModelOperations.getRoots(left, null))) {
      SNode rightBrother = MapSequence.fromMap(rightRootIndex).get(SPropertyOperations.getString(SNodeOperations.cast(leftRoot, "jetbrains.mps.baseLanguage.structure.IValidIdentifier"), "name"));
      buildNodeMap(SNodeOperations.cast(leftRoot, "jetbrains.mps.baseLanguage.structure.Classifier"), SNodeOperations.cast(rightBrother, "jetbrains.mps.baseLanguage.structure.Classifier"), nodeMap);
      // <node> 
    }
  }

  public static void buildNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {
    // handling this class and nested classes 
    Map<String, SNode> rightNestedIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode cl : ListSequence.fromList(SNodeOperations.getDescendants(right, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{}))) {
      MapSequence.fromMap(rightNestedIndex).put(SPropertyOperations.getString(cl, "name"), cl);
    }

    for (SNode cl : ListSequence.fromList(SNodeOperations.getDescendants(left, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{}))) {
      SNode rightBrother = SNodeOperations.cast(MapSequence.fromMap(rightNestedIndex).get(SPropertyOperations.getString(cl, "name")), "jetbrains.mps.baseLanguage.structure.Classifier");

      System.out.println("Mapping " + SPropertyOperations.getString(cl, "name") + " to " + SPropertyOperations.getString(rightBrother, "name"));

      Assert.assertNull(MapSequence.fromMap(nodeMap).get(cl));
      MapSequence.fromMap(nodeMap).put(cl, rightBrother);

      buildNodeMap(SLinkOperations.getTargets(left, "typeVariableDeclaration", true), SLinkOperations.getTargets(right, "typeVariableDeclaration", true), nodeMap);
      buildMethodTypeVarNodeMap(left, right, nodeMap);

    }

    if (SNodeOperations.isInstanceOf(left, "jetbrains.mps.baseLanguage.structure.Annotation") && SNodeOperations.isInstanceOf(right, "jetbrains.mps.baseLanguage.structure.Annotation")) {
      Map<String, SNode> rightMethodIndex = MapSequence.fromMap(new HashMap<String, SNode>());
      for (SNode mthd : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(right, "jetbrains.mps.baseLanguage.structure.Annotation"), "method", true))) {
        MapSequence.fromMap(rightMethodIndex).put(SPropertyOperations.getString(mthd, "name"), mthd);
      }

      for (SNode mthd : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(left, "jetbrains.mps.baseLanguage.structure.Annotation"), "method", true))) {
        Assert.assertNull(MapSequence.fromMap(nodeMap).get(mthd));
        MapSequence.fromMap(nodeMap).put(mthd, MapSequence.fromMap(rightMethodIndex).get(SPropertyOperations.getString(mthd, "name")));
      }
    }
  }

  public static void buildNodeMap(List<SNode> left, List<SNode> right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightTVar : ListSequence.fromList(right)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightTVar, "name"), rightTVar);
    }

    for (SNode leftTVar : ListSequence.fromList(left)) {
      // <node> 
      MapSequence.fromMap(nodeMap).put(leftTVar, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftTVar, "name")));
      System.out.println("Mapping type var " + SPropertyOperations.getString(leftTVar, "name") + " " + leftTVar.hashCode());
    }
  }

  public static void buildMethodTypeVarNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {
    List<SNode> leftMethods = new ArrayList<SNode>();
    List<SNode> rightMethods = new ArrayList<SNode>();
    ListSequence.fromList(leftMethods).addSequence(ListSequence.fromList(SLinkOperations.getTargets(left, "method", true)));
    ListSequence.fromList(rightMethods).addSequence(ListSequence.fromList(SLinkOperations.getTargets(right, "method", true)));

    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightMthd : ListSequence.fromList(rightMethods)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightMthd, "name"), rightMthd);
    }

    for (SNode leftMthd : ListSequence.fromList(leftMethods)) {
      buildNodeMap(SLinkOperations.getTargets(leftMthd, "typeVariableDeclaration", true), SLinkOperations.getTargets(MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftMthd, "name")), "typeVariableDeclaration", true), nodeMap);
    }
  }

  public static void buildMethodBodyNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {

    List<SNode> leftVars = new ArrayList<SNode>();
    ListSequence.fromList(leftVars).addSequence(ListSequence.fromList(SLinkOperations.getTargets(left, "parameter", true)));
    ListSequence.fromList(leftVars).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(left, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", false, new String[]{"jetbrains.mps.baseLanguage.structure.AnonymousClass"})));

    List<SNode> rightVars = new ArrayList<SNode>();
    ListSequence.fromList(rightVars).addSequence(ListSequence.fromList(SLinkOperations.getTargets(right, "parameter", true)));
    ListSequence.fromList(rightVars).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(right, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", false, new String[]{"jetbrains.mps.baseLanguage.structure.AnonymousClass"})));

    buildJustNodeMap(leftVars, rightVars, nodeMap);
  }

  public static void buildJustNodeMap(List<SNode> left, List<SNode> right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightNode : ListSequence.fromList(right)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightNode, "name"), rightNode);
    }

    for (SNode leftNode : ListSequence.fromList(left)) {
      // <node> 
      MapSequence.fromMap(nodeMap).put(leftNode, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftNode, "name")));
    }
  }
}
