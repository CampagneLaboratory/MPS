package jetbrains.mps.ide.java.workbench.actions;

/*Generated by MPS */

import jetbrains.mps.ide.platform.refactoring.RefactoringDialog;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.util.plugin.refactorings.ChangeMethodSignatureParameters;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.ide.embeddableEditor.EmbeddableEditor;
import java.util.List;
import jetbrains.mps.baseLanguage.util.plugin.refactorings.ChangeMethodSignatureRefactoring;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.ModelAccess;
import javax.swing.JComponent;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SModelOperations;
import javax.swing.border.TitledBorder;
import org.jetbrains.annotations.Nullable;
import java.awt.GridBagLayout;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.ArrayList;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.baseLanguage.util.plugin.refactorings.MethodRefactoringUtils;
import jetbrains.mps.progress.ProgressMonitorAdapter;

public class ChangeMethodSignatureDialog extends RefactoringDialog {
  private SNode myDeclaration;
  private ChangeMethodSignatureParameters myParameters;
  private IOperationContext myOperationContext;
  private EmbeddableEditor myEditor;
  private List<ChangeMethodSignatureRefactoring> myRefactorings = null;

  public ChangeMethodSignatureDialog(@NotNull Project project, SNode node, IOperationContext operationContext) {
    super(project, true);
    setTitle("Change Method Signature");

    this.myOperationContext = operationContext;
    this.myDeclaration = node;
    // TODO: call this constructor inside read action? 
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ChangeMethodSignatureDialog.this.myParameters = new ChangeMethodSignatureParameters(myDeclaration);
      }
    });

    init();
  }

  private JComponent createSingnaturePanel() {
    JPanel panel = new JPanel(new BorderLayout());
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        final SNode baseMethodDecalration = ChangeMethodSignatureDialog.this.myParameters.getDeclaration();
        SLinkOperations.setTarget(baseMethodDecalration, "body", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null), true);
        ChangeMethodSignatureDialog.this.myEditor = new EmbeddableEditor(ChangeMethodSignatureDialog.this.myOperationContext.getProject(), new _FunctionTypes._void_P1_E0<SModel>() {
          public void invoke(SModel m) {
            m.addRootNode(baseMethodDecalration);
          }
        }, true);
        myEditor.editNode(baseMethodDecalration);

        SModule module = ChangeMethodSignatureDialog.this.myOperationContext.getModule();
        if (module instanceof Language) {
          ChangeMethodSignatureDialog.this.myEditor.addLanguageStructureModel((Language) module);
        }
        SModule m = ChangeMethodSignatureDialog.this.myOperationContext.getModule();
        for (Language language : CollectionSequence.fromCollection(new GlobalModuleDependenciesManager(m).getUsedLanguages())) {
          ChangeMethodSignatureDialog.this.myEditor.addLanguage(language);
        }
        SModel model = ChangeMethodSignatureDialog.this.myDeclaration.getModel();
        for (SModelReference imported : ListSequence.fromList(SModelOperations.getImportedModelUIDs(model))) {
          ChangeMethodSignatureDialog.this.myEditor.addModel(imported);
        }
      }
    });
    panel.setBorder(new TitledBorder("Method signature"));
    panel.add(this.myEditor.getComponenet());
    return panel;
  }

  public List<ChangeMethodSignatureRefactoring> getAllRefactorings() {
    return myRefactorings;
  }

  @Nullable
  @Override
  protected JComponent createCenterPanel() {
    JPanel panel = new JPanel(new GridBagLayout());
    GridBagConstraints c = new GridBagConstraints();
    c.fill = GridBagConstraints.BOTH;
    c.insets = new Insets(3, 3, 3, 3);
    c.gridx = 0;
    c.gridy = 0;
    c.weightx = 1;
    c.weighty = 1;
    panel.add(this.createSingnaturePanel(), c);
    return panel;
  }

  @Override
  protected void doRefactoringAction() {
    final Wrappers._T<List<SNode>> methodsToRefactor = new Wrappers._T<List<SNode>>(new ArrayList<SNode>());
    ProgressManager.getInstance().run(new Task.Modal(myProject, "Search for overriding methods", true) {
      @Override
      public void run(@NotNull final ProgressIndicator indicator) {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            methodsToRefactor.value = MethodRefactoringUtils.findOverridingMethods(ChangeMethodSignatureDialog.this.myDeclaration, ChangeMethodSignatureDialog.this.myOperationContext, new ProgressMonitorAdapter(indicator));
          }
        });
      }
    });
    ListSequence.fromList(methodsToRefactor.value).addElement(myDeclaration);
    myRefactorings = ListSequence.fromList(new ArrayList<ChangeMethodSignatureRefactoring>());
    for (SNode method : ListSequence.fromList(methodsToRefactor.value)) {
      ListSequence.fromList(myRefactorings).addElement(new ChangeMethodSignatureRefactoring(this.myParameters, method));
    }
    super.doRefactoringAction();
  }

  @Override
  protected void dispose() {
    if (myEditor != null) {
      myEditor.disposeEditor();
      myEditor = null;
    }
    super.dispose();
  }
}
