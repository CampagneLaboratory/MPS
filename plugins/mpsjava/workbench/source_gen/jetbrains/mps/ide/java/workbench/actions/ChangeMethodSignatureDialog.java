package jetbrains.mps.ide.java.workbench.actions;

/*Generated by MPS */

import jetbrains.mps.ide.platform.refactoring.RefactoringDialog;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.util.plugin.refactorings.ChangeMethodSignatureParameters;
import jetbrains.mps.smodel.IOperationContext;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.ide.embeddableEditor.EmbeddableEditor;
import jetbrains.mps.project.Project;
import java.util.List;
import jetbrains.mps.baseLanguage.util.plugin.refactorings.ChangeMethodSignatureRefactoring;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.ide.project.ProjectHelper;
import javax.swing.JComponent;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import javax.swing.border.TitledBorder;
import org.jetbrains.annotations.Nullable;
import java.awt.GridBagLayout;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.ArrayList;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.progress.ProgressIndicator;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.baseLanguage.util.plugin.refactorings.MethodRefactoringUtils;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class ChangeMethodSignatureDialog extends RefactoringDialog {
  private SNode myDeclaration;
  private ChangeMethodSignatureParameters myParameters;
  private IOperationContext myOperationContext;
  private SModel myTempModel;
  private EmbeddableEditor myEditor;
  private Project myProject;
  private List<ChangeMethodSignatureRefactoring> myRefactorings = null;


  public ChangeMethodSignatureDialog(@NotNull com.intellij.openapi.project.Project project, SNode node, IOperationContext operationContext) {
    super(project, true);
    setTitle("Change Method Signature");
    this.myProject = ProjectHelper.toMPSProject(project);
    this.myOperationContext = operationContext;
    this.myDeclaration = node;
    // TODO: call this constructor inside read action? 
    myProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        ChangeMethodSignatureDialog.this.myParameters = new ChangeMethodSignatureParameters(myDeclaration);
      }
    });
    init();
  }

  private JComponent createSingnaturePanel() {
    JPanel panel = new JPanel(new BorderLayout());
    myProject.getRepository().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        SNode baseMethodDeclaration = ChangeMethodSignatureDialog.this.myParameters.getDeclaration();
        SLinkOperations.setTarget(baseMethodDeclaration, "body", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null), true);

        myTempModel = TemporaryModels.getInstance().create(false, TempModuleOptions.forDefaultModule());
        myTempModel.addRootNode(baseMethodDeclaration);
        TemporaryModels.getInstance().addMissingImports(myTempModel);

        ChangeMethodSignatureDialog.this.myEditor = new EmbeddableEditor(myProject, true);
        myEditor.editNode(baseMethodDeclaration);
      }
    });
    panel.setBorder(new TitledBorder("Method signature"));
    panel.add(this.myEditor);
    return panel;
  }

  public List<ChangeMethodSignatureRefactoring> getAllRefactorings() {
    return myRefactorings;
  }

  @Nullable
  @Override
  protected JComponent createCenterPanel() {
    JPanel panel = new JPanel(new GridBagLayout());
    GridBagConstraints c = new GridBagConstraints();
    c.fill = GridBagConstraints.BOTH;
    c.insets = new Insets(3, 3, 3, 3);
    c.gridx = 0;
    c.gridy = 0;
    c.weightx = 1;
    c.weighty = 1;
    panel.add(this.createSingnaturePanel(), c);
    return panel;
  }

  @Override
  protected void doRefactoringAction() {
    final Wrappers._T<List<SNode>> methodsToRefactor = new Wrappers._T<List<SNode>>(new ArrayList<SNode>());
    ProgressManager.getInstance().run(new Task.Modal(getProject(), "Search for overriding methods", true) {
      @Override
      public void run(@NotNull final ProgressIndicator indicator) {
        ModelAccess modelAccess = ChangeMethodSignatureDialog.this.myProject.getRepository().getModelAccess();
        modelAccess.runReadAction(new Runnable() {
          public void run() {
            methodsToRefactor.value = MethodRefactoringUtils.findOverridingMethods(ChangeMethodSignatureDialog.this.myDeclaration, ChangeMethodSignatureDialog.this.myOperationContext, new ProgressMonitorAdapter(indicator));
          }
        });
      }
    });
    ListSequence.fromList(methodsToRefactor.value).addElement(myDeclaration);
    myRefactorings = ListSequence.fromList(new ArrayList<ChangeMethodSignatureRefactoring>());
    for (SNode method : ListSequence.fromList(methodsToRefactor.value)) {
      ListSequence.fromList(myRefactorings).addElement(new ChangeMethodSignatureRefactoring(this.myParameters, method));
    }
    super.doRefactoringAction();
  }

  @Override
  protected void dispose() {
    if (myEditor != null) {
      myEditor.disposeEditor();
      myEditor = null;
    }
    if (myTempModel != null) {
      myProject.getRepository().getModelAccess().runWriteAction(new Runnable() {
        public void run() {
          TemporaryModels.getInstance().dispose(myTempModel);
          myTempModel = null;
        }
      });
    }
    super.dispose();
  }
}
