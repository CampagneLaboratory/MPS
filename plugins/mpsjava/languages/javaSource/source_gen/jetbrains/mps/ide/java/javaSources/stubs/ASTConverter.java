package jetbrains.mps.ide.java.javaSources.stubs;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SNode;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
import java.util.List;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
import org.eclipse.jdt.internal.compiler.ast.Annotation;
import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.DynamicReference;
import org.eclipse.jdt.internal.compiler.ast.Argument;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.Wildcard;
import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.TrueLiteral;
import org.eclipse.jdt.internal.compiler.ast.FalseLiteral;
import org.eclipse.jdt.internal.compiler.ast.StringLiteral;
import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.lang.typesystem.runtime.HUtil;


/**
 * Convert eclipse AST into BaseLanguage nodes.
 */
public class ASTConverter {
  private SModel myCurrentModel;
  @NotNull
  private TypeNameResolver myClassResolver;
  private boolean myConvertBodies = false;

  public ASTConverter(@NotNull SModel mdl, TypeNameResolver importResolver) {
    myCurrentModel = mdl;
    if (importResolver == null) {
      myClassResolver = new TypeNameResolver(myCurrentModel);
    } else {
      myClassResolver = importResolver;
    }
  }

  public SNode convertRoot(ASTNode node) {
    if (node instanceof TypeDeclaration) {

      TypeDeclaration decl = (TypeDeclaration) node;
      String name = new String(decl.name);
      myClassResolver.addTypeName(name);
      myClassResolver.enterType(name);
      try {
        return convertTypeDecl(decl);
      } finally {
        myClassResolver.leaveType();
      }

    } else {
      throw new JavaParseException("Root is not type decl");
    }
  }

  public SNode convertTypeDecl(TypeDeclaration x) {

    SNode cls;

    switch (TypeDeclaration.kind(x.modifiers)) {
      case TypeDeclaration.CLASS_DECL:
        cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassConcept", null);
        break;

      case TypeDeclaration.INTERFACE_DECL:
        cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Interface", null);
        break;

      case TypeDeclaration.ENUM_DECL:
        cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumClass", null);
        break;

      case TypeDeclaration.ANNOTATION_TYPE_DECL:
        cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Annotation", null);
        break;
      default:
        throw new JavaParseException("Unknown type declaration type");
    }

    SPropertyOperations.set(cls, "name", new String(x.name));
    SLinkOperations.setTarget(cls, "visibility", convertVisibility(x.modifiers), true);
    // <node> 
    // FIXME work around. what's with interface here 
    if (!(SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface")) && flagSet(x.modifiers, ClassFileConstants.AccStatic)) {
      // setting nonStatic only if static keyword is present 
      SPropertyOperations.set(cls, "nonStatic", "" + false);
    }

    // <node> 
    // <node> 


    // handling type params 
    myClassResolver.newTypeVarFrame();
    convertTypeVars(x.typeParameters, cls);


    // handling nested classes 
    if (x.memberTypes != null) {

      //  putting them into resolver's scope 
      for (TypeDeclaration innerTyp : x.memberTypes) {
        myClassResolver.addTypeName(new String(innerTyp.name));
      }

      // now actually processing them 
      for (TypeDeclaration innerTyp : x.memberTypes) {
        myClassResolver.enterType(new String(innerTyp.name));

        try {
          SNode nested = convertTypeDecl(innerTyp);
          SLinkOperations.getTargets(cls, "staticInnerClassifiers", true).add(nested);
        } finally {
          // maintaining valid state of ClassNameResolver 
          myClassResolver.leaveType();
        }
      }
    }

    convertAnnotations(x.annotations, cls);

    {
      SNode claz = cls;
      if (SNodeOperations.isInstanceOf(claz, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        // we're either class or enum 
        SLinkOperations.setTarget(claz, "superclass", SNodeOperations.cast(convertTypeRef(x.superclass), "jetbrains.mps.baseLanguage.structure.ClassifierType"), true);
        ListSequence.fromList(SLinkOperations.getTargets(claz, "implementedInterface", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.superInterfaces)).select(new ISelector<TypeReference, SNode>() {
          public SNode select(TypeReference it) {
            return SNodeOperations.cast(convertTypeRef(it), "jetbrains.mps.baseLanguage.structure.ClassifierType");
          }
        }));
        SPropertyOperations.set(claz, "abstractClass", "" + flagSet(x.modifiers, ClassFileConstants.AccAbstract));
        SPropertyOperations.set(claz, "isFinal", "" + flagSet(x.modifiers, ClassFileConstants.AccFinal));
      }
    }

    {
      SNode iface = cls;
      if (SNodeOperations.isInstanceOf(iface, "jetbrains.mps.baseLanguage.structure.Interface")) {
        // <node> 
        ListSequence.fromList(SLinkOperations.getTargets(iface, "extendedInterface", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.superInterfaces)).select(new ISelector<TypeReference, SNode>() {
          public SNode select(TypeReference it) {
            return SNodeOperations.cast(convertTypeRef(it), "jetbrains.mps.baseLanguage.structure.ClassifierType");
          }
        }));
      }
    }

    {
      SNode enm = cls;
      if (SNodeOperations.isInstanceOf(enm, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
        if (x.fields != null) {
          for (FieldDeclaration f : x.fields) {
            if (!(isEnumConstant(f))) {
              continue;
            }
            SNode constr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", null);
            // TODO 
            SNode item = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration", null);
            SPropertyOperations.set(item, "name", enumConstantName(f));
            // <node> 
            SLinkOperations.getTargets(enm, "enumConstant", true).add(item);
          }
        }
      }
    }

    // handle class fields 
    if (x.fields != null) {
      List<SNode> fields;
      SNode fDecl;

      for (FieldDeclaration f : x.fields) {

        if (f.name == null || isEnumConstant(f)) {
          continue;
        }

        fields = null;
        fDecl = null;

        if (flagSet(f.modifiers, ClassFileConstants.AccStatic) || SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface")) {
          // interfaces in java can have fields not declared as static, but they are static 
          fields = SLinkOperations.getTargets(cls, "staticField", true);
          SNode staticDecl = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration", null);
          fDecl = staticDecl;

        } else {
          assert SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept");

          fields = SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "field", true);
          SNode fieldDecl = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldDeclaration", null);

          SPropertyOperations.set(fieldDecl, "isVolatile", "" + flagSet(f.modifiers, ClassFileConstants.AccVolatile));
          SPropertyOperations.set(fieldDecl, "isTransient", "" + flagSet(f.modifiers, ClassFileConstants.AccTransient));

          fDecl = fieldDecl;
        }

        if ((fDecl != null)) {
          convertAnnotations(f.annotations, fDecl);

          SPropertyOperations.set(fDecl, "name", new String(f.name));
          SLinkOperations.setTarget(fDecl, "type", convertTypeRef(f.type), true);

          SLinkOperations.setTarget(SNodeOperations.cast(fDecl, "jetbrains.mps.baseLanguage.structure.IVisible"), "visibility", convertVisibility(f.modifiers), true);

          SPropertyOperations.set(fDecl, "isFinal", "" + flagSet(f.modifiers, ClassFileConstants.AccFinal));

          ListSequence.fromList(fields).addElement(fDecl);
        }
      }
    }

    // handling methods 
    if (x.methods != null) {
      List<SNode> methods;
      SNode result;

      for (AbstractMethodDeclaration method : x.methods) {

        if (method instanceof MethodDeclaration) {

          if (flagSet(method.modifiers, ClassFileConstants.AccStatic) && SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
            methods = SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "staticMethod", true);
            result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration", null);
          } else if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Annotation")) {
            methods = SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.Annotation"), "method", true);
            result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration", null);
          } else {
            methods = SLinkOperations.getTargets(cls, "method", true);
            result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration", null);
          }

          if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface")) {
            SPropertyOperations.set(SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"), "isAbstract", "" + true);
            SLinkOperations.setTarget(SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"), "visibility", new ASTConverter.QuotationClass_rbndtb_a0a1a3a1a3a53a1().createNode(), true);
          }

          methods.add(convertMethod((MethodDeclaration) method, result));

        } else if (method instanceof ConstructorDeclaration) {

          result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", null);
          SLinkOperations.setTarget(result, "returnType", new ASTConverter.QuotationClass_rbndtb_a0a2a0b0d0jb0b().createNode(), true);
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "constructor", true)).addElement(SNodeOperations.cast(convertMethod(method, result), "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration"));
        }
      }

    }

    myClassResolver.leaveTypeVarFrame();

    return cls;
  }

  public void convertTypeVars(TypeParameter[] pars, SNode result) {
    if (pars != null) {
      for (TypeParameter par : pars) {
        SNode typeVar = convertTypeVar(par);
        ListSequence.fromList(SLinkOperations.getTargets(result, "typeVariableDeclaration", true)).addElement(typeVar);
        myClassResolver.addTypeVar(typeVar);
      }
    }
  }

  public SNode convertTypeVar(TypeParameter par) {
    SNode tvar = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration", null);
    SPropertyOperations.set(tvar, "name", new String(par.name));
    // TODO constraints like extends, super ... 
    if (par.type != null) {
      SLinkOperations.setTarget(tvar, "bound", convertTypeRef(par.type), true);
    }
    if (par.bounds != null) {
      for (TypeReference b : par.bounds) {
        // FIXME report or tolerate error if it's not a classifier type 
        ListSequence.fromList(SLinkOperations.getTargets(tvar, "auxBounds", true)).addElement(SNodeOperations.cast(convertTypeRef(b), "jetbrains.mps.baseLanguage.structure.ClassifierType"));
      }
    }
    return tvar;
  }

  public void convertAnnotations(Annotation[] annos, SNode result) {
    if (annos != null) {
      for (Annotation anno : annos) {
        SLinkOperations.getTargets(result, "annotation", true).add(convertAnnotation(anno));
      }
    }
  }

  public SNode convertAnnotation(Annotation anno) {
    TypeReference typRef = anno.type;

    String name;
    if (typRef instanceof SingleTypeReference) {
      name = new String(((SingleTypeReference) typRef).token);
    } else if (typRef instanceof QualifiedTypeReference) {
      StringBuffer sb = new StringBuffer();
      name = ((QualifiedTypeReference) typRef).print(0, sb).toString();
    } else {
      throw new RuntimeException("FIXME");
    }

    SNode node = myClassResolver.resolveAnnotaion(name);
    for (MemberValuePair pair : anno.memberValuePairs()) {
      SNode val = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationInstanceValue", null);
      SReference ref = new DynamicReference("key", val, null, new String(pair.name));
      val.addReference(ref);
      SLinkOperations.setTarget(val, "value", convertExpression(pair.value), true);
      ListSequence.fromList(SLinkOperations.getTargets(node, "value", true)).addElement(val);
    }
    return node;
  }

  public SNode convertMethod(@NotNull AbstractMethodDeclaration x, @NotNull SNode result) {

    convertAnnotations(x.annotations, result);

    if (!(x instanceof ConstructorDeclaration)) {
      SPropertyOperations.set(result, "name", new String(x.selector));
    }

    {
      SNode imd = result;
      if (SNodeOperations.isInstanceOf(imd, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
        if (flagSet(x.modifiers, ClassFileConstants.AccAbstract)) {
          SPropertyOperations.set(imd, "isAbstract", "" + true);
        }
      }
    }

    myClassResolver.newTypeVarFrame();
    convertTypeVars(x.typeParameters(), result);

    if (x.arguments != null) {
      for (Argument arg : x.arguments) {
        SNode par = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParameterDeclaration", null);
        convertAnnotations(arg.annotations, par);
        SPropertyOperations.set(par, "name", new String(arg.name));
        SLinkOperations.setTarget(par, "type", convertTypeRef(arg.type), true);
        ListSequence.fromList(SLinkOperations.getTargets(result, "parameter", true)).addElement(par);
      }
    }

    if (x.thrownExceptions != null) {
      ListSequence.fromList(SLinkOperations.getTargets(result, "throwsItem", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.thrownExceptions)).select(new ISelector<TypeReference, SNode>() {
        public SNode select(TypeReference it) {
          return convertTypeRef(it);
        }
      }));
    }

    if (myConvertBodies) {
      // TODO build method bodies 
    } else {
      // make a different stub statement list 'source code' ? 
      SLinkOperations.setTarget(result, "body", new ASTConverter.QuotationClass_rbndtb_a0a1a0o0g().createNode(), true);
    }


    {
      SNode mem = result;
      if (SNodeOperations.isInstanceOf(mem, "jetbrains.mps.baseLanguage.structure.ClassifierMember")) {
        if ((SLinkOperations.getTarget(mem, "visibility", true) == null)) {
          SLinkOperations.setTarget(mem, "visibility", convertVisibility(x.modifiers), true);
        }
      }
    }

    // doesn't make sense for constructor, but it's how it's done in baseLanguage.structure 
    SPropertyOperations.set(result, "isFinal", "" + flagSet(x.modifiers, ClassFileConstants.AccFinal));
    SPropertyOperations.set(result, "isSynchronized", "" + flagSet(x.modifiers, ClassFileConstants.AccSynchronized));

    if (x instanceof MethodDeclaration) {
      // Not a constructor 

      MethodDeclaration mDecl = (MethodDeclaration) x;
      SLinkOperations.setTarget(result, "returnType", convertTypeRef(mDecl.returnType), true);
    }

    myClassResolver.leaveTypeVarFrame();

    return result;
  }

  public SNode convertVisibility(int astModifiers) {
    // Bad code ? 
    return (flagSet(astModifiers, ClassFileConstants.AccPublic) ?
      new ASTConverter.QuotationClass_rbndtb_a0a1a7().createNode() :
      (flagSet(astModifiers, ClassFileConstants.AccProtected) ?
        new ASTConverter.QuotationClass_rbndtb_a0a0b0h().createNode() :
        (flagSet(astModifiers, ClassFileConstants.AccPrivate) ?
          new ASTConverter.QuotationClass_rbndtb_a0a0a1a7().createNode() :
          null
        )
      )
    );
  }

  public SNode convertTypeRef(TypeReference typRef) {

    if (typRef == null) {
      return null;
    }

    SNode res;
    if (typRef instanceof SingleTypeReference) {
      res = convertUnqualTypeRef((SingleTypeReference) typRef);

    } else if (typRef instanceof QualifiedTypeReference) {
      res = convertQualifiedTypeRef((QualifiedTypeReference) typRef);

    } else {
      throw new JavaParseException("Unknown type reference kind in parsed java AST tree");
    }

    {
      SNode cls = res;
      if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
        TypeReference[] typeArgs = null;
        if (typRef instanceof ParameterizedQualifiedTypeReference) {
          // FIXME hack 
          ParameterizedQualifiedTypeReference parQRef = (ParameterizedQualifiedTypeReference) typRef;
          int last = parQRef.typeArguments.length - 1;
          typeArgs = parQRef.typeArguments[last];

        } else if (typRef instanceof ParameterizedSingleTypeReference) {
          typeArgs = ((ParameterizedSingleTypeReference) typRef).typeArguments;
        }
        if (typeArgs != null) {
          for (TypeReference typArg : typeArgs) {
            SNode argType = null;

            if (typArg instanceof Wildcard) {
              // it's a wildcard type of the form ? or ? extends ... or ? super ... 

              Wildcard wc = ((Wildcard) typArg);
              switch (wc.kind) {
                case Wildcard.UNBOUND:
                  argType = new ASTConverter.QuotationClass_rbndtb_a0a0a0d0c0a0c0g0i().createNode();
                  break;

                case Wildcard.EXTENDS:
                  SNode upperBound = convertTypeRef(wc.bound);
                  argType = new ASTConverter.QuotationClass_rbndtb_a0a1a1d0c0a0c0g0i().createNode(upperBound);
                  break;

                case Wildcard.SUPER:
                  SNode lowerBound = convertTypeRef(wc.bound);
                  argType = new ASTConverter.QuotationClass_rbndtb_a0a1a2d0c0a0c0g0i().createNode(lowerBound);
                  break;

                default:
              }
            } else {
              // it's a normal type reference 
              argType = convertTypeRef(typArg);
            }

            if (argType != null) {
              ListSequence.fromList(SLinkOperations.getTargets(cls, "parameter", true)).addElement(argType);
            }
          }
        }
      }
    }
    return res;
  }

  public SNode convertUnqualTypeRef(SingleTypeReference typRef) {
    String unqualTyp = new String(typRef.token);
    SNode base = myClassResolver.resolveShortTypeName(unqualTyp);
    if (typRef instanceof ArrayTypeReference && !(typRef instanceof ParameterizedSingleTypeReference)) {
      // it turns out this is an array, wrap base type in arraytype 
      // (in elicpse ParamSingleTypRef is subclass of ArrayTypRef) 
      return new ASTConverter.QuotationClass_rbndtb_a0c0c0j().createNode(base);
    } else {
      return base;
    }
  }

  public SNode convertQualifiedTypeRef(QualifiedTypeReference typRef) {

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < typRef.tokens.length; i++) {
      if (i > 0) {
        sb.append(".");
      }
      sb.append(new String(typRef.tokens[i]));
    }
    String qname = sb.toString();

    SNode base = myClassResolver.resolveQualifiedTypeName(qname);
    if (typRef instanceof ArrayQualifiedTypeReference && !(typRef instanceof ParameterizedQualifiedTypeReference)) {
      return new ASTConverter.QuotationClass_rbndtb_a0a0g0k().createNode(base);
    } else {
      return base;
    }
  }

  public SNode convertExpression(Expression exp) {
    if (exp instanceof TrueLiteral) {
      return new ASTConverter.QuotationClass_rbndtb_a0a0a0l().createNode();
    } else if (exp instanceof FalseLiteral) {
      return new ASTConverter.QuotationClass_rbndtb_a0a0a0a11().createNode();
    } else if (exp instanceof StringLiteral) {
      return new ASTConverter.QuotationClass_rbndtb_a0a0b0a11().createNode(new String(((StringLiteral) exp).source()));
    } else if (exp instanceof ArrayInitializer) {
      SNode arr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayLiteral", null);
      for (Expression e : ((ArrayInitializer) exp).expressions) {
        ListSequence.fromList(SLinkOperations.getTargets(arr, "item", true)).addElement(convertExpression(e));
      }
      return arr;
    } else if (exp instanceof QualifiedNameReference) {

      // FIXME HACK it can be static field ref as well, and maybe something else 
      SNode enumRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumConstantReference", null);
      char[][] tokens = ((QualifiedNameReference) exp).tokens;

      String enumName = new String(tokens[0]);
      for (int i = 1; i < tokens.length - 1; i++) {
        enumName = enumName + "." + new String(tokens[i]);
      }

      String enumConstName = new String(tokens[tokens.length - 1]);

      SReference enumClRef;
      if (enumName.contains(".")) {
        enumClRef = myClassResolver.resolveQualifiedClassName(enumName, enumRef, "enumClass");
      } else {
        enumClRef = myClassResolver.resolveShortClassName(enumName, enumRef, "enumClass");
      }
      SReference enumConstRef = new DynamicReference("enumConstantDeclaration", enumRef, null, enumConstName);

      enumRef.addReference(enumClRef);
      enumRef.addReference(enumConstRef);
      return enumRef;

    } else if (exp instanceof SingleNameReference) {
      // FIXME 
      return new ASTConverter.QuotationClass_rbndtb_a0b0e0a11().createNode();
    } else {
      throw new RuntimeException("This kind of expression is not supported yet: " + exp.getClass().getName());
    }

  }

  private boolean isEnumConstant(FieldDeclaration x) {
    return x.initialization != null && x.initialization instanceof AllocationExpression && ((AllocationExpression) x.initialization).enumConstant != null;
  }

  private String enumConstantName(FieldDeclaration x) {
    // Unsafe. supposed to be used after isEnumConstant 
    return new String(((AllocationExpression) x.initialization).enumConstant.name);
  }

  private boolean flagSet(int bitmap, int flag) {
    return (bitmap & flag) != 0;
  }

  public static class QuotationClass_rbndtb_a0a1a3a1a3a53a1 {
    public QuotationClass_rbndtb_a0a1a3a1a3a53a1() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PublicVisibility", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a2a0b0d0jb0b {
    public QuotationClass_rbndtb_a0a2a0b0d0jb0b() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.VoidType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a1a0o0g {
    public QuotationClass_rbndtb_a0a1a0o0g() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StubStatementList", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a1a7 {
    public QuotationClass_rbndtb_a0a1a7() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PublicVisibility", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0b0h {
    public QuotationClass_rbndtb_a0a0b0h() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ProtectedVisibility", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0a1a7 {
    public QuotationClass_rbndtb_a0a0a1a7() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PrivateVisibility", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0a0d0c0a0c0g0i {
    public QuotationClass_rbndtb_a0a0a0d0c0a0c0g0i() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.WildCardType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a1a1d0c0a0c0g0i {
    public QuotationClass_rbndtb_a0a1a1d0c0a0c0g0i() {
    }

    public SNode createNode(Object parameter_5) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.UpperBoundType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_3 = quotedNode_1;
        {
          quotedNode_2 = (SNode) parameter_5;
          SNode quotedNode1_4;
          if (_parameterValues_129834374.contains(quotedNode_2)) {
            quotedNode1_4 = HUtil.copyIfNecessary(quotedNode_2);
          } else {
            _parameterValues_129834374.add(quotedNode_2);
            quotedNode1_4 = quotedNode_2;
          }
          if (quotedNode1_4 != null) {
            quotedNode_1.addChild("bound", HUtil.copyIfNecessary(quotedNode1_4));
          }
        }
        result = quotedNode1_3;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a1a2d0c0a0c0g0i {
    public QuotationClass_rbndtb_a0a1a2d0c0a0c0g0i() {
    }

    public SNode createNode(Object parameter_5) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.LowerBoundType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_3 = quotedNode_1;
        {
          quotedNode_2 = (SNode) parameter_5;
          SNode quotedNode1_4;
          if (_parameterValues_129834374.contains(quotedNode_2)) {
            quotedNode1_4 = HUtil.copyIfNecessary(quotedNode_2);
          } else {
            _parameterValues_129834374.add(quotedNode_2);
            quotedNode1_4 = quotedNode_2;
          }
          if (quotedNode1_4 != null) {
            quotedNode_1.addChild("bound", HUtil.copyIfNecessary(quotedNode1_4));
          }
        }
        result = quotedNode1_3;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0c0c0j {
    public QuotationClass_rbndtb_a0c0c0j() {
    }

    public SNode createNode(Object parameter_5) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ArrayType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_3 = quotedNode_1;
        {
          quotedNode_2 = (SNode) parameter_5;
          SNode quotedNode1_4;
          if (_parameterValues_129834374.contains(quotedNode_2)) {
            quotedNode1_4 = HUtil.copyIfNecessary(quotedNode_2);
          } else {
            _parameterValues_129834374.add(quotedNode_2);
            quotedNode1_4 = quotedNode_2;
          }
          if (quotedNode1_4 != null) {
            quotedNode_1.addChild("componentType", HUtil.copyIfNecessary(quotedNode1_4));
          }
        }
        result = quotedNode1_3;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0g0k {
    public QuotationClass_rbndtb_a0a0g0k() {
    }

    public SNode createNode(Object parameter_5) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ArrayType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_3 = quotedNode_1;
        {
          quotedNode_2 = (SNode) parameter_5;
          SNode quotedNode1_4;
          if (_parameterValues_129834374.contains(quotedNode_2)) {
            quotedNode1_4 = HUtil.copyIfNecessary(quotedNode_2);
          } else {
            _parameterValues_129834374.add(quotedNode_2);
            quotedNode1_4 = quotedNode_2;
          }
          if (quotedNode1_4 != null) {
            quotedNode_1.addChild("componentType", HUtil.copyIfNecessary(quotedNode1_4));
          }
        }
        result = quotedNode1_3;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0a0l {
    public QuotationClass_rbndtb_a0a0a0l() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.BooleanConstant", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        quotedNode1_2.setProperty("value", "true");
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0a0a11 {
    public QuotationClass_rbndtb_a0a0a0a11() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.BooleanConstant", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0b0a11 {
    public QuotationClass_rbndtb_a0a0b0a11() {
    }

    public SNode createNode(Object parameter_3) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StringLiteral", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        quotedNode1_2.setProperty("value", (String) parameter_3);
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0b0e0a11 {
    public QuotationClass_rbndtb_a0b0e0a11() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StringLiteral", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        quotedNode1_2.setProperty("value", "NOT SUPPORTED YET");
        result = quotedNode1_2;
      }
      return result;
    }
  }
}
