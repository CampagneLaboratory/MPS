package jetbrains.mps.ide.java.parser;

/*Generated by MPS */

import com.intellij.openapi.ui.DialogWrapper;
import java.util.List;
import java.io.File;
import jetbrains.mps.reloading.IClassPathItem;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import javax.swing.JList;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.Nullable;
import javax.swing.JComponent;
import javax.swing.JScrollPane;
import com.intellij.ui.ScrollPaneFactory;
import javax.swing.DefaultListCellRenderer;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import javax.swing.ListCellRenderer;
import javax.swing.border.TitledBorder;
import java.awt.BorderLayout;
import com.intellij.ui.components.JBList;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import javax.swing.ListModel;
import javax.swing.DefaultListModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;

public class ClassPathDialog extends DialogWrapper implements ClasspathObserver {
  private List<File> mySourceDirs;
  private List<String> myUnresolvedClassFqNames;
  private List<IClassPathItem> myAdditionalClassPath = ListSequence.fromList(new ArrayList<IClassPathItem>());
  private Map<IClassPathItem, Set<String>> myClassPathToClasses = MapSequence.fromMap(new HashMap<IClassPathItem, Set<String>>());
  private JList myClassPathList;
  private JList myUnresolvedClassesList;

  public ClassPathDialog(@NotNull Project project, final Iterable<File> sourceDirs, Iterable<String> unresolvedClassFqNames) {
    super(project, true);
    setTitle("Classpath");

    myUnresolvedClassFqNames = ListSequence.fromListWithValues(new ArrayList<String>(), unresolvedClassFqNames);
    mySourceDirs = ListSequence.fromListWithValues(new ArrayList<File>(), sourceDirs);

    init();
  }

  @Nullable
  protected JComponent createCenterPanel() {
    JScrollPane panel = ScrollPaneFactory.createScrollPane(ClasspathSelectionTree.createClasspathSelectionTree(this, mySourceDirs));
    DefaultListCellRenderer renderer = new DefaultListCellRenderer();

    Tuples._2<JPanel, JList> classPathTuple = createListPanel("Added Classpaths", renderer);
    Tuples._2<JPanel, JList> unresolvedNamesTuple = createListPanel("Unresolved Names", renderer);

    myClassPathList = classPathTuple._1();
    myUnresolvedClassesList = unresolvedNamesTuple._1();
    updateLists();

    JSplitPane innerSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, classPathTuple._0(), unresolvedNamesTuple._0());
    innerSplitPane.setResizeWeight(0.5);
    JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panel, innerSplitPane);
    splitPane.setResizeWeight(0.33);
    return splitPane;
  }

  private Tuples._2<JPanel, JList> createListPanel(String title, ListCellRenderer renderer) {
    JPanel panel = new JPanel();
    panel.setBorder(new TitledBorder(title));
    panel.setLayout(new BorderLayout());

    JList list = new JBList();
    list.setCellRenderer(renderer);
    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(list);
    panel.add(scrollPane, BorderLayout.CENTER);

    return MultiTuple.<JPanel,JList>from(panel, list);
  }

  private void updateLists() {
    myClassPathList.setModel(createListModel(myAdditionalClassPath));
    myUnresolvedClassesList.setModel(createListModel(myUnresolvedClassFqNames));
  }

  private ListModel createListModel(List<? extends Object> list) {
    DefaultListModel model = new DefaultListModel();
    for (Object element : ListSequence.fromList(list)) {
      model.addElement(element);
    }
    return model;
  }

  public void classPathAdded(IClassPathItem classPath) {
    if (classPath == null) {
      return;
    }
    ListSequence.fromList(myAdditionalClassPath).addElement(classPath);

    Set<String> resolvedFqNames = SetSequence.fromSet(new LinkedHashSet<String>());
    for (String nextUnresolved : ListSequence.fromList(myUnresolvedClassFqNames)) {
      if (classPath.getClass(nextUnresolved) != null || classPath.getAvailableClasses(nextUnresolved).iterator().hasNext() || classPath.getSubpackages(nextUnresolved).iterator().hasNext()) {
        SetSequence.fromSet(resolvedFqNames).addElement(nextUnresolved);
      }
    }

    if (SetSequence.fromSet(resolvedFqNames).isNotEmpty()) {
      Set<String> fqNames = MapSequence.fromMap(myClassPathToClasses).get(classPath);
      if (fqNames == null) {
        fqNames = SetSequence.fromSet(new LinkedHashSet<String>());
        MapSequence.fromMap(myClassPathToClasses).put(classPath, fqNames);
      }
      SetSequence.fromSet(fqNames).addSequence(SetSequence.fromSet(resolvedFqNames));
      ListSequence.fromList(myUnresolvedClassFqNames).removeSequence(SetSequence.fromSet(resolvedFqNames));
    }

    updateLists();
  }

  public void classPathRemoved(IClassPathItem classPath) {
    if (classPath == null) {
      return;
    }
    ListSequence.fromList(myAdditionalClassPath).removeElement(classPath);
    Set<String> unresolvedNames = MapSequence.fromMap(myClassPathToClasses).removeKey(classPath);
    if (unresolvedNames != null) {
      ListSequence.fromList(myUnresolvedClassFqNames).addSequence(SetSequence.fromSet(unresolvedNames));
    }

    updateLists();
  }

  public List<IClassPathItem> getChoosenClassPath() {
    return ListSequence.fromListWithValues(new ArrayList<IClassPathItem>(), myAdditionalClassPath);
  }
}
