package jetbrains.mps.ide.java.platform.highlighters;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.EditorCheckerAdapter;
import java.util.Set;
import jetbrains.mps.smodel.SNodePointer;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import com.intellij.openapi.util.Pair;
import jetbrains.mps.typesystem.inference.TypeRecalculatedListener;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.nodeEditor.EditorMessage;
import java.util.List;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.typesystem.inference.ITypeContextOwner;
import jetbrains.mps.typesystem.inference.ITypechecking;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.event.SModelEventVisitor;
import jetbrains.mps.smodel.event.SModelEventVisitorAdapter;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.smodel.constraints.ModelConstraints;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.search.MethodResolveUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.nodeEditor.EditorComponent;

public class MethodDeclarationsFixer extends EditorCheckerAdapter {
  private static boolean DISABLED = false;
  private Set<SNodePointer> myCheckedMethodCalls = new HashSet<SNodePointer>();
  private Map<SNodePointer, Set<SNodePointer>> myMethodDeclsToCheckedMethodCalls = new HashMap<SNodePointer, Set<SNodePointer>>();
  private Map<Pair<String, String>, Set<SNodePointer>> myMethodConceptsAndNamesToCheckedMethodCalls = new HashMap<Pair<String, String>, Set<SNodePointer>>();
  private Map<SNodePointer, SNodePointer> myParametersToCheckedMethodCalls = new HashMap<SNodePointer, SNodePointer>();
  private Map<SNodePointer, SNodePointer> myMethodCallsToSetDecls = new HashMap<SNodePointer, SNodePointer>();
  private Set<SNodePointer> myCurrentExpressionsWithChangedTypes = new HashSet<SNodePointer>();
  private final Object myRecalculatedTypesLock = new Object();
  private TypeRecalculatedListener myTypeRecalculatedListener = new TypeRecalculatedListener() {
    public void typeWillBeRecalculatedForTerm(SNode term) {
      synchronized (myRecalculatedTypesLock) {
        myCurrentExpressionsWithChangedTypes.add(new SNodePointer(term));
      }
    }
  };

  public MethodDeclarationsFixer() {
  }

  public void init() {
    TypeChecker.getInstance().addTypeRecalculatedListener(myTypeRecalculatedListener);
  }

  public void doDispose() {
    TypeChecker.getInstance().removeTypeRecalculatedListener(myTypeRecalculatedListener);
    super.doDispose();
  }

  @Override
  protected Set<EditorMessage> createMessages(final SNode rootNode, final List<SModelEvent> events, final boolean wasCheckedOnce, final EditorContext editorContext) {
    return TypeContextManager.getInstance().runTypeCheckingComputation((ITypeContextOwner) editorContext.getEditorComponent(), rootNode, new ITypechecking.Computation<Set<EditorMessage>>() {
      public Set<EditorMessage> compute(TypeCheckingContext p0) {
        return doCreateMessages(rootNode, events, wasCheckedOnce, editorContext);
      }
    });
  }

  public Set<EditorMessage> doCreateMessages(SNode rootNode, List<SModelEvent> events, boolean wasCheckedOnce, final EditorContext editorContext) {
    if (DISABLED) {
      return new HashSet<EditorMessage>();
    }
    SModel model = SNodeOperations.getModel(rootNode);
    if (model.getModelDescriptor() == null || model.isTransient() || model.isDisposed()) {
      return new HashSet<EditorMessage>(0);
    }
    final Map<SNode, SNode> reResolvedTargets = new HashMap<SNode, SNode>();
    if (!(wasCheckedOnce)) {
      for (SNode methodCall : SNodeOperations.getDescendants(rootNode, "jetbrains.mps.baseLanguage.structure.IMethodCall", false, new String[]{})) {
        testAndFixMethodCall(methodCall, reResolvedTargets);
      }
    } else {
      Set<SNodePointer> expressionsWithChangedTypes;
      synchronized (myRecalculatedTypesLock) {
        expressionsWithChangedTypes = new HashSet<SNodePointer>(myCurrentExpressionsWithChangedTypes);
        myCurrentExpressionsWithChangedTypes.clear();
      }
      SModelEventVisitor visitor = new SModelEventVisitorAdapter() {
        public void visitChildEvent(SModelChildEvent event) {
          SNode child = event.getChild();
          if (event.isAdded()) {
            nodeAdded(child, reResolvedTargets);
          } else {
            nodeRemoved(child, event.getParent(), event.getModel(), reResolvedTargets);
          }
        }

        public void visitReferenceEvent(SModelReferenceEvent event) {
          SReference reference = event.getReference();
          SNode sourceNode = reference.getSourceNode();
          if (SNodeOperations.isInstanceOf(sourceNode, "jetbrains.mps.baseLanguage.structure.IMethodCall") && "baseMethodDeclaration".equals(reference.getRole())) {
            methodCallDeclarationChanged(SNodeOperations.cast(sourceNode, "jetbrains.mps.baseLanguage.structure.IMethodCall"), reResolvedTargets);
          }
        }

        public void visitPropertyEvent(SModelPropertyEvent event) {
          SNode node = event.getNode();
          SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
          if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration") && "name".equals(event.getPropertyName())) {
            methodDeclarationNameChanged(node, reResolvedTargets);
            methodDeclarationSignatureChanged(node, reResolvedTargets);
          }
        }
      };
      for (SModelEvent event : events) {
        if (event.getAffectedRoot() != rootNode) {
          continue;
        }
        event.accept(visitor);
      }
      for (SNodePointer expressionWithChangedType : expressionsWithChangedTypes) {
        expressionTypeChanged(expressionWithChangedType.getNode(), reResolvedTargets);
      }
    }
    ThreadUtils.runInUIThreadNoWait(new Runnable() {
      public void run() {
        if (reResolvedTargets.isEmpty()) {
          return;
        }
        Project p = (editorContext != null && editorContext.getOperationContext() != null ?
          editorContext.getOperationContext().getProject() :
          null
        );
        if (p == null) {
          return;
        }

        ModelAccess.instance().runUndoTransparentCommand(new Runnable() {
          public void run() {
            for (SNode methodCall : reResolvedTargets.keySet()) {
              SNode referent = reResolvedTargets.get(methodCall);
              if (referent != null && !(jetbrains.mps.util.SNodeOperations.isDisposed(referent))) {
                SLinkOperations.setTarget(methodCall, "baseMethodDeclaration", referent, false);
              }
            }
          }
        }, p);
      }
    });
    return new HashSet<EditorMessage>();
  }

  public void clearCaches() {
    myCheckedMethodCalls.clear();
    myMethodDeclsToCheckedMethodCalls.clear();
    myMethodConceptsAndNamesToCheckedMethodCalls.clear();
    myParametersToCheckedMethodCalls.clear();
    myMethodCallsToSetDecls.clear();
  }

  public void testAndFixMethodCall(@NotNull SNode methodCallNode, Map<SNode, SNode> reResolvedTargets) {
    SNode baseMethodDeclaration = SLinkOperations.getTarget(methodCallNode, "baseMethodDeclaration", false);
    String methodName = getMethodName(methodCallNode);

    Tuples._2<SNode, Boolean> resolveResult = resolveMethod(methodCallNode, methodName);
    SNode newTarget = resolveResult._0();
    boolean good = (boolean) resolveResult._1();

    if (newTarget != null) {
      if (baseMethodDeclaration == null || (good && newTarget != baseMethodDeclaration)) {
        reResolvedTargets.put(methodCallNode, newTarget);
      }
      SNodePointer methodCallPointer = new SNodePointer(methodCallNode);
      SNodePointer newTargetPointer = new SNodePointer(newTarget);
      myMethodCallsToSetDecls.put(methodCallPointer, newTargetPointer);
      myCheckedMethodCalls.add(methodCallPointer);
      for (SNode actualArgument : SLinkOperations.getTargets(methodCallNode, "actualArgument", true)) {
        myParametersToCheckedMethodCalls.put(new SNodePointer(actualArgument), methodCallPointer);
      }
      Set<SNodePointer> nodeSet = myMethodDeclsToCheckedMethodCalls.get(newTargetPointer);
      if (nodeSet == null) {
        nodeSet = new HashSet<SNodePointer>();
        myMethodDeclsToCheckedMethodCalls.put(newTargetPointer, nodeSet);
      }
      nodeSet.add(methodCallPointer);
      Pair<String, String> key = new Pair<String, String>(newTarget.getConcept().getConceptId(), methodName);
      Set<SNodePointer> nodesByNameAndConcept = myMethodConceptsAndNamesToCheckedMethodCalls.get(key);
      if (nodesByNameAndConcept == null) {
        nodesByNameAndConcept = new HashSet<SNodePointer>();
        myMethodConceptsAndNamesToCheckedMethodCalls.put(key, nodesByNameAndConcept);
      }
      nodesByNameAndConcept.add(methodCallPointer);
    }
  }

  private String getMethodName(SNode methodCall) {
    SNode baseMethodDeclaration = SLinkOperations.getTarget(methodCall, "baseMethodDeclaration", false);
    if (baseMethodDeclaration == null) {
      if (SLinkOperations.getTarget(SNodeOperations.as(methodCall, "jetbrains.mps.baseLanguage.structure.AnonymousClass"), "classifier", false) != null) {
        return SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.as(methodCall, "jetbrains.mps.baseLanguage.structure.AnonymousClass"), "classifier", false), "name");
      } else {
        return SLinkOperations.getResolveInfo(SNodeOperations.getReference(methodCall, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.IMethodCall", "baseMethodDeclaration")));
      }
    } else {
      return SPropertyOperations.getString(baseMethodDeclaration, "name");
    }
  }

  private Tuples._2<SNode, Boolean> resolveMethod(SNode methodCall, String name) {
    if (BehaviorReflection.invokeVirtual(Boolean.TYPE, methodCall, "virtual_useScopesForMethodDeclarationFixer_66132694723287898", new Object[]{})) {
      return resolveMethodUsingScopes(methodCall, name);
    }

    Iterable<SNode> candidates = getCandidates(methodCall, name);
    if (candidates == null || Sequence.fromIterable(candidates).isEmpty()) {
      return MultiTuple.<SNode,Boolean>from((SNode) null, false);
    }
    Map<SNode, SNode> typeByTypeVar = getTypeByTypeVar(methodCall);

    return resolveMethodByCandidatesAndTypes(methodCall, candidates, typeByTypeVar);
  }

  private Tuples._2<SNode, Boolean> resolveMethodUsingScopes(SNode methodCall, final String name) {
    if (SNodeOperations.getReference(methodCall, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.IMethodCall", "baseMethodDeclaration")) == null) {
      return MultiTuple.<SNode,Boolean>from((SNode) null, false);
    }

    Scope scope = ModelConstraints.getScope(SNodeOperations.getReference(methodCall, SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.IMethodCall", "baseMethodDeclaration")));
    SNode resolvedMethod = SNodeOperations.cast(scope.resolve(methodCall, name), "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
    if ((resolvedMethod != null)) {
      return MultiTuple.<SNode,Boolean>from(resolvedMethod, true);
    } else {
      return resolveMethodByCandidatesAndTypes(methodCall, Sequence.fromIterable(((Iterable<SNode>) scope.getAvailableElements(name))).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return eq_vo5uqs_a0a0a0a0a1a0a0e0s(SPropertyOperations.getString(it, "name"), name);
        }
      }), null);
    }
  }

  private Tuples._2<SNode, Boolean> resolveMethodByCandidatesAndTypes(SNode methodCall, Iterable<SNode> candidates, @Nullable Map<SNode, SNode> typeByTypeVar) {
    List<SNode> actualArgs = SLinkOperations.getTargets(methodCall, "actualArgument", true);
    SNode baseMethodDeclaration = SLinkOperations.getTarget(methodCall, "baseMethodDeclaration", false);

    jetbrains.mps.util.Pair<List<SNode>, Boolean> parmCountPair = MethodResolveUtil.selectByVisibilityReportNoGoodMethodNode(Sequence.fromIterable(candidates).toListSequence(), methodCall);
    List<SNode> methodDeclarationsGoodParams = parmCountPair.o1;

    if (methodDeclarationsGoodParams.size() == 1) {
      return MultiTuple.<SNode,Boolean>from(ListSequence.fromList(methodDeclarationsGoodParams).first(), parmCountPair.o2);
    } else {
      parmCountPair = MethodResolveUtil.selectByParmCountReportNoGoodMethodNode(methodDeclarationsGoodParams, actualArgs);
      methodDeclarationsGoodParams = parmCountPair.o1;
      if (methodDeclarationsGoodParams.size() == 1) {
        return MultiTuple.<SNode,Boolean>from(ListSequence.fromList(methodDeclarationsGoodParams).first(), parmCountPair.o2);
      } else {
        if (typeByTypeVar == null) {
          return MultiTuple.<SNode,Boolean>from(ListSequence.fromList(methodDeclarationsGoodParams).first(), false);
        }

        jetbrains.mps.util.Pair<SNode, Boolean> parmTypesPair = MethodResolveUtil.chooseByParameterTypeReportNoGoodMethodNode(baseMethodDeclaration, methodDeclarationsGoodParams, actualArgs, typeByTypeVar);
        return MultiTuple.<SNode,Boolean>from(parmTypesPair.o1, parmTypesPair.o2);
      }
    }
  }

  private Map<SNode, SNode> getTypeByTypeVar(SNode methodCall) {
    return BehaviorReflection.invokeVirtual((Class<Map<SNode, SNode>>) ((Class) Object.class), methodCall, "virtual_getTypesByTypeVars_851115533308208851", new Object[]{});
  }

  public Iterable<SNode> getCandidates(@NotNull SNode methodCall, String methodName) {
    Iterable<SNode> availableMethodDeclarations = BehaviorReflection.invokeVirtual((Class<Iterable<SNode>>) ((Class) Object.class), methodCall, "virtual_getAvailableMethodDeclarations_5776618742611315379", new Object[]{methodName});
    assert availableMethodDeclarations != null : "getAvailableMethodDeclarations() return null for concept: " + BehaviorReflection.invokeVirtual(String.class, SNodeOperations.getConceptDeclaration(methodCall), "virtual_getFqName_1213877404258", new Object[]{});
    return availableMethodDeclarations;
  }

  private void methodDeclarationNameChanged(SNode method, Map<SNode, SNode> resolveTargets) {
    Set<SNodePointer> methodCallPointers = myMethodDeclsToCheckedMethodCalls.get(new SNodePointer(method));
    for (SNode methodCall : Sequence.fromIterable(getMethodCalls(methodCallPointers))) {
      testAndFixMethodCall(methodCall, resolveTargets);
    }
  }

  private Iterable<SNode> getMethodCalls(Set<SNodePointer> methodCallPointers) {
    if (methodCallPointers == null) {
      return Sequence.fromIterable(Collections.<SNode>emptyList());
    }
    return SetSequence.fromSet(methodCallPointers).where(new IWhereFilter<SNodePointer>() {
      public boolean accept(SNodePointer it) {
        return it != null;
      }
    }).select(new ISelector<SNodePointer, SNode>() {
      public SNode select(SNodePointer it) {
        return SNodeOperations.cast(it.getNode(), "jetbrains.mps.baseLanguage.structure.IMethodCall");
      }
    }).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return it != null;
      }
    });
  }

  private void methodDeclarationSignatureChanged(SNode method, Map<SNode, SNode> resolveTargets) {
    Set<SNodePointer> methodCallPointers = myMethodConceptsAndNamesToCheckedMethodCalls.get(new Pair<String, String>(method.getConcept().getConceptId(), method.getName()));
    for (SNode methodCall : Sequence.fromIterable(getMethodCalls(methodCallPointers))) {
      testAndFixMethodCall(methodCall, resolveTargets);
    }
  }

  private void methodCallDeclarationChanged(SNode methodCall, Map<SNode, SNode> resolveTargets) {
    SNodePointer methodCallPointer = new SNodePointer(methodCall);
    if (myCheckedMethodCalls.contains(methodCallPointer) && SLinkOperations.getTarget(methodCall, "baseMethodDeclaration", false) == myMethodCallsToSetDecls.get(methodCallPointer).getNode()) {
      return;
    }
    testAndFixMethodCall(methodCall, resolveTargets);
  }

  private void expressionTypeChanged(SNode expression, Map<SNode, SNode> resolveTargets) {
    SNodePointer methodCallPointer = myParametersToCheckedMethodCalls.get(new SNodePointer(expression));
    if (methodCallPointer != null) {
      SNode methodCall = SNodeOperations.cast(methodCallPointer.getNode(), "jetbrains.mps.baseLanguage.structure.IMethodCall");
      if (methodCall != null) {
        testAndFixMethodCall(methodCall, resolveTargets);
      }
    }
  }

  private void nodeAdded(SNode child, Map<SNode, SNode> resolveTargets) {
    for (SNode methodCall : SNodeOperations.getDescendants(child, "jetbrains.mps.baseLanguage.structure.IMethodCall", true, new String[]{})) {
      testAndFixMethodCall(methodCall, resolveTargets);
    }
    SNode parent = SNodeOperations.getParent(child);
    SNodePointer parentPointer = new SNodePointer(parent);
    if (myCheckedMethodCalls.contains(parentPointer)) {
      SNode p = SNodeOperations.cast(parent, "jetbrains.mps.baseLanguage.structure.IMethodCall");
      myParametersToCheckedMethodCalls.put(new SNodePointer(child), parentPointer);
      testAndFixMethodCall(p, resolveTargets);
    }
    SNode formalParam = SNodeOperations.getAncestor(child, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration", true, false);
    if ((SNodeOperations.getParent(formalParam) != null)) {
      methodDeclarationSignatureChanged(SNodeOperations.getParent(formalParam), resolveTargets);
    }
  }

  private void nodeRemoved(SNode child, SNode formerParent, SModel m, Map<SNode, SNode> resolveTargets) {
    if (myCheckedMethodCalls.contains(new SNodePointer(m.getSModelReference(), formerParent.getNodeId()))) {
      myParametersToCheckedMethodCalls.remove(new SNodePointer(m.getSModelReference(), child.getNodeId()));
      testAndFixMethodCall(SNodeOperations.cast(formerParent, "jetbrains.mps.baseLanguage.structure.IMethodCall"), resolveTargets);
    }
    if (SNodeOperations.isInstanceOf(child, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration")) {
      methodDeclarationSignatureChanged(formerParent, resolveTargets);
    } else {
      SNode formalParam = SNodeOperations.getAncestor(formerParent, "jetbrains.mps.baseLanguage.structure.ParameterDeclaration", true, false);
      if ((SNodeOperations.getParent(formalParam) != null)) {
        methodDeclarationSignatureChanged(SNodeOperations.getParent(formalParam), resolveTargets);
      }
    }
  }

  public void clear(SNode node, EditorComponent editor) {
    clearCaches();
  }

  private static boolean eq_vo5uqs_a0a0a0a0a1a0a0e0s(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }
}
