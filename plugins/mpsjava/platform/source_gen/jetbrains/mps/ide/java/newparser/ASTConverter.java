package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import org.jetbrains.annotations.NotNull;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
import org.eclipse.jdt.internal.compiler.ast.Annotation;
import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.DynamicReference;
import org.jetbrains.annotations.Nullable;
import org.eclipse.jdt.internal.compiler.ast.Argument;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.Wildcard;
import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.Statement;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.Literal;
import org.eclipse.jdt.internal.compiler.impl.Constant;
import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
import jetbrains.mps.util.NameUtil;
import org.eclipse.jdt.internal.compiler.ast.AssertStatement;
import org.eclipse.jdt.internal.compiler.ast.Block;
import org.eclipse.jdt.internal.compiler.ast.BreakStatement;
import org.eclipse.jdt.internal.compiler.ast.SwitchStatement;
import org.eclipse.jdt.internal.compiler.ast.CaseStatement;
import org.eclipse.jdt.internal.compiler.ast.ContinueStatement;
import org.eclipse.jdt.internal.compiler.ast.DoStatement;
import org.eclipse.jdt.internal.compiler.ast.EmptyStatement;
import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ReturnStatement;
import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
import org.eclipse.jdt.internal.compiler.ast.ForeachStatement;
import org.eclipse.jdt.internal.compiler.ast.ForStatement;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.eclipse.jdt.internal.compiler.ast.IfStatement;
import org.eclipse.jdt.internal.compiler.ast.LabeledStatement;
import org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;
import org.eclipse.jdt.internal.compiler.ast.ThrowStatement;
import org.eclipse.jdt.internal.compiler.ast.TryStatement;
import org.eclipse.jdt.internal.compiler.ast.WhileStatement;
import org.eclipse.jdt.internal.compiler.impl.BooleanConstant;
import org.eclipse.jdt.internal.compiler.impl.ByteConstant;
import org.eclipse.jdt.internal.compiler.impl.CharConstant;
import org.eclipse.jdt.internal.compiler.impl.DoubleConstant;
import org.eclipse.jdt.internal.compiler.impl.FloatConstant;
import org.eclipse.jdt.internal.compiler.impl.IntConstant;
import org.eclipse.jdt.internal.compiler.impl.LongConstant;
import org.eclipse.jdt.internal.compiler.impl.ShortConstant;
import org.eclipse.jdt.internal.compiler.impl.StringConstant;
import org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression;
import org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression;
import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
import org.eclipse.jdt.internal.compiler.ast.ArrayReference;
import org.eclipse.jdt.internal.compiler.ast.Assignment;
import org.eclipse.jdt.internal.compiler.ast.BinaryExpression;
import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
import org.eclipse.jdt.internal.compiler.ast.CombinedBinaryExpression;
import org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;
import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
import org.eclipse.jdt.internal.compiler.ast.EqualExpression;
import org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression;
import org.eclipse.jdt.internal.compiler.ast.PostfixExpression;
import org.eclipse.jdt.internal.compiler.ast.PrefixExpression;
import org.eclipse.jdt.internal.compiler.ast.CastExpression;
import org.eclipse.jdt.internal.compiler.ast.SuperReference;
import org.eclipse.jdt.internal.compiler.ast.ThisReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;
import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
import jetbrains.mps.scope.Scope;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import org.eclipse.jdt.internal.compiler.ast.NameReference;
import org.eclipse.jdt.internal.compiler.ast.FieldReference;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
import org.eclipse.jdt.internal.compiler.ast.UnaryExpression;
import org.eclipse.jdt.internal.compiler.ast.TrueLiteral;
import org.eclipse.jdt.internal.compiler.ast.FalseLiteral;
import org.eclipse.jdt.internal.compiler.ast.StringLiteral;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptPropertyOperations;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import jetbrains.mps.scope.CompositeScope;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.project.ModuleId;
import java.lang.reflect.Constructor;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.IScope;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.smodel.SModelRepository;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.lang.typesystem.runtime.HUtil;


/**
 * Convert eclipse AST into BaseLanguage nodes.
 */
public class ASTConverter {
  private SNode myAnchorNode;
  @NotNull
  private TypeNameResolver myTypeResolver;
  private CompilationUnitDeclaration myCud;
  private boolean myConvertBodies = false;
  private List<ASTConverter.CodeBlock> myBlocks = ListSequence.fromList(new ArrayList<ASTConverter.CodeBlock>());

  public ASTConverter(String pkg, CompilationUnitDeclaration cud, TypeNameResolver typeResolver) {
    if (typeResolver == null) {
      myTypeResolver = new TypeNameResolver(pkg);
    } else {
      myTypeResolver = typeResolver;
    }
  }

  public ASTConverter(String pkg, SNode anchor, CompilationUnitDeclaration cud, TypeNameResolver typeResolver) {
    this(pkg, cud, typeResolver);
    myAnchorNode = anchor;
  }

  public SNode convertRoot(ASTNode node) {

    if (node instanceof TypeDeclaration) {
      TypeDeclaration decl = (TypeDeclaration) node;
      String name = new String(decl.name);
      myTypeResolver.addTypeName(name);
      myTypeResolver.enterType(name);
      try {
        return convertTypeDecl(decl);
      } finally {
        myTypeResolver.leaveType();
      }
    } else {
      throw new JavaParseException("Root is not type decl");
    }
  }

  public SNode convertTypeDecl(TypeDeclaration x) {

    SNode cls;

    boolean isAnonymous = x.allocation != null;

    if (isAnonymous) {
      cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnonymousClass", null);

    } else {
      switch (TypeDeclaration.kind(x.modifiers)) {
        case TypeDeclaration.CLASS_DECL:
          cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassConcept", null);
          break;

        case TypeDeclaration.INTERFACE_DECL:
          cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Interface", null);
          break;

        case TypeDeclaration.ENUM_DECL:
          cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumClass", null);
          break;

        case TypeDeclaration.ANNOTATION_TYPE_DECL:
          cls = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Annotation", null);
          break;
        default:
          throw new JavaParseException("Unknown type declaration type");
      }
    }

    String clsStringId = null;

    if (!(isAnonymous)) {
      SPropertyOperations.set(cls, "name", new String(x.name));
      SLinkOperations.setTarget(cls, "visibility", convertVisibility(x.modifiers), true);
      // <node> 
      // FIXME work around. what's with interface here 
      if (!(SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface")) && flagSet(x.modifiers, ClassFileConstants.AccStatic)) {
        // setting nonStatic only if static keyword is present 
        SPropertyOperations.set(cls, "nonStatic", "" + (false));
      }

      clsStringId = SNodeId.Foreign.ID_PREFIX + SPropertyOperations.getString(cls, "name");
      SNodeId id;
      cls.setId(new SNodeId.Foreign(clsStringId));
    }


    // handling type params 
    myTypeResolver.newTypeVarFrame();
    convertTypeVars(x.typeParameters, cls);


    // handling nested classes 
    if (x.memberTypes != null) {

      //  putting them into resolver's scope 
      for (TypeDeclaration innerTyp : x.memberTypes) {
        myTypeResolver.addTypeName(new String(innerTyp.name));
      }

      // now actually processing them 
      for (TypeDeclaration innerTyp : x.memberTypes) {
        myTypeResolver.enterType(new String(innerTyp.name));

        try {
          SNode nested = convertTypeDecl(innerTyp);
          SLinkOperations.getTargets(cls, "staticInnerClassifiers", true).add(nested);
        } finally {
          // maintaining valid state of ClassNameResolver 
          myTypeResolver.leaveType();
        }
      }
    }

    convertAnnotations(x.annotations, cls);

    {
      SNode claz = cls;
      if (SNodeOperations.isInstanceOf(claz, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
        // we're either class or enum 
        SLinkOperations.setTarget(claz, "superclass", SNodeOperations.cast(convertTypeRef(x.superclass), "jetbrains.mps.baseLanguage.structure.ClassifierType"), true);
        ListSequence.fromList(SLinkOperations.getTargets(claz, "implementedInterface", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.superInterfaces)).select(new ISelector<TypeReference, SNode>() {
          public SNode select(TypeReference it) {
            return SNodeOperations.cast(convertTypeRef(it), "jetbrains.mps.baseLanguage.structure.ClassifierType");
          }
        }));
        SPropertyOperations.set(claz, "abstractClass", "" + (flagSet(x.modifiers, ClassFileConstants.AccAbstract)));
        SPropertyOperations.set(claz, "isFinal", "" + (flagSet(x.modifiers, ClassFileConstants.AccFinal)));
      }
    }

    {
      SNode iface = cls;
      if (SNodeOperations.isInstanceOf(iface, "jetbrains.mps.baseLanguage.structure.Interface")) {
        // <node> 
        ListSequence.fromList(SLinkOperations.getTargets(iface, "extendedInterface", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.superInterfaces)).select(new ISelector<TypeReference, SNode>() {
          public SNode select(TypeReference it) {
            return SNodeOperations.cast(convertTypeRef(it), "jetbrains.mps.baseLanguage.structure.ClassifierType");
          }
        }));
      }
    }

    {
      SNode enm = cls;
      if (SNodeOperations.isInstanceOf(enm, "jetbrains.mps.baseLanguage.structure.EnumClass")) {
        if (x.fields != null) {
          for (FieldDeclaration f : x.fields) {
            if (!(isEnumConstant(f))) {
              continue;
            }
            SNode constr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", null);
            // TODO 
            SNode item = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration", null);
            SPropertyOperations.set(item, "name", enumConstantName(f));
            // <node> 
            SLinkOperations.getTargets(enm, "enumConstant", true).add(item);
          }
        }
      }
    }

    // handle class fields 
    if (x.fields != null) {
      List<SNode> fields;
      SNode fDecl;

      for (FieldDeclaration f : x.fields) {

        if (f.name == null || isEnumConstant(f)) {
          continue;
        }

        fields = null;
        fDecl = null;

        if (flagSet(f.modifiers, ClassFileConstants.AccStatic) || SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface")) {
          // interfaces in java can have fields not declared as static, but they are static 
          fields = SLinkOperations.getTargets(cls, "staticField", true);
          SNode staticDecl = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration", null);
          fDecl = staticDecl;

        } else {
          assert SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept");

          fields = SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "field", true);
          SNode fieldDecl = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldDeclaration", null);

          SPropertyOperations.set(fieldDecl, "isVolatile", "" + (flagSet(f.modifiers, ClassFileConstants.AccVolatile)));
          SPropertyOperations.set(fieldDecl, "isTransient", "" + (flagSet(f.modifiers, ClassFileConstants.AccTransient)));

          fDecl = fieldDecl;
        }

        if ((fDecl != null)) {
          convertAnnotations(f.annotations, fDecl);

          SPropertyOperations.set(fDecl, "name", new String(f.name));
          SLinkOperations.setTarget(fDecl, "type", convertTypeRef(f.type), true);

          SLinkOperations.setTarget(SNodeOperations.cast(fDecl, "jetbrains.mps.baseLanguage.structure.IVisible"), "visibility", convertVisibility(f.modifiers), true);
          SPropertyOperations.set(fDecl, "isFinal", "" + (flagSet(f.modifiers, ClassFileConstants.AccFinal)));

          SNodeId nodeId = new SNodeId.Foreign(SNodeId.Foreign.ID_PREFIX + SPropertyOperations.getString(cls, "name") + "." + SPropertyOperations.getString(fDecl, "name"));
          fDecl.setId(nodeId);

          ListSequence.fromList(fields).addElement(fDecl);
        }
      }
    }

    // handling methods 
    if (x.methods != null) {
      List<SNode> methods;
      SNode result;

      for (AbstractMethodDeclaration method : x.methods) {

        if (method instanceof MethodDeclaration) {

          if (flagSet(method.modifiers, ClassFileConstants.AccStatic) && SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
            methods = SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "staticMethod", true);
            result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration", null);
          } else if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Annotation")) {
            methods = SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.Annotation"), "method", true);
            result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationMethodDeclaration", null);
          } else {
            methods = SLinkOperations.getTargets(cls, "method", true);
            result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration", null);
          }

          if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.Interface")) {
            SPropertyOperations.set(SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"), "isAbstract", "" + (true));
            SLinkOperations.setTarget(SNodeOperations.cast(result, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"), "visibility", new ASTConverter.QuotationClass_rbndtb_a0a1a3a1a3a23a1().createNode(), true);
          }

          methods.add(convertMethod((MethodDeclaration) method, clsStringId, result));

        } else if (method instanceof ConstructorDeclaration) {

          result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ConstructorDeclaration", null);
          SLinkOperations.setTarget(result, "returnType", new ASTConverter.QuotationClass_rbndtb_a0a2a0b0d0gb0b().createNode(), true);
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "constructor", true)).addElement(SNodeOperations.cast(convertMethod(method, clsStringId, result), "jetbrains.mps.baseLanguage.structure.ConstructorDeclaration"));
        }
      }

    }

    myTypeResolver.leaveTypeVarFrame();

    return cls;
  }

  public void convertTypeVars(TypeParameter[] pars, SNode result) {
    if (pars != null) {
      for (TypeParameter par : pars) {
        SNode typeVar = convertTypeVar(par);
        ListSequence.fromList(SLinkOperations.getTargets(result, "typeVariableDeclaration", true)).addElement(typeVar);
        myTypeResolver.addTypeVar(typeVar);
      }
    }
  }

  public SNode convertTypeVar(TypeParameter par) {
    SNode tvar = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TypeVariableDeclaration", null);
    SPropertyOperations.set(tvar, "name", new String(par.name));
    // TODO constraints like extends, super ... 
    if (par.type != null) {
      SLinkOperations.setTarget(tvar, "bound", convertTypeRef(par.type), true);
    }
    if (par.bounds != null) {
      for (TypeReference b : par.bounds) {
        // FIXME report or tolerate error if it's not a classifier type 
        ListSequence.fromList(SLinkOperations.getTargets(tvar, "auxBounds", true)).addElement(SNodeOperations.cast(convertTypeRef(b), "jetbrains.mps.baseLanguage.structure.ClassifierType"));
      }
    }
    return tvar;
  }

  public void convertAnnotations(Annotation[] annos, SNode result) {
    if (annos != null) {
      for (Annotation anno : annos) {
        SLinkOperations.getTargets(result, "annotation", true).add(convertAnnotation(anno));
      }
    }
  }

  public SNode convertAnnotation(Annotation anno) {
    TypeReference typRef = anno.type;

    String name;
    if (typRef instanceof SingleTypeReference) {
      name = new String(((SingleTypeReference) typRef).token);
    } else if (typRef instanceof QualifiedTypeReference) {
      StringBuffer sb = new StringBuffer();
      name = ((QualifiedTypeReference) typRef).print(0, sb).toString();
    } else {
      throw new RuntimeException("FIXME");
    }

    SNode node = myTypeResolver.resolveAnnotaion(name);
    for (MemberValuePair pair : anno.memberValuePairs()) {
      SNode val = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnnotationInstanceValue", null);
      SReference ref = new DynamicReference("key", val, null, new String(pair.name));
      val.addReference(ref);
      SLinkOperations.setTarget(val, "value", convertExpression(pair.value), true);
      ListSequence.fromList(SLinkOperations.getTargets(node, "value", true)).addElement(val);
    }
    return node;
  }

  public SNode convertMethod(@NotNull AbstractMethodDeclaration x, @Nullable String idPrefix, @NotNull SNode result) {

    StringBuilder idBuilder = (idPrefix == null ?
      null :
      new StringBuilder(idPrefix)
    );

    convertAnnotations(x.annotations, result);

    if (!(x instanceof ConstructorDeclaration)) {
      SPropertyOperations.set(result, "name", new String(x.selector));
    }
    // using eclipse selector because result.name is not set for constructors 
    check_rbndtb_a7a6(idBuilder, x);

    {
      SNode imd = result;
      if (SNodeOperations.isInstanceOf(imd, "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
        if (flagSet(x.modifiers, ClassFileConstants.AccAbstract)) {
          SPropertyOperations.set(imd, "isAbstract", "" + (true));
        }
      }
    }

    myTypeResolver.newTypeVarFrame();
    convertTypeVars(x.typeParameters(), result);

    if (x.arguments != null) {
      for (Argument arg : x.arguments) {
        SNode par = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParameterDeclaration", null);
        convertAnnotations(arg.annotations, par);
        SPropertyOperations.set(par, "name", new String(arg.name));
        SLinkOperations.setTarget(par, "type", convertTypeRef(arg.type), true);
        ListSequence.fromList(SLinkOperations.getTargets(result, "parameter", true)).addElement(par);

        check_rbndtb_a6a0a41a6(idBuilder, par, this);
        check_rbndtb_a7a0a41a6(idBuilder);
      }
      // delete the last comma 
      if (x.arguments.length > 0) {
        check_rbndtb_a0a2a41a6(idBuilder, idBuilder);
      }
    }
    check_rbndtb_a51a6(idBuilder);

    if (x.thrownExceptions != null) {
      ListSequence.fromList(SLinkOperations.getTargets(result, "throwsItem", true)).addSequence(Sequence.fromIterable(Sequence.fromArray(x.thrownExceptions)).select(new ISelector<TypeReference, SNode>() {
        public SNode select(TypeReference it) {
          return convertTypeRef(it);
        }
      }));
    }

    if (myConvertBodies) {
      // TODO build method bodies 
      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(result, "body", true), "statement", true)).addSequence(ListSequence.fromList(convertStatements(x.statements)));
    } else {
      // make a different stub statement list 'source code' ? 
      SLinkOperations.setTarget(result, "body", new ASTConverter.QuotationClass_rbndtb_a0a1a0t0g().createNode(), true);
    }

    {
      SNode mem = result;
      if (SNodeOperations.isInstanceOf(mem, "jetbrains.mps.baseLanguage.structure.ClassifierMember")) {
        if ((SLinkOperations.getTarget(mem, "visibility", true) == null)) {
          SLinkOperations.setTarget(mem, "visibility", convertVisibility(x.modifiers), true);
        }
      }
    }

    // doesn't make sense for constructor, but it's how it's done in baseLanguage.structure 
    SPropertyOperations.set(result, "isFinal", "" + (flagSet(x.modifiers, ClassFileConstants.AccFinal)));
    SPropertyOperations.set(result, "isSynchronized", "" + (flagSet(x.modifiers, ClassFileConstants.AccSynchronized)));

    if (x instanceof MethodDeclaration) {
      // Not a constructor 

      MethodDeclaration mDecl = (MethodDeclaration) x;
      SLinkOperations.setTarget(result, "returnType", convertTypeRef(mDecl.returnType), true);
    }

    if (idBuilder != null) {
      result.setId(new SNodeId.Foreign(idBuilder.toString()));
    }

    myTypeResolver.leaveTypeVarFrame();

    return result;
  }

  public SNode convertVisibility(int astModifiers) {
    // Bad code ? 
    return (flagSet(astModifiers, ClassFileConstants.AccPublic) ?
      new ASTConverter.QuotationClass_rbndtb_a0a1a7().createNode() :
      (flagSet(astModifiers, ClassFileConstants.AccProtected) ?
        new ASTConverter.QuotationClass_rbndtb_a0a0b0h().createNode() :
        (flagSet(astModifiers, ClassFileConstants.AccPrivate) ?
          new ASTConverter.QuotationClass_rbndtb_a0a0a1a7().createNode() :
          null
        )
      )
    );
  }

  public SNode convertTypeRef(TypeReference typRef) {

    if (typRef == null) {
      return null;
    }

    SNode res;
    if (typRef instanceof SingleTypeReference) {
      res = convertUnqualTypeRef((SingleTypeReference) typRef);

    } else if (typRef instanceof QualifiedTypeReference) {
      res = convertQualifiedTypeRef((QualifiedTypeReference) typRef);

    } else {
      throw new JavaParseException("Unknown type reference kind in parsed java AST tree");
    }

    {
      SNode cls = res;
      if (SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
        TypeReference[] typeArgs = null;
        if (typRef instanceof ParameterizedQualifiedTypeReference) {
          // FIXME hack 
          ParameterizedQualifiedTypeReference parQRef = (ParameterizedQualifiedTypeReference) typRef;
          int last = parQRef.typeArguments.length - 1;
          typeArgs = parQRef.typeArguments[last];

        } else if (typRef instanceof ParameterizedSingleTypeReference) {
          typeArgs = ((ParameterizedSingleTypeReference) typRef).typeArguments;
        }
        if (typeArgs != null) {
          for (TypeReference typArg : typeArgs) {
            SNode argType = null;

            if (typArg instanceof Wildcard) {
              // it's a wildcard type of the form ? or ? extends ... or ? super ... 

              Wildcard wc = ((Wildcard) typArg);
              switch (wc.kind) {
                case Wildcard.UNBOUND:
                  argType = new ASTConverter.QuotationClass_rbndtb_a0a0a0d0c0a0c0g0i().createNode();
                  break;

                case Wildcard.EXTENDS:
                  SNode upperBound = convertTypeRef(wc.bound);
                  argType = new ASTConverter.QuotationClass_rbndtb_a0a1a1d0c0a0c0g0i().createNode(upperBound);
                  break;

                case Wildcard.SUPER:
                  SNode lowerBound = convertTypeRef(wc.bound);
                  argType = new ASTConverter.QuotationClass_rbndtb_a0a1a2d0c0a0c0g0i().createNode(lowerBound);
                  break;

                default:
              }
            } else {
              // it's a normal type reference 
              argType = convertTypeRef(typArg);
            }

            if (argType != null) {
              ListSequence.fromList(SLinkOperations.getTargets(cls, "parameter", true)).addElement(argType);
            }
          }
        }
      }
    }
    return res;
  }

  public SNode convertUnqualTypeRef(SingleTypeReference typRef) {
    String unqualTyp = new String(typRef.token);
    SNode base = myTypeResolver.resolveShortTypeName(unqualTyp);
    if (typRef instanceof ArrayTypeReference && !(typRef instanceof ParameterizedSingleTypeReference)) {
      // it turns out this is an array, wrap base type in arraytype 
      // (in elicpse ParamSingleTypRef is subclass of ArrayTypRef) 
      return new ASTConverter.QuotationClass_rbndtb_a0c0c0j().createNode(base);
    } else {
      return base;
    }
  }

  public SNode convertQualifiedTypeRef(QualifiedTypeReference typRef) {

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < typRef.tokens.length; i++) {
      if (i > 0) {
        sb.append(".");
      }
      sb.append(new String(typRef.tokens[i]));
    }
    String qname = sb.toString();

    SNode base = myTypeResolver.resolveQualifiedTypeName(qname);
    if (typRef instanceof ArrayQualifiedTypeReference && !(typRef instanceof ParameterizedQualifiedTypeReference)) {
      return new ASTConverter.QuotationClass_rbndtb_a0a0g0k().createNode(base);
    } else {
      return base;
    }
  }

  public List<SNode> convertStatements(Statement[] ss) {
    return null;
  }

  public SNode convertStatement(Statement s) {
    return null;
  }

  public List<SNode> convertStatements(ASTConverter.Position pos, Statement[] ss) {
    List<SNode> result = new ArrayList<SNode>();
    if (ss != null) {
      for (Statement stmt : ss) {
        SNode statement = convertStatementRefl(pos, stmt);
        if (statement != null) {
          result.add(statement);
          pos.index++;
          pos.anchor = statement;
        }
      }
    }
    return result;
  }

  public SNode convertStatementRefl(Statement x) {
    return null;
  }

  public SNode convertExpressionRefl(Expression x) {
    return null;
  }

  public SNode convertStatementRefl(ASTConverter.Position pos, Statement x) {
    if (x == null) {
      return null;
    }
    SNode statement;
    if (x instanceof Expression) {
      SNode expr = convertExpressionRefl(pos, (Expression) x);
      if ((expr == null)) {
        return null;
      }
      SNode expressionStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ExpressionStatement", null);
      SLinkOperations.setTarget(expressionStatement, "expression", expr, true);
      statement = expressionStatement;
    } else {
      statement = SNodeOperations.cast(dispatchRefl("convertStatement", pos, x), "jetbrains.mps.baseLanguage.structure.Statement");
    }
    return statement;
  }

  public SNode convertExpressionRefl(ASTConverter.Position pos, Expression expression) {
    SNode result = null;
    if (expression instanceof Literal) {
      ((Literal) expression).computeConstant();
      if (expression.constant != null) {
        if (expression.constant != Constant.NotAConstant) {
          result = SNodeOperations.cast(dispatchRefl("convertConstant", pos, expression.constant), "jetbrains.mps.baseLanguage.structure.Expression");
        } else if (expression instanceof NullLiteral) {
          result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.NullLiteral", null);
        } else {
          // import token as string constant even if it was an error in literal 
          result = new ASTConverter.QuotationClass_rbndtb_a0a1a0a0b0b0r().createNode(NameUtil.escapeString(new String(((Literal) expression).source())));
        }
      }
    }
    if ((result == null)) {
      result = SNodeOperations.cast(dispatchRefl("convertExpression", pos, expression), "jetbrains.mps.baseLanguage.structure.Expression");
    }
    if (expression != null) {
      int parenthesisCount = (expression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;
      for (int parenthsCreated = 0; parenthsCreated < parenthesisCount; parenthsCreated++) {
        SNode parenthesizedExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParenthesizedExpression", null);
        SLinkOperations.setTarget(parenthesizedExpression, "expression", result, true);
        result = parenthesizedExpression;
      }
    }
    return result;

  }

  /*package*/ List<SNode> convertExpressionStatements(Statement[] statements) {
    List<SNode> expressionStatements = new ArrayList<SNode>();
    if (statements != null) {
      for (int i = 0, n = statements.length; i < n; ++i) {
        SNode statement = convertStatementRefl(statements[i]);
        if ((statement != null)) {
          ListSequence.fromList(expressionStatements).addElement(SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.ExpressionStatement"));
        }
      }
    }
    return expressionStatements;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, AssertStatement x) {
    SNode expr = convertExpressionRefl(x.assertExpression);
    SNode arg = convertExpressionRefl(x.exceptionArgument);
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AssertStatement", null);
    SLinkOperations.setTarget(result, "condition", expr, true);
    SLinkOperations.setTarget(result, "message", arg, true);
    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, Block x) {
    if (x == null) {
      return null;
    }
    SNode blockStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BlockStatement", null);
    insertAt(pos, blockStatement);
    SNode statementList = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null);
    SLinkOperations.setTarget(blockStatement, "statements", statementList, true);
    addBlock(statementList, x.sourceStart(), x.sourceEnd());
    convertStatements(new ASTConverter.Position(statementList, "statement"), x.statements);
    // <node> 
    return blockStatement;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, BreakStatement x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BreakStatement", null);
    if (x.label != null) {
      SPropertyOperations.set(result, "label", new String(x.label));
    }
    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, SwitchStatement x) {
    SNode expression = convertExpressionRefl(x.expression);
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SwitchStatement", null);
    SLinkOperations.setTarget(result, "expression", expression, true);
    SLinkOperations.setTarget(result, "defaultBlock", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null), true);
    if (x.defaultCase != null) {
      addBlock(SLinkOperations.getTarget(result, "defaultBlock", true), x.defaultCase.sourceStart(), x.defaultCase.sourceEnd());
    }
    if (x.statements != null) {
      SNode currentSwitchCase = null;
      for (Statement stmt : x.statements) {
        if (stmt instanceof CaseStatement) {
          // advance end of previous case block 
          if ((currentSwitchCase != null)) {
            getBlock(currentSwitchCase).endPos = stmt.sourceStart;
          }
          CaseStatement caseStatement = (CaseStatement) stmt;
          if (caseStatement.constantExpression == null) {
            currentSwitchCase = SLinkOperations.getTarget(result, "defaultBlock", true);
          } else {
            SNode switchCase = convertCaseStatement(null, (CaseStatement) stmt);
            if ((switchCase != null)) {
              ListSequence.fromList(SLinkOperations.getTargets(result, "case", true)).addElement(switchCase);
            }
            currentSwitchCase = ((switchCase == null) ?
              null :
              SLinkOperations.getTarget(switchCase, "body", true)
            );
          }
        } else
        if ((currentSwitchCase != null)) {
          // advance end of case block 
          getBlock(currentSwitchCase).endPos = stmt.sourceEnd;
          ListSequence.fromList(SLinkOperations.getTargets(currentSwitchCase, "statement", true)).addElement(convertStatementRefl(stmt));
        }
      }
      // adjust end of last case block up to the end of switch statement 
      if ((currentSwitchCase != null)) {
        getBlock(currentSwitchCase).endPos = x.sourceEnd;
      }
    }
    return result;
  }

  /*package*/ SNode convertCaseStatement(ASTConverter.Position pos, CaseStatement x) {
    SNode expression = convertExpressionRefl(x.constantExpression);
    SNode switchCase = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SwitchCase", null);
    SLinkOperations.setTarget(switchCase, "expression", expression, true);
    SLinkOperations.setTarget(switchCase, "body", SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null), true);
    addBlock(SLinkOperations.getTarget(switchCase, "body", true), x.sourceStart(), x.sourceEnd());
    return switchCase;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, ContinueStatement x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ContinueStatement", null);
    if (x.label != null) {
      SPropertyOperations.set(result, "label", new String(x.label));
    }
    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, DoStatement x) {
    SNode loopTest = convertExpressionRefl(x.condition);
    SNode loopBody = convertStatementRefl(x.action);
    SNode doWhileStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DoWhileStatement", null);
    SLinkOperations.setTarget(doWhileStatement, "condition", loopTest, true);
    SNode body = getStatementListFromStatement(loopBody, x.action);
    SLinkOperations.setTarget(doWhileStatement, "body", body, true);
    return doWhileStatement;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, EmptyStatement x) {
    return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Statement", null);
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, LocalDeclaration x) {
    SNode decl = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", null);
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement", null);
    SLinkOperations.setTarget(result, "localVariableDeclaration", decl, true);
    insertAt(pos, result);

    SLinkOperations.setTarget(decl, "type", convertTypeRef(x.type), true);
    SPropertyOperations.set(decl, "name", new String(x.name));
    convertExpressionRefl(new ASTConverter.Position(decl, "initializer"), x.initialization);

    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, ReturnStatement x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ReturnStatement", null);
    SLinkOperations.setTarget(result, "expression", convertExpressionRefl(x.expression), true);
    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, ExplicitConstructorCall x) {
    if (x.isImplicitSuper()) {
      return null;
    }
    SNode result = (x.isSuperAccess() ?
      SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SuperConstructorInvocation", null) :
      SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ThisConstructorInvocation", null)
    );
    insertAt(pos, result);
    addCallArgs(result, x.arguments);
    SNode enclosing = SNodeOperations.getAncestor(pos.current, "jetbrains.mps.baseLanguage.structure.ClassConcept", false, false);
    if ((enclosing == null)) {
      enclosing = SNodeOperations.getAncestor(myAnchorNode, "jetbrains.mps.baseLanguage.structure.ClassConcept", false, false);
    }
    SLinkOperations.setTarget(result, "baseMethodDeclaration", findConstructor(enclosing, x.arguments), false);
    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, ForeachStatement x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ForeachStatement", null);
    SNode action = convertStatementRefl(x.action);
    SNode body = getStatementListFromStatement(action, x.action);


    SNode elementVar = SLinkOperations.getTarget(SNodeOperations.cast(convertStatement(x.elementVariable), "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement"), "localVariableDeclaration", true);


    SNode iterable = convertExpressionRefl(x.collection);
    SLinkOperations.setTarget(result, "iterable", iterable, true);
    SLinkOperations.setTarget(result, "variable", elementVar, true);
    SLinkOperations.setTarget(result, "body", body, true);
    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, ForStatement x) {
    SNode forStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ForStatement", null);
    List<SNode> init = convertStatements(x.initializations);
    SNode result = forStatement;
    if (ListSequence.fromList(init).any(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.baseLanguage.structure.ExpressionStatement");
      }
    })) {
      // we don't support for ( a=5, b=6; ...) {} in baseLanguage, workaround here 
      result = new ASTConverter.QuotationClass_rbndtb_a0a1a3a13().createNode(init, forStatement);
    } else if (!(init.isEmpty())) {
      boolean first = true;
      for (SNode statement : init) {
        if (SNodeOperations.isInstanceOf(statement, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement")) {
          SNode lvds = SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement");
          SNode variableDeclaration = SLinkOperations.getTarget(lvds, "localVariableDeclaration", true);
          if (first) {
            SLinkOperations.setTarget(forStatement, "variable", variableDeclaration, true);
            first = false;
          } else {
            SNode additionalForLoopVariable = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AdditionalForLoopVariable", null);
            SPropertyOperations.set(additionalForLoopVariable, "name", SPropertyOperations.getString(variableDeclaration, "name"));
            SNode inititalizer = SLinkOperations.getTarget(variableDeclaration, "initializer", true);
            if ((inititalizer != null)) {
              SLinkOperations.setTarget(additionalForLoopVariable, "initializer", inititalizer, true);
            }
            ListSequence.fromList(SLinkOperations.getTargets(forStatement, "additionalVar", true)).addElement(additionalForLoopVariable);
          }
        }
      }
    }
    SNode expr = convertExpressionRefl(x.condition);
    SLinkOperations.setTarget(forStatement, "condition", expr, true);
    List<SNode> incr = convertExpressionStatements(x.increments);
    if (!(incr.isEmpty())) {
      for (SNode expressionStatement : incr) {
        SNode expression = SLinkOperations.getTarget(expressionStatement, "expression", true);
        SNodeOperations.detachNode(expression);
        ListSequence.fromList(SLinkOperations.getTargets(forStatement, "iteration", true)).addElement(expression);
      }
    }
    SNode loopBody = convertStatementRefl(x.action);
    SNode body = getStatementListFromStatement(loopBody, x.action);
    SLinkOperations.setTarget(forStatement, "body", body, true);
    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, IfStatement x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IfStatement", null);
    insertAt(pos, result);
    convertExpressionRefl(new ASTConverter.Position(result, "condition"), x.condition);
    SNode thenStmt = convertStatementRefl(new ASTConverter.Position(result, "ifTrue"), x.thenStatement);
    convertStatementRefl(new ASTConverter.Position(result, "ifFalseStatement"), x.elseStatement);
    SNode ifTrue = getStatementListFromStatement(thenStmt, x.thenStatement);
    // adjust start of the "if" statement list block to get comments from "if (...)" there 
    getBlock(ifTrue).startPos = x.sourceStart;
    // replacing the ifTrue node 
    // <node> 
    SLinkOperations.setTarget(result, "ifTrue", ifTrue, true);
    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, LabeledStatement x) {
    SNode statement = convertStatementRefl(pos, x.statement);
    if ((statement == null)) {
      return null;
    }
    if (SNodeOperations.isInstanceOf(statement, "jetbrains.mps.baseLanguage.structure.AbstractLoopStatement")) {
      SNode loopStatement = SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.AbstractLoopStatement");
      SPropertyOperations.set(loopStatement, "label", new String(x.label));
    } else
    if (SNodeOperations.isInstanceOf(statement, "jetbrains.mps.baseLanguage.structure.SwitchStatement")) {
      SNode switchStatement = SNodeOperations.cast(statement, "jetbrains.mps.baseLanguage.structure.SwitchStatement");
      SPropertyOperations.set(switchStatement, "label", new String(x.label));
    }
    return statement;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, SynchronizedStatement x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SynchronizedStatement", null);
    SNode block = convertStatementRefl(x.block);
    SNode expr = convertExpressionRefl(x.expression);
    SLinkOperations.setTarget(result, "expression", expr, true);
    SLinkOperations.setTarget(result, "block", getStatementListFromStatement(block, x.block), true);
    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, ThrowStatement x) {
    SNode toThrow = convertExpressionRefl(x.exception);
    SNode throwStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ThrowStatement", null);
    SLinkOperations.setTarget(throwStatement, "throwable", toThrow, true);
    return throwStatement;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, TryStatement x) {
    SNode tryBlock = convertStatementRefl(x.tryBlock);
    List<SNode> catchArgs = new ArrayList<SNode>();
    List<SNode> catchBlocks = new ArrayList<SNode>();
    SNode finallyBlock = convertStatementRefl(x.finallyBlock);
    if (x.catchBlocks != null) {
      for (int i = 0, c = x.catchArguments.length; i < c; ++i) {



        SNode local = SLinkOperations.getTarget(SNodeOperations.cast(convertStatement(x.catchArguments[i]), "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement"), "localVariableDeclaration", true);



        ListSequence.fromList(catchArgs).addElement(local);
      }
      for (int i = 0, c = x.catchBlocks.length; i < c; ++i) {
        ListSequence.fromList(catchBlocks).addElement(convertStatementRefl(x.catchBlocks[i]));
      }
    }
    if ((finallyBlock != null)) {
      SNode tryStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TryStatement", null);
      for (int i = 0; i < catchBlocks.size(); i++) {
        SNode catchBlock = ListSequence.fromList(catchBlocks).getElement(i);
        SNode lvd = ListSequence.fromList(catchArgs).getElement(i);
        SNode catchClause = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.CatchClause", null);
        ListSequence.fromList(SLinkOperations.getTargets(tryStatement, "catchClause", true)).addElement(catchClause);
        SLinkOperations.setTarget(catchClause, "catchBody", getStatementListFromStatement(catchBlock, x.catchBlocks[i]), true);
        SLinkOperations.setTarget(catchClause, "throwable", lvd, true);
      }
      SLinkOperations.setTarget(tryStatement, "finallyBody", getStatementListFromStatement(finallyBlock, x.finallyBlock), true);
      SLinkOperations.setTarget(tryStatement, "body", getStatementListFromStatement(tryBlock, x.tryBlock), true);
      return tryStatement;
    } else {
      SNode tryCatchStatement = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TryCatchStatement", null);
      for (int i = 0; i < catchBlocks.size(); i++) {
        SNode catchBlock = ListSequence.fromList(catchBlocks).getElement(i);
        SNode lvd = ListSequence.fromList(catchArgs).getElement(i);
        SNode catchClause = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.CatchClause", null);
        ListSequence.fromList(SLinkOperations.getTargets(tryCatchStatement, "catchClause", true)).addElement(catchClause);
        SLinkOperations.setTarget(catchClause, "catchBody", getStatementListFromStatement(catchBlock, x.catchBlocks[i]), true);
        SLinkOperations.setTarget(catchClause, "throwable", lvd, true);
      }
      SLinkOperations.setTarget(tryCatchStatement, "body", getStatementListFromStatement(tryBlock, x.tryBlock), true);
      return tryCatchStatement;
    }
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, WhileStatement x) {
    SNode loopTest = convertExpressionRefl(x.condition);
    SNode loopBody = convertStatementRefl(x.action);
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.WhileStatement", null);
    SLinkOperations.setTarget(result, "condition", loopTest, true);
    SLinkOperations.setTarget(result, "body", getStatementListFromStatement(loopBody, x.action), true);
    return result;
  }

  /*package*/ SNode convertStatement(ASTConverter.Position pos, TypeDeclaration x) {
    throw new UnsupportedOperationException("Local type declarations are not supported");
  }

  /*package*/ SNode convertConstant(BooleanConstant x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BooleanConstant", null);
    SPropertyOperations.set(result, "value", "" + (x.booleanValue()));
    return result;
  }

  /*package*/ SNode convertConstant(ByteConstant x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IntegerConstant", null);
    SPropertyOperations.set(result, "value", "" + (x.byteValue()));
    return result;
  }

  /*package*/ SNode convertConstant(CharConstant x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.CharConstant", null);
    String value = NameUtil.escapeChar(x.charValue());
    SPropertyOperations.set(result, "charConstant", value);
    return result;
  }

  /*package*/ SNode convertConstant(DoubleConstant x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FloatingPointConstant", null);
    SPropertyOperations.set(result, "value", x.doubleValue() + "");
    return result;
  }

  /*package*/ SNode convertConstant(FloatConstant x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FloatingPointFloatConstant", null);
    SPropertyOperations.set(result, "value", x.floatValue() + "f");
    return result;
  }

  /*package*/ SNode convertConstant(ASTConverter.Position pos, IntConstant x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IntegerConstant", null);
    insertAt(pos, result);
    SPropertyOperations.set(result, "value", "" + (x.intValue()));
    return result;
  }

  /*package*/ SNode convertConstant(LongConstant x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LongLiteral", null);
    SPropertyOperations.set(result, "value", x.longValue() + "L");
    return result;
  }

  /*package*/ SNode convertConstant(ShortConstant x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.IntegerConstant", null);
    SPropertyOperations.set(result, "value", "" + (x.shortValue()));
    return result;
  }

  /*package*/ SNode convertConstant(ASTConverter.Position pos, StringConstant x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StringLiteral", null);
    SPropertyOperations.set(result, "value", NameUtil.escapeString(x.stringValue()));
    insertAt(pos, result);
    return result;
  }

  /*package*/ SNode convertBinaryOperation(Expression left, Expression right, SNode binaryOperation) {
    convertExpressionRefl(new ASTConverter.Position(binaryOperation, "leftExpression"), left);
    convertExpressionRefl(new ASTConverter.Position(binaryOperation, "rightExpression"), right);
    return binaryOperation;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, AND_AND_Expression x) {
    SNode andExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AndExpression", null);
    return convertBinaryOperation(x.left, x.right, andExpression);
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, OR_OR_Expression x) {
    SNode orExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.OrExpression", null);
    return convertBinaryOperation(x.left, x.right, orExpression);
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, ArrayAllocationExpression x) {
    SNode type = convertTypeRef(x.type);
    // FIXME HERE ARRAY TYPE IS EXPECTED, NOT COMPONENT TYPE 
    if (!(SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.ArrayType"))) {
      throw new JavaParseException("a type of array allocation should be an array type");
    }
    SNode arrayType = SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ArrayType");
    if (x.initializer != null) {
      List<SNode> initializers = new ArrayList<SNode>();
      if (x.initializer.expressions != null) {
        for (Expression expression : x.initializer.expressions) {
          ListSequence.fromList(initializers).addElement(convertExpressionRefl(expression));
        }
      }
      SNode arrayCreator = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayCreatorWithInitializer", null);
      for (SNode initializer : initializers) {
        ListSequence.fromList(SLinkOperations.getTargets(arrayCreator, "initValue", true)).addElement(initializer);
      }
      SLinkOperations.setTarget(arrayCreator, "componentType", SNodeOperations.copyNode(SLinkOperations.getTarget(arrayType, "componentType", true)), true);
      SNode genericNewExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
      SLinkOperations.setTarget(genericNewExpression, "creator", arrayCreator, true);
      return genericNewExpression;
    } else {
      List<SNode> dims = new ArrayList<SNode>();
      for (Expression dimension : x.dimensions) {
        if (dimension == null) {
          ListSequence.fromList(dims).addElement(null);
        } else {
          ListSequence.fromList(dims).addElement(convertExpressionRefl(dimension));
        }
      }
      SNode arrayCreator = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayCreator", null);
      for (SNode dim : dims) {
        SNode dimensionExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DimensionExpression", null);
        ListSequence.fromList(SLinkOperations.getTargets(arrayCreator, "dimensionExpression", true)).addElement(dimensionExpression);
        if (dim != null) {
          SLinkOperations.setTarget(dimensionExpression, "expression", dim, true);
        }
      }
      SNode deepestComponentType = SLinkOperations.getTarget(arrayType, "componentType", true);
      while (SNodeOperations.isInstanceOf(deepestComponentType, "jetbrains.mps.baseLanguage.structure.ArrayType")) {
        deepestComponentType = SLinkOperations.getTarget(SNodeOperations.cast(deepestComponentType, "jetbrains.mps.baseLanguage.structure.ArrayType"), "componentType", true);
      }
      SLinkOperations.setTarget(arrayCreator, "componentType", SNodeOperations.copyNode(deepestComponentType), true);
      SNode genericNewExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
      SLinkOperations.setTarget(genericNewExpression, "creator", arrayCreator, true);
      return genericNewExpression;
    }
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, ArrayInitializer x) {
    List<SNode> initializers = new ArrayList<SNode>();
    if (x.expressions != null) {
      for (Expression expression : x.expressions) {
        ListSequence.fromList(initializers).addElement(convertExpressionRefl(expression));
      }
    }
    SNode arrayLiteral = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayLiteral", null);
    for (SNode initializer : initializers) {
      ListSequence.fromList(SLinkOperations.getTargets(arrayLiteral, "item", true)).addElement(initializer);
    }
    return arrayLiteral;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, ArrayReference x) {
    SNode accessExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayAccessExpression", null);
    SLinkOperations.setTarget(accessExpression, "array", convertExpressionRefl(x.receiver), true);
    SLinkOperations.setTarget(accessExpression, "index", convertExpressionRefl(x.position), true);
    return accessExpression;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, Assignment x) {
    SNode assignmentExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AssignmentExpression", null);
    SLinkOperations.setTarget(assignmentExpression, "lValue", convertExpressionRefl(x.lhs), true);
    SLinkOperations.setTarget(assignmentExpression, "rValue", convertExpressionRefl(x.expression), true);
    return assignmentExpression;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, BinaryExpression x) {
    SNode op;
    int binOp = (x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT;
    switch (binOp) {
      case OperatorIds.LEFT_SHIFT:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShiftLeftExpression", null);
        break;
      case OperatorIds.RIGHT_SHIFT:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShiftRightExpression", null);
        break;
      case OperatorIds.UNSIGNED_RIGHT_SHIFT:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShiftRightUnsignedExpression", null);
        break;
      case OperatorIds.PLUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PlusExpression", null);
        break;
      case OperatorIds.MINUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.MinusExpression", null);
        break;
      case OperatorIds.REMAINDER:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.RemExpression", null);
        break;
      case OperatorIds.XOR:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseXorExpression", null);
        break;
      case OperatorIds.AND:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseAndExpression", null);
        break;
      case OperatorIds.MULTIPLY:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.MulExpression", null);
        break;
      case OperatorIds.OR:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseOrExpression", null);
        break;
      case OperatorIds.DIVIDE:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DivExpression", null);
        break;
      case OperatorIds.LESS_EQUAL:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LessThanOrEqualsExpression", null);
        break;
      case OperatorIds.GREATER_EQUAL:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GreaterThanOrEqualsExpression", null);
        break;
      case OperatorIds.GREATER:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GreaterThanExpression", null);
        break;
      case OperatorIds.LESS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LessThanExpression", null);
        break;
      default:
        throw new JavaParseException("Unsupported operator for BinaryExpression");
    }
    insertAt(pos, op);
    return convertBinaryOperation(x.left, x.right, op);
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, CombinedBinaryExpression x) {
    return convertExpression((BinaryExpression) x);
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, CompoundAssignment x) {
    SNode op;
    switch (x.operator) {
      case OperatorIds.PLUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PlusAssignmentExpression", null);
        break;
      case OperatorIds.MINUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.MinusAssignmentExpression", null);
        break;
      case OperatorIds.MULTIPLY:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.MulAssignmentExpression", null);
        break;
      case OperatorIds.DIVIDE:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DivAssignmentExpression", null);
        break;
      case OperatorIds.AND:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AndAssignmentExpression", null);
        break;
      case OperatorIds.OR:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.OrAssignmentExpression", null);
        break;
      case OperatorIds.XOR:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.XorAssignmentExpression", null);
        break;
      case OperatorIds.REMAINDER:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.RemAssignmentExpression", null);
        break;
      case OperatorIds.LEFT_SHIFT:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LeftShiftAssignmentExpression", null);
        break;
      case OperatorIds.RIGHT_SHIFT:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.RightShiftAssignmentExpression", null);
        break;
      case OperatorIds.UNSIGNED_RIGHT_SHIFT:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.UnsignedRightShiftAssignmentExpression", null);
        break;
      default:
        throw new JavaParseException("Unsupported operator for CompoundAssignment");
    }
    SLinkOperations.setTarget(op, "lValue", convertExpressionRefl(x.lhs), true);
    SLinkOperations.setTarget(op, "rValue", convertExpressionRefl(x.expression), true);
    return op;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, ConditionalExpression x) {
    SNode ifTest = convertExpressionRefl(x.condition);
    SNode thenExpr = convertExpressionRefl(x.valueIfTrue);
    SNode elseExpr = convertExpressionRefl(x.valueIfFalse);
    SNode tOp = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TernaryOperatorExpression", null);
    SLinkOperations.setTarget(tOp, "condition", ifTest, true);
    SLinkOperations.setTarget(tOp, "ifTrue", thenExpr, true);
    SLinkOperations.setTarget(tOp, "ifFalse", elseExpr, true);
    return tOp;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, EqualExpression x) {
    SNode op;
    switch ((x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) {
      case OperatorIds.EQUAL_EQUAL:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EqualsExpression", null);
        break;
      case OperatorIds.NOT_EQUAL:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.NotEqualsExpression", null);
        break;
      default:
        throw new JavaParseException("Unexpected operator for EqualExpression");
    }
    return convertBinaryOperation(x.left, x.right, op);
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, InstanceOfExpression x) {
    SNode expr = convertExpressionRefl(x.expression);
    SNode testType = convertTypeRef(x.type);
    SNode instanceOfExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceOfExpression", null);
    SLinkOperations.setTarget(instanceOfExpression, "leftExpression", expr, true);
    SLinkOperations.setTarget(instanceOfExpression, "classType", testType, true);
    return instanceOfExpression;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, PostfixExpression x) {
    SNode op;
    switch (x.operator) {
      case OperatorIds.MINUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PostfixDecrementExpression", null);
        break;
      case OperatorIds.PLUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PostfixIncrementExpression", null);
        break;
      default:
        throw new JavaParseException("Unexpected postfix operator");
    }
    SLinkOperations.setTarget(op, "expression", convertExpressionRefl(x.lhs), true);
    return op;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, PrefixExpression x) {
    SNode op;
    switch (x.operator) {
      case OperatorIds.MINUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PrefixDecrementExpression", null);
        break;
      case OperatorIds.PLUS:
        op = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PrefixIncrementExpression", null);
        break;
      default:
        throw new JavaParseException("Unexpected prefix operator");
    }
    SLinkOperations.setTarget(op, "expression", convertExpressionRefl(x.lhs), true);
    return op;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, CastExpression x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.CastExpression", null);
    insertAt(pos, result);
    convertExpressionRefl(new ASTConverter.Position(result, "expression"), x.expression);

    // x.type is expression, not type reference 
    // we're making TypeReference out of NameReference 
    TypeReference typRef = nameRefToTypeRef(x.type);
    if (typRef == null) {
      throw new JavaParseException("Unexpected type expression in type case: " + x.type.getClass().getName());
    }
    SLinkOperations.setTarget(result, "type", convertTypeRef(typRef), true);
    return result;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, NullLiteral x) {
    return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.NullLiteral", null);
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, SuperReference x) {
    throw new JavaParseException("we have no super-references; this case should be analyzed as method call");
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, ThisReference x) {
    return SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ThisExpression", null);
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, QualifiedThisReference x) {
    SNode thisRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ThisExpression", null);
    SNode type = convertTypeRef(x.qualification);
    if (!(SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.ClassifierType"))) {
      throw new JavaParseException("Type should be class in qualified this reference");
    }
    SReference sref = adjustClassReference(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ClassifierType"), thisRef, "classConcept");
    thisRef.addReference(sref);
    return thisRef;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, SingleNameReference x) {
    SNode varRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.VariableReference", null);
    insertAt(pos, varRef);
    SReference sref = new DynamicReference("variableDeclaration", varRef, null, new String(x.token));
    varRef.addReference(sref);
    return varRef;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, QualifiedNameReference x) {
    String[] tokens = new String[x.tokens.length];
    if (tokens.length == 0) {
      return null;
    }

    for (int i = 0; i < tokens.length; i++) {
      tokens[i] = new String(x.tokens[i]);
    }

    System.err.println("DEBUG: scoper = " + SPropertyOperations.getString(SNodeOperations.getConceptDeclaration(pos.current), "name") + " parent = " + SPropertyOperations.getString(SNodeOperations.getConceptDeclaration(SNodeOperations.getParent(pos.current)), "name") + " role " + pos.role + " index " + pos.index);


    // check if the first component is a variable (field, param, etc.) 
    Scope scope = getScopeAt(pos, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.VariableDeclaration"));
    if (scope == null) {
      System.err.println("DEBUG: sccope is null");
      return null;
    }

    SNode operand;
    int tokPos = 0;

    if (Sequence.fromIterable(scope.getAvailableElements(tokens[0])).isNotEmpty()) {
      System.err.println("DEBUG: token = " + tokens[0]);
      // it's a variable 
      SNode varRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.VariableReference", null);
      SReference sref = new DynamicReference("variableDeclaration", varRef, null, tokens[0]);
      varRef.addReference(sref);

      operand = varRef;
      tokPos = 1;

      System.err.println("DEBUG: normal dot expr");

    } else {
      // it must be a class 
      // <node> 
      // <node> 
      // <node> 

      // <node> 

      SNode cls = tryGetClassAt(pos, tokens[0]);

      if ((cls == null)) {
        return null;
      }

      SNode statFieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticFieldReference", null);

      // <node> 
      SLinkOperations.setTarget(statFieldRef, "classifier", cls, false);
      // <node> 
      // <node> 

      SReference fieldRef = new DynamicReference("staticFieldDeclaration", statFieldRef, null, tokens[1]);
      statFieldRef.addReference(fieldRef);

      operand = statFieldRef;
      tokPos = 2;
      System.err.println("DEBUG: no variable elements in scope");
    }

    while (tokPos < tokens.length) {
      SNode dotExpr = makeFieldDotExpression(operand, tokens[tokPos]);
      operand = dotExpr;
      tokPos++;
    }

    insertAt(pos, operand);
    return operand;
  }

  /*package*/ SNode makeFieldDotExpression(SNode holder, String fieldName) {
    SNode dotExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DotExpression", null);
    SLinkOperations.setTarget(dotExpr, "operand", holder, true);
    SNode fieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldReferenceOperation", null);
    SLinkOperations.setTarget(dotExpr, "operation", fieldRef, true);
    SReference sref = new DynamicReference("fieldDeclaration", fieldRef, null, fieldName);
    fieldRef.addReference(sref);
    return dotExpr;
  }

  /*package*/ SNode convertExpression1(ASTConverter.Position pos, SingleNameReference x) {
    // <node> 

    // <node> 

    System.err.println("DEBUG: scoper = " + SPropertyOperations.getString(SNodeOperations.getConceptDeclaration(pos.current), "name") + " parent = " + SPropertyOperations.getString(SNodeOperations.getConceptDeclaration(SNodeOperations.getParent(pos.current)), "name") + " role " + pos.role + " index " + pos.index);


    Scope scope = pos.getScope(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.VariableDeclaration"));

    if (scope == null) {
      System.err.println("DEBUG: scope is null");
    } else {
      System.err.println("DEBUG: got scope");
    }

    Iterable<SNode> nodesInScope = scope.getAvailableElements(new String(x.token));

    if (Sequence.fromIterable(nodesInScope).count() > 0) {
      System.err.println("DEBUG: there are elements");
      SNode firstInScope = Sequence.fromIterable(nodesInScope).iterator().next();

      System.out.println("DEBUG: scope element's concept = " + SPropertyOperations.getString(SNodeOperations.getConceptDeclaration(firstInScope), "name"));

      if (SNodeOperations.isInstanceOf(firstInScope, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration")) {
        SNode locVarRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LocalVariableReference", null);
        SLinkOperations.setTarget(locVarRef, "variableDeclaration", SNodeOperations.cast(firstInScope, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration"), false);
        insertAt(pos, locVarRef);
        return locVarRef;
      } else {
        return null;
      }
    } else {
      System.err.println("DEBUG: there are NO elements in SCOPER");

      Scope scope2 = Scope.getScope(myAnchorNode, null, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.VariableDeclaration"));
      nodesInScope = scope2.getAvailableElements(new String(x.token));

      if (Sequence.fromIterable(nodesInScope).count() > 0) {
        System.err.println("DEBUG: there are elements");
        SNode firstInScope = Sequence.fromIterable(nodesInScope).iterator().next();

        System.out.println("DEBUG: scope element's concept = " + SPropertyOperations.getString(SNodeOperations.getConceptDeclaration(firstInScope), "name"));

        if (SNodeOperations.isInstanceOf(firstInScope, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration")) {
          SNode locVarRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LocalVariableReference", null);
          SLinkOperations.setTarget(locVarRef, "variableDeclaration", SNodeOperations.cast(firstInScope, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration"), false);
          insertAt(pos, locVarRef);
          return locVarRef;
        } else {
          return null;
        }
      } else {
        System.err.println("DEBUG: there are NO elements AT ALL");

        return null;
      }

    }

  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, MessageSend x) {
    // it's a method call 
    //  results in either LocalStaticMethodCall, LocalInstanceMethodCall, StaticMethodCall 
    //  or DotExpression with MethodCallOperation 

    String methodName = new String(x.selector);
    SNode result = null;
    SNode callt = null;

    if (x.receiver instanceof ThisReference && ((ThisReference) x.receiver).isImplicitThis()) {
      // it's a local call, f() 
      Scope staticMethodsScope = getScopeAt(pos, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration"));
      Scope instMethodsScope = getScopeAt(pos, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration"));

      Iterable<SNode> staticMethods = staticMethodsScope.getAvailableElements(methodName);
      if (Sequence.fromIterable(staticMethods).isNotEmpty()) {
        SNode decl = SNodeOperations.cast(Sequence.fromIterable(staticMethods).iterator().next(), "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration");
        SNode call = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodCall", null);
        insertAt(pos, call);
        SLinkOperations.setTarget(call, "baseMethodDeclaration", decl, false);
        callt = call;
        result = call;

      } else {
        Iterable<SNode> instMethods = instMethodsScope.getAvailableElements(methodName);
        SNode decl = null;
        if (Sequence.fromIterable(instMethods).isNotEmpty()) {
          decl = SNodeOperations.cast(Sequence.fromIterable(instMethods).iterator().next(), "jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration");
        }
        SNode call = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LocalInstanceMethodCall", null);
        insertAt(pos, call);
        SLinkOperations.setTarget(call, "baseMethodDeclaration", decl, false);
        callt = call;
        result = call;
      }

    } else {
      // it's something.method(...) 
      // let's see if 'something' is SingleNameRef or QualifiedNameRef; if yes let's see if it's a class 
      // if either it's not a name ref or not a class then handle it just as some random expression 

      Expression receiver = x.receiver;
      if (receiver instanceof NameReference) {
        // if (it's a class) {... 

        StringBuffer sb = new StringBuffer();
        receiver.printExpression(0, sb);
        String name = sb.toString();

        SNode cls = tryGetClassAt(pos, name);

        if ((cls != null) && SNodeOperations.isInstanceOf(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
          SNode call = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StaticMethodCall", null);

          insertAt(pos, call);

          SLinkOperations.setTarget(call, "classConcept", SNodeOperations.cast(cls, "jetbrains.mps.baseLanguage.structure.ClassConcept"), false);
          SReference sref = new DynamicReference("staticMethodDeclaration", call, null, methodName);
          call.addReference(sref);

          callt = call;
          result = call;
        }


        // <node> 
        // <node> 
        // <node> 
      }

      if ((result == null)) {
        // not a static call 
        SNode dotExpr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DotExpression", null);
        insertAt(pos, dotExpr);
        ASTConverter.Position oprndPos = new ASTConverter.Position(dotExpr, "operand");
        convertExpressionRefl(oprndPos, x.receiver);

        SNode call = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation", null);
        SLinkOperations.setTarget(dotExpr, "operation", call, true);

        SReference sref = new DynamicReference("instanceMethodDeclaration", call, null, methodName);
        call.addReference(sref);

        callt = call;
        result = dotExpr;
      }
    }

    if ((callt != null)) {
      addCallArgs(callt, x.arguments);
    }

    return result;
  }

  public void addCallArgs(SNode call, Expression[] args) {
    ASTConverter.Position argPos = new ASTConverter.Position(call, "actualArgument");
    for (Expression arg : args) {
      SNode expr = convertExpressionRefl(argPos, arg);
      argPos.anchor = expr;
      argPos.index++;
    }
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, FieldReference x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DotExpression", null);
    insertAt(pos, result);
    convertExpressionRefl(new ASTConverter.Position(result, "operand"), x.receiver);
    SNode fieldRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.FieldReferenceOperation", null);
    SLinkOperations.setTarget(result, "operation", fieldRef, true);
    SReference sref = new DynamicReference("fieldDeclaration", fieldRef, null, new String(x.token));
    fieldRef.addReference(sref);
    return result;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, AllocationExpression x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
    insertAt(pos, result);
    SNode create = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassCreator", null);
    SLinkOperations.setTarget(result, "creator", create, true);

    StringBuffer sb = new StringBuffer();
    x.type.printExpression(0, sb);
    String typeName = sb.toString();

    SNode typ = tryGetClassAt(pos, typeName);
    if ((typ == null)) {
      System.err.println("DEBUG: type not found");
      return null;
    } else {
      // try to find the right constructor 
      SNode cons;
      if (!(SNodeOperations.isInstanceOf(typ, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
        return null;
      }
      SLinkOperations.setTarget(create, "baseMethodDeclaration", findConstructor(SNodeOperations.cast(typ, "jetbrains.mps.baseLanguage.structure.ClassConcept"), x.arguments), false);
    }
    if ((create != null)) {
      addCallArgs(create, x.arguments);
    }
    return result;
  }

  private SNode findConstructor(SNode claz, Expression[] args) {
    SNode result;
    List<SNode> conss = SLinkOperations.getTargets(claz, "constructor", true);
    if (ListSequence.fromList(conss).isEmpty()) {
      result = null;
    } else if ((int) ListSequence.fromList(conss).count() == 1) {
      result = ListSequence.fromList(conss).first();
    } else {
      final int argCount = args.length;
      Iterable<SNode> subset = ListSequence.fromList(conss).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return (int) ListSequence.fromList(SLinkOperations.getTargets(it, "parameter", true)).count() == argCount;
        }
      });
      result = Sequence.fromIterable(subset).first();
    }
    return result;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, QualifiedAllocationExpression x) {
    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GenericNewExpression", null);
    insertAt(pos, result);
    SNode create = null;
    if (x.anonymousType != null) {
      SNode anonCreate = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnonymousClassCreator", null);
      create = anonCreate;
      SLinkOperations.setTarget(result, "creator", anonCreate, true);
      SNode cls = SNodeOperations.cast(convertTypeDecl(x.anonymousType), "jetbrains.mps.baseLanguage.structure.AnonymousClass");
      SLinkOperations.setTarget(anonCreate, "cls", cls, true);
      SLinkOperations.setTarget(cls, "classifier", SLinkOperations.getTarget(SNodeOperations.cast(convertTypeRef(x.type), "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", false), false);
      addCallArgs(cls, x.arguments);
    }

    return result;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, ClassLiteralAccess x) {

    SNode argType = convertTypeRef(x.type);
    if (!(SNodeOperations.isInstanceOf(argType, "jetbrains.mps.baseLanguage.structure.ClassifierType"))) {
      throw new JavaParseException("Type in class literal access is expected to be classifier");
    }

    SNode result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierClassExpression", null);

    SReference sref = adjustClassReference(SNodeOperations.cast(argType, "jetbrains.mps.baseLanguage.structure.ClassifierType"), result, "classifier");
    result.addReference(sref);
    return result;
  }

  /*package*/ SNode convertExpression(ASTConverter.Position pos, UnaryExpression x) {
    int operator = ((x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT);
    switch (operator) {
      case OperatorIds.MINUS:
        SNode unaryMinus = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.UnaryMinus", null);
        SLinkOperations.setTarget(unaryMinus, "expression", convertExpressionRefl(x.expression), true);
        return unaryMinus;
      case OperatorIds.NOT:
        SNode notExpression = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.NotExpression", null);
        SLinkOperations.setTarget(notExpression, "expression", convertExpressionRefl(x.expression), true);
        return notExpression;
      case OperatorIds.PLUS:
        return convertExpressionRefl(x.expression);
      case OperatorIds.TWIDDLE:
        SNode twiddle = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseNotExpression", null);
        SLinkOperations.setTarget(twiddle, "expression", convertExpressionRefl(x.expression), true);
        return twiddle;
      default:
        throw new JavaParseException("Unexpected operator for unary expression");
    }
  }

  public SNode convertExpression(Expression exp) {
    if (exp instanceof TrueLiteral) {
      return new ASTConverter.QuotationClass_rbndtb_a0a0a0cd().createNode();
    } else if (exp instanceof FalseLiteral) {
      return new ASTConverter.QuotationClass_rbndtb_a0a0a0a08().createNode();
    } else if (exp instanceof StringLiteral) {
      return new ASTConverter.QuotationClass_rbndtb_a0a0b0a08().createNode(new String(((StringLiteral) exp).source()));
    } else if (exp instanceof ArrayInitializer) {
      SNode arr = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ArrayLiteral", null);
      for (Expression e : ((ArrayInitializer) exp).expressions) {
        ListSequence.fromList(SLinkOperations.getTargets(arr, "item", true)).addElement(convertExpression(e));
      }
      return arr;
    } else if (exp instanceof QualifiedNameReference) {

      // FIXME HACK it can be static field ref as well, and maybe something else 
      SNode enumRef = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumConstantReference", null);
      char[][] tokens = ((QualifiedNameReference) exp).tokens;

      String enumName = new String(tokens[0]);
      for (int i = 1; i < tokens.length - 1; i++) {
        enumName = enumName + "." + new String(tokens[i]);
      }

      String enumConstName = new String(tokens[tokens.length - 1]);

      SReference enumClRef;
      if (enumName.contains(".")) {
        enumClRef = myTypeResolver.resolveQualifiedClassName(enumName, enumRef, "enumClass");
      } else {
        enumClRef = myTypeResolver.resolveShortClassName(enumName, enumRef, "enumClass");
      }
      SReference enumConstRef = new DynamicReference("enumConstantDeclaration", enumRef, null, enumConstName);

      enumRef.addReference(enumClRef);
      enumRef.addReference(enumConstRef);
      return enumRef;

    } else if (exp instanceof SingleNameReference) {
      // FIXME 
      return new ASTConverter.QuotationClass_rbndtb_a0b0e0a08().createNode();
    } else {
      throw new RuntimeException("This kind of expression is not supported yet: " + exp.getClass().getName());
    }

  }

  private SReference adjustClassReference(SNode clsType, SNode source, String role) {
    SReference sref = clsType.getReference("classifier");
    if (sref instanceof DynamicReference) {
      return new DynamicReference(role, source, null, ((DynamicReference) sref).getResolveInfo());
    } else if (sref instanceof StaticReference) {
      return new StaticReference(role, source, ((StaticReference) sref).getTargetNode());
    } else {
      throw new RuntimeException("Unknown type of reference: " + sref.getClass().getName());
    }
  }

  private boolean isEnumConstant(FieldDeclaration x) {
    return x.initialization != null && x.initialization instanceof AllocationExpression && ((AllocationExpression) x.initialization).enumConstant != null;
  }

  private String enumConstantName(FieldDeclaration x) {
    // Unsafe. supposed to be used after isEnumConstant 
    return new String(((AllocationExpression) x.initialization).enumConstant.name);
  }

  private boolean flagSet(int bitmap, int flag) {
    return (bitmap & flag) != 0;
  }

  public String getTypeName(SNode type) {
    if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.PrimitiveType")) {
      // <node> 
      // <node> 
      return SConceptPropertyOperations.getString(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.PrimitiveType"), "alias");
    } else if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.ClassifierType")) {
      // <node> 
      //  we'll do assert later when parser always returns dynamic refs 
      // <node> 
      if (SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ClassifierType").getReference("classifier") instanceof DynamicReference) {
        DynamicReference dynRef = (DynamicReference) SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ClassifierType").getReference("classifier");
        return dynRef.getResolveInfo();
      } else {
        return SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", false), "name");
      }
    } else if (SNodeOperations.isInstanceOf(type, "jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
      return "Tv:" + SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.cast(type, "jetbrains.mps.baseLanguage.structure.TypeVariableReference"), "typeVariableDeclaration", false), "name");
    } else {
      return "unk";
    }
  }

  protected SNode dispatchRefl(String name, ASTConverter.Position pos, Object child) {
    if (child == null) {
      return null;
    }
    try {
      Method method = getClass().getDeclaredMethod(name, ASTConverter.Position.class, child.getClass());
      return (SNode) method.invoke(this, pos, child);
    } catch (Throwable e) {
      if (e instanceof InvocationTargetException) {
        e = ((InvocationTargetException) e).getTargetException();
      }
      throw new JavaParseException(e);
    }
  }

  private SNode getStatementListFromStatement(SNode possibleBlock, Statement x) {
    SNode result;
    if (SNodeOperations.isInstanceOf(possibleBlock, "jetbrains.mps.baseLanguage.structure.BlockStatement")) {
      result = SLinkOperations.getTarget(SNodeOperations.cast(possibleBlock, "jetbrains.mps.baseLanguage.structure.BlockStatement"), "statements", true);
      // FIXME should detach be called here? it depends on whether we're already in a model... 
      // <node> 
    } else {
      result = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null);
      addBlock(result, x.sourceStart(), x.sourceEnd());
      if ((possibleBlock != null)) {
        ListSequence.fromList(SLinkOperations.getTargets(result, "statement", true)).addElement(possibleBlock);
      }
    }
    return result;
  }

  public TypeReference nameRefToTypeRef(Expression x) {
    TypeReference myTypeRef = null;
    if (x instanceof SingleNameReference) {
      myTypeRef = new SingleTypeReference(((SingleNameReference) x).token, -1);
    } else if (x instanceof QualifiedNameReference) {
      myTypeRef = new QualifiedTypeReference(((QualifiedNameReference) x).tokens, new long[]{-1});
    }
    return myTypeRef;
  }

  private void addBlock(SNode node, int start, int end) {
    ListSequence.fromList(myBlocks).addElement(new ASTConverter.CodeBlock(node, myCud, Math.abs(start), Math.abs(end)));
  }

  private ASTConverter.CodeBlock getBlock(final SNode node) {
    return ListSequence.fromList(myBlocks).findFirst(new IWhereFilter<ASTConverter.CodeBlock>() {
      public boolean accept(ASTConverter.CodeBlock it) {
        return it.stmt == node;
      }
    });
  }

  private SNode findBlock(final int sourcePos) {
    long min = Long.MAX_VALUE;
    SNode stmt = null;

    // we could maintain the stack of blocks 
    // then we would just take the topmost element from the stack 
    for (ASTConverter.CodeBlock block : ListSequence.fromList(myBlocks).where(new IWhereFilter<ASTConverter.CodeBlock>() {
      public boolean accept(ASTConverter.CodeBlock it) {
        return it.startPos <= sourcePos && sourcePos <= it.endPos;
      }
    })) {
      long w = block.endPos - block.startPos;
      if (w < min) {
        min = w;
        stmt = block.stmt;
      }
    }

    return stmt;
  }

  private void insertAt(ASTConverter.Position pos, SNode node) {
    if (pos != null) {
      pos.insert(node);
    }
  }

  private Scope getScopeAt(ASTConverter.Position pos, SNode kind) {
    Scope outerScope = null;
    if ((myAnchorNode != null)) {
      outerScope = Scope.getScope(myAnchorNode, null, kind);
    }
    if (pos == null) {
      return outerScope;
    } else {
      return new CompositeScope(pos.getScope(kind), outerScope);
    }
  }

  private SNode tryGetClassAt(ASTConverter.Position pos, String name) {
    SNode cls = tryGetClassifier(pos.current, name);
    if ((cls == null)) {
      cls = tryGetClassifier(myAnchorNode, name);
    }
    return cls;
  }

  private SNode tryGetClassifier(SNode contextNode, String name) {
    IModule mod = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("f3061a53-9226-4cc5-a443-f952ceaf5816"));
    Class c = mod.getClass("jetbrains.mps.baseLanguage.scopes.ClassifiersScope");
    if (c == null) {
      System.out.println("DEBUG: no such class");
    } else {
      System.out.println("DEBUG: FOUND class");
    }
    SNode res = null;
    try {
      Constructor cons = c.getConstructor(SModel.class, IScope.class, String.class);
      Method m = c.getMethod("resolve", SNode.class, String.class);
      Object scope = cons.newInstance(SNodeOperations.getModel(myAnchorNode), new GlobalScope(MPSModuleRepository.getInstance(), SModelRepository.getInstance()), name);
      Object x = m.invoke(scope, contextNode, name);
      res = SNodeOperations.cast(SNode.class.cast(x), "jetbrains.mps.baseLanguage.structure.Classifier");
    } catch (Exception e) {
      e.printStackTrace();
    }
    if (res == null) {
      System.out.println("DEBUG: no result");
    } else {
      System.out.println("DEBUG: FOUND node");
    }

    return res;
  }

  private static StringBuilder check_rbndtb_a7a6(StringBuilder checkedDotOperand, AbstractMethodDeclaration x) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.append("." + new String(x.selector) + "(");
    }
    return null;
  }

  private static StringBuilder check_rbndtb_a6a0a41a6(StringBuilder checkedDotOperand, SNode par, ASTConverter checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.append(checkedDotThisExpression.getTypeName(SLinkOperations.getTarget(par, "type", true)));
    }
    return null;
  }

  private static StringBuilder check_rbndtb_a7a0a41a6(StringBuilder checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.append(",");
    }
    return null;
  }

  private static StringBuilder check_rbndtb_a0a2a41a6(StringBuilder checkedDotOperand, StringBuilder idBuilder) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.deleteCharAt(check_rbndtb_a0a0a0c0o0g(idBuilder) - 1);
    }
    return null;
  }

  private static int check_rbndtb_a0a0a0c0o0g(StringBuilder checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.length();
    }
    return 0;
  }

  private static StringBuilder check_rbndtb_a51a6(StringBuilder checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.append(")");
    }
    return null;
  }

  public class CodeBlock {
    private SNode stmt;
    private CompilationUnitDeclaration cud;
    private long startPos;
    private long endPos;

    public CodeBlock(SNode n, CompilationUnitDeclaration d, long s, long e) {
      stmt = n;
      cud = d;
      startPos = s;
      endPos = e;
    }
  }

  /*package*/ static class Position {
    private SNode current;
    private SNode anchor;
    private String role;
    private int index;

    public Position(SNode n, String rol) {
      current = n;
      role = rol;
      index = 0;
      anchor = null;
    }

    public Scope getScope(SNode kind) {
      return Scope.getScope(current, role, index, kind);
    }

    public void insert(SNode node) {
      if (index == 0) {
        current.addChild(role, node);
      } else {
        SNode anchor = current.getChildren(role).get(index - 1);
        current.insertChild(anchor, role, node);
      }

    }
  }

  public static class QuotationClass_rbndtb_a0a1a3a1a3a23a1 {
    public QuotationClass_rbndtb_a0a1a3a1a3a23a1() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PublicVisibility", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a2a0b0d0gb0b {
    public QuotationClass_rbndtb_a0a2a0b0d0gb0b() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.VoidType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a1a0t0g {
    public QuotationClass_rbndtb_a0a1a0t0g() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StubStatementList", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a1a7 {
    public QuotationClass_rbndtb_a0a1a7() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PublicVisibility", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0b0h {
    public QuotationClass_rbndtb_a0a0b0h() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ProtectedVisibility", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0a1a7 {
    public QuotationClass_rbndtb_a0a0a1a7() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PrivateVisibility", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0a0d0c0a0c0g0i {
    public QuotationClass_rbndtb_a0a0a0d0c0a0c0g0i() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.WildCardType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a1a1d0c0a0c0g0i {
    public QuotationClass_rbndtb_a0a1a1d0c0a0c0g0i() {
    }

    public SNode createNode(Object parameter_5) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.UpperBoundType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_3 = quotedNode_1;
        {
          quotedNode_2 = (SNode) parameter_5;
          SNode quotedNode1_4;
          if (_parameterValues_129834374.contains(quotedNode_2)) {
            quotedNode1_4 = HUtil.copyIfNecessary(quotedNode_2);
          } else {
            _parameterValues_129834374.add(quotedNode_2);
            quotedNode1_4 = quotedNode_2;
          }
          if (quotedNode1_4 != null) {
            quotedNode_1.addChild("bound", HUtil.copyIfNecessary(quotedNode1_4));
          }
        }
        result = quotedNode1_3;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a1a2d0c0a0c0g0i {
    public QuotationClass_rbndtb_a0a1a2d0c0a0c0g0i() {
    }

    public SNode createNode(Object parameter_5) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.LowerBoundType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_3 = quotedNode_1;
        {
          quotedNode_2 = (SNode) parameter_5;
          SNode quotedNode1_4;
          if (_parameterValues_129834374.contains(quotedNode_2)) {
            quotedNode1_4 = HUtil.copyIfNecessary(quotedNode_2);
          } else {
            _parameterValues_129834374.add(quotedNode_2);
            quotedNode1_4 = quotedNode_2;
          }
          if (quotedNode1_4 != null) {
            quotedNode_1.addChild("bound", HUtil.copyIfNecessary(quotedNode1_4));
          }
        }
        result = quotedNode1_3;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0c0c0j {
    public QuotationClass_rbndtb_a0c0c0j() {
    }

    public SNode createNode(Object parameter_5) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ArrayType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_3 = quotedNode_1;
        {
          quotedNode_2 = (SNode) parameter_5;
          SNode quotedNode1_4;
          if (_parameterValues_129834374.contains(quotedNode_2)) {
            quotedNode1_4 = HUtil.copyIfNecessary(quotedNode_2);
          } else {
            _parameterValues_129834374.add(quotedNode_2);
            quotedNode1_4 = quotedNode_2;
          }
          if (quotedNode1_4 != null) {
            quotedNode_1.addChild("componentType", HUtil.copyIfNecessary(quotedNode1_4));
          }
        }
        result = quotedNode1_3;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0g0k {
    public QuotationClass_rbndtb_a0a0g0k() {
    }

    public SNode createNode(Object parameter_5) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ArrayType", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_3 = quotedNode_1;
        {
          quotedNode_2 = (SNode) parameter_5;
          SNode quotedNode1_4;
          if (_parameterValues_129834374.contains(quotedNode_2)) {
            quotedNode1_4 = HUtil.copyIfNecessary(quotedNode_2);
          } else {
            _parameterValues_129834374.add(quotedNode_2);
            quotedNode1_4 = quotedNode_2;
          }
          if (quotedNode1_4 != null) {
            quotedNode_1.addChild("componentType", HUtil.copyIfNecessary(quotedNode1_4));
          }
        }
        result = quotedNode1_3;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a1a0a0b0b0r {
    public QuotationClass_rbndtb_a0a1a0a0b0b0r() {
    }

    public SNode createNode(Object parameter_3) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StringLiteral", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        quotedNode1_2.setProperty("value", (String) parameter_3);
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a1a3a13 {
    public QuotationClass_rbndtb_a0a1a3a13() {
    }

    public SNode createNode(Object parameter_12, Object parameter_13) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      SNode quotedNode_2 = null;
      SNode quotedNode_3 = null;
      SNode quotedNode_4 = null;
      SNode quotedNode_5 = null;
      SNode quotedNode_6 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.BlockStatement", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_7 = quotedNode_1;
        {
          quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StatementList", null, GlobalScope.getInstance(), false);
          SNode quotedNode1_8 = quotedNode_2;
          {
            quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.SingleLineComment", null, GlobalScope.getInstance(), false);
            SNode quotedNode1_9 = quotedNode_3;
            {
              quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.TextCommentPart", null, GlobalScope.getInstance(), false);
              SNode quotedNode1_10 = quotedNode_6;
              quotedNode1_10.setProperty("text", "converted:  for ( expr; ...) {}  ->  { expr; for ( ; ...) {} }");
              quotedNode_3.addChild("commentPart", quotedNode1_10);
            }
            quotedNode_2.addChild("statement", quotedNode1_9);
          }
          {
            List<SNode> nodes = (List<SNode>) parameter_12;
            for (SNode child : nodes) {
              quotedNode_2.addChild("statement", HUtil.copyIfNecessary(child));
            }
          }
          {
            quotedNode_5 = (SNode) parameter_13;
            SNode quotedNode1_11;
            if (_parameterValues_129834374.contains(quotedNode_5)) {
              quotedNode1_11 = HUtil.copyIfNecessary(quotedNode_5);
            } else {
              _parameterValues_129834374.add(quotedNode_5);
              quotedNode1_11 = quotedNode_5;
            }
            if (quotedNode1_11 != null) {
              quotedNode_2.addChild("statement", HUtil.copyIfNecessary(quotedNode1_11));
            }
          }
          quotedNode_1.addChild("statements", quotedNode1_8);
        }
        result = quotedNode1_7;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0a0cd {
    public QuotationClass_rbndtb_a0a0a0cd() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.BooleanConstant", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        quotedNode1_2.setProperty("value", "true");
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0a0a08 {
    public QuotationClass_rbndtb_a0a0a0a08() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.BooleanConstant", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0a0b0a08 {
    public QuotationClass_rbndtb_a0a0b0a08() {
    }

    public SNode createNode(Object parameter_3) {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StringLiteral", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        quotedNode1_2.setProperty("value", (String) parameter_3);
        result = quotedNode1_2;
      }
      return result;
    }
  }

  public static class QuotationClass_rbndtb_a0b0e0a08 {
    public QuotationClass_rbndtb_a0b0e0a08() {
    }

    public SNode createNode() {
      SNode result = null;
      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();
      SNode quotedNode_1 = null;
      {
        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StringLiteral", null, GlobalScope.getInstance(), false);
        SNode quotedNode1_2 = quotedNode_1;
        quotedNode1_2.setProperty("value", "NOT SUPPORTED YET");
        result = quotedNode1_2;
      }
      return result;
    }
  }
}
