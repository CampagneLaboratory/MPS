package jetbrains.mps.ide.java.util;

/*Generated by MPS */

import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.LanguageID;
import java.util.Set;
import jetbrains.mps.smodel.SModelReference;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.List;
import org.jetbrains.mps.openapi.model.SReference;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.smodel.IOperationContext;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.kernel.model.MissingDependenciesFixer;
import jetbrains.mps.project.OptimizeImportsHelper;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.project.IModule;
import jetbrains.mps.extapi.model.EditableSModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.smodel.constraints.ModelConstraints;
import jetbrains.mps.scope.ErrorScope;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.util.Computable;
import jetbrains.mps.internal.collections.runtime.IListSequence;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import jetbrains.mps.logging.Logger;

public class StubResolver {
  private static final String JAVA_STUB = SModelStereotype.getStubStereotypeForId(LanguageID.JAVA);
  private Set<SModelReference> myUsedModels;

  public StubResolver() {
    // resolve to any nonstub model 
    myUsedModels = null;
  }

  public StubResolver(Iterable<SModel> models) {
    // resolve only to models from sequence 
    myUsedModels = SetSequence.fromSetWithValues(new HashSet<SModelReference>(), Sequence.fromIterable(models).select(new ISelector<SModel, SModelReference>() {
      public SModelReference select(SModel it) {
        return it.getReference();
      }
    }));
  }

  private List<SReference> getReferencesToResolve(SModel sourceModel, Map<SModelReference, SModelReference> models) {
    // fills models map with stub -> model correspondance 
    List<SReference> result = ListSequence.fromList(new ArrayList<SReference>());
    for (SNode node : ListSequence.fromList(SModelOperations.getNodes(sourceModel, null))) {
      for (SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(node))) {
        SModelReference targetModelRef = ref.getTargetSModelReference();
        if (targetModelRef == null || !(JAVA_STUB.equals(targetModelRef.getStereotype()))) {
          continue;
        }
        // trying to find correspondent nonstub model 
        SModelFqName modelName = new SModelFqName(targetModelRef.getLongName(), null);
        SModelReference modelRef = check_ar1im2_a0e0a0c0e(SModelRepository.getInstance().getModelDescriptor(modelName));
        if (modelRef == null) {
          continue;
        }
        if (myUsedModels == null || SetSequence.fromSet(myUsedModels).contains(modelRef)) {
          MapSequence.fromMap(models).put(targetModelRef, modelRef);
          ListSequence.fromList(result).addElement(ref);
        }
      }
    }
    return result;
  }

  public void resolveInModel(final SModel model, IOperationContext context) {
    Map<SModelReference, SModelReference> models = MapSequence.fromMap(new HashMap<SModelReference, SModelReference>());
    List<SReference> toResolve = getReferencesToResolve(model, models);
    if (ListSequence.fromList(toResolve).isEmpty()) {
      return;
    }

    Iterable<SModelReference> modelsToAdd = Sequence.fromIterable(MapSequence.fromMap(models).values()).where(new IWhereFilter<SModelReference>() {
      public boolean accept(SModelReference it) {
        return !(jetbrains.mps.smodel.SModelOperations.getImportedModelUIDs(model).contains(it));
      }
    });
    Sequence.fromIterable(modelsToAdd).visitAll(new IVisitor<SModelReference>() {
      public void visit(SModelReference it) {
        ((jetbrains.mps.smodel.SModel) model).addModelImport(it, false);
      }
    });
    if (Sequence.fromIterable(modelsToAdd).isNotEmpty()) {
      new MissingDependenciesFixer(model.getModelDescriptor()).fix(false);
    }

    int cnt = StubResolver.resolveReferences(toResolve, models, context);

    new OptimizeImportsHelper(context).optimizeModelImports(model.getModelDescriptor());
    LOG.info(cnt + " stub references were re-resolved in model " + SModelOperations.getModelName(model) + ". (" + ListSequence.fromList(toResolve).count() + ")");
  }

  public void resolveInModels(List<SModel> models, IOperationContext context) {
    for (SModel model : ListSequence.fromList(models)) {
      resolveInModel(model.getSModel(), context);
    }
  }

  public void resolveInProject(MPSProject project, IOperationContext context) {
    for (IModule module : ListSequence.fromList(project.getModulesWithGenerators())) {
      if (module.isPackaged()) {
        continue;
      }
      for (SModel model : ListSequence.fromList(module.getOwnModelDescriptors())) {
        if (SModelStereotype.isUserModel(model) && model instanceof EditableSModel) {
          resolveInModel(model.getSModel(), context);
        }
      }
    }
  }

  public static int resolveReferences(List<SReference> toResolve, Map<SModelReference, SModelReference> models, IOperationContext context) {
    int cnt = 0;
    boolean found;
    do {
      found = false;
      for (SReference ref : ListSequence.fromList(toResolve).toGenericArray(SReference.class)) {
        SNode node = ref.getSourceNode();
        final SModelReference modelRef = MapSequence.fromMap(models).get(ref.getTargetSModelReference());
        final String resolveInfo = SLinkOperations.getResolveInfo(ref);
        if (modelRef == null || resolveInfo == null) {
          continue;
        }
        final Scope refScope = ModelConstraints.getScope(ref);
        if (refScope instanceof ErrorScope) {
          continue;
        }
        List<SNode> resolved = TypeContextManager.getInstance().runResolveAction(new Computable<IListSequence<SNode>>() {
          public IListSequence<SNode> compute() {
            return Sequence.fromIterable(refScope.getAvailableElements(null)).where(new IWhereFilter<SNode>() {
              public boolean accept(SNode n) {
                return modelRef.equals(SNodeOperations.getModel(n).getReference()) && resolveInfo.equals(jetbrains.mps.util.SNodeOperations.getResolveInfo(n));
              }
            }).toListSequence();
          }
        });
        if (ListSequence.fromList(resolved).count() > 1) {
          LOG.error("more than 1 possible resolution for " + SLinkOperations.getResolveInfo(ref) + " in model " + modelRef.getLongName());
        }
        if (ListSequence.fromList(resolved).count() > 0) {
          SNodeAccessUtil.setReferenceTarget(node, SLinkOperations.getRole(ref), ListSequence.fromList(resolved).first());
          ListSequence.fromList(toResolve).removeElement(ref);
          ++cnt;
          found = true;
        }
      }
    } while (found);
    return cnt;
  }

  private static Logger LOG = Logger.getLogger(StubResolver.class);

  private static SModelReference check_ar1im2_a0e0a0c0e(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getReference();
    }
    return null;
  }
}
