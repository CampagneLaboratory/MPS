package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import jetbrains.mps.ide.java.parser.FeatureKind;
import java.util.Map;
import java.util.HashMap;
import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
import org.eclipse.jdt.internal.core.util.CodeSnippetParsingUtil;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Statement;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.eclipse.jdt.internal.compiler.ast.ImportReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.smodel.ModelAccess;
import org.eclipse.jdt.internal.core.util.RecordedParsingInformation;

public class JavaParser {
  public JavaParser() {
  }

  @NotNull
  public JavaParser.JavaParseResult parseCompilationUnit(String code) {
    return parse(code, null, FeatureKind.CLASS, true);
  }

  public JavaParser.JavaParseResult parse(String code, String pkg, FeatureKind what, boolean recovery) {
    // in eclipse there is full recovery and statement recovery 
    // TODO use full recovery 

    char[] source = code.toCharArray();

    Map<String, String> settings = new HashMap<String, String>();
    settings.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);

    if (FeatureKind.CLASS.equals(what) || FeatureKind.CLASS_STUB.equals(what)) {
      boolean stubsMode = FeatureKind.CLASS_STUB.equals(what);

      CodeSnippetParsingUtil util = new CodeSnippetParsingUtil(stubsMode);
      CompilationUnitDeclaration compRes = util.parseCompilationUnit(source, settings, true);

      if (compRes == null) {
        return JavaParser.JavaParseResult.UNKNOWN_ERROR;
      }

      ASTNode[] astNodes = compRes.types;
      List<SNode> roots = new ArrayList<SNode>();

      if (astNodes != null && astNodes.length > 0) {
        TypeNameResolver typeResolver = new TypeNameResolver(pkg);
        typeResolver.addImports(extractImports(compRes));
        ASTConverter converter = new ASTConverter(compRes, typeResolver, stubsMode);

        for (ASTNode astNode : astNodes) {
          ListSequence.fromList(roots).addElement(converter.convertRoot(astNode));
        }
      }

      // there may be no types and still no compilation errors 
      // e.g. package-info.java only includes 'package pkg'; 

      String pkgName = null;
      if (compRes.currentPackage != null) {
        StringBuffer sb = new StringBuffer();
        compRes.currentPackage.print(0, sb, false);
        pkgName = sb.toString();
      }

      return new JavaParser.JavaParseResult(roots, pkgName, problemDescription(util.recordedParsingInformation));

    } else if (FeatureKind.STATEMENTS.equals(what)) {

      CodeSnippetParsingUtil util = new CodeSnippetParsingUtil();
      AbstractMethodDeclaration absMethod = util.parseStatements(source, settings, true, recovery);

      if (absMethod == null) {
        return JavaParser.JavaParseResult.UNKNOWN_ERROR;
      }

      Statement[] stmts = absMethod.statements;
      List<SNode> nodes = new ArrayList<SNode>();

      if (stmts != null && stmts.length > 0) {
        TypeNameResolver typeResolver = new TypeNameResolver(pkg);
        // TODO construct typeResolver from parent node context 
        ASTConverter converter = new ASTConverter(null, typeResolver, false);
        ListSequence.fromList(nodes).addSequence(ListSequence.fromList(converter.convertStatements(stmts)));
      }

      return new JavaParser.JavaParseResult(nodes, problemDescription(util.recordedParsingInformation));

    } else if (FeatureKind.CLASS_CONTENT.equals(what)) {

      CodeSnippetParsingUtil util = new CodeSnippetParsingUtil(false);
      ASTNode[] astNodes = util.parseClassBodyDeclarations(source, 0, source.length, settings, false, true);

      TypeNameResolver typeResolver = new TypeNameResolver(pkg);
      ASTConverter converter = new ASTConverter(null, typeResolver, false);

      // type decl (inner), field, method 
      List<SNode> nodes = converter.convertClassContents(astNodes, SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassConcept", null));

      return new JavaParser.JavaParseResult(nodes, problemDescription(util.recordedParsingInformation));

    } else {
      throw new IllegalArgumentException("Parsing other than class and statements is not supported yet ");
    }

  }

  public List<TypeNameResolver.Import> extractImports(CompilationUnitDeclaration compResult) {
    List<TypeNameResolver.Import> imps = ListSequence.fromList(new ArrayList<TypeNameResolver.Import>());
    if (compResult.imports != null) {
      for (ImportReference imprt : compResult.imports) {
        imps.add(makeImport(imprt));
      }
    }
    return imps;
  }

  private TypeNameResolver.Import makeImport(ImportReference impRef) {
    boolean onDemand = (impRef.bits & ASTNode.OnDemand) != 0;
    boolean isStatic = impRef.isStatic();

    char[][] toks = impRef.getImportName();
    StringBuffer sb = new StringBuffer();
    int until = (onDemand ?
      toks.length :
      toks.length - 1
    );
    for (int i = 0; i < until; i++) {
      char[] tok = toks[i];
      if (i > 0) {
        sb.append('.');
      }
      sb.append(tok);
    }

    String pkg = sb.toString();
    String clas = (onDemand ?
      null :
      new String(toks[toks.length - 1])
    );

    return new TypeNameResolver.Import(pkg, clas, isStatic);
  }

  public void tryResolveRoots(List<SNode> roots) {
    for (SNode node : ListSequence.fromList(roots)) {
      List<SNode> unknowns = SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.IYetUnresolved", false, new String[]{});
      for (SNode unk : ListSequence.fromList(unknowns)) {
        final SNode unkNode = unk;
        final SNode subst = ((SNode) BehaviorManager.getInstance().invoke(Object.class, unk, "virtual_evaluateSubst_8136348407761606764", new Class[]{SNode.class}));
        if ((subst != null)) {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              SNodeOperations.replaceWithAnother(unkNode, subst);
            }
          });
        }
      }
    }
  }

  private String problemDescription(@NotNull RecordedParsingInformation info) {
    if (info.problems != null && info.problems.length > 0) {
      return "There were some problems";
    } else {
      return null;
    }
  }

  public static class JavaParseResult {
    public static final JavaParser.JavaParseResult UNKNOWN_ERROR = new JavaParser.JavaParseResult(new ArrayList<SNode>(), "Parse failed and return no errors");

    @NotNull
    private List<SNode> nodes;
    private String pakage;
    private String errorMsg;

    public JavaParseResult(List<SNode> ns, String error) {
      nodes = ns;
      errorMsg = error;
    }

    public JavaParseResult(List<SNode> ns, String pkg, String error) {
      this(ns, error);
      pakage = pkg;
    }

    @NotNull
    public List<SNode> getNodes() {
      return nodes;
    }

    public String getPackage() {
      return pakage;
    }

    public String getErrorMsg() {
      return errorMsg;
    }
  }
}
