package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.java.parser.FeatureKind;
import java.util.Map;
import java.util.HashMap;
import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
import java.util.ArrayList;
import org.eclipse.jdt.internal.core.util.CodeSnippetParsingUtil;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Statement;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.eclipse.jdt.internal.compiler.ast.ImportReference;

public class JavaParser {
  public JavaParser() {
  }

  public List<SNode> parse(String code, String pkg, SNode parent, FeatureKind depth, boolean recovery) {
    // in eclipse there is full recovery and statement recovery 
    // TODO use full recovery 

    char[] source = code.toCharArray();

    Map<String, String> settings = new HashMap<String, String>();
    settings.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);

    List<SNode> res = new ArrayList<SNode>();

    if (FeatureKind.CLASS.equals(depth) || FeatureKind.CLASS_STUB.equals(depth)) {
      boolean ignoreMethodBodies = FeatureKind.CLASS_STUB.equals(depth);

      CodeSnippetParsingUtil util = new CodeSnippetParsingUtil(ignoreMethodBodies);
      CompilationUnitDeclaration compRes = util.parseCompilationUnit(source, settings, true);

      if (compRes == null || compRes.types == null && compRes.compilationResult.problems != null) {
        throw new JavaParseException("Could not parse anything");
      }

      ASTNode[] roots = compRes.types;

      TypeNameResolver typeResolver = new TypeNameResolver(pkg);
      typeResolver.addImports(extractImports(compRes));
      ASTConverter converter = new ASTConverter(pkg, compRes, typeResolver);


      if (compRes.types != null) {
        // there may be no types and still no compilation errors 
        // e.g. package-info.java only includes 'package pkg'; 
        for (ASTNode root : roots) {
          ListSequence.fromList(res).addElement(converter.convertRoot(root));
          // <node> 
        }
      }

    } else if (FeatureKind.STATEMENTS.equals(depth)) {

      CodeSnippetParsingUtil util = new CodeSnippetParsingUtil();
      AbstractMethodDeclaration absMethod = util.parseStatements(source, settings, true, recovery);
      if (absMethod == null || absMethod.statements == null) {
        throw new JavaParseException("Could not parse anything");
      }
      Statement[] stmts = absMethod.statements;

      TypeNameResolver typeResolver = new TypeNameResolver(pkg);
      // TODO construct typeResolver from parent node context 
      ASTConverter converter = new ASTConverter(pkg, parent, null, typeResolver);
      // statement list is needed to make a proper position, so that scopes work 
      SNode stmtList = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.StatementList", null);
      List<SNode> nodes = converter.convertStatements(new ASTConverter.Position(stmtList, "statement"), stmts);
      for (SNode n : ListSequence.fromList(SNodeOperations.getChildren(stmtList))) {
        stmtList.removeChild(n);
      }
      ListSequence.fromList(res).addSequence(ListSequence.fromList(nodes));

    } else {
      throw new IllegalArgumentException("Parsing depth other than top-level is not supported yet ");
    }



    return res;
  }

  public List<TypeNameResolver.Import> extractImports(CompilationUnitDeclaration compResult) {
    List<TypeNameResolver.Import> imps = ListSequence.fromList(new ArrayList<TypeNameResolver.Import>());
    if (compResult.imports != null) {
      for (ImportReference imprt : compResult.imports) {
        imps.add(makeImport(imprt));
      }
    }
    return imps;
  }

  private TypeNameResolver.Import makeImport(ImportReference impRef) {
    boolean onDemand = (impRef.bits & ASTNode.OnDemand) != 0;
    boolean isStatic = impRef.isStatic();

    char[][] toks = impRef.getImportName();
    StringBuffer sb = new StringBuffer();
    int until = (onDemand ?
      toks.length :
      toks.length - 1
    );
    for (int i = 0; i < until; i++) {
      char[] tok = toks[i];
      if (i > 0) {
        sb.append('.');
      }
      sb.append(tok);
    }

    String pkg = sb.toString();
    String clas = (onDemand ?
      null :
      new String(toks[toks.length - 1])
    );

    return new TypeNameResolver.Import(pkg, clas, isStatic);
  }
}
