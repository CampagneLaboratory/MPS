package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.ide.java.parser.FeatureKind;
import org.eclipse.jdt.internal.core.util.CodeSnippetParsingUtil;
import java.util.Map;
import java.util.HashMap;
import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import java.util.ArrayList;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Statement;
import org.eclipse.jdt.internal.core.util.RecordedParsingInformation;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Comparator;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.ide.java.parser.CommentHelper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.eclipse.jdt.internal.compiler.ast.ImportReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.ModelAccess;

public class JavaParser {
  private static Logger LOG = Logger.getLogger(JavaParser.class);

  public JavaParser() {
  }

  @NotNull
  public JavaParser.JavaParseResult parseCompilationUnit(String code) throws JavaParseException {
    // temp thing: peek at the package name 
    String pkg = peekPackage(code);
    return parse(code, pkg, FeatureKind.CLASS, true);
  }

  @NotNull
  public JavaParser.JavaParseResult parse(String code, String pkg, FeatureKind what, boolean recovery) throws JavaParseException {
    // in eclipse there is full recovery and statement recovery 
    // TODO use full recovery 

    boolean stubsMode = FeatureKind.CLASS_STUB.equals(what);
    CodeSnippetParsingUtil util = new CodeSnippetParsingUtil(stubsMode);
    Map<String, String> settings = new HashMap<String, String>();
    settings.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);
    settings.put(CompilerOptions.OPTION_DocCommentSupport, "enabled");
    TypeNameResolver typeResolver = new TypeNameResolver(pkg);
    ASTConverter converter = new ASTConverter(null, typeResolver, stubsMode);

    List<SNode> resultNodes = new ArrayList<SNode>();
    String resultPackageName = null;

    char[] source = code.toCharArray();


    switch (what) {
      case CLASS:
        // fall-through 
      case CLASS_STUB:

        CompilationUnitDeclaration compRes = util.parseCompilationUnit(source, settings, true);
        if (compRes == null) {
          return JavaParser.JavaParseResult.UNKNOWN_ERROR;
        }

        ASTNode[] astTypes = compRes.types;

        if (astTypes != null && astTypes.length > 0) {
          typeResolver.addImports(extractImports(compRes));

          List<SNode> roots = new ArrayList<SNode>();
          for (ASTNode astNode : astTypes) {
            try {
              ListSequence.fromList(roots).addElement(converter.convertRoot(astNode));
            } catch (ReflectException e) {
              // reflect exception will go away completely 
              throw new RuntimeException(e);
            }
          }
          resultNodes = roots;
        }

        // there may be no types and still no compilation errors 
        // e.g. package-info.java only includes 'package pkg'; 

        // getting package out of the parsed source code 
        if (compRes.currentPackage != null) {
          StringBuffer sb = new StringBuffer();
          compRes.currentPackage.print(0, sb, false);
          resultPackageName = sb.toString();
        }

        break;

      case CLASS_CONTENT:

        ASTNode[] astNodes = util.parseClassBodyDeclarations(source, 0, source.length, settings, true, recovery);
        // type decl (inner), field, method 
        if (astNodes != null && astNodes.length > 0) {
          try {
            resultNodes = converter.convertClassContents(astNodes, SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassConcept", null));
          } catch (ReflectException e) {
            throw new RuntimeException(e);
          }
        }

        break;

      case STATEMENTS:

        AbstractMethodDeclaration absMethod = util.parseStatements(source, settings, true, recovery);
        if (absMethod == null) {
          return JavaParser.JavaParseResult.UNKNOWN_ERROR;
        }

        Statement[] stmts = absMethod.statements;
        List<SNode> nodes = new ArrayList<SNode>();

        if (stmts != null && stmts.length > 0) {
          // TODO construct typeResolver from parent node context 
          try {
            resultNodes = converter.convertStatements(stmts);
          } catch (ReflectException e) {
            throw new RuntimeException(e);
          }
        }

        break;

      default:
        throw new IllegalArgumentException("Parsing other than class and statements is not supported yet ");
    }

    // now insert comments 
    attachComments(source, converter, util.recordedParsingInformation, converter.getCodeBlocks());

    return new JavaParser.JavaParseResult(resultNodes, resultPackageName, problemDescription(util.recordedParsingInformation));
  }

  public void attachComments(char[] source, ASTConverter converter, RecordedParsingInformation parseInfo, Iterable<ASTConverter.CodeBlock> blocks) {

    char[] content = source;
    int[][] comments = parseInfo.commentPositions;
    int[] lineends = parseInfo.lineEnds;

    final Map<SNode, Integer> positions = converter.getPositions();
    Map<Integer, SNode> javadocs = converter.getJavadocs();

    Iterable<ASTConverter.CodeBlock> blcks = Sequence.fromIterable(blocks).sort(new Comparator<ASTConverter.CodeBlock>() {
      public int compare(ASTConverter.CodeBlock a, ASTConverter.CodeBlock b) {
        return a.getEndPos() - b.getEndPos();
      }
    }, true);
    for (int[] comment : comments) {
      if (comment[1] > 0) {
        // javadoc 
        SNode doc = MapSequence.fromMap(javadocs).get(comment[0]);

        List<String> lines = CommentHelper.processJavadoc(CommentHelper.splitString(content, lineends, comment[0], comment[1] + 1));
        for (String text : ListSequence.fromList(lines)) {
          SNode commentLine = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.javadoc.structure.CommentLine", null);
          SPropertyOperations.set(SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(commentLine, "part", true)).getElement(0), "jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart"), "text", text);
          ListSequence.fromList(SLinkOperations.getTargets(doc, "body", true)).addElement(commentLine);
        }

        continue;
      }

      final int linestart = Math.abs(comment[0]);
      // find appropriate block 
      SNode block = null;
      for (ASTConverter.CodeBlock blk : Sequence.fromIterable(blcks)) {
        if (blk.getStartPos() <= linestart && linestart <= blk.getEndPos()) {
          block = blk.getStatementList();
          break;
        }
      }
      if ((block != null)) {
        int pos = ListSequence.fromList(SLinkOperations.getTargets(block, "statement", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return !(MapSequence.fromMap(positions).containsKey(it)) || Math.abs(MapSequence.fromMap(positions).get(it)) <= linestart;
          }
        }).count();
        for (String line : ListSequence.fromList(CommentHelper.processComment(CommentHelper.splitString(content, lineends, linestart, Math.abs(comment[1]))))) {
          SNode commentText = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TextCommentPart", null);
          SPropertyOperations.set(commentText, "text", line);
          SNode commentLine = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SingleLineComment", null);
          ListSequence.fromList(SLinkOperations.getTargets(commentLine, "commentPart", true)).addElement(commentText);
          ListSequence.fromList(SLinkOperations.getTargets(block, "statement", true)).insertElement(pos++, commentLine);
        }
      } else {
        // FIXME 
        LOG.warning("cannot find a place to import comment from " + "<Main type name>" + ":\n" + new String(content, linestart, Math.abs(comment[1]) - linestart));
      }
    }
  }

  public List<TypeNameResolver.Import> extractImports(CompilationUnitDeclaration compResult) {
    List<TypeNameResolver.Import> imps = ListSequence.fromList(new ArrayList<TypeNameResolver.Import>());
    if (compResult.imports != null) {
      for (ImportReference imprt : compResult.imports) {
        imps.add(makeImport(imprt));
      }
    }
    return imps;
  }

  private TypeNameResolver.Import makeImport(ImportReference impRef) {
    boolean onDemand = (impRef.bits & ASTNode.OnDemand) != 0;
    boolean isStatic = impRef.isStatic();

    char[][] toks = impRef.getImportName();
    StringBuffer sb = new StringBuffer();
    int until = (onDemand ?
      toks.length :
      toks.length - 1
    );
    for (int i = 0; i < until; i++) {
      char[] tok = toks[i];
      if (i > 0) {
        sb.append('.');
      }
      sb.append(tok);
    }

    String pkg = sb.toString();
    String clas = (onDemand ?
      null :
      new String(toks[toks.length - 1])
    );

    return new TypeNameResolver.Import(pkg, clas, isStatic);
  }

  public void tryResolveRoots(List<SNode> roots) {
    for (SNode node : ListSequence.fromList(roots)) {
      List<SNode> unknowns = SNodeOperations.getDescendants(node, "jetbrains.mps.baseLanguage.structure.IYetUnresolved", false, new String[]{});
      for (SNode unk : ListSequence.fromList(unknowns)) {

        final SNode unkNode = unk;
        final _FunctionTypes._return_P0_E0<? extends SNode> subst = BehaviorReflection.invokeVirtual((Class<_FunctionTypes._return_P0_E0<? extends SNode>>) ((Class) Object.class), unk, "virtual_evaluateSubst_8136348407761606764", new Object[]{});
        if (subst == null) {
          continue;
        }

        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            SNode theRightNode = subst.invoke();
            SNodeOperations.replaceWithAnother(unkNode, theRightNode);
          }
        });

      }
    }
  }

  private String problemDescription(RecordedParsingInformation info) {
    if (info == null) {
      return null;
    }
    if (info.problems != null && info.problems.length > 0) {
      return "There were some problems";
    } else {
      return null;
    }
  }

  private String peekPackage(String source) {
    // WILL GO AWAY COMPLETELY 
    final String str = "package ";
    StringBuilder packageName = new StringBuilder();
    for (int i = source.indexOf(str) + str.length(); i < source.length(); i++) {
      char c = source.charAt(i);
      if (Character.isWhitespace(c) || c == ';') {
        break;
      }
      packageName.append(c);
    }
    return packageName.toString();
  }

  public static class JavaParseResult {
    public static final JavaParser.JavaParseResult UNKNOWN_ERROR = new JavaParser.JavaParseResult(new ArrayList<SNode>(), "Parse failed and return no errors");
    @NotNull
    private List<SNode> nodes;
    private String pakage;
    private String errorMsg;

    public JavaParseResult(List<SNode> ns, String error) {
      nodes = ns;
      errorMsg = error;
    }

    public JavaParseResult(List<SNode> ns, String pkg, String error) {
      this(ns, error);
      pakage = pkg;
    }

    @NotNull
    public List<SNode> getNodes() {
      return nodes;
    }

    public String getPackage() {
      return pakage;
    }

    public String getErrorMsg() {
      return errorMsg;
    }
  }
}
