package jetbrains.mps.ide.java.parser;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.ide.java.newparser.FeatureKind;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public abstract class SourceWrapper {
  protected String mySource;
  protected String myWrappedSource;
  protected String myClassName;
  protected SModel myModel;

  public SourceWrapper(String source, SModel model) {
    mySource = source;
    myModel = model;
  }

  public abstract List<SNode> getOurNodesFromClassifier(SNode classifier);

  protected String wrapStatements(String source, String shortClassName) {
    StringBuilder sb = new StringBuilder();
    classHeader(shortClassName, sb);
    methodHeader(sb);
    sb.append(source);
    methodFooter(sb);
    classFooter(sb);
    String result = sb.toString();
    return result;
  }

  protected String wrapMethods(String source, String shortClassName) {
    StringBuilder sb = new StringBuilder();
    classHeader(shortClassName, sb);
    sb.append(source);
    classFooter(sb);
    String result = sb.toString();
    return result;
  }

  protected void classFooter(StringBuilder sb) {
    sb.append("\n}");
  }

  protected void methodFooter(StringBuilder sb) {
    sb.append("}\n");
  }

  protected void methodHeader(StringBuilder sb) {
    sb.append("private void foo() {\n");
  }

  protected void classHeader(String shortClassName, StringBuilder sb) {
    sb.append("package ");
    sb.append(myModel.getLongName());
    sb.append(";\n\n");
    imports(sb);
    sb.append("public class " + shortClassName + " {\n\n");
  }

  protected void imports(StringBuilder sb) {
    sb.append("\n");
    for (SModelDescriptor modelDescriptor : SModelOperations.allImportedModels(myModel, GlobalScope.getInstance())) {
      sb.append("import " + modelDescriptor.getLongName() + ".*;\n");
    }
    sb.append("\n");
  }

  protected String synthesizedClassName() {
    return "Temp1233429";
  }

  public String getWrappedSource() {
    return myWrappedSource;
  }

  public String getShortClassName() {
    return myClassName;
  }

  public String getSource() {
    return mySource;
  }

  public static SourceWrapper wrapSource(String source, SModel model, FeatureKind featureKind) {
    switch (featureKind) {
      case CLASS:
        return new SourceWrapper.ClassWrapper(source, model);
      case CLASS_CONTENT:
        return new SourceWrapper.MethodsWrapper(source, model);
      case STATEMENTS:
        return new SourceWrapper.StatementsWrapper(source, model);
      default:
        throw new IllegalArgumentException();
    }
  }

  public static class StatementsWrapper extends SourceWrapper {
    public StatementsWrapper(String source, SModel model) {
      super(source, model);
      myClassName = synthesizedClassName();
      myWrappedSource = wrapStatements(source, myClassName);
    }

    @Override
    public List<SNode> getOurNodesFromClassifier(SNode classifier) {
      return SLinkOperations.getTargets(SLinkOperations.getTarget(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classifier, "jetbrains.mps.baseLanguage.structure.Classifier", "call_methods_5292274854859311639", new Object[]{})).first(), "body", true), "statement", true);
    }
  }

  public static class MethodsWrapper extends SourceWrapper {
    public MethodsWrapper(String source, SModel model) {
      super(source, model);
      myClassName = synthesizedClassName();
      myWrappedSource = wrapMethods(source, myClassName);
    }

    @Override
    public List<SNode> getOurNodesFromClassifier(SNode classifier) {
      List<SNode> result = new ArrayList<SNode>();
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classifier, "jetbrains.mps.baseLanguage.structure.Classifier", "call_methods_5292274854859311639", new Object[]{}))).addSequence(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classifier, "jetbrains.mps.baseLanguage.structure.Classifier", "call_staticFields_5292274854859223538", new Object[]{}))).addSequence(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classifier, "jetbrains.mps.baseLanguage.structure.Classifier", "call_nestedClassifiers_5292274854859193142", new Object[]{})));
      SNode classs = SNodeOperations.as(classifier, "jetbrains.mps.baseLanguage.structure.ClassConcept");
      if ((classs != null)) {
        ListSequence.fromList(result).addSequence(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classs, "jetbrains.mps.baseLanguage.structure.ClassConcept", "call_fields_5292274854859383272", new Object[]{}))).addSequence(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classs, "jetbrains.mps.baseLanguage.structure.ClassConcept", "call_staticMethods_5292274854859435867", new Object[]{})));
      }
      return result;
    }
  }

  public static class ClassWrapper extends SourceWrapper {
    private static final String PACKAGE_ = "package ";

    public ClassWrapper(String source, SModel model) {
      super(source, model);
      String sClass = "class";
      int index = source.indexOf(sClass);
      if (index == -1) {
        sClass = "interface";
        index = source.indexOf(sClass);
      }
      if (index == -1) {
        sClass = "enum";
        index = source.indexOf(sClass);
      }
      if (index == -1) {
        throw new ConversionFailedException("not a class or interface");
      } else {
        int i = index + sClass.length();
        while (Character.isWhitespace(source.charAt(i))) {
          i++;
        }
        StringBuilder sb = new StringBuilder();
        while (!(Character.isWhitespace(source.charAt(i)) || source.charAt(i) == '{')) {
          char c = source.charAt(i);
          sb.append(c);
          i++;
        }
        myClassName = sb.toString();
        // replace package x.y.z; with import x.y.z.*; if necessary 
        int iPackage = source.indexOf(PACKAGE_);
        if (0 <= iPackage && iPackage < i && isNotEmpty_kkyay4_a0a7a0f0b02(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.getModelName(model))) {
          int iPackageEnd = iPackage + PACKAGE_.length();
          while (!(Character.isWhitespace(source.charAt(iPackageEnd)) || source.charAt(iPackageEnd) == ';')) {
            iPackageEnd++;
          }
          source = source.substring(0, iPackage) + "import " + source.substring(iPackage + PACKAGE_.length(), iPackageEnd) + ".*" + source.substring(iPackageEnd);
        }
        // add package if necessary 
        if (isEmpty_kkyay4_a0j0a5a1u(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.getModelName(model))) {
          myWrappedSource = source;
        } else {
          myWrappedSource = PACKAGE_ + jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.getModelName(model) + ";\n" + source;
        }
      }
    }

    @Override
    public List<SNode> getOurNodesFromClassifier(SNode classifier) {
      List<SNode> result = new ArrayList<SNode>();
      ListSequence.fromList(result).addElement(classifier);
      return result;
    }

    public static boolean isNotEmpty_kkyay4_a0a7a0f0b02(String str) {
      return str != null && str.length() > 0;
    }

    public static boolean isEmpty_kkyay4_a0j0a5a1u(String str) {
      return str == null || str.length() == 0;
    }
  }
}
