package jetbrains.mps.ide.java.sourceStubs;

/*Generated by MPS */

import jetbrains.mps.smodel.BaseSpecialModelDescriptor;
import org.jetbrains.mps.openapi.persistence.MultiStreamDataSourceListener;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.mps.openapi.persistence.MultiStreamDataSource;
import java.util.Map;
import java.util.Set;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.ide.java.newparser.JavaParser;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.ide.java.parser.FeatureKind;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.io.IOException;
import jetbrains.mps.ide.java.newparser.JavaParseException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.persistence.DataSource;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.io.InputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class JavaSourceStubModelDescriptor extends BaseSpecialModelDescriptor implements MultiStreamDataSourceListener {

  private static Logger LOG = Logger.getLogger(JavaSourceStubModelDescriptor.class);

  private SModelReference myModelRef;
  private SModel myModel;
  private MultiStreamDataSource myDataSource;
  private String myJavaPackage;
  private Map<String, Set<SNode>> myRootsPerFile = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private Map<SNodeId, SNode> myRootsById = MapSequence.fromMap(new HashMap<SNodeId, SNode>());



  public JavaSourceStubModelDescriptor(SModelReference modelRef, MultiStreamDataSource dataSource, String javaPackage) {
    super(modelRef);
    myModelRef = modelRef;
    myDataSource = dataSource;
    myJavaPackage = javaPackage;
  }



  @Override
  protected SModel createModel() {

    JavaParser parser = new JavaParser();
    myModel = new SModel(myModelRef);

    for (String fileName : Sequence.fromIterable(myDataSource.getAvailableStreams())) {
      try {
        String code = readInputStream(myDataSource.openInputStream(fileName));

        JavaParser.JavaParseResult parseResult = parser.parse(code, myJavaPackage, FeatureKind.CLASS_STUB, true);
        if (ListSequence.fromList(parseResult.getNodes()).isNotEmpty()) {
          for (SNode node : ListSequence.fromList(parseResult.getNodes())) {
            SModelOperations.addRootNode(myModel, node);
            MapSequence.fromMap(myRootsById).put(node.getSNodeId(), node);
          }
          MapSequence.fromMap(myRootsPerFile).put(fileName, SetSequence.fromSetWithValues(new HashSet<SNode>(), parseResult.getNodes()));
        }

      } catch (IOException e) {
        LOG.error("Failed to read java file. " + e.getMessage(), e);
      } catch (JavaParseException e) {
        LOG.error("Failed to parse java file. " + e.getMessage());
      }
    }

    return myModel;
  }



  @Override
  public void attach() {
    myDataSource.addListener(this);
  }



  @Override
  public void dispose() {
    myDataSource.removeListener(this);
  }



  @Override
  @NotNull
  public MultiStreamDataSource getSource() {
    return myDataSource;
  }




  @Override
  public void changed(DataSource source, Iterable<String> changedItems) {
    ModelAccess.assertLegalWrite();

    LOG.info("got change event");

    // full rebuild 
    mySModel = null;
    // <node> 

    final SNode n = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassConcept", null);
    SPropertyOperations.set(n, "name", "Bla");
    ModelAccess.instance().runUndoTransparentCommand(new Runnable() {
      public void run() {
        SModelOperations.addRootNode(myModel, n);
      }
    }, null);

    try {
      for (String item : Sequence.fromIterable(changedItems)) {
        InputStream is = myDataSource.openInputStream(item);
        if (is == null) {
          // deleted 

          continue;
        }

        // changed or created 

      }

    } catch (IOException e) {
      LOG.error("Exception while handling change", e);
    }
  }



  @Override
  public void changed(DataSource source) {
    // ignore 
  }

  private String readInputStream(InputStream is) throws IOException {
    BufferedReader br = null;
    try {
      br = new BufferedReader(new InputStreamReader(is));
      StringBuilder sb = new StringBuilder();
      while (br.ready()) {
        sb.append(br.readLine());
      }
      return sb.toString();
    } finally {
      if (br != null) {
        br.close();
      }
    }
  }
}
