package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.reloading.CompositeClassPathItem;
import java.util.Map;
import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.io.File;
import jetbrains.mps.project.IModule;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.ide.java.parser.FeatureKind;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.reloading.CommonPaths;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.project.MPSExtentions;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.project.SModelRoot;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.util.NameUtil;

public class DirParser {
  private static final Logger LOG = Logger.getLogger(DirParser.class);

  private CompositeClassPathItem myClassPathItem;
  private Map<String, CompilationUnit> myCompilationUnits = new HashMap<String, CompilationUnit>();
  private List<SModel> myCreatedModels = ListSequence.fromList(new ArrayList<SModel>());
  private List<File> mySourceDirs;
  private IModule myModule;
  private SModel myBaseModelToAddSource;
  private String myPrefix = null;
  private Map<String, SModel> myPackageFQNamesToModels = new HashMap<String, SModel>();
  private Set<String> myModelsToCreate = new HashSet<String>();
  private JavaParser myJavaParser = new JavaParser();

  public DirParser(IModule mod, SModel baseModel, File sourceDir) {
    myModule = mod;
    myBaseModelToAddSource = baseModel;
    mySourceDirs = ListSequence.fromListAndArray(new ArrayList<File>(), sourceDir);
  }

  public List<SNode> parseDir(File dir) {
    List<SNode> result = new ArrayList<SNode>();
    JavaParser parser = new JavaParser();

    if (dir == null || !(dir.exists()) || !(dir.isDirectory())) {
      throw new IllegalArgumentException("Bad directory");
    }

    for (File file : dir.listFiles()) {
      if (!(file.isDirectory()) && file.getName().endsWith(".java")) {
        String code = FileUtil.read(file);
        List<SNode> oneFileRoots = parser.parse(code, "", FeatureKind.CLASS, true).getNodes();
        ListSequence.fromList(result).addSequence(ListSequence.fromList(oneFileRoots));
      }
    }
    parser.tryResolveRoots(result);
    return result;
  }

  public void parseDirs() {
    // <node> 
    // <node> 
    for (File sourceDir : ListSequence.fromList(mySourceDirs)) {
      myPrefix = null;
      addSourceFromDirectory(sourceDir, "");
    }

    for (SModel m : ListSequence.fromList(myCreatedModels)) {
      System.out.println("DEBUG:  model " + SModelOperations.getModelName(m));
      myJavaParser.tryResolveRoots(SModelOperations.getRoots(m, null));
    }

  }

  private void initClassPathItem(final IModule module) {
    ModelAccess.instance().runReadAction(new Runnable() {
      @Override
      public void run() {
        CompositeClassPathItem compositeClassPathItem = new CompositeClassPathItem();
        compositeClassPathItem.add(module.getModuleWithDependenciesClassPathItem());
        compositeClassPathItem.add(CommonPaths.getJDKClassPath());
        compositeClassPathItem.add(CommonPaths.getMPSClassPath());
        myClassPathItem = compositeClassPathItem;
      }
    });
  }

  public void addSourceFromDirectory(File dir, final String packageNameWithoutPrefix) {
    assert dir.isDirectory();

    // packages which match the directory 
    // in the proper case: there should be only one 
    String pkg = null;
    boolean wasDefaultPkg = false;
    final List<SNode> roots = new ArrayList<SNode>();

    for (File file : dir.listFiles()) {
      if (file.isDirectory()) {
        addSourceFromDirectory(file, packageNameWithoutPrefix + (((packageNameWithoutPrefix == null || packageNameWithoutPrefix.length() == 0) ?
          "" :
          "."
        )) + file.getName());
      } else if (file.getName().endsWith(".java")) {

        JavaParser.JavaParseResult parseRes = parseFile(file);
        String p = parseRes.getPackage();

        if (p == null) {
          // default package (i.e. none), bad 
          if (!(wasDefaultPkg)) {
            LOG.error("default package is not supported in java source directory input (first such file in dir: " + file.getName() + ")");
            wasDefaultPkg = true;
          }
          continue;
        }
        if (pkg == null) {
          if (DirParser.checkPackageMatchesSourceDirectory(p, dir)) {
            pkg = p;
          } else {
            LOG.error("package " + p + " doesn't match directory " + dir.getAbsolutePath() + " (in file " + file.getName() + ")");
            continue;
          }

        } else if (!(pkg.equals(p))) {
          LOG.error("different packages in directory " + dir.getAbsolutePath() + ", namely " + pkg + " and " + p);
          continue;
        }
        ListSequence.fromList(roots).addSequence(ListSequence.fromList(parseRes.getNodes()));
      }
    }

    // do model stuff 
    final String finalPkg = pkg;
    if (pkg != null && ListSequence.fromList(roots).count() > 0) {
      ModelAccess.instance().runWriteActionInCommand(new Runnable() {
        public void run() {
          SModel mdl = registerModelForPackage(finalPkg);
          // <node> 

          if (mdl != null) {
            for (SNode r : ListSequence.fromList(roots)) {
              SModelOperations.addRootNode(mdl, r);
            }
            ListSequence.fromList(myCreatedModels).addElement(mdl);
          }
        }
      });
    } else {
      LOG.info("skipping directory " + dir.getAbsolutePath());
    }
  }

  private JavaParser.JavaParseResult parseFile(File file) {
    String contents = FileUtil.read(file);
    return myJavaParser.parseCompilationUnit(contents);
  }

  public void addSourceFromFile(File file, String packageNameWithoutPrefix) {
    try {
      final String str = "package ";
      String fileContents = FileUtil.read(file);
      StringBuilder classFQName = new StringBuilder();
      for (int i = fileContents.indexOf(str) + str.length(); i < fileContents.length(); i++) {
        char c = fileContents.charAt(i);
        if (Character.isWhitespace(c) || c == ';') {
          break;
        }
        classFQName.append(c);
      }
      String packageNameFromFile = classFQName.toString();
      if (myPrefix != null) {
        String pattern;
        if ("".equals(packageNameWithoutPrefix) || "".equals(myPrefix)) {
          pattern = myPrefix + packageNameWithoutPrefix;
        } else {
          pattern = myPrefix + "." + packageNameWithoutPrefix;
        }
        if (!(pattern.equals(packageNameFromFile))) {
          LOG.error("package " + packageNameFromFile + " in a source file " + file.getName() + " does not correspond to file path: " + pattern);
          return;
        }
      } else {
        if (packageNameFromFile.endsWith(packageNameWithoutPrefix)) {
          int index = packageNameFromFile.length() - packageNameWithoutPrefix.length();
          myPrefix = packageNameFromFile.substring(0, index);
          if (myPrefix.endsWith(".")) {
            myPrefix = myPrefix.substring(0, myPrefix.length() - 1);
          }
        } else {
          LOG.error("package " + packageNameFromFile + " in a source file " + file.getName() + " does not correspond to file path: " + packageNameWithoutPrefix);
          return;
        }
      }
      String fileName;
      String nameAndExtension = file.getName();
      int offset = nameAndExtension.lastIndexOf('.');
      if (offset < 0) {
        fileName = nameAndExtension;
      } else {
        fileName = nameAndExtension.substring(0, offset);
      }
      classFQName.append(".");
      classFQName.append(fileName);
      registerModelForPackage(packageNameFromFile);

      final SModel pkgModel = (packageNameWithoutPrefix.equals("") ?
        myBaseModelToAddSource :
        getModelForPackage(packageNameFromFile)
      );

      if (pkgModel != null) {
        try {
          final List<SNode> classes = myJavaParser.parse(fileContents, packageNameFromFile, FeatureKind.CLASS, true).getNodes();
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              for (SNode cls : ListSequence.fromList(classes)) {
                SModelOperations.addRootNode(pkgModel, cls);
              }
            }
          });

        } catch (Exception e) {
          // FIXME 
          e.printStackTrace();
        }
        // <node> 
      }

    } catch (Throwable t) {
      LOG.error(t);
    }
  }

  private SModel registerModelForPackage(String fqName) {
    SModelFqName sModelFqName = SModelFqName.fromString(fqName);
    SModelDescriptor modelDescriptor = SModelRepository.getInstance().getModelDescriptor(sModelFqName);
    if (modelDescriptor != null) {
      if (!(myModule.getOwnModelDescriptors().contains(modelDescriptor))) {
        LOG.error("model with fq name " + fqName + " is not owned by module " + myModule.getModuleFqName());
        return null;
      }
      // package is already present... 
      // maybe we shouldn't touch it then, maybe it should be an option 
      return modelDescriptor.getSModel();
    } else {
      return createModel(fqName);
    }
  }

  public void addSource(String classFqName, String text) {
    CompilationUnit compilationUnit = new CompilationUnit(text.toCharArray(), classFqName.replace(".", File.separator) + MPSExtentions.DOT_JAVAFILE, FileUtil.DEFAULT_CHARSET_NAME);
    myCompilationUnits.put(classFqName, compilationUnit);
  }

  public SModel getModelForPackage(String packageName) {
    SModel result = myPackageFQNamesToModels.get(packageName);

    if (result == null) {
      result = createModel(packageName);
      if (result != null) {
        myPackageFQNamesToModels.put(packageName, result);
      }
    }
    return result;
  }

  private SModel createModel(String packageName) {
    // first check if it is possible 
    if (getRootToCreateModel(SModelFqName.fromString(packageName)) == null) {
      LOG.error("Cannot create model " + packageName + " in module " + myModule.getModuleFqName());
      return null;
    }

    SModelFqName modelFqName = SModelFqName.fromString(packageName);
    SModelDescriptor modelDescr = myModule.createModel(modelFqName, getRootToCreateModel(modelFqName), null);
    assert modelDescr != null;

    return modelDescr.getSModel();
  }

  @Nullable
  private SModelRoot getRootToCreateModel(SModelFqName modelFqName) {
    for (SModelRoot root : CollectionSequence.fromCollection(myModule.getSModelRoots())) {
      if (root.getManager().canCreateModel(myModule, root.getModelRoot(), modelFqName)) {
        return root;
      }
    }
    return null;
  }

  public static boolean checkPackageMatchesSourceDirectory(String pkg, File sourceDir) {
    String pathPostfix = NameUtil.pathFromNamespace(pkg);
    return sourceDir.getAbsolutePath().endsWith(pathPostfix);
  }
}
