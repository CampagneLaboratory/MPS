package jetbrains.mps.ide.java.tests.utility;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.textGen.TextGenerationResult;
import jetbrains.mps.textGen.TextGenerationUtil;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.tool.builder.FileMPSProject;
import java.io.File;
import jetbrains.mps.util.PathManager;
import jetbrains.mps.ide.java.newparser.JavaParser;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.ide.java.newparser.FeatureKind;
import java.util.List;
import junit.framework.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.test.matcher.NodeDifference;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.ide.java.newparser.JavaParseException;
import jetbrains.mps.ide.java.sourceStubs.JavaSourceStubModelRoot;
import java.util.Iterator;
import java.util.ArrayList;
import jetbrains.mps.ide.java.newparser.DirParser;
import jetbrains.mps.vfs.FileSystem;
import java.io.IOException;
import jetbrains.mps.persistence.java.library.JavaClassStubsModelRoot;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;

public class Utils {
  public Utils() {
  }

  private static SModule getModule() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("c3786d2b-aba2-45e5-8de0-1124fd14259b(jetbrains.mps.ide.java.tests)"));
  }

  public static String generateCode(SNode node) {
    TextGenerationResult res = TextGenerationUtil.generateText(new ProjectOperationContext(new FileMPSProject(new File(PathManager.getHomePath()))), node);
    return (String) res.getResult();
  }



  public static void checkStringStubs(String code, SNode expected) {
    checkString(code, expected, true);
  }



  public static void checkString(String code, SNode expected, boolean onlyStubs) {
    try {
      JavaParser parser = new JavaParser();
      SModel mdl;
      mdl = SModelRepository.getInstance().getModelDescriptor(new SModelReference("jetbrains.mps.ide.java.testMaterial.placeholder", ""));
      FeatureKind howToParse = (onlyStubs ?
        FeatureKind.CLASS_STUB :
        FeatureKind.CLASS
      );
      List<SNode> res = parser.parse(code, howToParse, null, true).getNodes();
      Assert.assertSame(ListSequence.fromList(res).count(), 1);

      SNode result = SNodeOperations.cast(res.get(0), "jetbrains.mps.baseLanguage.structure.Classifier");
      SModelOperations.addRootNode(mdl, result);

      if (onlyStubs) {
        NodePatcher.removeStatements(expected);
      } else {
        JavaParser.tryResolveUnknowns(Sequence.<SNode>singleton(result));
      }
      NodePatcher.fixNonStatic(expected);
      NodePatcher.fixNonStatic(result);
      NodePatcher.copyImportAttrs(result, expected);

      Map<SNode, SNode> nodeMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      buildClassifierNodeMap(result, expected, nodeMap);
      NodeDifference diff = NodesMatcher.matchNodes(result, expected, nodeMap);

      Assert.assertEquals(null, diff);

    } catch (JavaParseException e) {
      throw new RuntimeException(e);
    }
  }

  public static void checkFile(String path, SNode expected) {

    JavaSourceStubModelRoot mr = new JavaSourceStubModelRoot();
    mr.setModule(getModule());
    mr.setContentRoot(path);
    mr.addFile(JavaSourceStubModelRoot.SOURCE_ROOTS, path);

    Iterator<SModel> models = mr.loadModels().iterator();
    Assert.assertTrue("No models returned from model root", models.hasNext());

    Iterator<? extends SNode> roots = models.next().getRootNodes().iterator();
    Assert.assertTrue("The model has no roots", roots.hasNext());
    SNode result = SNodeOperations.cast((roots.next()), "jetbrains.mps.baseLanguage.structure.Classifier");
    result = SNodeOperations.copyNode(result);
    expected = SNodeOperations.copyNode(expected);

    NodePatcher.removeStatements(expected);
    NodePatcher.fixNonStatic(expected);
    NodePatcher.fixNonStatic(result);
    NodePatcher.copyImportAttrs(result, expected);
    // <node> 
    // <node> 

    Assert.assertEquals(null, NodesMatcher.matchNodes(ListSequence.fromListAndArray(new ArrayList<SNode>(), expected), ListSequence.fromListAndArray(new ArrayList<SNode>(), result)));

  }

  public static void checkStubModel(String dirPath, SModel expected) {
    checkStubModels(dirPath, ListSequence.fromListAndArray(new ArrayList<SModel>(), expected));
  }

  public static void checkStubModels(String dirPath, List<SModel> expected) {

    JavaSourceStubModelRoot mr = new JavaSourceStubModelRoot();
    mr.setModule(getModule());
    mr.setContentRoot(dirPath);
    mr.addFile(JavaSourceStubModelRoot.SOURCE_ROOTS, dirPath);


    List<SModel> models = ListSequence.fromList(new ArrayList<SModel>());
    for (SModel md : Sequence.fromIterable(mr.loadModels())) {
      SModel m = md;
      ListSequence.fromList(models).addElement(m);
    }

    for (SModel m : ListSequence.fromList(expected)) {
      for (SNode root : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
        NodePatcher.removeStatements(SNodeOperations.cast(root, "jetbrains.mps.baseLanguage.structure.Classifier"));
        NodePatcher.fixNonStatic(SNodeOperations.cast(root, "jetbrains.mps.baseLanguage.structure.Classifier"));
      }
    }

    compare(models, expected);
  }

  public static void checkSourceModel(String dirPath, SModel expected) {
    try {
      SModule testMaterials = ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("49166c31-952a-46f6-8970-ea45964379d0(jetbrains.mps.ide.java.testMaterial)"));

      DirParser dirParser = new DirParser(testMaterials, new FileMPSProject(new File(PathManager.getHomePath())), FileSystem.getInstance().getFileByPath(dirPath));

      dirParser.parseDirs();

      List<SModel> parsedModels = dirParser.getAffectedModels();
      assert (int) ListSequence.fromList(parsedModels).count() == 1;
      SModel resultModel = ListSequence.fromList(parsedModels).getElement(0);

      for (SNode root : ListSequence.fromList(SModelOperations.getRoots(expected, null))) {
        NodePatcher.fixNonStatic(SNodeOperations.cast(root, "jetbrains.mps.baseLanguage.structure.Classifier"));
      }

      Map<SNode, SNode> referentMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      buildModelNodeMap(resultModel, expected, referentMap);

      boolean wereErrors = compare2models(resultModel, expected, referentMap);
      Assert.assertFalse(wereErrors);

    } catch (JavaParseException e) {
      throw new RuntimeException(e);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  public static void compareBinAndSrcStubs(String binPath, String sourcePath) {
    JavaSourceStubModelRoot src2 = new JavaSourceStubModelRoot();

    // just 2 distinct modules 
    SModule mod1 = ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("c3786d2b-aba2-45e5-8de0-1124fd14259b(jetbrains.mps.ide.java.tests)"));
    SModule mod2 = ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("49166c31-952a-46f6-8970-ea45964379d0(jetbrains.mps.ide.java.testMaterial)"));

    List<SModel> binModels = ListSequence.fromList(new ArrayList<SModel>());
    JavaClassStubsModelRoot binSRoot = new JavaClassStubsModelRoot();
    binSRoot.setModule(mod1);
    binSRoot.setContentRoot(binPath);
    binSRoot.addFile(JavaClassStubsModelRoot.SOURCE_ROOTS, binPath);
    Iterable<SModel> binStubModels = binSRoot.loadModels();
    for (SModel md : Sequence.fromIterable(binStubModels)) {
      SModel m = md;
      ListSequence.fromList(binModels).addElement(m);

      for (SNode binRoot : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
        NodePatcher.fixNonStatic(binRoot);
        NodePatcher.removeConstructorName(binRoot);
        NodePatcher.removeExtendsObject(binRoot);
        NodePatcher.removeInitializers(binRoot);

        NodePatcher.sortNestedClass(SNodeOperations.cast(binRoot, "jetbrains.mps.baseLanguage.structure.Classifier"));

        // FIXME should be fixed in java source stubs 
        NodePatcher.removeStatements(binRoot);
      }
    }

    Iterable<SModel> srcModels;
    List<SModel> srcModelsX = ListSequence.fromList(new ArrayList<SModel>());

    src2.setModule(mod2);
    src2.setContentRoot(sourcePath);
    src2.addFile(JavaSourceStubModelRoot.SOURCE_ROOTS, sourcePath);
    srcModels = src2.loadModels();

    for (SModel m : Sequence.fromIterable(srcModels)) {
      // <node> 

      SModel zzz = m;
      ListSequence.fromList(srcModelsX).addElement(zzz);

      for (SNode srcRoot : ListSequence.fromList(SModelOperations.getRoots(zzz, null))) {
        NodePatcher.fixNonStatic(srcRoot);
        NodePatcher.removeSourceLevelAnnotations(srcRoot);

        NodePatcher.sortNestedClass(SNodeOperations.cast(srcRoot, "jetbrains.mps.baseLanguage.structure.Classifier"));
      }
    }

    compare(binModels, srcModelsX);
    // <node> 
  }

  public static void compare(Iterable<SModel> leftModels, Iterable<SModel> rightModels) {

    Map<String, SModel> leftModelMap = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel m : Sequence.fromIterable(leftModels)) {
      MapSequence.fromMap(leftModelMap).put(jetbrains.mps.util.SNodeOperations.getModelLongName(m), m);
    }

    Map<String, SModel> rightModelMap = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel m : Sequence.fromIterable(rightModels)) {
      MapSequence.fromMap(rightModelMap).put(jetbrains.mps.util.SNodeOperations.getModelLongName(m), m);
    }

    Assert.assertTrue(SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet()).containsSequence(SetSequence.fromSet(MapSequence.fromMap(rightModelMap).keySet())) && SetSequence.fromSet(MapSequence.fromMap(rightModelMap).keySet()).containsSequence(SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())));

    // constructing the map of corresponding nodes 
    Map<SNode, SNode> classMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    for (String name : SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())) {
      SModel binModel = MapSequence.fromMap(leftModelMap).get(name);
      SModel srcModel = MapSequence.fromMap(rightModelMap).get(name);

      buildModelNodeMap(binModel, srcModel, classMap);
    }

    // <node> 

    boolean errors = false;

    for (String name : SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())) {
      SModel binModel = MapSequence.fromMap(leftModelMap).get(name);
      SModel srcModel = MapSequence.fromMap(rightModelMap).get(name);

      errors = compare2models(binModel, srcModel, classMap) || errors;
    }

    Assert.assertFalse("Models differ", errors);
  }

  public static boolean compare2models(SModel left, SModel right, Map<SNode, SNode> nodeMap) {
    boolean wereErrors = false;
    List<SNode> binRoots = SModelOperations.getRoots(left, null);
    List<SNode> srcRoots = SModelOperations.getRoots(right, null);

    binRoots = ListSequence.fromList(binRoots).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.Classifier"), "name");
      }
    }, true).toListSequence();
    srcRoots = ListSequence.fromList(srcRoots).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.Classifier"), "name");
      }
    }, true).toListSequence();

    // <node> 
    List<NodeDifference> diff = NodesMatcher.matchNodes(binRoots, srcRoots, nodeMap);
    if (diff != null) {
      wereErrors = true;
      System.out.println("Diff: " + diff);
    }
    return wereErrors;
  }

  public static void buildModelNodeMap(SModel left, SModel right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightRootIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightRoot : ListSequence.fromList(SModelOperations.getRoots(right, null))) {
      MapSequence.fromMap(rightRootIndex).put(SPropertyOperations.getString(SNodeOperations.cast(rightRoot, "jetbrains.mps.baseLanguage.structure.IValidIdentifier"), "name"), rightRoot);
    }

    for (SNode leftRoot : ListSequence.fromList(SModelOperations.getRoots(left, null))) {
      SNode rightBrother = MapSequence.fromMap(rightRootIndex).get(SPropertyOperations.getString(SNodeOperations.cast(leftRoot, "jetbrains.mps.baseLanguage.structure.IValidIdentifier"), "name"));
      if ((rightBrother != null)) {
        NodePatcher.copyImportAttrs(leftRoot, rightBrother);
      }
      buildClassifierNodeMap(SNodeOperations.cast(leftRoot, "jetbrains.mps.baseLanguage.structure.Classifier"), SNodeOperations.cast(rightBrother, "jetbrains.mps.baseLanguage.structure.Classifier"), nodeMap);
      // <node> 
    }
  }

  public static void buildClassifierNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {
    // handling this class and nested classes 
    Map<String, SNode> rightNestedIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode cl : ListSequence.fromList(SNodeOperations.getDescendants(right, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{}))) {
      MapSequence.fromMap(rightNestedIndex).put(SPropertyOperations.getString(cl, "name"), cl);
    }

    for (SNode cl : ListSequence.fromList(SNodeOperations.getDescendants(left, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{}))) {
      SNode rightBrother = SNodeOperations.cast(MapSequence.fromMap(rightNestedIndex).get(SPropertyOperations.getString(cl, "name")), "jetbrains.mps.baseLanguage.structure.Classifier");

      // <node> 

      Assert.assertNull(MapSequence.fromMap(nodeMap).get(cl));
      MapSequence.fromMap(nodeMap).put(cl, rightBrother);

      buildJustNodeMap(SLinkOperations.getTargets(left, "typeVariableDeclaration", true), SLinkOperations.getTargets(right, "typeVariableDeclaration", true), nodeMap);
      buildMethodsNodeMap(left, right, nodeMap);

    }

    if (SNodeOperations.isInstanceOf(left, "jetbrains.mps.baseLanguage.structure.Annotation") && SNodeOperations.isInstanceOf(right, "jetbrains.mps.baseLanguage.structure.Annotation")) {
      Map<String, SNode> rightMethodIndex = MapSequence.fromMap(new HashMap<String, SNode>());
      for (SNode mthd : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(right, "jetbrains.mps.baseLanguage.structure.Annotation"), "method", true))) {
        MapSequence.fromMap(rightMethodIndex).put(SPropertyOperations.getString(mthd, "name"), mthd);
      }

      for (SNode mthd : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(left, "jetbrains.mps.baseLanguage.structure.Annotation"), "method", true))) {
        Assert.assertNull(MapSequence.fromMap(nodeMap).get(mthd));
        MapSequence.fromMap(nodeMap).put(mthd, MapSequence.fromMap(rightMethodIndex).get(SPropertyOperations.getString(mthd, "name")));
      }
    }
  }

  public static void buildMethodsNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {
    List<SNode> leftMethods = new ArrayList<SNode>();
    List<SNode> rightMethods = new ArrayList<SNode>();
    ListSequence.fromList(leftMethods).addSequence(Sequence.fromIterable(Classifier_Behavior.call_methods_5292274854859311639(left)));
    ListSequence.fromList(rightMethods).addSequence(Sequence.fromIterable(Classifier_Behavior.call_methods_5292274854859311639(right)));

    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightMthd : ListSequence.fromList(rightMethods)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightMthd, "name"), rightMthd);
    }

    for (SNode leftMthd : ListSequence.fromList(leftMethods)) {
      MapSequence.fromMap(nodeMap).put(leftMthd, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftMthd, "name")));
      buildMethodBodyNodeMap(leftMthd, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftMthd, "name")), nodeMap);
      // <node> 
    }
  }

  public static void buildMethodBodyNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {

    //  type vars 
    buildJustNodeMap(SLinkOperations.getTargets(left, "typeVariableDeclaration", true), SLinkOperations.getTargets(right, "typeVariableDeclaration", true), nodeMap);

    // local vars and params 
    List<SNode> leftVars = new ArrayList<SNode>();
    ListSequence.fromList(leftVars).addSequence(ListSequence.fromList(SLinkOperations.getTargets(left, "parameter", true)));
    ListSequence.fromList(leftVars).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(left, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", false, new String[]{"jetbrains.mps.baseLanguage.structure.AnonymousClass"})));

    List<SNode> rightVars = new ArrayList<SNode>();
    ListSequence.fromList(rightVars).addSequence(ListSequence.fromList(SLinkOperations.getTargets(right, "parameter", true)));
    ListSequence.fromList(rightVars).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(right, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", false, new String[]{"jetbrains.mps.baseLanguage.structure.AnonymousClass"})));

    buildJustNodeMap(leftVars, rightVars, nodeMap);

    // anonymous classes and their insides 


  }

  public static void buildJustNodeMap(List<SNode> left, List<SNode> right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightNode : ListSequence.fromList(right)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightNode, "name"), rightNode);
    }

    for (SNode leftNode : ListSequence.fromList(left)) {
      // <node> 
      MapSequence.fromMap(nodeMap).put(leftNode, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftNode, "name")));
    }
  }
}
