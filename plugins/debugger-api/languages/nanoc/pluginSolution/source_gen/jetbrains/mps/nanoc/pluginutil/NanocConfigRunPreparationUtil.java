package jetbrains.mps.nanoc.pluginutil;

/*Generated by MPS */

import java.io.File;
import com.intellij.execution.ExecutionException;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelReference;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.project.facets.JavaModuleFacet;
import jetbrains.mps.nanoc.debug.ProgramsLocationUtil;
import java.io.IOException;

public class NanocConfigRunPreparationUtil {
  public NanocConfigRunPreparationUtil() {
  }

  public static File prepare(String nodeId, String modelRef) throws ExecutionException {
    SModel descriptor = SModelRepository.getInstance().getModelDescriptor(SModelReference.fromString(modelRef));
    SNode node = descriptor.getNode(SNodeId.fromString(nodeId));
    final SNode sourceFileNode = SNodeOperations.cast(node, "jetbrains.mps.nanoc.structure.File");
    AbstractModule module = (AbstractModule) descriptor.getModule();
    final Wrappers._T<String> sourceFileName = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      @Override
      public void run() {
        sourceFileName.value = SPropertyOperations.getString(sourceFileNode, "name");
      }
    });
    String packageName = NameUtil.pathFromNamespace(jetbrains.mps.util.SNodeOperations.getModelLongName(descriptor));
    File modelSourceFolder = new File(module.getOutputPath() + File.separator + packageName);
    File modelClassesFolder = new File(module.getFacet(JavaModuleFacet.class).getClassesGen().getPath() + File.separator + packageName);
    File f = new File(modelSourceFolder, sourceFileName.value + ".c");
    if (!((f.exists()))) {
      throw new ExecutionException("node is not generated");
    }
    File gcc = new File(ProgramsLocationUtil.getGccLocation());
    if (!((gcc.exists()))) {
      throw new ExecutionException("no GCC found");
    }
    ProcessBuilder processBuilder = new ProcessBuilder();
    String outputExtension = ".exe";
    File executableFile = new File(modelClassesFolder, sourceFileName.value + outputExtension);
    processBuilder.command(gcc.getAbsolutePath(), f.getAbsolutePath(), "-o" + executableFile.getAbsolutePath(), "-g", "-xc");
    processBuilder.directory(f.getParentFile());
    Process compileProcess;
    try {
      compileProcess = processBuilder.start();
    } catch (IOException ioException) {
      throw new ExecutionException("error executing gcc compiler", ioException);
    }
    int timeout = 5000;
    int current = 100;
    boolean success = false;
    while (current < timeout) {
      try {
        Thread.sleep(100);
      } catch (InterruptedException ignored) {
      }
      if (executableFile.exists()) {
        success = true;
        break;
      }
      current += 100;
    }
    if (!((success))) {
      compileProcess.destroy();
      throw new ExecutionException("executable file not found");
    }
    return executableFile;
  }
}
