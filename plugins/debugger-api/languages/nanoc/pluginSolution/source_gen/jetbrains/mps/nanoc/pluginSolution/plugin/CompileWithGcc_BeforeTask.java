package jetbrains.mps.nanoc.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.execution.api.configurations.BaseMpsBeforeTaskProvider;
import com.intellij.openapi.util.Key;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.openapi.project.Project;
import com.intellij.execution.process.ProcessHandler;
import jetbrains.mps.execution.api.commands.OutputRedirector;
import com.intellij.execution.process.ProcessAdapter;
import com.intellij.execution.process.ProcessEvent;
import com.intellij.execution.process.ProcessOutputTypes;
import org.apache.log4j.Priority;
import jetbrains.mps.execution.api.commands.ProcessHandlerBuilder;
import java.io.File;
import com.intellij.execution.ExecutionException;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class CompileWithGcc_BeforeTask extends BaseMpsBeforeTaskProvider<CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask> {
  private static final Key<CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask> KEY = Key.create("jetbrains.mps.nanoc.pluginSolution.plugin.CompileWithGcc_BeforeTask");

  public CompileWithGcc_BeforeTask() {
    super("Compile with gcc");
  }

  protected CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask createTaskImpl() {
    return new CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask();
  }

  public Key<CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask> getId() {
    return KEY;
  }

  public static class CompileWithGcc_BeforeTask_RunTask extends BaseMpsBeforeTaskProvider.BaseMpsBeforeRunTask<CompileWithGcc_BeforeTask.CompileWithGcc_BeforeTask_RunTask> {
    private SNode myFile;

    public CompileWithGcc_BeforeTask_RunTask() {
      super(KEY);
    }

    public boolean configure(SNode file) {
      myFile = file;
      return true;
    }

    public boolean execute(Project project) {
      try {
        ProcessHandler process = OutputRedirector.redirect(new Gcc_Command().createProcess(myFile), new ProcessAdapter() {
          @Override
          public void onTextAvailable(ProcessEvent event, Key key) {
            if (ProcessOutputTypes.STDERR.equals(key)) {
              if (LOG.isEnabledFor(Priority.ERROR)) {
                LOG.error(event.getText());
              }
            } else {
              if (LOG.isInfoEnabled()) {
                LOG.info(event.getText());
              }
            }
          }
        });
        int exitCode = ProcessHandlerBuilder.startAndWait(process);
        if (exitCode != 0) {
          return false;
        }
        return new File(Gcc_Command.getExecutableFile(myFile).getAbsolutePath()).exists();
      } catch (ExecutionException e) {
        if (LOG.isEnabledFor(Priority.ERROR)) {
          LOG.error("", e);
        }
        return false;
      }
    }
  }

  protected static Logger LOG = LogManager.getLogger(CompileWithGcc_BeforeTask.class);
}
