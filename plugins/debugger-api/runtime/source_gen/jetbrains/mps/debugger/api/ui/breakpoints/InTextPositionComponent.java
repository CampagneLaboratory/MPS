package jetbrains.mps.debugger.api.ui.breakpoints;

/*Generated by MPS */

import com.intellij.openapi.components.ProjectComponent;
import jetbrains.mps.debug.api.SessionChangeListener;
import jetbrains.mps.debug.api.DebugSessionManagerComponent;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.editor.markup.RangeHighlighter;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.debug.api.AbstractDebugSession;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.ide.actions.FileOpenUtil;
import com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.debug.api.programState.IStackFrame;
import jetbrains.mps.debug.api.programState.ILocation;
import jetbrains.mps.debug.api.programState.NullLocation;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.fileEditor.FileDocumentManager;
import com.intellij.openapi.editor.colors.EditorColorsScheme;
import com.intellij.openapi.editor.colors.EditorColorsManager;
import com.intellij.openapi.editor.markup.TextAttributes;
import com.intellij.openapi.editor.colors.TextAttributesKey;
import com.intellij.openapi.editor.ex.MarkupModelEx;
import com.intellij.openapi.editor.impl.DocumentMarkupModel;
import com.intellij.openapi.editor.markup.HighlighterLayer;
import jetbrains.mps.debug.api.SessionChangeAdapter;

public class InTextPositionComponent implements ProjectComponent {
  private final SessionChangeListener myChangeListener = new InTextPositionComponent.MySessionChangeListener();
  private final DebugSessionManagerComponent.DebugSessionListener myCurrentDebugSessionListener = new InTextPositionComponent.MyCurrentDebugSessionListener();
  private final Project myProject;
  private volatile RangeHighlighter myHighlighter;

  public InTextPositionComponent(Project project) {
    myProject = project;
  }

  public void projectOpened() {
  }

  public void projectClosed() {
  }

  public void initComponent() {
    DebugSessionManagerComponent component = myProject.getComponent(DebugSessionManagerComponent.class);
    component.addDebugSessionListener(myCurrentDebugSessionListener);
  }

  public void disposeComponent() {
    DebugSessionManagerComponent component = myProject.getComponent(DebugSessionManagerComponent.class);
    component.removeDebugSessionListener(myCurrentDebugSessionListener);
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "Text Position Component";
  }

  protected AbstractDebugSession getCurrentSession() {
    return myProject.getComponent(DebugSessionManagerComponent.class).getDebugSessionByCurrentTab();
  }

  public void currentSessionChanged(AbstractDebugSession session) {
    reAttachPainter(session);
  }

  public void reAttachPainter(AbstractDebugSession session) {
    detachPainter();
    attachPainter(session);
  }

  private _FunctionTypes._void_P0_E0 attachPainterRunnable(AbstractDebugSession session, final boolean open) {
    final Tuples._2<VirtualFile, Integer> location = getLocation(session);
    if (location == null) {
      return null;
    }

    return new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        myHighlighter = createHighlighter(location);
        if (open) {
          FileOpenUtil.openFile(myProject, location._0(), (int) location._1());
        }
      }
    };
  }

  private void attachPainter(AbstractDebugSession session) {
    AbstractDebugSession currentSession = getCurrentSession();
    final _FunctionTypes._void_P0_E0 runnable = attachPainterRunnable(session, currentSession != null && session == currentSession);
    if (runnable == null) {
      return;
    }
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        runnable.invoke();
      }
    });
  }

  public void detachPainter() {
    if (myHighlighter != null) {
      RangeHighlighter highlighter = myHighlighter;
      myHighlighter = null;
      highlighter.dispose();
    }
  }

  @Nullable
  public Tuples._2<VirtualFile, Integer> getLocation(AbstractDebugSession session) {
    IStackFrame stackFrame = session.getUiState().getStackFrame();
    if (stackFrame != null) {
      ILocation location = stackFrame.getLocation();
      if (!(location instanceof NullLocation)) {
        VirtualFile file = FileOpenUtil.findFile(myProject, location.getUnitName(), location.getFileName());
        if (file != null) {
          return MultiTuple.<VirtualFile,Integer>from(file, location.getLineNumber());
        }
      }
    }
    return null;
  }

  @Nullable
  public RangeHighlighter createHighlighter(Tuples._2<VirtualFile, Integer> location) {
    int lineIndex = (int) location._1();
    Document document = FileDocumentManager.getInstance().getDocument(location._0());
    if (document == null) {
      return null;
    }
    if (lineIndex < 0 || lineIndex >= document.getLineCount()) {
      return null;
    }
    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();
    TextAttributes attributes = scheme.getAttributes(TextAttributesKey.createTextAttributesKey("CurrentLine"));
    RangeHighlighter highlighter = ((MarkupModelEx) DocumentMarkupModel.forDocument(document, myProject, true)).addPersistentLineHighlighter(lineIndex, HighlighterLayer.SELECTION - 1, attributes);
    if (highlighter == null || !(highlighter.isValid())) {
      return null;
    }
    return highlighter;
  }

  private class MyCurrentDebugSessionListener implements DebugSessionManagerComponent.DebugSessionListener {
    private MyCurrentDebugSessionListener() {
    }

    @Override
    public void registered(AbstractDebugSession session) {
      session.addChangeListener(myChangeListener);
    }

    @Override
    public void currentSessionChanged(AbstractDebugSession session) {
      InTextPositionComponent.this.currentSessionChanged(session);
    }

    @Override
    public void detached(AbstractDebugSession session) {
      detachPainter();
      session.removeChangeListener(myChangeListener);
    }
  }

  private class MySessionChangeListener extends SessionChangeAdapter {
    private MySessionChangeListener() {
    }

    @Override
    public void stateChanged(AbstractDebugSession session) {
      reAttachPainter(session);
    }

    @Override
    public void paused(AbstractDebugSession session) {
      reAttachPainter(session);
    }

    @Override
    public void resumed(AbstractDebugSession session) {
      detachPainter();
    }
  }
}
