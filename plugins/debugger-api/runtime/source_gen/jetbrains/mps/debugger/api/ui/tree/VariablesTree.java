package jetbrains.mps.debugger.api.ui.tree;

/*Generated by MPS */

import jetbrains.mps.ide.ui.tree.MPSTree;
import com.intellij.openapi.actionSystem.DataProvider;
import com.intellij.openapi.actionSystem.DataKey;
import jetbrains.mps.debug.api.programState.IValue;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.debug.api.AbstractUiState;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.IOperationContext;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.ide.project.ProjectHelper;
import javax.swing.KeyStroke;
import java.awt.event.KeyEvent;
import javax.swing.AbstractAction;
import java.awt.event.ActionEvent;
import com.intellij.openapi.actionSystem.ActionGroup;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import jetbrains.mps.workbench.action.BaseGroup;
import com.intellij.openapi.actionSystem.ActionManager;
import java.util.List;
import jetbrains.mps.debug.api.programState.IWatchable;
import jetbrains.mps.ide.ui.tree.TextTreeNode;
import java.util.Map;
import jetbrains.mps.debug.api.programState.WatchablesCategory;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.SortedSet;
import jetbrains.mps.internal.collections.runtime.SortedSetSequence;
import java.util.TreeSet;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Collections;
import jetbrains.mps.util.ToStringComparator;
import java.util.Comparator;
import jetbrains.mps.ide.messages.Icons;
import org.jetbrains.annotations.Nullable;
import javax.swing.tree.TreePath;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.ide.actions.MPSCommonDataKeys;

public class VariablesTree extends MPSTree implements DataProvider {
  private static final String COMMAND_OPEN_NODE_IN_PROJECT = "COMMAND_OPEN_NODE_IN_PROJECT";
  public static final DataKey<IValue> MPS_DEBUGGER_VALUE = DataKey.create("MPS_DEBUGGER_VALUE");
  @NotNull
  private AbstractUiState myUiState;
  private final Project myProject;
  private final IOperationContext myContext;

  public VariablesTree(Project project, AbstractUiState state) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    myUiState = state;
    myProject = project;
    myContext = new ProjectOperationContext(ProjectHelper.toMPSProject(project));
    getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), COMMAND_OPEN_NODE_IN_PROJECT);
    getActionMap().put(COMMAND_OPEN_NODE_IN_PROJECT, new AbstractAction() {
      @Override
      public void actionPerformed(ActionEvent e) {
        AbstractWatchableNode selectedNode = findSelectedNode();
        if (selectedNode != null) {
          selectedNode.openNode(false, true);
        }
      }
    });
    setRootVisible(false);
    setShowsRootHandles(true);
  }

  @Override
  protected ActionGroup createPopupActionGroup(MPSTreeNode node) {
    if (node instanceof AbstractWatchableNode) {
      return ((BaseGroup) ActionManager.getInstance().getAction("jetbrains.mps.debugger.api.ui.actions.AbstractWatchableNodeActions_ActionGroup"));
    }
    return null;
  }

  public void setUiState(@NotNull AbstractUiState uiState) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    myUiState = uiState;
  }

  @Override
  protected MPSTreeNode rebuild() {
    List<IWatchable> watchables = myUiState.getWatchables();

    if (watchables.isEmpty()) {
      return createEmptyTree();
    }

    MPSTreeNode rootTreeNode = new TextTreeNode("Local Variables");
    rootTreeNode.setTree(this);

    //  collecting nodes 
    Map<WatchablesCategory, List<IWatchable>> orphanesByCategory = MapSequence.fromMap(new HashMap<WatchablesCategory, List<IWatchable>>());
    Map<WatchablesCategory, Map<SNode, List<IWatchable>>> nodeToVarsMapByCategory = MapSequence.fromMap(new HashMap<WatchablesCategory, Map<SNode, List<IWatchable>>>());
    for (IWatchable watchable : watchables) {
      WatchablesCategory category = watchable.getCategory();
      SNode node = watchable.getNode();
      if (node == null) {
        List<IWatchable> orphanes = MapSequence.fromMap(orphanesByCategory).get(category);
        if (orphanes == null) {
          orphanes = new ArrayList<IWatchable>();
          MapSequence.fromMap(orphanesByCategory).put(category, orphanes);
        }
        orphanes.add(watchable);
      } else {
        Map<SNode, List<IWatchable>> nodeToVarsMap = MapSequence.fromMap(nodeToVarsMapByCategory).get(category);
        if (nodeToVarsMap == null) {
          nodeToVarsMap = MapSequence.fromMap(new LinkedHashMap<SNode, List<IWatchable>>(16, (float) 0.75, false));
          MapSequence.fromMap(nodeToVarsMapByCategory).put(category, nodeToVarsMap);
        }
        List<IWatchable> watchableList = MapSequence.fromMap(nodeToVarsMap).get(node);
        if (watchableList == null) {
          watchableList = ListSequence.fromList(new ArrayList<IWatchable>());
          MapSequence.fromMap(nodeToVarsMap).put(node, watchableList);
        }
        ListSequence.fromList(watchableList).addElement(watchable);
      }
    }
    SortedSet<WatchablesCategory> keys = SortedSetSequence.fromSetWithValues(new TreeSet<WatchablesCategory>(), SetSequence.fromSet(MapSequence.fromMap(orphanesByCategory).keySet()).union(SetSequence.fromSet(MapSequence.fromMap(nodeToVarsMapByCategory).keySet())));

    for (WatchablesCategory category : keys) {
      List<IWatchable> orphanes = MapSequence.fromMap(orphanesByCategory).get(category);
      Map<SNode, List<IWatchable>> nodeToVarsMap = MapSequence.fromMap(nodeToVarsMapByCategory).get(category);
      if (orphanes == null) {
        orphanes = ListSequence.fromList(new ArrayList<IWatchable>());
      }
      if (nodeToVarsMap == null) {
        nodeToVarsMap = MapSequence.fromMap(new HashMap<SNode, List<IWatchable>>());
      }
      //  sorting 
      List<SNode> nodes = ListSequence.fromList(new ArrayList<SNode>());
      nodes.addAll(MapSequence.fromMap(nodeToVarsMap).keySet());
      Collections.sort(nodes, new ToStringComparator());
      Collections.sort(orphanes, new Comparator<IWatchable>() {
        @Override
        public int compare(IWatchable o1, IWatchable o2) {
          return o1.getName().compareTo(o2.getName());
        }
      });

      //  adding nodes 
      for (SNode snode : MapSequence.fromMap(nodeToVarsMap).keySet()) {
        List<IWatchable> watchablesWithNodes = MapSequence.fromMap(nodeToVarsMap).get(snode);
        if ((int) ListSequence.fromList(watchablesWithNodes).count() == 1) {
          rootTreeNode.add(new WatchableNode(myContext, ListSequence.fromList(watchablesWithNodes).first(), myUiState));
        } else {
          NodeTreeNode nodeTreeNode = new NodeTreeNode(myContext, snode);
          for (IWatchable watchable : watchablesWithNodes) {
            nodeTreeNode.add(new WatchableNode(myContext, watchable, myUiState));
          }
          rootTreeNode.add(nodeTreeNode);
        }
      }
      for (IWatchable watchable : orphanes) {
        rootTreeNode.add(new WatchableNode(myContext, watchable, myUiState));
      }
    }
    return rootTreeNode;
  }

  private MPSTreeNode createEmptyTree() {
    TextTreeNode rootNode = new TextTreeNode("");
    TextTreeNode messageNode = new TextTreeNode("No local variables available") {
      @Override
      public boolean isLeaf() {
        return true;
      }
    };
    messageNode.setIcon(Icons.INFORMATION_ICON);
    rootNode.add(messageNode);
    return rootNode;
  }

  @Nullable
  private AbstractWatchableNode findSelectedNode() {
    TreePath selectionPath = getSelectionPath();
    if (selectionPath == null) {
      return null;
    }
    Object selectedNode = selectionPath.getLastPathComponent();
    if (selectedNode instanceof AbstractWatchableNode) {
      return ((AbstractWatchableNode) selectedNode);
    }
    return null;
  }

  @Override
  @Nullable
  public Object getData(@NonNls String dataId) {
    if (dataId.equals(MPSCommonDataKeys.NODE.getName())) {
      AbstractWatchableNode selectedNode = findSelectedNode();
      if (selectedNode != null) {
        return selectedNode.getNode();
      }
    } else if (dataId.equals(MPS_DEBUGGER_VALUE.getName())) {
      AbstractWatchableNode selectedNode = findSelectedNode();
      if (selectedNode != null) {
        if (selectedNode instanceof WatchableNode) {
          return ((WatchableNode) selectedNode).getValue();
        }
      }
    } else if (dataId.equals(MPSCommonDataKeys.TREE_NODE.getName())) {
      return findSelectedNode();
    }
    return null;
  }

  public Project getProject() {
    return myProject;
  }
}
