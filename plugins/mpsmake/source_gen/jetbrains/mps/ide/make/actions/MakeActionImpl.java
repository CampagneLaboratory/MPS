package jetbrains.mps.ide.make.actions;

/*Generated by MPS */

import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.project.Project;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.ide.generator.GenerationCheckHelper;
import jetbrains.mps.make.IMakeService;
import jetbrains.mps.generator.ModelGenerationStatusManager;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.resources.MResource;

public class MakeActionImpl {
  private IOperationContext context;
  private MakeActionParameters params;
  private boolean cleanMake;

  public MakeActionImpl(IOperationContext context, MakeActionParameters params, boolean cleanMake) {
    this.context = context;
    this.params = params;
    this.cleanMake = cleanMake;
  }

  public void executeAction() {
    final Iterable<? extends IResource> inputRes = params.collectInput(!(this.cleanMake));

    // save all before launching make 
    final Project project = context.getProject();
    project.getRepository().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        project.getRepository().saveAll();
      }
    });

    final List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), MakeActionImpl.this.selectModels(inputRes));
    MakeSession session = new MakeSession(context, null, cleanMake) {
      @Override
      public void doExecute(Runnable scriptRunnable) {
        if (GenerationCheckHelper.getInstance().checkModelsBeforeGenerationIfNeeded(project, MakeActionImpl.this.context, models)) {
          // ok to go 
          scriptRunnable.run();
        } else {
          // errors found, abort 
          IMakeService.INSTANCE.get().closeSession(this);
        }
      }
    };

    if (IMakeService.INSTANCE.get().openNewSession(session)) {
      IMakeService.INSTANCE.get().make(session, inputRes);
    }
    // Although both make-runtime.FileProcessor and ModelCacheReloader take care to invalidate MGSM on 'generated' file change, 
    // GenStatusUpdater is picky not to perform any updates while make session is active. Either GenStatusUpdater need change to  
    // ignore make in progress, or we shall fire changes once again here (outside of make session). Drawback of approach chosen here is  
    // that we don't invalidate any models not explicitly selected for make. OTOH, UI updates during make (if GSU stops respecting active make) 
    // are not good. Perhaps, GSU could have collected and postponed updates while in make, but there's no event 'make completed' to fire them then. 
    ModelGenerationStatusManager.getInstance().invalidateData(models);
  }

  private Iterable<SModel> selectModels(Iterable<? extends IResource> inputRes) {
    return Sequence.fromIterable(inputRes).translate(new ITranslator2<IResource, SModel>() {
      public Iterable<SModel> translate(IResource it) {
        return ((MResource) it).models();
      }
    });
  }
}
