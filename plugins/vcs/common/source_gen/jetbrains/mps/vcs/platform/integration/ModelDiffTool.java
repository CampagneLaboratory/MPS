package jetbrains.mps.vcs.platform.integration;

/*Generated by MPS */

import com.intellij.openapi.diff.DiffTool;
import com.intellij.openapi.fileTypes.FileType;
import jetbrains.mps.fileTypes.MPSFileTypeFactory;
import com.intellij.openapi.diff.DiffRequest;
import com.intellij.openapi.diff.DiffContent;
import com.intellij.openapi.diff.FileContent;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.vcs.diff.ui.ModelDifferenceDialog;
import com.intellij.openapi.diff.DiffManager;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.diff.DiffViewer;
import java.awt.Window;
import com.intellij.openapi.Disposable;
import jetbrains.mps.vcs.diff.merge.MergeTemporaryModel;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.project.MPSExtentions;
import jetbrains.mps.persistence.PersistenceUtil;
import jetbrains.mps.util.FileUtil;
import java.io.IOException;
import org.apache.log4j.Priority;
import com.intellij.openapi.diff.DocumentContent;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.smodel.SModelFileTracker;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.persistence.FilePerRootDataSource;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class ModelDiffTool implements DiffTool {
  public static final FileType[] DIFF_SUPPORTED_TYPES = {MPSFileTypeFactory.MPS_FILE_TYPE, MPSFileTypeFactory.MPS_HEADER_FILE_TYPE, MPSFileTypeFactory.MPS_ROOT_FILE_TYPE};

  public ModelDiffTool() {
  }

  @Override
  public void show(final DiffRequest request) {
    DiffContent[] contents = request.getContents();
    String[] titles = request.getContentTitles();
    FileType[] types = {contents[0].getContentType(), contents[1].getContentType()};
    FileType type = (types[1] == null ?
      types[0] :
      types[1]
    );

    // trying to fix null content type 
    if (type == null) {
      for (int i = 0; i < contents.length; i++) {
        if (contents[i] instanceof FileContent && contents[i].getFile() != null) {
          type = contents[i].getFile().getFileType();
          break;
        }
      }
    }

    // support per-root persistence 
    if (MPSFileTypeFactory.MPS_ROOT_FILE_TYPE.equals(type) || MPSFileTypeFactory.MPS_HEADER_FILE_TYPE.equals(type)) {
      Tuples._2<SModel, SNodeId> oldModel = getModelAndRoot(contents[0]);
      Tuples._2<SModel, SNodeId> newModel = getModelAndRoot(contents[1]);
      if (oldModel != null && newModel != null) {
        SNodeId rootId = (newModel._1() != null ?
          newModel._1() :
          oldModel._1()
        );
        ModelDifferenceDialog.showRootDifference(request.getProject(), oldModel._0(), newModel._0(), rootId, titles[0], titles[1], null, request);
        return;
      }
    } else {
      SModel oldModel = getModel(contents[0]);
      SModel newModel = getModel(contents[1]);
      if (oldModel != null && newModel != null) {
        new ModelDifferenceDialog(request.getProject(), oldModel, newModel, titles[0], titles[1], request).show();
        return;
      }
    }

    DiffManager.getInstance().getIdeaDiffTool().show(request);
  }

  @Override
  public boolean canShow(DiffRequest request) {
    DiffContent[] contents = request.getContents();
    if (contents.length != 2) {
      return false;
    }
    FileType[] types = {contents[0].getContentType(), contents[1].getContentType()};
    for (FileType type : DIFF_SUPPORTED_TYPES) {
      if ((types[0] == null || types[0].equals(type)) && (types[1] == null || types[1].equals(type))) {
        return true;
      }
    }
    return false;
  }

  @Nullable
  @Override
  public DiffViewer createComponent(String string, DiffRequest request, Window window, Disposable disposable) {
    return null;
  }



  @Nullable
  private static SModel readModel(DiffContent content) {
    try {
      byte[] bytes = content.getBytes();
      // for added/deleted models create empty model to compare with 
      if (bytes.length == 0) {
        return new MergeTemporaryModel(new SModelReference("", ""), true);
      }
      FileType contentType = content.getContentType();
      String ext = MPSExtentions.MODEL;
      // we use same model loader for perroot (to load root or header) and file persistence 
      if (contentType != null && !(contentType.equals(MPSFileTypeFactory.MPS_ROOT_FILE_TYPE) || contentType.equals(MPSFileTypeFactory.MPS_HEADER_FILE_TYPE))) {
        contentType.getDefaultExtension();
      }
      return PersistenceUtil.loadModel(new String(bytes, FileUtil.DEFAULT_CHARSET), ext);
    } catch (IOException ioe) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error("Couldn't read content: " + ioe.getMessage(), ioe);
      }
    }
    return null;
  }

  @Nullable
  private static SModel getModel(DiffContent content) {
    if ((content instanceof DocumentContent || content instanceof FileContent) && content.getFile() != null) {
      IFile file = VirtualFileUtils.toIFile(content.getFile());
      SModel model = SModelFileTracker.getInstance().findModel(file);
      if (model != null) {
        return model;
      }
    }
    return readModel(content);
  }



  @Nullable
  private static Tuples._2<SModel, SNodeId> getModelAndRoot(DiffContent content) {
    if ((content instanceof DocumentContent || content instanceof FileContent) && content.getFile() != null) {
      IFile file = VirtualFileUtils.toIFile(content.getFile());
      Tuples._2<SModel, SNodeId> result = findModelAndRoot(file);
      if (result != null) {
        return result;
      }
    }
    SModel model = readModel(content);
    if (model == null) {
      return null;
    }
    int size = ListSequence.fromList(SModelOperations.getRoots(model, null)).count();
    assert size <= 1;
    return MultiTuple.<SModel,SNodeId>from(model, (size == 0 ?
      (SNodeId) null :
      ListSequence.fromList(SModelOperations.getRoots(model, null)).getElement(0).getNodeId()
    ));

  }

  @Nullable
  private static Tuples._2<SModel, SNodeId> findModelAndRoot(IFile file) {
    assert FilePerRootDataSource.isPerRootPersistenceFile(file);
    SModel model = SModelFileTracker.getInstance().findModel(file.getParent());
    if (model == null) {
      return null;
    }
    // get rootId from file 
    SModel diskModel = PersistenceUtil.loadModel(file, MPSExtentions.MODEL);
    if (diskModel == null) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error("Error reading MPS file " + file.getPath());
      }
      return null;
    }
    int size = ListSequence.fromList(SModelOperations.getRoots(diskModel, null)).count();
    assert size <= 1;
    return MultiTuple.<SModel,SNodeId>from(model, (size == 0 ?
      (SNodeId) null :
      ListSequence.fromList(SModelOperations.getRoots(diskModel, null)).getElement(0).getNodeId()
    ));
  }

  protected static Logger LOG = LogManager.getLogger(ModelDiffTool.class);
}
