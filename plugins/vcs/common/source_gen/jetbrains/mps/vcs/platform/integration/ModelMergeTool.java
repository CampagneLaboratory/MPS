package jetbrains.mps.vcs.platform.integration;

/*Generated by MPS */

import com.intellij.openapi.diff.impl.mergeTool.MergeTool;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Set;
import com.intellij.openapi.fileTypes.FileType;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.diff.DiffRequest;
import com.intellij.openapi.diff.impl.mergeTool.MergeRequestImpl;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import com.intellij.openapi.vfs.VirtualFile;
import org.apache.log4j.Level;
import com.intellij.openapi.vfs.LocalFileSystem;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import java.io.File;
import jetbrains.mps.vcs.platform.util.MergeBackupUtil;
import com.intellij.openapi.diff.DiffContent;
import jetbrains.mps.persistence.FilePerRootDataSource;
import jetbrains.mps.project.MPSExtentions;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.vcspersistence.VCSPersistenceUtil;
import jetbrains.mps.vcs.util.MergeConstants;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.vcs.diff.ui.merge.MergeModelsDialog;
import javax.swing.SwingUtilities;
import jetbrains.mps.vcs.diff.ui.merge.ISaveMergedModel;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.persistence.PersistenceVersionAware;
import com.intellij.openapi.ui.Messages;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.io.IOException;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.ui.DialogWrapper;
import jetbrains.mps.persistence.PersistenceUtil;

public class ModelMergeTool extends MergeTool {
  private static final Logger LOG = LogManager.getLogger(ModelMergeTool.class);
  public static final Set<FileType> SUPPORTED_TYPES = SetSequence.fromSetAndArray(new HashSet<FileType>(), ModelDiffToolOld.DIFF_SUPPORTED_TYPES);
  public ModelMergeTool() {
  }
  @Override
  public void show(final DiffRequest request) {
    final MergeRequestImpl mrequest = (MergeRequestImpl) request;
    try {
      final Wrappers._T<VirtualFile> file = new Wrappers._T<VirtualFile>(check_7qvsj_a0a0b0d(mrequest.getResultContent()));
      if (file.value == null) {
        if (LOG_705910402.isEnabledFor(Level.ERROR)) {
          LOG_705910402.error("No file");
        }
        file.value = LocalFileSystem.getInstance().findFileByPath("/");
      }
      final IFile iFile = FileSystem.getInstance().getFileByPath(file.value.getPath());

      final File backupFile = MergeBackupUtil.zipModel(request.getContents(), file.value);
      DiffContent[] contents = mrequest.getContents();
      final Wrappers._T<String> ext = new Wrappers._T<String>(file.value.getExtension());
      if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
        ext.value = MPSExtentions.MODEL;
      }
      final SModel baseModel = VCSPersistenceUtil.loadModel(contents[MergeConstants.ORIGINAL].getDocument().getText().getBytes(FileUtil.DEFAULT_CHARSET), ext.value);
      SModel mineModel = loadModel(contents[MergeConstants.CURRENT].getBytes(), ext.value);
      SModel newModel = loadModel(contents[MergeConstants.LAST_REVISION].getBytes(), ext.value);
      if (baseModel == null || mineModel == null || newModel == null) {
        if (LOG_705910402.isEnabledFor(Level.WARN)) {
          LOG_705910402.warn("Couldn't read model, invoking text merge");
        }
        super.show(request);
        return;
      }

      final MergeModelsDialog dialog = new MergeModelsDialog(baseModel, mineModel, newModel, mrequest);
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          dialog.toFront();
        }
      });

      ISaveMergedModel saver = new ISaveMergedModel() {
        public boolean save(MergeModelsDialog parent, final SModel resultModel) {
          final Wrappers._boolean closeDialog = new Wrappers._boolean(true);
          final Wrappers._T<String> resultContent = new Wrappers._T<String>(null);

          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              try {
                resultContent.value = ModelMergeTool.saveModel(resultModel, iFile, file.value, ext.value);
              } catch (Throwable error) {
                // this can be when saving in 9 persistence after merge with 8 persistence => trying to save in 8th 
                if (baseModel instanceof PersistenceVersionAware && resultModel instanceof PersistenceVersionAware && ((PersistenceVersionAware) baseModel).getPersistenceVersion() == 8 && ((PersistenceVersionAware) resultModel).getPersistenceVersion() == 9) {
                  String message = "The merged model cannot be saved using the new 9th persistence." + " The most-likely reason: one of the languages used in this model has not yet been generated." + " You can revert the changes, merge and generate the used languages first and only then merge this model again." + " Alternatively, you can save the model in old 8th persistence version and then migrate it to the latest persistence, after all used languages will have been merged manually.";
                  int result = Messages.showYesNoCancelDialog(dialog.getContentPane(), message, "Save model " + SModelOperations.getModelName(resultModel), "Save in 8th persistence", "Revert changes", "Return to merge", Messages.getWarningIcon());
                  switch (result) {
                    case Messages.YES:
                      ((PersistenceVersionAware) resultModel).setPersistenceVersion(8);
                      resultContent.value = ModelMergeTool.saveModel(resultModel, iFile, file.value, ext.value);
                      break;
                    case Messages.NO:
                      resultContent.value = null;
                      break;
                    default:
                      closeDialog.value = false;
                      break;
                  }
                } else {
                  if (LOG_705910402.isEnabledFor(Level.ERROR)) {
                    LOG_705910402.error("Cannot save merge resulting model " + SModelOperations.getModelName(resultModel), error);
                  }
                }
              }

              if (resultContent.value != null) {
                setResolved(mrequest, resultContent.value);
                MergeBackupUtil.packMergeResult(backupFile, file.value.getName(), resultContent.value);
              }
            }
          });

          return closeDialog.value;
        }
      };

      dialog.setSaver(saver);
      dialog.show();

    } catch (IOException e) {
      LOG.error(null, e);
    }
  }
  @Nullable
  private static SModel loadModel(byte[] bytes, String ext) {
    if (bytes.length == 0) {
      return null;
    }
    return VCSPersistenceUtil.loadModel(bytes, ext);
  }
  @Override
  public boolean canShow(DiffRequest request) {
    if (!(super.canShow(request))) {
      return false;
    }
    DiffContent[] contents = request.getContents();
    if (contents.length != 3) {
      return false;
    }
    FileType[] types = {contents[0].getContentType(), contents[1].getContentType(), contents[2].getContentType()};
    if (!(SetSequence.fromSet(SUPPORTED_TYPES).contains(types[MergeConstants.ORIGINAL]))) {
      return false;
    }
    if (types[MergeConstants.CURRENT] != null && types[MergeConstants.CURRENT] != types[MergeConstants.ORIGINAL] || types[MergeConstants.LAST_REVISION] != null && types[MergeConstants.LAST_REVISION] != types[MergeConstants.ORIGINAL]) {
      return false;
    }
    return true;
  }
  private static void setResolved(MergeRequestImpl req, final String result) {
    req.setResult(DialogWrapper.OK_EXIT_CODE);
    final VirtualFile modelFile = check_7qvsj_a0b0g(req.getResultContent());
    ModelAccess.instance().runWriteInEDT(new Runnable() {
      public void run() {
        try {
          modelFile.setBinaryContent(result.getBytes(FileUtil.DEFAULT_CHARSET));
        } catch (IOException e) {
          if (LOG_705910402.isEnabledFor(Level.ERROR)) {
            LOG_705910402.error("Cannot save merge result into " + modelFile.getPath(), e);
          }
        }
      }
    });
  }
  private static String saveModel(SModel resultModel, IFile iFile, VirtualFile file, String ext) {
    if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
      return PersistenceUtil.savePerRootModel(resultModel, file.getExtension().equals(MPSExtentions.MODEL_HEADER));
    } else {
      return PersistenceUtil.saveModel(resultModel, ext);
    }
  }
  protected static Logger LOG_705910402 = LogManager.getLogger(ModelMergeTool.class);
  private static VirtualFile check_7qvsj_a0a0b0d(DiffContent checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getFile();
    }
    return null;
  }
  private static VirtualFile check_7qvsj_a0b0g(DiffContent checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getFile();
    }
    return null;
  }
}
