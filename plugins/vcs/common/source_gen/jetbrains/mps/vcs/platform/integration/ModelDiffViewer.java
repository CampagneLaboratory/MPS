package jetbrains.mps.vcs.platform.integration;

/*Generated by MPS */

import com.intellij.diff.FrameDiffTool;
import jetbrains.mps.vcs.diff.ui.ModelDifferenceViewer;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import com.intellij.diff.DiffContext;
import com.intellij.diff.requests.ContentDiffRequest;
import java.util.List;
import com.intellij.diff.contents.DiffContent;
import com.intellij.openapi.fileTypes.FileType;
import jetbrains.mps.fileTypes.MPSFileTypeFactory;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNodeId;
import com.intellij.diff.requests.DiffRequest;
import com.intellij.diff.contents.EmptyContent;
import com.intellij.diff.contents.DocumentContent;
import com.intellij.diff.contents.FileContent;
import org.jetbrains.annotations.Nullable;
import javax.swing.JComponent;
import jetbrains.mps.vcs.diff.merge.MergeTemporaryModel;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SModelId;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.vcspersistence.VCSPersistenceUtil;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.smodel.SModelFileTracker;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.Computable;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import com.intellij.openapi.fileEditor.OpenFileDescriptor;

public class ModelDiffViewer implements FrameDiffTool.DiffViewer {
  private ModelDifferenceViewer myViewer;

  private Project myProject;

  public ModelDiffViewer(@NotNull DiffContext context, @NotNull ContentDiffRequest request) {
    myProject = context.getProject();

    List<DiffContent> contents = request.getContents();
    FileType type = (contents.get(0).getContentType() != null ? contents.get(0).getContentType() : contents.get(1).getContentType());

    if (MPSFileTypeFactory.MPS_ROOT_FILE_TYPE.equals(type) || MPSFileTypeFactory.MPS_HEADER_FILE_TYPE.equals(type)) {
      Tuples._2<SModel, SNodeId> oldModel = getModelAndRoot(contents.get(0), type);
      Tuples._2<SModel, SNodeId> newModel = getModelAndRoot(contents.get(1), type);
      SNodeId rootId = (newModel._1() != null ? newModel._1() : oldModel._1());
      myViewer = new ModelDifferenceViewer(myProject, oldModel._0(), newModel._0(), rootId, false);
    } else {
      SModel oldModel = ModelDiffViewer.getModel(contents.get(0), type);
      SModel newModel = ModelDiffViewer.getModel(contents.get(1), type);
      myViewer = new ModelDifferenceViewer(myProject, oldModel, newModel, null, true);
    }
    List<String> titles = request.getContentTitles();
    myViewer.setContentTitles(titles.get(0), titles.get(1));
  }

  public static boolean canShow(@NotNull DiffContext context, @NotNull DiffRequest request) {
    if (!((request instanceof ContentDiffRequest))) {
      return false;
    }
    List<DiffContent> contents = ((ContentDiffRequest) request).getContents();
    if (contents.size() != 2) {
      return false;
    }
    if (!((canShowContent(contents.get(0)) && canShowContent(contents.get(1))))) {
      return false;
    }
    if (contents.get(0) instanceof EmptyContent && contents.get(1) instanceof EmptyContent) {
      return false;
    }
    for (FileType type : ModelDiffTool.DIFF_SUPPORTED_TYPES) {
      if (sameTypes(type, contents.get(0).getContentType(), contents.get(1).getContentType())) {
        return true;
      }
    }
    return false;
  }

  private static boolean canShowContent(@NotNull DiffContent content) {
    return content instanceof EmptyContent || content instanceof DocumentContent || content instanceof FileContent;
  }
  private static boolean sameTypes(@NotNull FileType baseType, @Nullable FileType type1, @Nullable FileType type2) {
    if (type1 != null && !(baseType.equals(type1))) {
      return false;
    }
    if (type2 != null && !(baseType.equals(type2))) {
      return false;
    }
    if (type1 == null && type2 == null) {
      return false;
    }
    return true;
  }


  @NotNull
  public JComponent getComponent() {
    return myViewer.getComponent();
  }
  @Nullable
  public JComponent getPreferredFocusedComponent() {
    return myViewer.getPreferredFocusedComponent();
  }
  @NotNull
  public FrameDiffTool.ToolbarComponents init() {
    return new FrameDiffTool.ToolbarComponents();
  }
  public void dispose() {
    if (myViewer != null) {
      // in EDT? 
      myViewer.dispose();
    }
  }

  @Nullable
  private static SModel readModel(DiffContent content, FileType type) {
    if (content instanceof EmptyContent) {
      return new MergeTemporaryModel(new SModelReference(null, SModelId.generate(), "<empty merge model>"), true);
    }

    if (content instanceof FileContent) {
      IFile file = VirtualFileUtils.toIFile(((FileContent) content).getFile());
      return VCSPersistenceUtil.loadModel(file);
    }
    if (content instanceof DocumentContent) {
      String text = ((DocumentContent) content).getDocument().getText();
      return VCSPersistenceUtil.loadModel(text.getBytes(), type.getDefaultExtension());
    }
    return null;
  }
  @Nullable
  private static IFile getFileByContent(@NotNull DiffContent content) {
    VirtualFile vfile = null;
    if ((content instanceof com.intellij.openapi.diff.DocumentContent || content instanceof com.intellij.openapi.diff.FileContent)) {
      vfile = check_qg7y9c_a0a0b0s(content.getOpenFileDescriptor());
    }
    // ? is it necessary? 
    if (vfile == null && content instanceof FileContent) {
      vfile = ((FileContent) content).getFile();
    }
    return (vfile == null ? null : VirtualFileUtils.toIFile(vfile));
  }
  @Nullable
  private static SModel getModel(@NotNull DiffContent content, FileType type) {
    // first try to find model in repository 
    IFile file = getFileByContent(content);
    if (file != null) {
      SModel model = SModelFileTracker.getInstance().findModel(file);
      if (model != null) {
        return model;
      }
    }
    // read model from content 
    return readModel(content, type);
  }

  @Nullable
  private static Tuples._2<SModel, SNodeId> getModelAndRoot(DiffContent content, FileType type) {
    final Wrappers._T<SModel> model = new Wrappers._T<SModel>(null);
    // first try to find model in repository 
    IFile file = getFileByContent(content);
    if (file != null) {
      model.value = SModelFileTracker.getInstance().findModel(file.getParent());
    }
    if (model.value == null) {
      model.value = readModel(content, type);
    }
    if (model.value == null) {
      return null;
    }

    SNodeId nodeId = null;
    int size = ModelAccess.instance().runReadAction(new Computable<Integer>() {
      public Integer compute() {
        return ListSequence.fromList(SModelOperations.roots(model.value, null)).count();
      }
    });
    // todo: find root for models in repository by filename (important when new root added int per-root persistence) 
    if (size == 1) {
      nodeId = ModelAccess.instance().runReadAction(new Computable<SNodeId>() {
        public SNodeId compute() {
          return ListSequence.fromList(SModelOperations.roots(model.value, null)).getElement(0).getNodeId();
        }
      });
    }
    return MultiTuple.<SModel,SNodeId>from(model.value, nodeId);
  }
  private static VirtualFile check_qg7y9c_a0a0b0s(OpenFileDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getFile();
    }
    return null;
  }
}
