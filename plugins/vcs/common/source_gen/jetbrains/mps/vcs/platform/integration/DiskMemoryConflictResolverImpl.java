package jetbrains.mps.vcs.platform.integration;

/*Generated by MPS */

import jetbrains.mps.smodel.DiskMemoryConflictResolver;
import org.jetbrains.mps.openapi.persistence.DataSource;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.extapi.persistence.FileDataSource;
import java.io.File;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.ide.platform.watching.ReloadManager;
import jetbrains.mps.util.Computable;
import jetbrains.mps.smodel.ModelAccess;
import javax.swing.JOptionPane;
import com.intellij.openapi.ui.Messages;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.vcs.util.MergeDriverBackupUtil;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.vcs.platform.util.MergeBackupUtil;
import java.io.IOException;
import org.apache.log4j.Priority;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.project.ProjectManager;
import jetbrains.mps.vcs.diff.ui.ModelDifferenceDialog;
import javax.swing.SwingUtilities;
import jetbrains.mps.vcs.util.ModelVersion;
import com.intellij.openapi.ui.TestDialog;
import com.intellij.openapi.application.Application;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class DiskMemoryConflictResolverImpl extends DiskMemoryConflictResolver {
  public DiskMemoryConflictResolverImpl() {
  }

  @Override
  public void resolveDiskMemoryConflict(DataSource source, final SModel model, final EditableSModel modelDescriptor) {
    final IFile file = ((FileDataSource) source).getFile();
    final File backupFile = doBackup(file, model);
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        // do nothing if conflict was already resolved and model was saved or reloaded 
        if (!(modelDescriptor.isChanged())) {
          backupFile.delete();
          return;
        }
        assert SNodeOperations.isModelDisposed(model) == false;

        boolean needSave = ReloadManager.getInstance().computeNoReload(new Computable<Boolean>() {
          public Boolean compute() {
            if (file.exists()) {
              return showDiskMemoryQuestion(file, model, backupFile);
            } else {
              return showDeletedFromDiskQuestion(model, backupFile);
            }
          }
        });
        if (needSave) {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              modelDescriptor.updateTimestamp();
              modelDescriptor.save();
            }
          });
        } else {
          ModelAccess.instance().runWriteAction(new Runnable() {
            public void run() {
              modelDescriptor.reloadFromSource();
            }
          });
        }
      }
    });
  }

  private static boolean showDeletedFromDiskQuestion(SModel inMemory, File backupFile) {
    // <node> 

    if (isApplicationInUnitTestOrHeadless()) {
      return ourTestImplementation.show("") == 0;
    }
    int result = JOptionPane.showConfirmDialog(null, "Model file for model \n" + inMemory + "\n was externally deleted from disk.\n" + "Backup of it was saved to \"" + backupFile.getAbsolutePath() + "\"\nDo you wish to restore it?", "Model Deleted Externally", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, Messages.getQuestionIcon());
    return result == 0;
  }

  private static boolean showDiskMemoryQuestion(IFile modelFile, SModel inMemory, File backupFile) {
    String message = "Changes have been made to \n" + inMemory + "\n model in memory and on disk.\n" + "Backup of both versions was saved to \"" + backupFile.getAbsolutePath() + "\"\n" + "Which version to use?";
    String title = "Model Versions Conflict";
    String[] options = {"Load File System Version", "Save Memory Version", "Show Difference"};
    while (true) {
      // <node> 
      if (isApplicationInUnitTestOrHeadless()) {
        return ourTestImplementation.show("") == 1;
      }
      int result = JOptionPane.showOptionDialog(null, message, title, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, Messages.getQuestionIcon(), options, null);
      switch (result) {
        case 0:
          // disk version 
          return false;
        case 1:
          // memory version 
          return true;
        case 2:
        default:
          // diff dialog or cancel 
          openDiffDialog(modelFile, inMemory);
      }
    }
  }

  private static File doBackup(IFile modelFile, SModel inMemory) {
    try {
      File tmp = FileUtil.createTmpDir();
      MergeDriverBackupUtil.writeContentsToFile(ModelPersistence.modelToString(((SModelBase) inMemory).getSModelInternal()).getBytes(FileUtil.DEFAULT_CHARSET), modelFile.getName(), tmp, DiskMemoryConflictResolverImpl.DiskMemoryConflictVersion.MEMORY.getSuffix());
      if (modelFile.exists()) {
        com.intellij.openapi.util.io.FileUtil.copy(new File(modelFile.getPath()), new File(tmp.getAbsolutePath(), modelFile.getName() + "." + DiskMemoryConflictResolverImpl.DiskMemoryConflictVersion.FILE_SYSTEM.getSuffix()));
      }
      File zipfile = MergeBackupUtil.chooseZipFileForModelFile(modelFile);
      zipfile.getParentFile().mkdirs();
      FileUtil.zip(tmp, zipfile);
      FileUtil.delete(tmp);
      return zipfile;
    } catch (IOException e) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error("Cannot create backup during resolving disk-memory conflict for " + SNodeOperations.getModelLongName(inMemory), e);
      }
      throw new RuntimeException(e);
    }
  }

  private static void openDiffDialog(IFile modelFile, SModel inMemory) {
    jetbrains.mps.smodel.SModel onDisk = new jetbrains.mps.smodel.SModel(inMemory.getReference());
    try {
      onDisk = ModelPersistence.readModel(new FileDataSource(modelFile), false);
    } catch (ModelReadException e) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error("Could not read model", e);
      }
    }
    Project project = ProjectManager.getInstance().getOpenProjects()[0];
    final ModelDifferenceDialog dialog = new ModelDifferenceDialog(onDisk, ((SModelBase) inMemory).getSModelInternal(), project, "Filesystem version (Read-Only)", "Memory Version");
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        dialog.toFront();
      }
    });
    dialog.show();
  }

  public static   enum DiskMemoryConflictVersion implements ModelVersion {
    FILE_SYSTEM("filesystem"),
    MEMORY("memory");

    private final String mySuffix;

    DiskMemoryConflictVersion(String suffix) {
      mySuffix = suffix;
    }

    @Override
    public String getSuffix() {
      return mySuffix;
    }
  }


  private static TestDialog ourTestImplementation = TestDialog.DEFAULT;

  public static TestDialog setTestDialog(TestDialog newValue) {
    Application application = ApplicationManager.getApplication();
    if (application != null) {
      assert application.isUnitTestMode() : "This method is available for tests only";
    }
    TestDialog oldValue = ourTestImplementation;
    ourTestImplementation = newValue;
    return oldValue;
  }

  private static boolean isApplicationInUnitTestOrHeadless() {
    final Application application = ApplicationManager.getApplication();
    return application != null && (application.isUnitTestMode() || application.isHeadlessEnvironment());
  }

  protected static Logger LOG = LogManager.getLogger(DiskMemoryConflictResolverImpl.class);
}
