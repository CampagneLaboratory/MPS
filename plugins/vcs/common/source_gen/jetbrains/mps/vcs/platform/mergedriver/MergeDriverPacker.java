package jetbrains.mps.vcs.platform.mergedriver;

/*Generated by MPS */

import java.util.Arrays;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import com.intellij.openapi.application.PathManager;
import java.io.File;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.InternalFlag;
import com.intellij.ide.plugins.IdeaPluginDescriptor;
import com.intellij.ide.plugins.PluginManager;
import com.intellij.openapi.extensions.PluginId;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;

public abstract class MergeDriverPacker {
  private static MergeDriverPacker ourInstance;
  private static final Iterable<String> mpsLibJars = Arrays.asList("mps-closures.jar", "mps-collections.jar", "mps-tuples.jar", "mps-core.jar");
  protected static Iterable<String> mpsAddJars = Arrays.asList("asm.jar", "diffutils-1.2.1.jar");
  private static final Iterable<String> ideaLibJars = Arrays.asList("xstream.jar", "guava-11.0.1.jar", "org.eclipse.jdt.core_3.5.2.v_981_R35x.jar", "jdom.jar", "log4j.jar", "trove4j.jar", "annotations.jar", "commons-lang-2.4.jar", "commons-logging-1.1.1.jar");
  private static final Iterable<String> svnJars = Arrays.asList("svnkit.jar", "sequence-library.jar");
  private static final String MERGEDRIVER_PATH = "mergedriver";
  private static final String MERGER_RT = "merger-rt.jar";
  private static boolean ourUpToDate = false;
  protected static Log log = LogFactory.getLog(MergeDriverPacker.class);

  public MergeDriverPacker() {
  }

  public String getPath() {
    return PathManager.getConfigPath() + File.separator + MERGEDRIVER_PATH;
  }

  private File getFile() {
    return new File(getPath());
  }

  public void pack() {
    File tmpDir = FileUtil.createTmpDir();
    FileUtil.delete(getFile());

    Iterable<String> classpathDirs = getClasspath(false);
    Iterable<String> classPathJars = Sequence.fromIterable(classpathDirs).where(new IWhereFilter<String>() {
      public boolean accept(String cpd) {
        return cpd.endsWith(".jar");
      }
    });
    internalPack(classPathJars, tmpDir, false);

    if (InternalFlag.isInternalMode()) {
      Iterable<String> classpathInternal = Sequence.fromIterable(classpathDirs).where(new IWhereFilter<String>() {
        public boolean accept(String cpd) {
          return !(cpd.endsWith(".jar"));
        }
      });
      File tmpDirRT = FileUtil.createTmpDir();
      internalPack(classpathInternal, tmpDirRT, true);
      FileUtil.zip(tmpDirRT, new File(tmpDir + File.separator + MERGER_RT));
      FileUtil.delete(tmpDirRT);
    }
    FileUtil.copyDir(tmpDir, getFile());
    FileUtil.delete(tmpDir);
  }

  private void internalPack(Iterable<String> classpathDirs, File tmpDir, boolean isForZip) {
    for (String classpathDir : Sequence.fromIterable(classpathDirs)) {
      File file = new File(classpathDir);
      if (file.exists()) {
        if (file.isDirectory()) {
          FileUtil.copyDir(file, tmpDir);
        } else {
          FileUtil.copyFile(file, tmpDir);
        }
      } else {
        if (log.isErrorEnabled()) {
          log.error("couldn't find class path: " + classpathDir);
        }
      }
    }
    // Workaround for rare case when MPS build is invoked with internal flag (MPS-13819) 
    if (isForZip && Sequence.fromIterable(classpathDirs).isEmpty()) {
      FileUtil.write(new File(tmpDir, "dummy.txt"), new byte[0]);
    }
  }

  public AbstractInstaller.State packIfNeeded(boolean dryRun) {
    if (!(ourUpToDate)) {
      if (dryRun) {
        if (getFile().exists()) {
          return AbstractInstaller.State.OUTDATED;
        } else {
          return AbstractInstaller.State.NOT_INSTALLED;
        }
      } else {
        pack();
        ourUpToDate = true;
        return AbstractInstaller.State.INSTALLED;
      }
    } else {
      return AbstractInstaller.State.INSTALLED;
    }
  }

  private Iterable<String> getSvnJars() {
    final IdeaPluginDescriptor svnPlugin = PluginManager.getPlugin(PluginId.getId("Subversion"));
    if (svnPlugin != null) {
      return Sequence.fromIterable(svnJars).select(new ISelector<String, String>() {
        public String select(String it) {
          return svnPlugin.getPath() + File.separator + "lib" + File.separator + it;
        }
      });
    }
    return null;
  }

  protected String getVCSCorePluginPath() {
    IdeaPluginDescriptor vcsCorePlugin = PluginManager.getPlugin(PluginId.getId("jetbrains.mps.vcs"));
    assert vcsCorePlugin != null;
    return vcsCorePlugin.getPath().getPath();
  }

  protected abstract String getMPSCorePath();

  protected abstract Set<String> getClasspathInternal();

  public Set<String> getClasspath(boolean withSvnkit) {
    Set<String> classpathItems = SetSequence.fromSet(new LinkedHashSet<String>());
    if (InternalFlag.isInternalMode()) {
      SetSequence.fromSet(classpathItems).addSequence(SetSequence.fromSet(getClasspathInternal()));
    } else {
      final String mpsCorePath = getMPSCorePath();
      SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(mpsLibJars).select(new ISelector<String, String>() {
        public String select(String it) {
          return mpsCorePath + File.separator + it;
        }
      }));
      SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(mpsAddJars).select(new ISelector<String, String>() {
        public String select(String it) {
          return mpsCorePath + File.separator + it;
        }
      }));
      SetSequence.fromSet(classpathItems).addElement(getVCSCorePluginPath() + File.separator + "lib" + File.separator + "mps-vcs-core.jar");
    }

    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(ideaLibJars).select(new ISelector<String, String>() {
      public String select(String it) {
        return PathManager.getLibPath() + File.separator + it;
      }
    }));
    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(getSvnJars()));
    return classpathItems;
  }

  public static MergeDriverPacker getInstance() {
    return ourInstance;
  }

  protected static void setInstance(MergeDriverPacker instance) {
    ourInstance = instance;
  }
}
