package jetbrains.mps.vcs.platform.integration;

/*Generated by MPS */

import java.util.List;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.project.Project;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.TreeSet;
import java.util.Comparator;
import com.intellij.openapi.vcs.changes.Change;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import com.intellij.openapi.vcs.changes.ChangeListManager;
import com.intellij.openapi.vcs.FileStatus;
import com.intellij.openapi.vcs.changes.ContentRevision;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.intellij.openapi.vcs.merge.MergeProvider;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.intellij.openapi.vcs.merge.MergeData;
import com.intellij.openapi.vcs.VcsException;
import org.apache.log4j.Level;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.persistence.FilePerRootDataSource;
import jetbrains.mps.project.MPSExtentions;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.persistence.PersistenceUtil;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.vcs.diff.merge.MergeSession;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import com.intellij.openapi.progress.Task;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.util.FileUtil;
import com.intellij.openapi.vcs.changes.VcsDirtyScopeManager;
import java.io.IOException;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class ConflictingModelsUtil {
  public static List<VirtualFile> getConflictingModelFiles(Project proj) {
    Set<VirtualFile> conflictedFiles = SetSequence.fromSet(new TreeSet<VirtualFile>(new Comparator<VirtualFile>() {
      public int compare(VirtualFile a, VirtualFile b) {
        return a.getPresentableUrl().compareTo(b.getPresentableUrl());
      }
    }));
    for (Change change : CollectionSequence.fromCollection(ChangeListManager.getInstance(proj).getAllChanges())) {
      if (change.getFileStatus() == FileStatus.MERGED_WITH_CONFLICTS) {
        ContentRevision before = change.getBeforeRevision();
        ContentRevision after = change.getAfterRevision();
        if (before != null) {
          VirtualFile file = before.getFile().getVirtualFile();
          if (file != null) {
            SetSequence.fromSet(conflictedFiles).addElement(file);
          }
        }
        if (after != null) {
          VirtualFile file = after.getFile().getVirtualFile();
          if (file != null) {
            SetSequence.fromSet(conflictedFiles).addElement(file);
          }
        }
      }
    }
    return SetSequence.fromSet(conflictedFiles).where(new IWhereFilter<VirtualFile>() {
      public boolean accept(VirtualFile f) {
        return SetSequence.fromSet(ModelMergeTool.SUPPORTED_TYPES).contains(f.getFileType());
      }
    }).toListSequence();
  }

  public static boolean hasResolvableConflicts(Project project, MergeProvider provider, Iterable<VirtualFile> conflictedFiles) {
    for (VirtualFile file : Sequence.fromIterable(conflictedFiles)) {
      MergeData mergeData = null;
      try {
        mergeData = provider.loadRevisions(file);
      } catch (VcsException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error loading revisions to merge", e);
        }
      }

      IFile iFile = FileSystem.getInstance().getFileByPath(file.getPath());
      String ext = file.getExtension();
      if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
        ext = MPSExtentions.MODEL;
      }
      final SModel baseModel = PersistenceUtil.loadModel(mergeData.ORIGINAL, ext);
      final SModel mineModel = PersistenceUtil.loadModel(mergeData.CURRENT, ext);
      final SModel repoModel = PersistenceUtil.loadModel(mergeData.LAST, ext);
      if (baseModel == null || mineModel == null || repoModel == null) {
        if (LOG.isEnabledFor(Level.WARN)) {
          LOG.warn("Couldn't read model " + file.getPath());
        }
        continue;
      }
      // read action: 
      final Wrappers._T<MergeSession> mergeSession = new Wrappers._T<MergeSession>();
      ProjectHelper.getModelAccess(project).runReadAction(new Runnable() {
        public void run() {
          mergeSession.value = MergeSession.createMergeSession(baseModel, mineModel, repoModel);
        }
      });
      int conflictingChangesCount = Sequence.fromIterable(mergeSession.value.getAllChanges()).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange c) {
          return Sequence.fromIterable(mergeSession.value.getConflictedWith(c)).isNotEmpty();
        }
      }).count();
      if (conflictingChangesCount == 0) {
        return true;
      }
    }

    return false;
  }

  public static ConflictingModelsUtil.ModelConflictResolver getModelConflictResolverTask(Project project, MergeProvider provider, com.intellij.openapi.vcs.merge.MergeSession session, List<VirtualFile> conflictedFiles) {
    return new ConflictingModelsUtil.ModelConflictResolver(project, provider, session, conflictedFiles);
  }

  public static class ModelConflictResolver extends Task.Modal {
    private Project myProject;
    private MergeProvider myProvider;
    private com.intellij.openapi.vcs.merge.MergeSession mySession;
    private List<VirtualFile> myConflictedModelFiles;
    private List<VirtualFile> myResolvedModelFiles = ListSequence.fromList(new ArrayList<VirtualFile>());

    public ModelConflictResolver(Project project, MergeProvider provider, com.intellij.openapi.vcs.merge.MergeSession session, List<VirtualFile> conflictedFiles) {
      super(project, "Resolving conflicts in models", true);
      myProvider = provider;
      mySession = session;
      myProject = project;
      myConflictedModelFiles = conflictedFiles;
    }

    public List<VirtualFile> getResolvedFiles() {
      return myResolvedModelFiles;
    }

    public void run(@NotNull ProgressIndicator indicator) {
      final ProgressMonitor monitor = new ProgressMonitorAdapter(indicator);
      monitor.start("Resolving...", ListSequence.fromList(myConflictedModelFiles).count());
      final ModelAccess ma = ProjectHelper.getModelAccess(myProject);
      try {
        for (final VirtualFile file : ListSequence.fromList(myConflictedModelFiles)) {
          monitor.step(file.getCanonicalPath());

          MergeData mergeData = null;
          try {
            mergeData = myProvider.loadRevisions(file);
          } catch (VcsException e) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("Error loading revisions to merge", e);
            }
          }

          final IFile iFile = FileSystem.getInstance().getFileByPath(file.getPath());
          final Wrappers._T<String> ext = new Wrappers._T<String>(file.getExtension());
          if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
            ext.value = MPSExtentions.MODEL;
          }
          final SModel baseModel = PersistenceUtil.loadModel(mergeData.ORIGINAL, ext.value);
          final SModel mineModel = PersistenceUtil.loadModel(mergeData.CURRENT, ext.value);
          final SModel repoModel = PersistenceUtil.loadModel(mergeData.LAST, ext.value);

          final Wrappers._T<MergeSession> mergeSession = new Wrappers._T<MergeSession>(null);
          // read action: 
          ma.runReadAction(new Runnable() {
            public void run() {
              mergeSession.value = MergeSession.createMergeSession(baseModel, mineModel, repoModel);
            }
          });
          int conflictingChangesCount = Sequence.fromIterable(mergeSession.value.getAllChanges()).where(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange c) {
              return Sequence.fromIterable(mergeSession.value.getConflictedWith(c)).isNotEmpty();
            }
          }).count();
          if (conflictingChangesCount != 0) {
            if (LOG.isInfoEnabled()) {
              LOG.info("there are still conflicted changes in " + SModelOperations.getModelName(baseModel));
            }
            monitor.advance(1);
            if (monitor.isCanceled()) {
              return;
            }
            continue;
          }
          if (LOG.isInfoEnabled()) {
            LOG.info("no conflicted changes in " + SModelOperations.getModelName(baseModel));
          }
          ma.runReadAction(new Runnable() {
            public void run() {
              mergeSession.value.applyChanges(mergeSession.value.getAllChanges());
            }
          });

          ThreadUtils.runInUIThreadAndWait(new Runnable() {
            public void run() {
              ma.runWriteAction(new Runnable() {
                public void run() {
                  SModel resultModel = mergeSession.value.getResultModel();
                  if (resultModel == null) {
                  } else if (mergeSession.value.hasIdsToRestore()) {
                    if (LOG.isInfoEnabled()) {
                      LOG.info(String.format("%s: node id duplication detected, should merge in UI.", SModelOperations.getModelName(baseModel)));
                    }
                  } else {
                    String resultContent;
                    if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
                      resultContent = PersistenceUtil.savePerRootModel(resultModel, file.getExtension().equals(MPSExtentions.MODEL_HEADER));
                    } else {
                      resultContent = PersistenceUtil.saveModel(resultModel, ext.value);
                    }
                    try {
                      file.setBinaryContent(resultContent.getBytes(FileUtil.DEFAULT_CHARSET));
                      check_2bxr1q_a1a2a0b0a0a0a0a02a0a3a01g(mySession, file);
                      VcsDirtyScopeManager.getInstance(myProject).fileDirty(file);
                      ListSequence.fromList(myResolvedModelFiles).addElement(file);
                    } catch (IOException e) {
                      if (LOG.isEnabledFor(Level.ERROR)) {
                        LOG.error("Cannot save merge result into " + file.getPath(), e);
                      }
                    }

                  }
                }
              });

            }
          });

          monitor.advance(1);
          if (monitor.isCanceled()) {
            return;
          }
        }
      } finally {
        monitor.done();
      }
    }
    private static void check_2bxr1q_a1a2a0b0a0a0a0a02a0a3a01g(com.intellij.openapi.vcs.merge.MergeSession checkedDotOperand, VirtualFile file) {
      if (null != checkedDotOperand) {
        checkedDotOperand.conflictResolvedForFile(file, com.intellij.openapi.vcs.merge.MergeSession.Resolution.Merged);
      }

    }
  }
  protected static Logger LOG = LogManager.getLogger(ConflictingModelsUtil.class);
}
