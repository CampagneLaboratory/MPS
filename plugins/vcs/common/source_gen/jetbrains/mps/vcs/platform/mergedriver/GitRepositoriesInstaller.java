package jetbrains.mps.vcs.platform.mergedriver;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.vcs.core.mergedriver.FileType;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.vcs.platform.util.PluginUtil;
import com.intellij.openapi.vcs.VcsRoot;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import com.intellij.openapi.ui.Messages;
import jetbrains.mps.util.NameUtil;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.util.StringsIO;
import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import com.intellij.openapi.vcs.AbstractVcs;

/*package*/ class GitRepositoriesInstaller extends AbstractInstaller {
  private static final String ATTRIBUTES_FILE = ".gitattributes";
  private static final List<String> PATTERNS = ListSequence.fromListAndArray(new ArrayList<String>(), "*" + FileType.MODEL.getSuffix(), "*" + FileType.LANGUAGE.getSuffix(), "*" + FileType.SOLUTION.getSuffix(), "*" + FileType.DEVKIT.getSuffix(), "*" + FileType.PROJECT.getSuffix(), FileType.TRACE_CACHE.getSuffix(), FileType.JAVA_DEPENDENCIES.getSuffix(), FileType.GENERATOR_DEPENDENCIES.getSuffix());

  public GitRepositoriesInstaller(Project project) {
    super(project);
  }

  @NotNull
  protected AbstractInstaller.State install(final boolean dryRun) {
    if (!(PluginUtil.isGitPluginEnabled())) {
      return AbstractInstaller.State.INSTALLED;
    }
    Iterable<VcsRoot> gitRoots = getGitRoots();
    if (Sequence.fromIterable(gitRoots).isEmpty()) {
      return AbstractInstaller.State.INSTALLED;
    } else {
      List<AbstractInstaller.State> states = Sequence.fromIterable(gitRoots).select(new ISelector<VcsRoot, AbstractInstaller.State>() {
        public AbstractInstaller.State select(VcsRoot r) {
          return installForRoot(getPath(r), dryRun);
        }
      }).toListSequence();
      if (ListSequence.fromList(states).all(new IWhereFilter<AbstractInstaller.State>() {
        public boolean accept(AbstractInstaller.State s) {
          return s == AbstractInstaller.State.INSTALLED;
        }
      })) {
        return AbstractInstaller.State.INSTALLED;
      } else if (ListSequence.fromList(states).any(new IWhereFilter<AbstractInstaller.State>() {
        public boolean accept(AbstractInstaller.State s) {
          return s == AbstractInstaller.State.OUTDATED;
        }
      })) {
        if (dryRun) {
          return AbstractInstaller.State.OUTDATED;
        }
      } else {
        if (dryRun) {
          return AbstractInstaller.State.NOT_INSTALLED;
        }
      }
      return installForRoots(gitRoots);
    }
  }

  private int getRootsToInstall() {
    return Sequence.fromIterable(getGitRoots()).select(new ISelector<VcsRoot, AbstractInstaller.State>() {
      public AbstractInstaller.State select(VcsRoot r) {
        return installForRoot(getPath(r), true);
      }
    }).where(new IWhereFilter<AbstractInstaller.State>() {
      public boolean accept(AbstractInstaller.State st) {
        return st != AbstractInstaller.State.INSTALLED;
      }
    }).count();
  }

  private Iterable<VcsRoot> getGitRoots() {
    VcsRoot[] allRoots = myProject.getComponent(ProjectLevelVcsManager.class).getAllVcsRoots();
    return Sequence.fromIterable(Sequence.fromArray(allRoots)).where(new IWhereFilter<VcsRoot>() {
      public boolean accept(VcsRoot root) {
        return "Git".equals(getVcs(root).getName());
      }
    });
  }

  private AbstractInstaller.State installForRoots(Iterable<VcsRoot> roots) {
    int updated = 0;
    int failed = 0;
    for (VcsRoot root : Sequence.fromIterable(roots)) {
      if (installForRoot(getPath(root), false) == AbstractInstaller.State.INSTALLED) {
        updated++;
      } else {
        failed++;
      }
    }
    if (updated != 0) {
      Messages.showInfoMessage(myProject, "Successfully updated attributes for " + NameUtil.formatNumericalString(updated, "Git root"), "Attributes");
    }
    if (failed == 0) {
      return AbstractInstaller.State.INSTALLED;
    } else {
      return AbstractInstaller.State.NOT_INSTALLED;
    }
  }

  public String getActionTitle() {
    return "Git file attributes for " + NameUtil.formatNumericalString(getRootsToInstall(), "repository") + "  (.gitattributes)";
  }

  public String getAffectedVcsName() {
    return "Git";
  }

  @NotNull
  private static AbstractInstaller.State installForRoot(VirtualFile vcsRootPath, boolean dryRun) {
    VirtualFile attributesFile = vcsRootPath.findChild(ATTRIBUTES_FILE);
    if (attributesFile != null && attributesFile.isDirectory()) {
      return AbstractInstaller.State.NOT_INSTALLED;
    }
    try {
      if (attributesFile == null || !(attributesFile.exists())) {
        if (dryRun) {
          return AbstractInstaller.State.NOT_INSTALLED;
        }
        attributesFile = vcsRootPath.createChildData(GitRepositoriesInstaller.class, ATTRIBUTES_FILE);
      }
      final List<String> lines = StringsIO.readLines(attributesFile.getInputStream());

      if (ListSequence.fromList(PATTERNS).all(new IWhereFilter<String>() {
        public boolean accept(final String pat) {
          return ListSequence.fromList(lines).any(new IWhereFilter<String>() {
            public boolean accept(String line) {
              return line.matches("\\s*" + pat.replace("*", "\\*") + ".+merge=mps\\s*");
            }
          });
        }
      })) {
        return AbstractInstaller.State.INSTALLED;
      }

      for (String pat : ListSequence.fromList(PATTERNS)) {
        boolean addNew = true;
        for (int i = 0; i < ListSequence.fromList(lines).count(); i++) {
          if (ListSequence.fromList(lines).getElement(i).matches("\\s*" + pat.replace("*", "\\*") + ".*")) {
            if (ListSequence.fromList(lines).getElement(i).contains("merge=mps")) {
              if (dryRun) {
                return AbstractInstaller.State.OUTDATED;
              }
            } else {
              ListSequence.fromList(lines).setElement(i, ListSequence.fromList(lines).getElement(i) + " merge=mps");
            }
            addNew = false;
          }
        }
        if (addNew) {
          ListSequence.fromList(lines).addElement(pat + " text merge=mps");
        }
      }

      if (dryRun) {
        return AbstractInstaller.State.NOT_INSTALLED;
      }

      StringsIO.writeLines(attributesFile.getOutputStream(GitRepositoriesInstaller.class), lines);
      return AbstractInstaller.State.INSTALLED;
    } catch (IOException e) {
      return AbstractInstaller.State.NOT_INSTALLED;
    }
  }

  private static VirtualFile getPath(VcsRoot root) {
    // was changed in IDEA12 from public field to get method: .path -> .getPath() 
    try {
      return root.path;

    } catch (NoSuchFieldError e) {
      try {
        Method method = VcsRoot.class.getMethod("getPath", VirtualFile.class);
        return (VirtualFile) method.invoke(root);
      } catch (NoSuchMethodException ex) {
        ex.printStackTrace();
        return null;
      } catch (InvocationTargetException ex) {
        ex.printStackTrace();
        return null;
      } catch (IllegalAccessException ex) {
        ex.printStackTrace();
        return null;
      }
    }
  }

  private static AbstractVcs getVcs(VcsRoot root) {
    // was changed in IDEA12 from public field to get method: .vcs -> .getVcs() 
    try {
      return root.vcs;

    } catch (NoSuchFieldError e) {
      try {
        Method method = VcsRoot.class.getMethod("getVcs", AbstractVcs.class);
        return (AbstractVcs) method.invoke(root);
      } catch (NoSuchMethodException ex) {
        ex.printStackTrace();
        return null;
      } catch (InvocationTargetException ex) {
        ex.printStackTrace();
        return null;
      } catch (IllegalAccessException ex) {
        ex.printStackTrace();
        return null;
      }
    }
  }
}
