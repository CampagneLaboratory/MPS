package jetbrains.mps.vcs.platform.actions;

/*Generated by MPS */

import jetbrains.mps.workbench.action.BaseAction;
import javax.swing.Icon;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;
import com.intellij.openapi.vcs.merge.MergeProvider;
import git4idea.GitVcs;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.fileTypes.FileType;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.vcs.platform.integration.ModelMergeTool;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.persistence.FilePerRootDataSource;
import jetbrains.mps.project.MPSExtentions;
import com.intellij.openapi.vcs.merge.MergeData;
import com.intellij.openapi.vcs.VcsException;
import org.apache.log4j.Level;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.persistence.PersistenceUtil;
import jetbrains.mps.vcs.diff.merge.MergeSession;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.ide.actions.MPSCommonDataKeys;
import java.util.List;
import com.intellij.openapi.vcs.merge.MergeProvider2;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.util.FileUtil;
import java.io.IOException;
import com.intellij.openapi.vcs.changes.VcsDirtyScopeManager;
import java.util.Set;
import java.util.TreeSet;
import java.util.Comparator;
import com.intellij.openapi.vcs.changes.Change;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import com.intellij.openapi.vcs.changes.ChangeListManager;
import com.intellij.openapi.vcs.FileStatus;
import com.intellij.openapi.vcs.changes.ContentRevision;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class ResolveNonconflictingChanges_Action extends BaseAction {
  private static final Icon ICON = null;
  public ResolveNonconflictingChanges_Action() {
    super("Resolve non-conflicting changes in MPS models", "", ICON);
    this.setIsAlwaysVisible(false);
    this.setExecuteOutsideCommand(false);
  }
  @Override
  public boolean isDumbAware() {
    return true;
  }
  public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {
    MergeProvider provider = GitVcs.getInstance(((MPSProject) MapSequence.fromMap(_params).get("project")).getProject()).getMergeProvider();

    for (VirtualFile file : ListSequence.fromList(ResolveNonconflictingChanges_Action.this.getConflictedFIles(_params))) {
      FileType fileType = file.getFileType();
      if (!((SetSequence.fromSet(ModelMergeTool.SUPPORTED_TYPES).contains(fileType)))) {
        continue;
      }

      IFile iFile = FileSystem.getInstance().getFileByPath(file.getPath());
      String ext = file.getExtension();
      if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
        ext = MPSExtentions.MODEL;
      }

      MergeData mergeData = null;
      try {
        mergeData = provider.loadRevisions(file);
      } catch (VcsException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error loading revisions to merge", e);
        }
      }
      SModel baseModel = PersistenceUtil.loadModel(mergeData.ORIGINAL, ext);
      SModel mineModel = PersistenceUtil.loadModel(mergeData.CURRENT, ext);
      SModel repoModel = PersistenceUtil.loadModel(mergeData.LAST, ext);
      // read action: 
      final MergeSession mergeSession = MergeSession.createMergeSession(baseModel, mineModel, repoModel);
      int conflictingChangesCount = Sequence.fromIterable(mergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange c) {
          return Sequence.fromIterable(mergeSession.getConflictedWith(c)).isNotEmpty();
        }
      }).count();
      if (conflictingChangesCount == 0) {
        return true;
      }
    }

    return false;
  }
  public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {
    try {
      {
        boolean enabled = this.isApplicable(event, _params);
        this.setEnabledState(event.getPresentation(), enabled);
      }
    } catch (Throwable t) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("User's action doUpdate method failed. Action:" + "ResolveNonconflictingChanges", t);
      }
      this.disable(event.getPresentation());
    }
  }
  protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {
    if (!(super.collectActionData(event, _params))) {
      return false;
    }
    MapSequence.fromMap(_params).put("project", event.getData(MPSCommonDataKeys.MPS_PROJECT));
    if (MapSequence.fromMap(_params).get("project") == null) {
      return false;
    }
    return true;
  }
  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {
    try {
      List<VirtualFile> conflictedFiles = ResolveNonconflictingChanges_Action.this.getConflictedFIles(_params);

      // merge with git provider 
      MergeProvider provider = GitVcs.getInstance(((MPSProject) MapSequence.fromMap(_params).get("project")).getProject()).getMergeProvider();
      com.intellij.openapi.vcs.merge.MergeSession session = (provider instanceof MergeProvider2 ? ((MergeProvider2) provider).createMergeSession(conflictedFiles) : null);


      for (final VirtualFile file : ListSequence.fromList(conflictedFiles)) {
        FileType fileType = file.getFileType();
        if (!((SetSequence.fromSet(ModelMergeTool.SUPPORTED_TYPES).contains(fileType)))) {
          continue;
        }

        IFile iFile = FileSystem.getInstance().getFileByPath(file.getPath());
        String ext = file.getExtension();
        if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
          ext = MPSExtentions.MODEL;
        }

        MergeData mergeData = null;
        try {
          mergeData = provider.loadRevisions(file);
        } catch (VcsException e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Error loading revisions to merge", e);
          }
        }
        SModel baseModel = PersistenceUtil.loadModel(mergeData.ORIGINAL, ext);
        SModel mineModel = PersistenceUtil.loadModel(mergeData.CURRENT, ext);
        SModel repoModel = PersistenceUtil.loadModel(mergeData.LAST, ext);
        // read action: 
        final MergeSession mergeSession = MergeSession.createMergeSession(baseModel, mineModel, repoModel);
        int conflictingChangesCount = Sequence.fromIterable(mergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
          public boolean accept(ModelChange c) {
            return Sequence.fromIterable(mergeSession.getConflictedWith(c)).isNotEmpty();
          }
        }).count();
        if (conflictingChangesCount != 0) {
          if (LOG.isInfoEnabled()) {
            LOG.info("there are still conflicted changes in " + SModelOperations.getModelName(baseModel));
          }
          continue;
        }
        if (LOG.isInfoEnabled()) {
          LOG.info("no conflicted changes in " + SModelOperations.getModelName(baseModel));
        }
        mergeSession.applyChanges(mergeSession.getAllChanges());
        if (mergeSession.hasIdsToRestore()) {
          if (LOG.isInfoEnabled()) {
            LOG.info(String.format("%s: node id duplication detected, should merge in UI.", SModelOperations.getModelName(baseModel)));
          }
          continue;
        }

        SModel resultModel = mergeSession.getResultModel();
        if (resultModel != null) {
          final Wrappers._T<String> resultContent = new Wrappers._T<String>();
          if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
            resultContent.value = PersistenceUtil.savePerRootModel(resultModel, file.getExtension().equals(MPSExtentions.MODEL_HEADER));
          } else {
            resultContent.value = PersistenceUtil.saveModel(resultModel, ext);
          }
          ((MPSProject) MapSequence.fromMap(_params).get("project")).getModelAccess().runWriteInEDT(new Runnable() {
            public void run() {
              try {
                file.setBinaryContent(resultContent.value.getBytes(FileUtil.DEFAULT_CHARSET));
              } catch (IOException e) {
                if (LOG.isEnabledFor(Level.ERROR)) {
                  LOG.error("", e);
                }
              }
            }
          });

          check_nkvzp6_a4a12a7a0(session, file);
          VcsDirtyScopeManager.getInstance(((MPSProject) MapSequence.fromMap(_params).get("project")).getProject()).fileDirty(file);
        }
      }
    } catch (Throwable t) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("User's action execute method failed. Action:" + "ResolveNonconflictingChanges", t);
      }
    }
  }
  private List<VirtualFile> getConflictedFIles(final Map<String, Object> _params) {
    Set<VirtualFile> conflictedFiles = SetSequence.fromSet(new TreeSet<VirtualFile>(new Comparator<VirtualFile>() {
      public int compare(VirtualFile a, VirtualFile b) {
        return a.getPresentableUrl().compareTo(b.getPresentableUrl());
      }
    }));
    for (Change change : CollectionSequence.fromCollection(ChangeListManager.getInstance(((MPSProject) MapSequence.fromMap(_params).get("project")).getProject()).getAllChanges())) {
      if (change.getFileStatus() == FileStatus.MERGED_WITH_CONFLICTS) {
        ContentRevision before = change.getBeforeRevision();
        ContentRevision after = change.getAfterRevision();
        if (before != null) {
          VirtualFile file = before.getFile().getVirtualFile();
          if (file != null) {
            SetSequence.fromSet(conflictedFiles).addElement(file);
          }
        }
        if (after != null) {
          VirtualFile file = after.getFile().getVirtualFile();
          if (file != null) {
            SetSequence.fromSet(conflictedFiles).addElement(file);
          }
        }
      }
    }
    return SetSequence.fromSet(conflictedFiles).toListSequence();
  }
  protected static Logger LOG = LogManager.getLogger(ResolveNonconflictingChanges_Action.class);
  private static void check_nkvzp6_a4a12a7a0(com.intellij.openapi.vcs.merge.MergeSession checkedDotOperand, VirtualFile file) {
    if (null != checkedDotOperand) {
      checkedDotOperand.conflictResolvedForFile(file, com.intellij.openapi.vcs.merge.MergeSession.Resolution.Merged);
    }

  }
}
