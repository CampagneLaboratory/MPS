package jetbrains.mps.vcs.changesmanager;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import jetbrains.mps.extapi.model.EditableSModel;
import jetbrains.mps.smodel.EventsCollector;
import com.intellij.util.containers.BidirectionalMultiMap;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.util.containers.BidirectionalMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.List;
import com.intellij.openapi.vcs.FileStatus;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.vcs.diff.changes.MetadataChange;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.extapi.persistence.FileDataSource;
import jetbrains.mps.vfs.IFile;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.vcs.platform.util.ConflictsUtil;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.persistence.PersistenceUtil;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.ChangeSet;
import jetbrains.mps.vcs.diff.ChangeSetBuilder;
import jetbrains.mps.vcs.diff.ChangeSetImpl;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.vcs.diff.changes.NodeChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.event.SModelLanguageEvent;
import jetbrains.mps.smodel.event.SModelDevKitEvent;
import jetbrains.mps.smodel.event.SModelImportEvent;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.vcs.diff.changes.ModuleDependencyChange;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.vcs.diff.changes.ImportedModelChange;
import jetbrains.mps.smodel.SModelRepositoryAdapter;
import jetbrains.mps.logging.Logger;

public class ChangesTracking {
  private Project myProject;
  private CurrentDifference myDifference;
  private SimpleCommandQueue myQueue;
  private EditableSModel myModelDescriptor;
  private ChangesTracking.MyModelListener myModelListener = new ChangesTracking.MyModelListener();
  private EventsCollector myEventsCollector = new ChangesTracking.MyEventsCollector();
  private boolean myDisposed = false;
  private BidirectionalMultiMap<SNodeId, ModelChange> myNodesToChanges = new BidirectionalMultiMap<SNodeId, ModelChange>();
  private Set<ModelChange> myMetadataChanges = SetSequence.fromSet(new HashSet<ModelChange>());
  private BidirectionalMap<SNodeId, ModelChange> myAddedNodesToChanges = new BidirectionalMap<SNodeId, ModelChange>();
  private Tuples._2<SNodeId, List<SNodeId>> myLastParentAndNewChildrenIds;
  private FileStatus myStatusOnLastUpdate;
  private EventConsumingMapping myEventConsumingMapping = new EventConsumingMapping();

  public ChangesTracking(@NotNull Project project, @NotNull CurrentDifference difference) {
    myDifference = difference;
    myProject = project;
    myModelDescriptor = myDifference.getModelDescriptor();
    myQueue = CurrentDifferenceRegistry.getInstance(project).getCommandQueue();
    synchronized (this) {
      SModelRepository.getInstance().addModelRepositoryListener(myModelListener);
      myEventsCollector.add(myModelDescriptor);
    }
  }

  public void dispose() {
    synchronized (this) {
      if (!(myDisposed)) {
        myDisposed = true;
        SModelRepository.getInstance().removeModelRepositoryListener(myModelListener);
        myEventsCollector.remove(myModelDescriptor);
        myEventsCollector.dispose();
        myQueue.runTask(new Runnable() {
          public void run() {
            myDifference.removeChangeSet();
          }
        });
      }
    }
  }

  private void updateCacheForChange(@NotNull ModelChange change) {
    SNodeId id = getNodeIdForChange(change);
    if (id != null) {
      myNodesToChanges.put(id, change);
    } else {
      SetSequence.fromSet(myMetadataChanges).addElement((MetadataChange) change);
    }
    if (change instanceof AddRootChange) {
      MapSequence.fromMap(myAddedNodesToChanges).put(change.getRootId(), change);
    } else if (change instanceof NodeGroupChange) {
      for (SNodeId i : Sequence.fromIterable(getNodeIdsForNodeGroupChange((NodeGroupChange) change, myLastParentAndNewChildrenIds))) {
        MapSequence.fromMap(myAddedNodesToChanges).put(i, change);
      }
    }
  }

  private void buildCaches() {
    myNodesToChanges.clear();
    SetSequence.fromSet(myMetadataChanges).clear();
    myAddedNodesToChanges.clear();
    myLastParentAndNewChildrenIds = null;
    for (ModelChange ch : ListSequence.fromList(myDifference.getChangeSet().getModelChanges())) {
      updateCacheForChange(ch);
    }
  }

  /*package*/ void scheduleFullUpdate() {
    myQueue.addTask(new Runnable() {
      public void run() {
        update(false);
      }
    });
  }

  private void update(boolean force) {
    final Wrappers._boolean _force = new Wrappers._boolean(force);
    myQueue.assertSoftlyIsCommandThread();
    if (!(myDifference.isEnabled())) {
      return;
    }

    if (!(myModelDescriptor.getSource() instanceof FileDataSource)) {
      return;
    }
    IFile modelFile = ((FileDataSource) myModelDescriptor.getSource()).getFile();
    if (!(modelFile.exists())) {
      return;
    }
    VirtualFile modelVFile = VirtualFileUtils.getVirtualFile(modelFile);
    if (modelVFile == null || ProjectLevelVcsManager.getInstance(myProject).getVcsFor(modelVFile) == null) {
      return;
    }
    FileStatus status = FileStatusManager.getInstance(myProject).getStatus(modelVFile);
    if (ConflictsUtil.isModelOrModuleConflicting(myModelDescriptor, myProject)) {
      status = FileStatus.MERGED_WITH_CONFLICTS;
    }

    if (myDifference.getChangeSet() != null) {
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          if (myDifference.getChangeSet().getNewModel().getModelDescriptor() != myModelDescriptor) {
            _force.value = true;
          }
        }
      });
    }

    if (myStatusOnLastUpdate == status && !(_force.value)) {
      return;
    }
    myDifference.removeChangeSet();
    myStatusOnLastUpdate = status;
    if (FileStatus.NOT_CHANGED == status && !(_force.value)) {
      return;
    }
    final Wrappers._T<SModel> baseVersionModel = new Wrappers._T<SModel>(null);
    if (BaseVersionUtil.isAddedFileStatus(status) || ConflictsUtil.isModelOrModuleConflicting(myModelDescriptor, myProject)) {
      baseVersionModel.value = new SModel(myModelDescriptor.getReference());
    } else {
      Object content = BaseVersionUtil.getBaseVersionContent(modelVFile, myProject);
      if (content == null && status != FileStatus.NOT_CHANGED) {
        LOG.error("Base version content is null while file status is " + status);
      }
      if (content == null) {
        return;
      }
      String ext = modelVFile.getExtension();
      org.jetbrains.mps.openapi.model.SModel md = (content instanceof String ?
        PersistenceUtil.loadModel((String) content, ext) :
        PersistenceUtil.loadModel((byte[]) content, ext)
      );
      if (md == null) {
        return;
      }
      baseVersionModel.value = ((SModelBase) md).getSModelInternal();

      if (Sequence.fromIterable(((Iterable<org.jetbrains.mps.openapi.model.SModel.Problem>) md.getProblems())).any(new IWhereFilter<org.jetbrains.mps.openapi.model.SModel.Problem>() {
        public boolean accept(org.jetbrains.mps.openapi.model.SModel.Problem it) {
          return it.isError();
        }
      })) {
        StringBuilder sb = new StringBuilder();
        for (org.jetbrains.mps.openapi.model.SModel.Problem p : Sequence.fromIterable((Iterable<org.jetbrains.mps.openapi.model.SModel.Problem>) md.getProblems())) {
          sb.append((p.isError() ?
            "error: " :
            "warn: "
          )).append(p.getText()).append("\n");
        }
        LOG.warning(sb.toString());
        return;
      }
    }
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        synchronized (ChangesTracking.this) {
          if (!(myDisposed)) {
            ChangeSet changeSet = ChangeSetBuilder.buildChangeSet(baseVersionModel.value, ((SModelBase) myModelDescriptor).getSModelInternal(), true);
            myDifference.setChangeSet((ChangeSetImpl) changeSet);
            buildCaches();
          }
        }
      }
    });
  }

  private void addChange(@NotNull ModelChange change) {
    updateCacheForChange(change);
    myDifference.addChange(change);
  }

  private void removeChange(@NotNull ModelChange change) {
    if (change instanceof MetadataChange) {
      SetSequence.fromSet(myMetadataChanges).removeElement((MetadataChange) change);
    } else {
      myNodesToChanges.removeValue(change);
    }
    myAddedNodesToChanges.removeValue(change);
    myDifference.removeChange(change);
  }

  private <C extends ModelChange> int removeChanges(SNodeId nodeId, final Class<C> changeClass, final _FunctionTypes._return_P1_E0<? extends Boolean, ? super C> condition) {
    Set<ModelChange> changes = (nodeId == null ?
      myMetadataChanges :
      myNodesToChanges.getValues(nodeId)
    );
    List<ModelChange> toRemove = SetSequence.fromSet(changes).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return changeClass.isInstance(ch) && condition.invoke((C) ch);
      }
    }).toListSequence();
    ListSequence.fromList(toRemove).visitAll(new IVisitor<ModelChange>() {
      public void visit(ModelChange it) {
        removeChange(it);
      }
    });
    return ListSequence.fromList(toRemove).count();
  }

  private void removeDescendantChanges(SNodeId parentId, String role) {
    SNode oldNode = getOldNode(parentId);
    assert oldNode != null;
    List<? extends SNode> children = IterableUtil.asList(oldNode.getChildren(role));
    ListSequence.fromList(children).visitAll(new IVisitor<SNode>() {
      public void visit(SNode c) {
        removeDescendantChanges(c.getNodeId());
      }
    });
  }

  private void removeDescendantChanges(SNodeId nodeId) {
    SNode oldNode = getOldNode(nodeId);
    assert oldNode != null;
    for (SNode d : ListSequence.fromList(SNodeOperations.getDescendants(oldNode, null, true, new String[]{}))) {
      removeChanges(d.getNodeId(), ModelChange.class, new _FunctionTypes._return_P1_E0<Boolean, ModelChange>() {
        public Boolean invoke(ModelChange ch) {
          return true;
        }
      });
    }
  }

  private void buildAndAddChanges(_FunctionTypes._void_P1_E0<? super ChangeSetBuilder> buildAction) {
    ChangeSet cs = myDifference.getChangeSet();
    ChangeSetBuilder builder = ChangeSetBuilder.createBuilder(cs);
    buildAction.invoke(builder);
    ListSequence.fromList(builder.getNewChanges()).visitAll(new IVisitor<ModelChange>() {
      public void visit(ModelChange ch) {
        addChange(ch);
      }
    });
  }

  @Nullable
  private SNode getOldNode(@NotNull SNodeId id) {
    return check_5iuzi5_a0a0a52(myDifference.getChangeSet()).getNode(id);
  }

  private void runUpdateTask(final _FunctionTypes._void_P0_E0 task, SNode currentNode, final SModelEvent event) {
    myEventConsumingMapping.addEvent(event);
    final List<SNodeId> ancestors = ListSequence.fromList(SNodeOperations.getAncestors(currentNode, null, true)).select(new ISelector<SNode, SNodeId>() {
      public SNodeId select(SNode a) {
        return a.getNodeId();
      }
    }).toListSequence();
    myQueue.runTask(new Runnable() {
      public void run() {
        if (myDifference.getChangeSet() == null) {
          update(true);
        } else {
          if (ListSequence.fromList(ancestors).any(new IWhereFilter<SNodeId>() {
            public boolean accept(SNodeId a) {
              return myAddedNodesToChanges.containsKey(a);
            }
          })) {
            // ignore 
          } else {
            if (myEventConsumingMapping.removeEvent(event)) {
              myDifference.getBroadcaster().changeUpdateStarted();
              ModelAccess.instance().runReadAction(new Runnable() {
                public void run() {
                  synchronized (ChangesTracking.this) {
                    if (!(myDisposed)) {
                      task.invoke();
                    }
                  }
                }
              });
              myDifference.getBroadcaster().changeUpdateFinished();
            }
          }
        }
      }
    });
  }

  private static Iterable<SNodeId> getNodeIdsForNodeGroupChange(@NotNull NodeGroupChange ngc, @Nullable Tuples._2<SNodeId, List<SNodeId>> lastParentAndNewChildrenIds) {
    List<SNodeId> childrenIds;
    if (lastParentAndNewChildrenIds == null || neq_5iuzi5_a0a1a72(lastParentAndNewChildrenIds._0(), ngc.getParentNodeId())) {
      List<? extends SNode> children = IterableUtil.asList(ngc.getChangeSet().getNewModel().getNode(ngc.getParentNodeId()).getChildren(ngc.getRole()));
      childrenIds = ListSequence.fromList(children).select(new ISelector<SNode, SNodeId>() {
        public SNodeId select(SNode n) {
          return n.getNodeId();
        }
      }).toListSequence();
    } else {
      childrenIds = lastParentAndNewChildrenIds._1();
    }
    return ListSequence.fromList(childrenIds).page(ngc.getResultBegin(), ngc.getResultEnd());
  }

  @Nullable
  private static SNodeId getNodeIdForChange(@NotNull ModelChange change) {
    if (change instanceof NodeChange) {
      return ((NodeChange) change).getAffectedNodeId();
    } else if (change instanceof AddRootChange || change instanceof DeleteRootChange) {
      return change.getRootId();
    } else if (change instanceof NodeGroupChange) {
      return ((NodeGroupChange) change).getParentNodeId();
    }
    return null;
  }

  public class MyEventsCollector extends EventsCollector {
    public MyEventsCollector() {
    }

    @Override
    protected void eventsHappened(List<SModelEvent> evets) {
      Map<SNode, Set<String>> chlidChanged = MapSequence.fromMap(new HashMap<SNode, Set<String>>());
      for (SModelEvent event : ListSequence.fromList(evets)) {
        if (event instanceof SModelPropertyEvent) {
          processProperty((SModelPropertyEvent) event);
        } else if (event instanceof SModelReferenceEvent) {
          processReference((SModelReferenceEvent) event);
        } else if (event instanceof SModelChildEvent) {
          processChild((SModelChildEvent) event, chlidChanged);
        } else if (event instanceof SModelRootEvent) {
          processRoot((SModelRootEvent) event);
        } else if (event instanceof SModelLanguageEvent) {
          processLanguage((SModelLanguageEvent) event);
        } else if (event instanceof SModelDevKitEvent) {
          processDevkit((SModelDevKitEvent) event);
        } else if (event instanceof SModelImportEvent) {
          processImport((SModelImportEvent) event);
        }
      }
    }

    private void processProperty(SModelPropertyEvent event) {
      final SNode node = event.getNode();
      if (node.getModel() == null) {
        return;
      }
      final SNodeId nodeId = node.getNodeId();
      final String propertyName = event.getPropertyName();
      runUpdateTask(new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          removeChanges(nodeId, SetPropertyChange.class, new _FunctionTypes._return_P1_E0<Boolean, SetPropertyChange>() {
            public Boolean invoke(SetPropertyChange ch) {
              return propertyName.equals(ch.getPropertyName());
            }
          });
          buildAndAddChanges(new _FunctionTypes._void_P1_E0<ChangeSetBuilder>() {
            public void invoke(ChangeSetBuilder b) {
              b.buildForProperty(getOldNode(nodeId), node, propertyName);
            }
          });
        }
      }, node, event);
    }

    private void processReference(SModelReferenceEvent event) {
      SReference ref = event.getReference();
      final SNode sourceNode = ref.getSourceNode();
      if (sourceNode.getModel() == null) {
        return;
      }
      final SNodeId nodeId = sourceNode.getNodeId();
      final String role = ref.getRole();
      runUpdateTask(new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          removeChanges(nodeId, SetReferenceChange.class, new _FunctionTypes._return_P1_E0<Boolean, SetReferenceChange>() {
            public Boolean invoke(SetReferenceChange ch) {
              return role.equals(ch.getRole());
            }
          });
          buildAndAddChanges(new _FunctionTypes._void_P1_E0<ChangeSetBuilder>() {
            public void invoke(ChangeSetBuilder b) {
              b.buildForReference(getOldNode(nodeId), sourceNode, role);
            }
          });
        }
      }, event.getReference().getSourceNode(), event);
    }

    private void processChild(SModelChildEvent event, Map<SNode, Set<String>> childChanged) {
      SNode parent = event.getParent();
      if (parent.getModel() == null) {
        return;
      }
      final String childRole = event.getChildRole();

      // tyring to avoid update task execution for the same child role twice 
      Set<String> childRoles = MapSequence.fromMap(childChanged).get(parent);
      if (childRoles == null) {
        childRoles = SetSequence.fromSet(new HashSet<String>());
        MapSequence.fromMap(childChanged).put(parent, childRoles);
      }
      if (SetSequence.fromSet(childRoles).contains(childRole)) {
        return;
      } else {
        SetSequence.fromSet(childRoles).addElement(childRole);
      }
      final SNodeId parentId = parent.getNodeId();

      final Wrappers._T<List<? extends SNode>> childrenRightAfterEvent = new Wrappers._T<List<? extends SNode>>(IterableUtil.asList(parent.getChildren(childRole)));
      childrenRightAfterEvent.value = ListSequence.fromList(childrenRightAfterEvent.value).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode n) {
          return CopyUtil.copyAndPreserveId(n, false);
        }
      }).toListSequence();
      runUpdateTask(new _FunctionTypes._void_P0_E0() {
        public void invoke() {

          removeChanges(parentId, NodeGroupChange.class, new _FunctionTypes._return_P1_E0<Boolean, NodeGroupChange>() {
            public Boolean invoke(NodeGroupChange ch) {
              return childRole.equals(ch.getRole());
            }
          });
          removeDescendantChanges(parentId, childRole);
          myLastParentAndNewChildrenIds = MultiTuple.<SNodeId,List<SNodeId>>from(parentId, ListSequence.fromList(childrenRightAfterEvent.value).select(new ISelector<SNode, SNodeId>() {
            public SNodeId select(SNode n) {
              return n.getNodeId();
            }
          }).toListSequence());
          buildAndAddChanges(new _FunctionTypes._void_P1_E0<ChangeSetBuilder>() {
            public void invoke(ChangeSetBuilder b) {
              b.buildForNodeRole(IterableUtil.asList(getOldNode(parentId).getChildren(childRole)), childrenRightAfterEvent.value, parentId, childRole);
            }
          });
        }
      }, parent, event);
    }

    private void processRoot(final SModelRootEvent event) {
      SNode root = event.getRoot();
      final boolean added = event.isAdded();
      if ((added ?
        root.getModel() == null :
        root.getModel() != null
      )) {
        return;
      }
      final SNodeId rootId = root.getNodeId();
      runUpdateTask(new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          if (added) {
            removeChanges(rootId, DeleteRootChange.class, new _FunctionTypes._return_P1_E0<Boolean, DeleteRootChange>() {
              public Boolean invoke(DeleteRootChange ch) {
                return true;
              }
            });
            buildAndAddChanges(new _FunctionTypes._void_P1_E0<ChangeSetBuilder>() {
              public void invoke(ChangeSetBuilder b) {
                b.buildForNode(getOldNode(rootId), event.getRoot());
              }
            });
          } else {
            if (removeChanges(rootId, AddRootChange.class, new _FunctionTypes._return_P1_E0<Boolean, AddRootChange>() {
              public Boolean invoke(AddRootChange ch) {
                return true;
              }
            }) == 0) {
              // root was not added 
              removeDescendantChanges(rootId);
              buildAndAddChanges(new _FunctionTypes._void_P1_E0<ChangeSetBuilder>() {
                public void invoke(ChangeSetBuilder b) {
                  b.buildForNode(getOldNode(rootId), null);
                }
              });
            }
          }
        }
      }, null, event);
    }

    private void processLanguage(SModelLanguageEvent event) {
      moduleDependencyEvent(event, event.getLanguageNamespace(), ModuleDependencyChange.DependencyType.USED_LANG, event.isAdded());
    }

    private void processDevkit(SModelDevKitEvent event) {
      moduleDependencyEvent(event, event.getDevkitNamespace(), ModuleDependencyChange.DependencyType.USED_DEVKIT, event.isAdded());
    }

    private void moduleDependencyEvent(SModelEvent event, final SModuleReference moduleRef, final ModuleDependencyChange.DependencyType type, final boolean added) {
      runUpdateTask(new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          if (removeChanges(null, ModuleDependencyChange.class, new _FunctionTypes._return_P1_E0<Boolean, ModuleDependencyChange>() {
            public Boolean invoke(ModuleDependencyChange mdc) {
              return type == mdc.getDependencyType() && moduleRef.equals(mdc.getModuleReference());
            }
          }) == 0) {
            addChange(new ModuleDependencyChange(myDifference.getChangeSet(), moduleRef, type, !(added)));
          }
        }
      }, null, event);
    }

    private void processImport(final SModelImportEvent event) {
      final SModelReference modelRef = event.getModelUID();
      runUpdateTask(new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          if (removeChanges(null, ImportedModelChange.class, new _FunctionTypes._return_P1_E0<Boolean, ImportedModelChange>() {
            public Boolean invoke(ImportedModelChange imc) {
              return modelRef.equals(imc.getModelReference());
            }
          }) == 0) {
            addChange(new ImportedModelChange(myDifference.getChangeSet(), modelRef, !(event.isAdded())));
          }
        }
      }, null, event);
    }
  }

  private class MyModelListener extends SModelRepositoryAdapter {
    public MyModelListener() {
    }

    @Override
    public void modelsReplaced(Set<org.jetbrains.mps.openapi.model.SModel> descriptors) {
      if (descriptors.contains(myModelDescriptor)) {
        scheduleFullUpdate();
      }
    }
  }

  private static Logger LOG = Logger.getLogger(ChangesTracking.class);

  private static SModel check_5iuzi5_a0a0a52(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getOldModel();
    }
    return null;
  }

  private static boolean neq_5iuzi5_a0a1a72(Object a, Object b) {
    return !((a != null ?
      a.equals(b) :
      a == b
    ));
  }
}
