package jetbrains.mps.vcs.changesmanager;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import java.util.Map;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SModelRepositoryListener;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.DefaultSModelDescriptor;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.smodel.SModelFileTracker;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.vcs.FileStatusListener;
import jetbrains.mps.smodel.SModelRepositoryAdapter;
import jetbrains.mps.extapi.model.EditableSModel;

public class CurrentDifferenceRegistry extends AbstractProjectComponent {
  private final Map<SModelReference, CurrentDifference> myCurrentDifferences = MapSequence.fromMap(new HashMap<SModelReference, CurrentDifference>());
  private final SModelRepositoryListener myModelRepositoryListener = new CurrentDifferenceRegistry.MySModelRepositoryListener();
  private final SimpleCommandQueue myCommandQueue = new SimpleCommandQueue("ChangesManager command queue");
  private CurrentDifferenceBroadcaster myGlobalBroadcaster = new CurrentDifferenceBroadcaster(myCommandQueue);
  private CurrentDifferenceRegistry.MyFileStatusListener myFileStatusListener = new CurrentDifferenceRegistry.MyFileStatusListener();

  public CurrentDifferenceRegistry(@NotNull Project project, ProjectLevelVcsManager vcsManager, FileStatusManager fileStatusManager) {
    super(project);
  }

  @Override
  public void projectOpened() {
    FileStatusManager.getInstance(myProject).addFileStatusListener(myFileStatusListener);
    SModelRepository.getInstance().addModelRepositoryListener(myModelRepositoryListener);

    updateLoadedModels();
  }

  @Override
  public void projectClosed() {
    FileStatusManager.getInstance(myProject).removeFileStatusListener(myFileStatusListener);
    SModelRepository.getInstance().removeModelRepositoryListener(myModelRepositoryListener);

    synchronized (myCurrentDifferences) {
      for (CurrentDifference modelChangesManager : Sequence.fromIterable(MapSequence.fromMap(myCurrentDifferences).values())) {
        modelChangesManager.dispose();
      }
      MapSequence.fromMap(myCurrentDifferences).clear();
    }
    myCommandQueue.dispose();
  }

  public Project getProject() {
    return myProject;
  }

  private void updateModel(@NotNull DefaultSModelDescriptor modelDescriptor) {
    synchronized (myCurrentDifferences) {
      SModelReference modelRef = modelDescriptor.getSModelReference();
      if (MapSequence.fromMap(myCurrentDifferences).containsKey(modelRef)) {
        MapSequence.fromMap(myCurrentDifferences).get(modelRef).getChangesTracker().scheduleFullUpdate();
        return;
      }
      CurrentDifference cd = new CurrentDifference(this, modelDescriptor);
      MapSequence.fromMap(myCurrentDifferences).put(modelRef, cd);
    }
  }

  private void updateModel(@Nullable VirtualFile file) {
    if (file == null) {
      return;
    }
    IFile iFile = VirtualFileUtils.toIFile(file);
    if (iFile == null) {
      return;
    }
    DefaultSModelDescriptor modelDescriptor = ((DefaultSModelDescriptor) SModelFileTracker.getInstance().findModel(iFile));
    if (modelDescriptor == null || !(modelDescriptor.isLoaded())) {
      return;
    }
    updateModel(modelDescriptor);
  }

  public void updateLoadedModels() {
    for (SModel md : ListSequence.fromList(SModelRepository.getInstance().getModelDescriptors())) {
      if (md instanceof DefaultSModelDescriptor) {
        updateModel((DefaultSModelDescriptor) md);
      }
    }
  }

  private void disposeModelChangesManager(@NotNull SModelReference modelReference) {
    synchronized (myCurrentDifferences) {
      if (MapSequence.fromMap(myCurrentDifferences).containsKey(modelReference)) {
        MapSequence.fromMap(myCurrentDifferences).get(modelReference).dispose();
        MapSequence.fromMap(myCurrentDifferences).removeKey(modelReference);
      }
    }
  }

  @NotNull
  public CurrentDifference getCurrentDifference(@NotNull DefaultSModelDescriptor modelDescriptor) {
    synchronized (myCurrentDifferences) {
      SModelReference modelRef = modelDescriptor.getSModelReference();
      if (!(MapSequence.fromMap(myCurrentDifferences).containsKey(modelRef))) {
        MapSequence.fromMap(myCurrentDifferences).put(modelRef, new CurrentDifference(this, modelDescriptor));
      }
      return MapSequence.fromMap(myCurrentDifferences).get(modelRef);
    }
  }

  public void addGlobalDifferenceListener(@NotNull CurrentDifferenceListener listener) {
    myGlobalBroadcaster.addDifferenceListener(listener);
  }

  public void removeGlobalDifferenceListener(@NotNull CurrentDifferenceListener listener) {
    myGlobalBroadcaster.removeDifferenceListener(listener);
  }

  @NotNull
  public SimpleCommandQueue getCommandQueue() {
    return myCommandQueue;
  }

  /*package*/ CurrentDifferenceBroadcaster getGlobalBroadcaster() {
    return myGlobalBroadcaster;
  }

  public static CurrentDifferenceRegistry getInstance(Project project) {
    return project.getComponent(CurrentDifferenceRegistry.class);
  }

  private class MyFileStatusListener implements FileStatusListener {
    public MyFileStatusListener() {
    }

    @Override
    public void fileStatusesChanged() {
      updateLoadedModels();
    }

    @Override
    public void fileStatusChanged(@NotNull VirtualFile vf) {
      updateModel(vf);
    }
  }

  private class MySModelRepositoryListener extends SModelRepositoryAdapter {
    public MySModelRepositoryListener() {
    }

    @Override
    public void beforeModelRemoved(SModel descriptor) {
      if (descriptor instanceof EditableSModel) {
        disposeModelChangesManager(descriptor.getReference());
      }
    }
  }
}
