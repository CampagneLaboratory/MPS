package jetbrains.mps.vcs.changesmanager;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import java.util.Map;

import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.mps.openapi.model.SNodeReference;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.workbench.nodesFs.MPSNodesVirtualFileSystem;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.util.Computable;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.DefaultSModelDescriptor;
import jetbrains.mps.vcs.platform.util.ConflictsUtil;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.util.SNodeOperations;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.vcs.diff.ChangeSet;

public class NodeFileStatusMapping extends AbstractProjectComponent {
  private final CurrentDifferenceRegistry myRegistry;
  private final Map<SNodeReference, FileStatus> myFileStatusMap = MapSequence.fromMap(new HashMap<SNodeReference, FileStatus>());
  private final CurrentDifferenceListener myGlobalListener = new NodeFileStatusMapping.MyGlobalListener();

  public NodeFileStatusMapping(Project project, CurrentDifferenceRegistry registry) {
    super(project);
    myRegistry = registry;
  }

  @Override
  public void projectOpened() {
    myRegistry.addGlobalDifferenceListener(myGlobalListener);
  }

  @Override
  public void projectClosed() {
    myRegistry.removeGlobalDifferenceListener(myGlobalListener);
  }

  private void statusChanged(@NotNull final SNodeReference nodePointer) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        FileStatusManager fsm = FileStatusManager.getInstance(myProject);
        MPSNodesVirtualFileSystem nvfs = MPSNodesVirtualFileSystem.getInstance();
        SNode currentNode = nodePointer.resolve(MPSModuleRepository.getInstance());
        if (currentNode == null) {
          return;
        }
        statusChanged(fsm, nvfs, nodePointer);
      }
    });
  }

  protected void statusChanged(FileStatusManager fsm, MPSNodesVirtualFileSystem nvfs, SNodeReference nodePointer) {
    fsm.fileStatusChanged(nvfs.getFileFor(nodePointer));
  }

  private void updateNodeStatus(@NotNull final SNodeReference nodePointer) {
    myRegistry.getCommandQueue().runTask(new Runnable() {
      public void run() {
        if (calcStatus(nodePointer)) {
          statusChanged(nodePointer);
        }
      }
    });
  }

  private boolean calcStatus(@NotNull final SNodeReference root) {
    FileStatus status = ModelAccess.instance().runReadAction(new Computable<FileStatus>() {
      public FileStatus compute() {
        SModelDescriptor modelDescriptor = SModelRepository.getInstance().getModelDescriptor(root.getModelReference());
        if (modelDescriptor instanceof DefaultSModelDescriptor) {
          DefaultSModelDescriptor md = (DefaultSModelDescriptor) modelDescriptor;
          if (ConflictsUtil.isModelOrModuleConflicting(md, myProject)) {
            return FileStatus.MERGED_WITH_CONFLICTS;
          }
          CurrentDifference diff = myRegistry.getCurrentDifference(md);
          List<ModelChange> modelChanges = check_onkh7z_a0d0b0a0a0a0j(diff.getChangeSet());
          List<ModelChange> rootChanges = ListSequence.fromList(modelChanges).where(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange ch) {
              return root.getNodeId().equals(ch.getRootId());
            }
          }).toListSequence();
          if (ListSequence.fromList(rootChanges).count() != 0) {
            if (ListSequence.fromList(rootChanges).first() instanceof AddRootChange) {
              VirtualFile vf = VirtualFileUtils.getVirtualFile(md.getSource().getFile());
              if (vf != null) {
                FileStatus modelStatus = FileStatusManager.getInstance(myProject).getStatus(vf);
                if (BaseVersionUtil.isAddedFileStatus(modelStatus)) {
                  return modelStatus;
                }
              }
              return FileStatus.ADDED;
            }
            return FileStatus.MODIFIED;
          }
        }
        return FileStatus.NOT_CHANGED;
      }
    });
    synchronized (myFileStatusMap) {
      if (MapSequence.fromMap(myFileStatusMap).get(root) != status) {
        MapSequence.fromMap(myFileStatusMap).put(root, status);
        return true;
      } else {
        return false;
      }
    }
  }

  @Nullable
  public FileStatus getStatus(@NotNull final SNode root) {
    final Wrappers._T<SNodeReference> nodePointer = new Wrappers._T<SNodeReference>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        nodePointer.value = new jetbrains.mps.smodel.SNodePointer(root);
        myRegistry.getCommandQueue().runTask(new Runnable() {
          public void run() {
            ModelAccess.instance().runReadAction(new Runnable() {
              public void run() {
                SModelDescriptor modelDescriptor = null;
                if (!(SNodeOperations.isDisposed(root) || jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.getModel(root).isDisposed())) {
                  modelDescriptor = jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.getModel(root).getModelDescriptor();
                }
                if (modelDescriptor instanceof DefaultSModelDescriptor) {
                  myRegistry.getCurrentDifference((DefaultSModelDescriptor) modelDescriptor).setEnabled(true);
                }
              }
            });
          }
        });
      }
    });
    synchronized (myFileStatusMap) {
      return MapSequence.fromMap(myFileStatusMap).get(nodePointer.value);
    }
  }

  @Nullable
  public FileStatus getStatus(@NotNull SNodeReference nodePointer) {
    synchronized (myFileStatusMap) {
      return MapSequence.fromMap(myFileStatusMap).get(nodePointer);
    }
  }

  private class MyGlobalListener extends CurrentDifferenceAdapter {
    private List<SNodeReference> myAffectedRoots = ListSequence.fromList(new ArrayList<SNodeReference>());

    private MyGlobalListener() {
    }

    @Override
    public void changeUpdateFinished() {
      ListSequence.fromList(myAffectedRoots).visitAll(new IVisitor<SNodeReference>() {
        public void visit(SNodeReference np) {
          updateNodeStatus(np);
        }
      });
      ListSequence.fromList(myAffectedRoots).clear();
    }

    private void addAffectedRoot(@NotNull ModelChange change) {
      if (change.getRootId() != null) {
        ListSequence.fromList(myAffectedRoots).addElement(new jetbrains.mps.smodel.SNodePointer(change.getChangeSet().getNewModel().getSModelReference(), change.getRootId()));
      }
    }

    @Override
    public void changeAdded(@NotNull ModelChange change) {
      addAffectedRoot(change);
    }

    @Override
    public void changeRemoved(@NotNull ModelChange change) {
      addAffectedRoot(change);
    }
  }

  private static List<ModelChange> check_onkh7z_a0d0b0a0a0a0j(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
}
