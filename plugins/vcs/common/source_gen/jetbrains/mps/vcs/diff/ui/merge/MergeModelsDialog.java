package jetbrains.mps.vcs.diff.ui.merge;

/*Generated by MPS */

import com.intellij.openapi.ui.DialogWrapper;
import javax.swing.Icon;
import com.intellij.openapi.util.IconLoader;
import com.intellij.openapi.project.Project;
import jetbrains.mps.vcs.diff.merge.MergeSession;
import jetbrains.mps.vcs.diff.merge.MergeSessionState;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import jetbrains.mps.smodel.SNodeId;
import java.util.Set;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.actionSystem.ActionToolbar;
import jetbrains.mps.smodel.SModel;
import com.intellij.openapi.diff.DiffRequest;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.vcs.diff.ui.common.DiffTemporaryModule;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.vcs.diff.ui.MetadataUtil;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.Separator;
import jetbrains.mps.vcs.diff.ui.common.InvokeTextDiffAction;
import com.intellij.openapi.diff.impl.mergeTool.MergeTool;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import com.intellij.ui.ScrollPaneFactory;
import java.awt.Dimension;
import com.intellij.openapi.util.DimensionService;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.MetadataChange;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import javax.swing.Action;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import javax.swing.SwingUtilities;
import jetbrains.mps.vcs.diff.ui.common.DiffModelTree;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import javax.swing.JComponent;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.vcs.diff.ui.common.GoToNeighbourRootActions;
import javax.swing.event.TreeSelectionListener;
import javax.swing.event.TreeSelectionEvent;
import jetbrains.mps.workbench.action.BaseAction;
import java.util.Arrays;
import jetbrains.mps.vcs.diff.changes.ChangeType;
import com.intellij.ui.SimpleTextAttributes;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.vcs.diff.ui.common.ChangeColors;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.SModelDescriptor;

public class MergeModelsDialog extends DialogWrapper {
  public static final Icon APPLY_NON_CONFLICTS = IconLoader.getIcon("/diff/applyNotConflicts.png");
  public static final Icon RESET = IconLoader.getIcon("/actions/reset.png");
  private Project myProject;
  private MergeSession myMergeSession;
  private MergeSession myMetadataMergeSession;
  private MergeSessionState myInitialState;
  private MergeSessionState myMetadataInitialState;
  private MergeModelsDialog.MergeModelsTree myMergeTree;
  private JPanel myPanel = new JPanel(new BorderLayout());
  private boolean myApplyChanges = false;
  private MergeRootsDialog myMergeRootsDialog = null;
  private SNodeId myRootId;
  private String[] myContentTitles;
  private Set<ModelChange> myAppliedMetadataChanges = SetSequence.fromSet(new HashSet<ModelChange>());
  private ActionToolbar myToolbar;

  public MergeModelsDialog(final SModel baseModel, final SModel mineModel, final SModel repositoryModel, DiffRequest request) {
    super(request.getProject(), true);
    setTitle("Merging " + SModelOperations.getModelName(baseModel));
    myProject = request.getProject();
    myContentTitles = request.getContentTitles();
    assert myContentTitles.length == 3;
    myMergeSession = new MergeSession(baseModel, mineModel, repositoryModel);
    DiffTemporaryModule.setSModelId(myMergeSession.getResultModel(), "result");
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        myInitialState = myMergeSession.getCurrentState();
      }
    });
    if (ListSequence.fromList(myMergeSession.getMetadataChanges()).isNotEmpty()) {
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          SModel baseMetaModel = MetadataUtil.createMetadataModel(baseModel);
          SModel mineMetaModel = MetadataUtil.createMetadataModel(mineModel);
          SModel repoMetaModel = MetadataUtil.createMetadataModel(repositoryModel);
          myMetadataMergeSession = new MergeSession(baseMetaModel, mineMetaModel, repoMetaModel);
          DiffTemporaryModule.setSModelId(myMetadataMergeSession.getResultModel(), "result");
          myMetadataInitialState = myMetadataMergeSession.getCurrentState();
        }
      });
    }
    final jetbrains.mps.project.Project p = ProjectHelper.toMPSProject(myProject);
    DiffTemporaryModule.createModuleForModel(myMergeSession.getResultModel(), "result", p, true);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        DiffTemporaryModule.registerModel(myMergeSession.getResultModel(), p);
      }
    });
    myMergeSession.installResultModelListener();
    DiffTemporaryModule.createModuleForModel(mineModel, "mine", p);
    DiffTemporaryModule.createModuleForModel(repositoryModel, "repository", p);
    if (myMetadataMergeSession != null) {
      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getResultModel(), "result", p, true);
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          DiffTemporaryModule.registerModel(myMetadataMergeSession.getResultModel(), p);
        }
      });
      myMetadataMergeSession.installResultModelListener();
      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getMyModel(), "mine", p);
      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getRepositoryModel(), "repository", p);
    }

    myMergeTree = new MergeModelsDialog.MergeModelsTree();

    DefaultActionGroup actionGroup = ActionUtils.groupFromActions(new ResetState(this), new MergeNonConflictingRoots(this), Separator.getInstance(), AcceptYoursTheirs.yoursInstance(this), AcceptYoursTheirs.theirsInstance(this), Separator.getInstance(), new InvokeTextDiffAction("Merge as Text (Use Carefully!)", "Merge models using text merge for XML contents", this, request, new MergeTool()));
    myToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, actionGroup, true);
    myToolbar.updateActionsImmediately();
    myPanel.add(myToolbar.getComponent(), BorderLayout.NORTH);
    myPanel.add(ScrollPaneFactory.createScrollPane(myMergeTree), BorderLayout.CENTER);
    final Dimension size = DimensionService.getInstance().getSize(getDimensionServiceKey());
    if (size == null) {
      myPanel.setPreferredSize(new Dimension(500, 450));
    }
    init();
  }

  public String getDimensionServiceKey() {
    return getClass().getName();
  }

  protected void doOKAction() {
    MergeConfirmation.showMergeConfirmationAndTakeAction(this, myMergeSession, Sequence.fromIterable(myMergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(ch instanceof MetadataChange);
      }
    }), myMetadataMergeSession, (myMetadataMergeSession == null ?
      null :
      myMetadataMergeSession.getAllChanges()
    ), new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        mergeNonConflictingRoots();
      }
    }, new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        myApplyChanges = true;
        close(OK_EXIT_CODE);
      }
    });
  }

  protected Action[] createActions() {
    List<Action> actions = ListSequence.fromList(new ArrayList<Action>());
    ListSequence.fromList(actions).addElement(getOKAction());
    ListSequence.fromList(actions).addElement(getCancelAction());
    return ListSequence.fromList(actions).toGenericArray(Action.class);
  }

  public SModel getResultModel() {
    return (myApplyChanges ?
      myMergeSession.getResultModel() :
      null
    );
  }

  public SModel getResultModelWithFixedId() {
    if (!(myApplyChanges)) {
      return null;
    }
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        DiffTemporaryModule.resetSModelId(myMergeSession.getResultModel());
      }
    });
    return myMergeSession.getResultModel();
  }

  public void unregisterResultModel() {
    final SModel resultModel = myMergeSession.getResultModel();
    assert check_3qqb0l_a0b0v(check_3qqb0l_a0a1a12(resultModel)) instanceof DiffTemporaryModule;
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        DiffTemporaryModule.unregisterModel(resultModel, ProjectHelper.toMPSProject(myProject));
      }
    });
    if (myMetadataMergeSession != null) {
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          DiffTemporaryModule.unregisterModel(myMetadataMergeSession.getResultModel(), ProjectHelper.toMPSProject(myProject));
        }
      });
    }
  }

  /*package*/ void rebuildLater() {
    myToolbar.updateActionsImmediately();
    myMergeTree.rebuildLater();
  }

  /*package*/ Project getProject() {
    return myProject;
  }

  @Nullable
  public SNodeId getNeighbourRoot(@NotNull SNodeId rootId, boolean next) {
    return myMergeTree.getNeighbourRoot(rootId, next);
  }

  public void invokeMergeRoots(@Nullable final SNodeId rootId) {
    if (myMergeRootsDialog != null) {
      return;
    }

    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        MergeSession mergeSession = (rootId == null ?
          myMetadataMergeSession :
          myMergeSession
        );
        SNodeId nodeId = (rootId == null ?
          ListSequence.fromList(SModelOperations.getRoots(myMetadataMergeSession.getBaseModel(), null)).first().getSNodeId() :
          rootId
        );

        myRootId = rootId;
        myMergeRootsDialog = new MergeRootsDialog(myProject, mergeSession, nodeId, myMergeTree.getNameForRoot(rootId), getContentTitles(), getWindow(), new MergeModelsDialog.MyGoToNeighbourRootActions().getActions());
      }
    });
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        myMergeRootsDialog.toFront();
      }
    });
    boolean isOk = myMergeRootsDialog.showAndGet();
    if (!(isOk)) {
      ModelAccess.instance().runWriteActionInCommand(new Runnable() {
        public void run() {
          myMergeRootsDialog.restoreState();
        }
      });
    }
    applyMetadataChanges();
    myMergeRootsDialog = null;
    rebuildLater();
  }

  public void setCurrentRoot(@Nullable final SNodeId rootId) {
    assert myMergeRootsDialog != null;
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        myRootId = rootId;
        if (rootId == null) {
          myMergeRootsDialog.setRoodId(Sequence.fromIterable(myMetadataMergeSession.getAffectedRoots()).first(), myMergeTree.getNameForRoot(rootId), myMetadataMergeSession);
        } else {
          myMergeRootsDialog.setRoodId(rootId, myMergeTree.getNameForRoot(rootId), myMergeSession);
        }
      }
    });
  }

  @Nullable
  public SNodeId getCurrentRoot() {
    return myRootId;
  }

  public Iterable<ModelChange> getApplicableChangesInNonConflictingRoots() {
    return Sequence.fromIterable(myMergeSession.getApplicableChangesInNonConflictingRoots()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange it) {
        return !(it instanceof MetadataChange);
      }
    });
  }

  public Iterable<ModelChange> getApplicableChangesInMetadata() {
    return myMetadataMergeSession.getApplicableChangesInNonConflictingRoots();
  }

  public void mergeNonConflictingRoots() {
    myMergeSession.applyChanges(getApplicableChangesInNonConflictingRoots());
    if (myMetadataMergeSession != null) {
      myMetadataMergeSession.applyChanges(getApplicableChangesInMetadata());
      applyMetadataChanges();
    }
  }

  public boolean hasNonConflictingRoots() {
    return Sequence.fromIterable(getApplicableChangesInNonConflictingRoots()).isNotEmpty() || myMetadataMergeSession != null && Sequence.fromIterable(getApplicableChangesInMetadata()).isNotEmpty();
  }

  public boolean isAcceptYoursTheirsEnabled() {
    return Sequence.fromIterable(getModelChangesForSelection()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(myMergeSession.isChangeResolved(ch));
      }
    }).isNotEmpty() || isMetadataSelected() && Sequence.fromIterable(myMetadataMergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(myMetadataMergeSession.isChangeResolved(ch));
      }
    }).isNotEmpty();
  }

  public void acceptVersionForSelectedRoots(boolean mine) {
    applyUnresolvedChanges(myMergeSession, getModelChangesForSelection(), mine);
    if (isMetadataSelected()) {
      applyUnresolvedChanges(myMetadataMergeSession, myMetadataMergeSession.getAllChanges(), mine);
      applyMetadataChanges();
    }
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        myMergeTree.rebuildNow();
      }
    });
  }

  private void applyMetadataChanges() {
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        if (myMetadataMergeSession != null) {
          MetadataUtil.applyMetadataChanges(myMergeSession.getResultModel(), myMetadataMergeSession.getResultModel());
        }
      }
    });
  }

  private boolean isMetadataSelected() {
    return myMergeTree.getSelectedNodes(DiffModelTree.MetadataTreeNode.class, null).length == 1 || myMergeTree.getSelectedNodes(DiffModelTree.ModelTreeNode.class, null).length == 1;
  }

  private Iterable<ModelChange> getModelChangesForSelection() {
    if (myMergeTree.getSelectedNodes(DiffModelTree.ModelTreeNode.class, null).length == 1) {
      return Sequence.fromIterable(myMergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return !(ch instanceof MetadataChange);
        }
      });
    } else {
      return Sequence.fromIterable(Sequence.fromArray(myMergeTree.getSelectedNodes(DiffModelTree.RootTreeNode.class, null))).select(new ISelector<DiffModelTree.RootTreeNode, SNodeId>() {
        public SNodeId select(DiffModelTree.RootTreeNode rtn) {
          return rtn.getRootId();
        }
      }).where(new IWhereFilter<SNodeId>() {
        public boolean accept(SNodeId root) {
          return root != null;
        }
      }).translate(new ITranslator2<SNodeId, ModelChange>() {
        public Iterable<ModelChange> translate(SNodeId root) {
          return myMergeSession.getChangesForRoot(root);
        }
      });
    }
  }

  private void applyUnresolvedChanges(final MergeSession session, Iterable<ModelChange> changes, boolean mine) {
    final List<ModelChange> changesToApply = ListSequence.fromList(new ArrayList<ModelChange>());
    final List<ModelChange> changesToExclude = ListSequence.fromList(new ArrayList<ModelChange>());
    for (ModelChange change : Sequence.fromIterable(changes).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(session.isChangeResolved(ch));
      }
    })) {
      if (mine == session.isMyChange(change)) {
        ListSequence.fromList(changesToApply).addElement(change);
      } else {
        ListSequence.fromList(changesToExclude).addElement(change);
      }
    }
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        session.applyChanges(changesToApply);
        session.excludeChanges(changesToExclude);
      }
    });
  }

  /*package*/ void markMetadataChangesAsApplied(Iterable<ModelChange> changes) {
    SetSequence.fromSet(myAppliedMetadataChanges).addSequence(Sequence.fromIterable(changes));
  }

  /*package*/ void rootsDialogClosed() {
    myMergeRootsDialog = null;
  }

  /*package*/ String[] getContentTitles() {
    return myContentTitles;
  }

  /*package*/ MergeSession getMergeSession() {
    return myMergeSession;
  }

  public void resetState() {
    myMergeSession.restoreState(myInitialState);
    if (myMetadataMergeSession != null) {
      myMetadataMergeSession.restoreState(myMetadataInitialState);
    }
    rebuildLater();
  }

  @Nullable
  protected JComponent createCenterPanel() {
    return myPanel;
  }

  /*package*/ static String generateUnresolvedChangesText(int totalChanges, int conflictingChanges) {
    if (conflictingChanges != 0) {
      String text = NameUtil.formatNumericalString(conflictingChanges, "conficting change");
      if (totalChanges == conflictingChanges) {
        return text;
      } else {
        return text + " of " + totalChanges + " total";
      }
    } else {
      if (totalChanges == 0) {
        return "All changes resolved";
      } else {
        return NameUtil.formatNumericalString(totalChanges, " change");
      }
    }
  }

  private class MyGoToNeighbourRootActions extends GoToNeighbourRootActions.GoToByTree {
    public MyGoToNeighbourRootActions() {
      super(myMergeTree);
    }

    @Nullable
    protected SNodeId getCurrentNodeId() {
      return getCurrentRoot();
    }

    public void setCurrentNodeId(@Nullable SNodeId nodeId) {
      setCurrentRoot(nodeId);
    }
  }

  private class MergeModelsTree extends DiffModelTree {
    private MergeModelsTree() {
      super(DiffTemporaryModule.getOperationContext(myProject, myMergeSession.getResultModel()));
      addTreeSelectionListener(new TreeSelectionListener() {
        public void valueChanged(TreeSelectionEvent event) {
          myToolbar.updateActionsImmediately();
        }
      });
    }

    protected Iterable<BaseAction> getRootActions() {
      MergeModelsDialog md = MergeModelsDialog.this;
      return Arrays.<BaseAction>asList(new InvokeMergeRootsAction(md), AcceptYoursTheirs.yoursInstance(md), AcceptYoursTheirs.theirsInstance(md));
    }

    protected void updateRootCustomPresentation(@NotNull DiffModelTree.RootTreeNode rootTreeNode) {
      final MergeSession session = (rootTreeNode.getRootId() == null ?
        myMetadataMergeSession :
        myMergeSession
      );
      List<ModelChange> changes = Sequence.fromIterable(((rootTreeNode.getRootId() == null ?
        myMetadataMergeSession.getAllChanges() :
        myMergeSession.getChangesForRoot(rootTreeNode.getRootId())
      ))).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return !(session.isChangeResolved(ch));
        }
      }).toListSequence();

      int conflictedCount = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return Sequence.fromIterable(session.getConflictedWith(ch)).isNotEmpty();
        }
      }).count();
      int nonConflictedCount = ListSequence.fromList(changes).count() - conflictedCount;
      ChangeType compositeChangeType = null;
      rootTreeNode.setTooltipText(generateUnresolvedChangesText(ListSequence.fromList(changes).count(), conflictedCount));
      if (conflictedCount != 0) {
        compositeChangeType = ChangeType.CONFLICTED;
        rootTreeNode.setAdditionalText("with conflicts");
      } else {
        if (nonConflictedCount == 0) {
          if (rootTreeNode.getRootId() != null && myMergeSession.getResultModel().getNodeById(rootTreeNode.getRootId()) == null) {
            rootTreeNode.setTextStyle(SimpleTextAttributes.STYLE_STRIKEOUT);
          }
        } else {
          compositeChangeType = ChangeType.CHANGE;
          if (ListSequence.fromList(changes).all(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange ch) {
              return ch instanceof AddRootChange || ch instanceof DeleteRootChange;
            }
          })) {
            compositeChangeType = ListSequence.fromList(changes).first().getType();
          }

          int myChangesCount = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange ch) {
              return session.isMyChange(ch);
            }
          }).count();
          if (myChangesCount == nonConflictedCount) {
            rootTreeNode.setAdditionalText("local");
          } else if (myChangesCount == 0) {
            rootTreeNode.setAdditionalText("remote");
          } else {
            rootTreeNode.setAdditionalText("both modified");
          }
        }
      }

      if (compositeChangeType != null) {
        rootTreeNode.setColor(ChangeColors.getForTree(compositeChangeType));
      }
    }

    protected Iterable<SModel> getModels() {
      return Arrays.asList(myMergeSession.getBaseModel(), myMergeSession.getMyModel(), myMergeSession.getRepositoryModel());
    }

    protected Iterable<SNodeId> getAffectedRoots() {
      return myMergeSession.getAffectedRoots();
    }

    @Override
    protected boolean isMultipleRootNames() {
      return true;
    }
  }

  private static IModule check_3qqb0l_a0b0v(SModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }

  private static SModelDescriptor check_3qqb0l_a0a1a12(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }
}
