package jetbrains.mps.vcs.diff.ui.merge;

/*Generated by MPS */

import com.intellij.openapi.ui.DialogWrapper;
import javax.swing.Icon;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.project.Project;
import jetbrains.mps.vcs.diff.merge.MergeSession;
import jetbrains.mps.vcs.diff.merge.MergeSessionState;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.mps.openapi.model.SModel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import com.intellij.ui.JBSplitter;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.diff.ex.DiffStatusBar;
import com.intellij.openapi.diff.impl.util.TextDiffType;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import jetbrains.mps.vcs.diff.ui.common.GoToNeighbourRootActions;
import java.util.Set;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.diff.DiffRequest;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.vcs.diff.ui.common.DiffModelUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.vcs.diff.ui.MetadataUtil;
import jetbrains.mps.workbench.action.ActionUtils;
import jetbrains.mps.vcs.diff.ui.common.InvokeTextDiffAction;
import com.intellij.openapi.diff.impl.mergeTool.MergeTool;
import com.intellij.openapi.actionSystem.Separator;
import org.jetbrains.annotations.Nullable;
import com.intellij.ui.ScrollPaneFactory;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import java.awt.Dimension;
import com.intellij.openapi.util.DimensionService;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.MetadataChange;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.annotations.NotNull;
import javax.swing.Action;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.util.Computable;
import jetbrains.mps.vcs.diff.merge.MergeTemporaryModel;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.vcs.diff.ui.common.DiffModelTree;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.util.NameUtil;
import javax.swing.event.TreeSelectionListener;
import javax.swing.event.TreeSelectionEvent;
import jetbrains.mps.workbench.action.BaseAction;
import java.util.Arrays;
import jetbrains.mps.vcs.diff.changes.ChangeType;
import com.intellij.ui.SimpleTextAttributes;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.vcs.diff.ui.common.ChangeColors;

public class MergeModelsDialog extends DialogWrapper {
  public static final Icon APPLY_NON_CONFLICTS = AllIcons.Diff.ApplyNotConflicts;
  public static final Icon RESET = AllIcons.Actions.Rollback;

  private Project myProject;
  private MergeSession myMergeSession;
  private MergeSession myMetadataMergeSession;
  private MergeSessionState myInitialState;
  private MergeSessionState myMetadataInitialState;
  private SNodeId myRootId;

  private ISaveMergedModel mySaver = new ISaveMergedModel() {
    public boolean save(MergeModelsDialog dialog, SModel resultModel) {
      return false;
    }
  };

  private MergeModelsDialog.MergeModelsTree myMergeTree;
  private JPanel myComponent = new JPanel(new BorderLayout());
  private JBSplitter myPanel = new JBSplitter(true, 0.25f);
  private MergeRootsPane myMergeRootsPane = null;
  private final JComponent myNoRootPanel = new JLabel("Select root to merge", SwingConstants.CENTER);
  private ActionToolbar myToolbar;
  private DiffStatusBar myStatusBar = new DiffStatusBar(TextDiffType.DIFF_TYPES);

  private DefaultActionGroup myActionGroup;
  private GoToNeighbourRootActions myGoToNeighbourRootActions;

  private String[] myContentTitles;
  private Set<ModelChange> myAppliedMetadataChanges = SetSequence.fromSet(new HashSet<ModelChange>());

  public MergeModelsDialog(final SModel baseModel, final SModel mineModel, final SModel repoModel, DiffRequest request) {
    super(request.getProject(), true);
    setTitle("Merging " + SModelOperations.getModelName(baseModel));
    myProject = request.getProject();
    myContentTitles = request.getContentTitles();
    assert myContentTitles.length == 3;
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        myMergeSession = MergeSession.createMergeSession(baseModel, mineModel, repoModel);
        myInitialState = myMergeSession.getCurrentState();
      }
    });
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        DiffModelUtil.renameModelAndRegister(myMergeSession.getBaseModel(), "base");
        DiffModelUtil.renameModelAndRegister(myMergeSession.getMyModel(), "mine");
        DiffModelUtil.renameModelAndRegister(myMergeSession.getRepositoryModel(), "repo");
        DiffModelUtil.renameModelAndRegister(myMergeSession.getResultModel(), "result");
      }
    });
    if (ListSequence.fromList(myMergeSession.getMetadataChanges()).isNotEmpty()) {
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          SModel baseMetaModel = MetadataUtil.createMetadataModel(myMergeSession.getBaseModel(), "metadata_base", false);
          SModel mineMetaModel = MetadataUtil.createMetadataModel(myMergeSession.getMyModel(), "metadata_mine", false);
          SModel repoMetaModel = MetadataUtil.createMetadataModel(myMergeSession.getRepositoryModel(), "metadata_repo", false);
          myMetadataMergeSession = MergeSession.createMergeSession(baseMetaModel, mineMetaModel, repoMetaModel);
          myMetadataInitialState = myMetadataMergeSession.getCurrentState();
          DiffModelUtil.renameModelAndRegister(myMetadataMergeSession.getResultModel(), "result");
        }
      });
    }

    myMergeSession.installResultModelListener();

    myActionGroup = ActionUtils.groupFromActions(new InvokeTextDiffAction("Merge as Text (Use Carefully!)", "Merge models using text merge for XML contents", this, request, new MergeTool()), Separator.getInstance(), new ResetState(this), new MergeNonConflictingRoots(this), Separator.getInstance(), AcceptYoursTheirs.yoursInstance(this), AcceptYoursTheirs.theirsInstance(this));

    init();
  }

  public void setSaver(ISaveMergedModel saver) {
    mySaver = saver;
  }

  protected boolean saveModel(SModel resultModel) {
    return mySaver.save(this, resultModel);
  }

  @Nullable
  @Override
  protected JComponent createCenterPanel() {
    myPanel.setSplitterProportionKey(getClass().getName() + "ModelTreeSplitter");
    myMergeTree = new MergeModelsDialog.MergeModelsTree();
    myPanel.setFirstComponent(ScrollPaneFactory.createScrollPane(myMergeTree));
    myPanel.setSecondComponent(myNoRootPanel);

    myGoToNeighbourRootActions = new MergeModelsDialog.MyGoToNeighbourRootActions();
    myGoToNeighbourRootActions.previous().registerCustomShortcutSet(GoToNeighbourRootActions.PREV_ROOT_SHORTCUT, myComponent);
    myGoToNeighbourRootActions.next().registerCustomShortcutSet(GoToNeighbourRootActions.NEXT_ROOT_SHORTCUT, myComponent);

    myToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, myActionGroup, true);
    myToolbar.updateActionsImmediately();

    myComponent.add(myToolbar.getComponent(), BorderLayout.NORTH);
    myComponent.add(myPanel, BorderLayout.CENTER);
    myComponent.add(myStatusBar, BorderLayout.SOUTH);

    final Dimension size = DimensionService.getInstance().getSize(getDimensionServiceKey());
    if (size == null) {
      myComponent.setPreferredSize(new Dimension(500, 450));
    }

    return myComponent;
  }
  @Override
  public String getDimensionServiceKey() {
    return getClass().getName();
  }
  @Nullable
  @Override
  public JComponent getPreferredFocusedComponent() {
    return myMergeTree;
  }
  @Override
  protected void doOKAction() {
    applyMetadataChanges();

    MergeConfirmation.showMergeConfirmationAndTakeAction(this, myMergeSession, Sequence.fromIterable(myMergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(ch instanceof MetadataChange);
      }
    }), myMetadataMergeSession, (myMetadataMergeSession == null ? null : myMetadataMergeSession.getAllChanges()), new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        mergeNonConflictingRoots();
      }
    }, new _FunctionTypes._void_P0_E0() {
      public void invoke() {

        if (saveModel(getResultModelWithFixedId())) {
          unregisterModels();
          close(OK_EXIT_CODE);
        }

      }
    });
  }
  @Override
  @NotNull
  protected Action[] createActions() {
    List<Action> actions = ListSequence.fromList(new ArrayList<Action>());
    ListSequence.fromList(actions).addElement(getOKAction());
    ListSequence.fromList(actions).addElement(getCancelAction());
    return ListSequence.fromList(actions).toGenericArray(Action.class);
  }
  @Override
  protected void dispose() {
    if (myMergeRootsPane != null) {
      myMergeRootsPane.dispose();
    }
    super.dispose();
  }

  private SModel getResultModelWithFixedId() {
    SModel resultModel = ModelAccess.instance().runReadAction(new Computable<MergeTemporaryModel>() {
      public MergeTemporaryModel compute() {
        // copy to avoid problems with de-registration 
        jetbrains.mps.smodel.SModel resModel = CopyUtil.copyModel(as_3qqb0l_a0a0a1a0a0a0a0a0nb(myMergeSession.getResultModel(), SModelBase.class).getSModelInternal());
        return new MergeTemporaryModel(resModel, false);
      }
    });
    DiffModelUtil.restoreModelName(resultModel);
    // fix??? 
    for (SModel m : new SModel[]{myMergeSession.getMyModel(), myMergeSession.getRepositoryModel()}) {
      DiffModelUtil.fixModelReferences(resultModel, m.getReference());
    }
    return resultModel;
  }
  private void unregisterModels() {
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        if (myMetadataMergeSession != null) {
          DiffModelUtil.unregisterModel(myMetadataMergeSession.getResultModel());
          MetadataUtil.dispose(myMetadataMergeSession.getRepositoryModel());
          MetadataUtil.dispose(myMetadataMergeSession.getMyModel());
          MetadataUtil.dispose(myMetadataMergeSession.getBaseModel());
        }
        DiffModelUtil.unregisterModel(myMergeSession.getResultModel());
        DiffModelUtil.unregisterModel(myMergeSession.getRepositoryModel());
        DiffModelUtil.unregisterModel(myMergeSession.getMyModel());
        DiffModelUtil.unregisterModel(myMergeSession.getBaseModel());
      }
    });
  }
  /*package*/ void rebuildLater() {
    myToolbar.updateActionsImmediately();
    myMergeTree.rebuildLater();
  }
  /*package*/ Project getProject() {
    return myProject;
  }
  @Nullable
  public SNodeId getNeighbourRoot(@NotNull SNodeId rootId, boolean next) {
    return myMergeTree.getNeighbourRoot(rootId, next);
  }

  public void resetCurrentRoot() {
    if (myMergeRootsPane == null) {
      return;
    }

    myMergeRootsPane.unregisterShortcuts(myComponent);
    myPanel.setSecondComponent(myNoRootPanel);
    myMergeRootsPane.dispose();
    myMergeRootsPane = null;
    myRootId = null;
    myStatusBar.setText("");
    applyMetadataChanges();
  }
  private void changeCurrentRoot(@Nullable final SNodeId rootId) {
    if (myMergeRootsPane != null && myRootId == rootId) {
      return;
    }
    applyMetadataChanges();

    myRootId = rootId;
    final MergeSession session = (rootId == null ? myMetadataMergeSession : myMergeSession);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        SNodeId nodeId = (rootId == null ? Sequence.fromIterable(myMetadataMergeSession.getAffectedRoots()).first() : rootId);
        if (myMergeRootsPane == null) {
          myMergeRootsPane = new MergeRootsPane(myProject, session, nodeId, myMergeTree.getNameForRoot(rootId), myContentTitles, myStatusBar);
          DefaultActionGroup actionGroup = new DefaultActionGroup();
          actionGroup.addAll(myMergeRootsPane.getActions());
          ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, actionGroup, true);
          myMergeRootsPane.registerShortcuts(myComponent);
          JPanel panel = new JPanel(new BorderLayout());
          panel.add(toolbar.getComponent(), BorderLayout.NORTH);
          panel.add(myMergeRootsPane.getPanel(), BorderLayout.CENTER);
          myPanel.setSecondComponent(panel);
        } else {
          myMergeRootsPane.setRoodId(nodeId, session);
        }
      }
    });
  }
  public void setCurrentRoot(@Nullable SNodeId rootId) {
    myMergeTree.setSelected(rootId);
    changeCurrentRoot(rootId);
  }
  @Nullable
  public SNodeId getCurrentRoot() {
    return myRootId;
  }

  public Iterable<ModelChange> getApplicableChangesInNonConflictingRoots() {
    return Sequence.fromIterable(myMergeSession.getApplicableChangesInNonConflictingRoots()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange it) {
        return !(it instanceof MetadataChange);
      }
    });
  }
  public Iterable<ModelChange> getApplicableChangesInMetadata() {
    return myMetadataMergeSession.getApplicableChangesInNonConflictingRoots();
  }

  public void mergeNonConflictingRoots() {
    myMergeSession.applyChanges(getApplicableChangesInNonConflictingRoots());
    if (myMetadataMergeSession != null) {
      myMetadataMergeSession.applyChanges(getApplicableChangesInMetadata());
      applyMetadataChanges();
    }
  }
  public boolean hasNonConflictingRoots() {
    return Sequence.fromIterable(getApplicableChangesInNonConflictingRoots()).isNotEmpty() || myMetadataMergeSession != null && Sequence.fromIterable(getApplicableChangesInMetadata()).isNotEmpty();
  }
  public boolean isAcceptYoursTheirsEnabled() {
    return Sequence.fromIterable(getModelChangesForSelection()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(myMergeSession.isChangeResolved(ch));
      }
    }).isNotEmpty() || myMetadataMergeSession != null && isMetadataSelected() && Sequence.fromIterable(myMetadataMergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(myMetadataMergeSession.isChangeResolved(ch));
      }
    }).isNotEmpty();
  }
  public void acceptVersionForSelectedRoots(boolean mine) {
    applyUnresolvedChanges(myMergeSession, getModelChangesForSelection(), mine);
    if (myMetadataMergeSession != null && isMetadataSelected()) {
      applyUnresolvedChanges(myMetadataMergeSession, myMetadataMergeSession.getAllChanges(), mine);
      applyMetadataChanges();
    }
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        myMergeTree.rebuildNow();
      }
    });
  }
  private void applyMetadataChanges() {
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        if (myMetadataMergeSession != null) {
          MetadataUtil.applyMetadataChanges(myMergeSession.getResultModel(), myMetadataMergeSession.getResultModel());
        }
      }
    });
  }
  private boolean isMetadataSelected() {
    return myMergeTree.getSelectedNodes(DiffModelTree.MetadataTreeNode.class, null).length == 1 || myMergeTree.getSelectedNodes(DiffModelTree.ModelTreeNode.class, null).length == 1;
  }
  private Iterable<ModelChange> getModelChangesForSelection() {
    if (myMergeTree.getSelectedNodes(DiffModelTree.ModelTreeNode.class, null).length == 1) {
      return Sequence.fromIterable(myMergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return !(ch instanceof MetadataChange);
        }
      });
    } else {
      return Sequence.fromIterable(Sequence.fromArray(myMergeTree.getSelectedNodes(DiffModelTree.RootTreeNode.class, null))).select(new ISelector<DiffModelTree.RootTreeNode, SNodeId>() {
        public SNodeId select(DiffModelTree.RootTreeNode rtn) {
          return rtn.getRootId();
        }
      }).where(new IWhereFilter<SNodeId>() {
        public boolean accept(SNodeId root) {
          return root != null;
        }
      }).translate(new ITranslator2<SNodeId, ModelChange>() {
        public Iterable<ModelChange> translate(SNodeId root) {
          return myMergeSession.getChangesForRoot(root);
        }
      });
    }
  }
  private void applyUnresolvedChanges(final MergeSession session, Iterable<ModelChange> changes, boolean mine) {
    final List<ModelChange> changesToApply = ListSequence.fromList(new ArrayList<ModelChange>());
    final List<ModelChange> changesToExclude = ListSequence.fromList(new ArrayList<ModelChange>());
    for (ModelChange change : Sequence.fromIterable(changes).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(session.isChangeResolved(ch));
      }
    })) {
      if (mine == session.isMyChange(change)) {
        ListSequence.fromList(changesToApply).addElement(change);
      } else {
        ListSequence.fromList(changesToExclude).addElement(change);
      }
    }
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        session.applyChanges(changesToApply);
        session.excludeChanges(changesToExclude);
      }
    });
  }
  /*package*/ void markMetadataChangesAsApplied(Iterable<ModelChange> changes) {
    SetSequence.fromSet(myAppliedMetadataChanges).addSequence(Sequence.fromIterable(changes));
  }

  /*package*/ String[] getContentTitles() {
    return myContentTitles;
  }
  /*package*/ MergeSession getMergeSession() {
    return myMergeSession;
  }
  public void resetState() {
    myMergeSession.restoreState(myInitialState);
    if (myMetadataMergeSession != null) {
      myMetadataMergeSession.restoreState(myMetadataInitialState);
    }
    rebuildLater();
  }

  /*package*/ static String generateUnresolvedChangesText(int totalChanges, int conflictingChanges) {
    if (conflictingChanges != 0) {
      String text = NameUtil.formatNumericalString(conflictingChanges, "conficting change");
      if (totalChanges == conflictingChanges) {
        return text;
      } else {
        return text + " of " + totalChanges + " total";
      }
    } else {
      if (totalChanges == 0) {
        return "All changes resolved";
      } else {
        return NameUtil.formatNumericalString(totalChanges, " change");
      }
    }
  }

  private class MyGoToNeighbourRootActions extends GoToNeighbourRootActions.GoToByTree {
    public MyGoToNeighbourRootActions() {
      super(myMergeTree);
    }
    @Nullable
    @Override
    protected SNodeId getCurrentNodeId() {
      return getCurrentRoot();
    }
    @Override
    public void setCurrentNodeId(@Nullable SNodeId nodeId) {
      setCurrentRoot(nodeId);
    }
  }

  private class MergeModelsTree extends DiffModelTree {
    private MergeModelsTree() {
      addTreeSelectionListener(new TreeSelectionListener() {
        @Override
        public void valueChanged(TreeSelectionEvent event) {
          myToolbar.updateActionsImmediately();
        }
      });
    }
    @Override
    protected Iterable<BaseAction> getRootActions() {
      MergeModelsDialog md = MergeModelsDialog.this;
      return Arrays.<BaseAction>asList(AcceptYoursTheirs.yoursInstance(md), AcceptYoursTheirs.theirsInstance(md));
    }
    @Override
    protected void updateRootCustomPresentation(@NotNull DiffModelTree.RootTreeNode rootTreeNode) {
      final MergeSession session = (rootTreeNode.getRootId() == null ? myMetadataMergeSession : myMergeSession);
      List<ModelChange> changes = Sequence.fromIterable(((rootTreeNode.getRootId() == null ? myMetadataMergeSession.getAllChanges() : myMergeSession.getChangesForRoot(rootTreeNode.getRootId())))).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return !(session.isChangeResolved(ch));
        }
      }).toListSequence();

      int conflictedCount = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return Sequence.fromIterable(session.getConflictedWith(ch)).isNotEmpty();
        }
      }).count();
      int nonConflictedCount = ListSequence.fromList(changes).count() - conflictedCount;
      ChangeType compositeChangeType = null;
      rootTreeNode.setTooltipText(generateUnresolvedChangesText(ListSequence.fromList(changes).count(), conflictedCount));
      if (conflictedCount != 0) {
        compositeChangeType = ChangeType.CONFLICTED;
        rootTreeNode.setAdditionalText("with conflicts");
      } else {
        if (nonConflictedCount == 0) {
          if (rootTreeNode.getRootId() != null && myMergeSession.getResultModel().getNode(rootTreeNode.getRootId()) == null) {
            rootTreeNode.setTextStyle(SimpleTextAttributes.STYLE_STRIKEOUT);
          } else {
            rootTreeNode.setAdditionalText(null);
          }
        } else {
          compositeChangeType = ChangeType.CHANGE;
          if (ListSequence.fromList(changes).all(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange ch) {
              return ch instanceof AddRootChange || ch instanceof DeleteRootChange;
            }
          })) {
            compositeChangeType = ListSequence.fromList(changes).first().getType();
          }

          int myChangesCount = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange ch) {
              return session.isMyChange(ch);
            }
          }).count();
          if (myChangesCount == nonConflictedCount) {
            rootTreeNode.setAdditionalText("local");
          } else if (myChangesCount == 0) {
            rootTreeNode.setAdditionalText("remote");
          } else {
            rootTreeNode.setAdditionalText("both modified");
          }
        }
      }

      rootTreeNode.setColor((compositeChangeType == null ? null : ChangeColors.getForTree(compositeChangeType)));
    }
    @Override
    protected Iterable<SModel> getModels() {
      return Arrays.asList(myMergeSession.getBaseModel(), myMergeSession.getMyModel(), myMergeSession.getRepositoryModel());
    }
    @Override
    protected Iterable<SNodeId> getAffectedRoots() {
      return myMergeSession.getAffectedRoots();
    }
    @Override
    protected boolean isMultipleRootNames() {
      return true;
    }

    @Override
    protected void onUnselect() {
      resetCurrentRoot();
    }
    @Override
    protected void onSelectRoot(@Nullable SNodeId rootId) {
      changeCurrentRoot(rootId);
    }
  }
  private static <T> T as_3qqb0l_a0a0a1a0a0a0a0a0nb(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
