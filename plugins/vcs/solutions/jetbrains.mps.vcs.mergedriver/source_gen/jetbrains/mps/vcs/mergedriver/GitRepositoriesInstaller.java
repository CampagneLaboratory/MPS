package jetbrains.mps.vcs.mergedriver;

/*Generated by MPS */

import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Scanner;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.io.PrintWriter;
import java.io.IOException;
import com.intellij.openapi.vcs.VcsRoot;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import com.intellij.openapi.ui.Messages;
import jetbrains.mps.util.NameUtil;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class GitRepositoriesInstaller {
  private GitRepositoriesInstaller() {
  }

  private static boolean install(VirtualFile path, boolean dryRun) {
    VirtualFile attributesFile = path.findChild(".gitattributes");
    if (attributesFile == null || attributesFile.isDirectory()) {
      return false;
    }
    try {
      final Wrappers._T<List<String>> lines = new Wrappers._T<List<String>>(ListSequence.fromList(new ArrayList<String>()));
      if (attributesFile.exists()) {
        final Scanner sc = new Scanner(attributesFile.getInputStream());
        lines.value = Sequence.fromIterable(new _FunctionTypes._return_P0_E0<Iterable<String>>() {
          public Iterable<String> invoke() {
            return new Iterable<String>() {
              public Iterator<String> iterator() {
                return new YieldingIterator<String>() {
                  private int __CP__ = 0;

                  protected boolean moveToNext() {
__loop__:
                    do {
__switch__:
                      switch (this.__CP__) {
                        case -1:
                          assert false : "Internal error";
                          return false;
                        case 2:
                          if (sc.hasNextLine()) {
                            this.__CP__ = 3;
                            break;
                          }
                          this.__CP__ = 1;
                          break;
                        case 4:
                          this.__CP__ = 2;
                          this.yield(((String) sc.nextLine()));
                          return true;
                        case 0:
                          this.__CP__ = 2;
                          break;
                        case 3:
                          this.__CP__ = 4;
                          break;
                        default:
                          break __loop__;
                      }
                    } while (true);
                    return false;
                  }
                };
              }
            };
          }
        }.invoke()).toListSequence();
        sc.close();
      }

      List<String> extensions = ListSequence.fromListAndArray(new ArrayList<String>(), "mps", "mpl", "msd");
      if (dryRun) {
        return ListSequence.fromList(extensions).all(new IWhereFilter<String>() {
          public boolean accept(final String ext) {
            return ListSequence.fromList(lines.value).any(new IWhereFilter<String>() {
              public boolean accept(String line) {
                return line.matches("\\s*\\*\\." + ext + ".+merge=mps\\s*");
              }
            });
          }
        });
      }
      ListSequence.fromList(extensions).visitAll(new IVisitor<String>() {
        public void visit(String ext) {
          boolean updated = false;
          for (int i = 0; i < ListSequence.fromList(lines.value).count(); i++) {
            if (ListSequence.fromList(lines.value).getElement(i).matches("\\s*\\*\\." + ext + ".*") && !(ListSequence.fromList(lines.value).getElement(i).contains("merge=mps"))) {
              ListSequence.fromList(lines.value).setElement(i, ListSequence.fromList(lines.value).getElement(i) + " merge=mps");
              updated = true;
            }
          }
          if (!(updated)) {
            ListSequence.fromList(lines.value).addElement("*." + ext + " merge=mps");
          }
        }
      });
      final PrintWriter wr = new PrintWriter(attributesFile.getOutputStream(null));
      ListSequence.fromList(lines.value).visitAll(new IVisitor<String>() {
        public void visit(String line) {
          wr.println(line);
        }
      });
      wr.close();
      return true;
    } catch (IOException e) {
      return false;
    }
  }

  private static boolean isInstalled(VirtualFile path) {
    return install(path, true);
  }

  private static void install(VirtualFile path) {
    install(path, false);
  }

  public static Iterable<VcsRoot> getRepositoriesToInstall(Project project) {
    return Sequence.fromIterable(Sequence.fromArray(project.getComponent(ProjectLevelVcsManager.class).getAllVcsRoots())).where(new IWhereFilter<VcsRoot>() {
      public boolean accept(VcsRoot root) {
        return "Git".equals(root.vcs.getName()) && !(isInstalled(root.path));
      }
    });
  }

  public static void installForRepositories(Project project) {
    Iterable<VcsRoot> roots = getRepositoriesToInstall(project);
    assert Sequence.fromIterable(roots).isNotEmpty();
    Sequence.fromIterable(roots).visitAll(new IVisitor<VcsRoot>() {
      public void visit(VcsRoot root) {
        install(root.path);
      }
    });
    Messages.showInfoMessage(project, "Successfully updated attributes for " + roots, "Attributes");
  }

  public static void installForRepositoriesIfNeeded(Project project, String globalMessage) {
    if (Sequence.fromIterable(getRepositoriesToInstall(project)).isEmpty()) {
      Messages.showInfoMessage(project, globalMessage, "Merge Driver");
    } else {
      Iterable<VcsRoot> rootsToUpdate = getRepositoriesToInstall(project);
      String repositories = NameUtil.formatNumericalString(Sequence.fromIterable(rootsToUpdate).count(), "Git repository");
      int answer = Messages.showYesNoDialog(project, globalMessage + "\nDo you want to to update MPS files attributes in the following Git repositories?\n" + StringUtils.join(Sequence.fromIterable(rootsToUpdate).<String>select(new ISelector<VcsRoot, String>() {
        public String select(VcsRoot r) {
          return r.path.getPath();
        }
      }).toListSequence(), "\n"), "Update Git " + ((Sequence.fromIterable(rootsToUpdate).count() == 1 ?
        "Repository" :
        "Repositories"
      )), null);

      if (answer == 0) {
        installForRepositories(project);
        Messages.showInfoMessage(project, "Successfully updated attributes for " + repositories, "Attributes");
      }
    }
  }
}
