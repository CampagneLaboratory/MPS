package jetbrains.mps.vcs;

/*Generated by MPS */

import jetbrains.mps.WorkbenchMpsTest;
import java.io.File;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.project.Project;
import jetbrains.mps.project.Solution;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.junit.Test;
import jetbrains.mps.testbench.junit.runners.ProjectTestsSupport;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.CopyUtil;
import org.junit.Assert;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SNodeId;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import java.util.Scanner;
import java.util.regex.Pattern;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.io.PrintWriter;
import java.io.FileNotFoundException;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.ui.TestDialog;
import jetbrains.mps.vcs.platform.integration.ModelStorageProblemsListener;
import jetbrains.mps.extapi.model.ReloadableSModelBase;
import javax.swing.SwingUtilities;
import java.lang.reflect.InvocationTargetException;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vfs.LocalFileSystem;
import com.intellij.openapi.vfs.newvfs.RefreshSession;
import com.intellij.openapi.vfs.newvfs.RefreshQueue;
import jetbrains.mps.project.SModuleOperations;
import java.io.IOException;
import jetbrains.mps.ide.ThreadUtils;

/**
 * * @author Evgeny Gerashchenko
 * * @since 3/23/11
 */
public class DiskMemoryConflictsTest extends WorkbenchMpsTest {
  private static final File DESTINATION_PROJECT_DIR = new File(FileUtil.getTempDir(), "testConflicts");
  private static final File PROJECT_ARCHIVE = new File("testbench/modules/simpleProject.zip");
  private static final String PROJECT_FILE = "simpleProject.mpr";
  private static final String MODEL_UID = "r:21cf9f47-5464-40f2-9509-d94ba20bfe82(simpleModel)";
  private static final File MODEL_FILE = getModelFile();
  private static final String FIELD_DEFAULT_NAME = "theField";
  private static final String FIELD_NAME_IN_FILE = "theFieldInFile";
  private static final String FIELD_NAME_IN_MODEL = "theFieldInModel";
  private Project myProject;
  private Solution myModule;
  private SNode myNodeBackup;
  private EditableSModel myModel;

  public DiskMemoryConflictsTest() {
  }

  @Test
  public void testDiskMemoryConflicts() {
    final DiskMemoryConflictsTest.Action[] startedAction = new DiskMemoryConflictsTest.Action[1];
    final DiskMemoryConflictsTest.DiskModification[] startedDiskModification = new DiskMemoryConflictsTest.DiskModification[1];
    final DiskMemoryConflictsTest.VersionToChoose[] startedVersion = new DiskMemoryConflictsTest.VersionToChoose[1];
    final boolean result = ProjectTestsSupport.testOnProjectCopy(PROJECT_ARCHIVE, DESTINATION_PROJECT_DIR, PROJECT_FILE, new ProjectTestsSupport.ProjectRunnable() {
      @Override
      public boolean execute(final Project project) {
        final boolean[] resultArr = new boolean[1];
        try {
          myProject = project;
          myModel = (EditableSModel) SModelRepository.getInstance().getModelDescriptor(PersistenceFacade.getInstance().createModelReference(DiskMemoryConflictsTest.MODEL_UID));
          myModule = (Solution) myModel.getModule();
          ModelAccess.instance().runReadAction(new Runnable() {
            @Override
            public void run() {
              myNodeBackup = CopyUtil.copyAndPreserveId(myModel.getRootNodes().iterator().next());
            }
          });
          checkInitialState();
          for (DiskMemoryConflictsTest.Action a : DiskMemoryConflictsTest.Action.values()) {
            for (DiskMemoryConflictsTest.DiskModification dm : DiskMemoryConflictsTest.DiskModification.values()) {
              for (DiskMemoryConflictsTest.VersionToChoose v : DiskMemoryConflictsTest.VersionToChoose.values()) {
                startedAction[0] = a;
                startedVersion[0] = v;
                startedDiskModification[0] = dm;
                provokeAndCheckConflict(a, dm, v);
                restoreAndCheckOriginalState();
              }
            }
          }
          resultArr[0] = true;
        } catch (Throwable e) {
          e.printStackTrace();
          return false;
        }
        return resultArr[0];
      }
    });
    if (!(result)) {
      Assert.fail("Last started check action=" + startedAction[0] + ", disk modification=" + startedDiskModification[0] + ", version=" + startedVersion[0]);
    }
  }

  private String processFieldNameInModel(final String nameToWrite) {
    final String[] result = new String[1];
    ModelAccess.instance().runCommandInEDT(new Runnable() {
      @Override
      public void run() {
        if (SModelRepository.getInstance().getModelDescriptor(myModel.getReference()) != null) {
          try {
            final SModel modelDescriptor = myModel;
            Assert.assertNotNull(modelDescriptor);
            SNode node = modelDescriptor.getNode(SNodeId.fromString("6010389230754495469"));
            Assert.assertNotNull(node);
            if (nameToWrite == null) {
              result[0] = SNodeAccessUtil.getProperty(node, "name");
            } else {
              SNodeAccessUtil.setProperty(node, "name", nameToWrite);
            }
          } catch (Throwable ignored) {
          }
        }
      }
    }, myProject);
    DiskMemoryConflictsTest.waitEDT();
    return result[0];
  }

  private void setFieldNameInModel(String value) {
    processFieldNameInModel(value);
  }

  private String getFieldNameFromModel() {
    return processFieldNameInModel(null);
  }

  private String processFieldNameInFile(final String nameToWrite) {
    //  File stuff 
    if (!(MODEL_FILE.exists())) {
      return null;
    }
    try {
      Scanner scanner = new Scanner(MODEL_FILE);
      String FIELD_PATTERN = "      <property name=\"name\" nameId=\"tpck.1169194664001\" value=\"%s\" />";
      Pattern fieldNamePattern = Pattern.compile(String.format(FIELD_PATTERN, "([^\"]+)"));
      boolean inField = false;
      List<String> lines = new ArrayList<String>();
      while (scanner.hasNextLine()) {
        String line = scanner.nextLine();
        if (line.contains("<node role=\"field\" roleId=\"tpee.1068390468199\" type=\"tpee.FieldDeclaration\" typeId=\"tpee.1068390468200\" id=\"6010389230754495469\"")) {
          inField = true;
        } else
        if (inField) {
          Matcher matcher = fieldNamePattern.matcher(line);
          if (matcher.matches()) {
            if (nameToWrite == null) {
              return matcher.group(1);
            } else {
              lines.add(matcher.replaceFirst(String.format(FIELD_PATTERN, nameToWrite)));
              inField = false;
              continue;
            }
          }
        }
        lines.add(line);
      }
      scanner.close();
      long lastModifiedBefore = MODEL_FILE.lastModified();
      PrintWriter w = new PrintWriter(MODEL_FILE);
      for (String line : lines) {
        w.println(line);
      }
      w.close();
      if (MODEL_FILE.lastModified() == lastModifiedBefore) {
        DiskMemoryConflictsTest.setLastModified(lastModifiedBefore + 1000);
      }
      DiskMemoryConflictsTest.setLastModified(lastModifiedBefore + 2000 + (int) (Math.random() * 100000));
    } catch (FileNotFoundException e) {
      Assert.fail();
    }
    return null;
  }

  private String getFieldNameFromFile() {
    return processFieldNameInFile(null);
  }

  private void setFieldNameInFile(String name) {
    processFieldNameInFile(name);
  }

  private void checkInitialState() {
    checkSynchronizedState(FIELD_DEFAULT_NAME);
  }

  private void checkSynchronizedState(@Nullable String fieldName) {
    Assert.assertEquals(fieldName, getFieldNameFromModel());
    Assert.assertEquals(fieldName, getFieldNameFromFile());
    if (fieldName == null) {
      Assert.assertNull(SModelRepository.getInstance().getModelDescriptor(myModel.getReference()));
    } else {
      Assert.assertFalse(myModel.isChanged());
    }
  }

  private void provokeAndCheckConflict(DiskMemoryConflictsTest.Action action, final DiskMemoryConflictsTest.DiskModification diskModification, final DiskMemoryConflictsTest.VersionToChoose versionToChoose) {
    setFieldNameInModel(FIELD_NAME_IN_MODEL);
    if (DiskMemoryConflictsTest.DiskModification.MODIFY == diskModification) {
      setFieldNameInFile(FIELD_NAME_IN_FILE);
    } else {
      DiskMemoryConflictsTest.delete();
    }
    refreshVfs();
    final boolean[] dialogWasInvoked = new boolean[1];
    Messages.setTestDialog(new TestDialog() {
      @Override
      public int show(String message) {
        dialogWasInvoked[0] = true;
        if (DiskMemoryConflictsTest.DiskModification.DELETE == diskModification) {
          return (DiskMemoryConflictsTest.VersionToChoose.MEMORY == versionToChoose ? 0 : 1);
        } else {
          return (DiskMemoryConflictsTest.VersionToChoose.MEMORY == versionToChoose ? 1 : 0);
        }
      }
    });
    ModelStorageProblemsListener.setTestDialog(new TestDialog() {
      @Override
      public int show(String message) {
        dialogWasInvoked[0] = true;
        if (DiskMemoryConflictsTest.DiskModification.DELETE == diskModification) {
          return (DiskMemoryConflictsTest.VersionToChoose.MEMORY == versionToChoose ? 0 : 1);
        } else {
          return (DiskMemoryConflictsTest.VersionToChoose.MEMORY == versionToChoose ? 1 : 0);
        }
      }
    });

    if (DiskMemoryConflictsTest.Action.SAVE == action) {
      //  save conflicting model 
      ModelAccess.instance().runCommandInEDT(new Runnable() {
        @Override
        public void run() {
          SModelRepository.getInstance().saveAll();
        }
      }, myProject);
    } else {
      //  reload conflict 
      ModelAccess.instance().runWriteInEDT(new Runnable() {
        @Override
        public void run() {
          ((ReloadableSModelBase) myModel).reloadFromDiskSafe();
        }
      });
    }
    ModelAccess.instance().flushEventQueue();
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
        }
      });
    } catch (InterruptedException e) {
    } catch (InvocationTargetException e) {
    }
    Assert.assertTrue(dialogWasInvoked[0]);
    String expectedFieldName;
    if (DiskMemoryConflictsTest.VersionToChoose.MEMORY == versionToChoose) {
      expectedFieldName = FIELD_NAME_IN_MODEL;
    } else {
      if (DiskMemoryConflictsTest.DiskModification.MODIFY == diskModification) {
        expectedFieldName = FIELD_NAME_IN_FILE;
      } else {
        expectedFieldName = null;
      }
    }
    checkSynchronizedState(expectedFieldName);
  }

  private void refreshVfs() {
    VirtualFile vf = LocalFileSystem.getInstance().findFileByIoFile(MODEL_FILE);
    if (vf == null || !(vf.exists())) {
      vf = LocalFileSystem.getInstance().findFileByIoFile(MODEL_FILE.getParentFile());
    }
    RefreshSession rs = RefreshQueue.getInstance().createSession(false, true, null);
    assert vf != null;
    rs.addFile(vf);
    rs.launch();
  }

  private void restoreAndCheckOriginalState() {
    if (MODEL_FILE.exists()) {
      setFieldNameInFile(FIELD_DEFAULT_NAME);
      refreshVfs();
      ModelAccess.instance().runWriteAction(new Runnable() {
        @Override
        public void run() {
          myModel.reloadFromSource();
        }
      });
    } else {
      //  Restore model 
      ModelAccess.instance().runCommandInEDT(new Runnable() {
        @Override
        public void run() {
          myModel = ((EditableSModel) SModuleOperations.createModelWithAdjustments(PersistenceFacade.getInstance().createModelReference(DiskMemoryConflictsTest.MODEL_UID).getModelName(), myModule.getModelRoots().iterator().next()));
          myModel.addRootNode(CopyUtil.copyAndPreserveId(myNodeBackup));
          myModel.save();
        }
      }, myProject);
      DiskMemoryConflictsTest.waitEDT();
    }
    checkInitialState();
  }

  private static File getModelFile() {
    File modelFile = new File(DESTINATION_PROJECT_DIR, "solutions/simpleProject/simpleModel.mps");
    try {
      return modelFile.getCanonicalFile();
    } catch (IOException ex) {
      ex.printStackTrace();
    }
    return modelFile;
  }

  private static void setLastModified(long timeStamp) {
    //  this is a workaround of JRE bug #4243868 
    //  http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4243868 
    int count = 0;
    while (!(MODEL_FILE.setLastModified(timeStamp)) && count < 10) {
      count++;
      System.gc();
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        Assert.fail();
        return;
      }
    }
    Assert.assertTrue(count < 10);
  }

  private static void delete() {
    //  this is a workaround of JRE bug similar to #4243868 
    //  http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4243868 
    int count = 0;
    while (!(MODEL_FILE.delete()) && count < 10) {
      count++;
      System.gc();
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        Assert.fail();
        return;
      }
    }
    Assert.assertTrue(count < 10);
  }

  private static void waitEDT() {
    ModelAccess.instance().flushEventQueue();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      @Override
      public void run() {
      }
    });
  }

  private static   enum Action {
    SAVE(),
    RELOAD();

    Action() {
    }
  }

  private static   enum VersionToChoose {
    MEMORY(),
    DISK();

    VersionToChoose() {
    }
  }

  private static   enum DiskModification {
    MODIFY(),
    DELETE();

    DiskModification() {
    }
  }
}
