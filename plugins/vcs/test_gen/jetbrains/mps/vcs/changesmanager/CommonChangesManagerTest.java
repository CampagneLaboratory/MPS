package jetbrains.mps.vcs.changesmanager;

/*Generated by MPS */

import java.io.File;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.project.Project;
import com.intellij.openapi.vcs.changes.ChangeListManager;
import com.intellij.openapi.vcs.AbstractVcs;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.smodel.SModelAdapter;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.openapi.vcs.impl.projectlevelman.AllVcses;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.smodel.SReference;
import org.junit.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.intellij.openapi.vcs.changes.Change;
import java.util.Arrays;
import com.intellij.openapi.vcs.changes.VcsDirtyScopeManager;
import com.intellij.openapi.vcs.VcsException;
import jetbrains.mps.vcs.concrete.GitUtils;
import java.io.IOException;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import java.util.List;
import java.util.ArrayList;
import com.intellij.openapi.vcs.rollback.RollbackProgressListener;
import jetbrains.mps.vcs.diff.ChangeSet;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.Computable;
import jetbrains.mps.vcs.diff.ChangeSetBuilder;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.SNodePointer;
import javax.swing.SwingUtilities;
import com.intellij.openapi.fileEditor.FileEditor;
import jetbrains.mps.workbench.nodesFs.MPSNodeVirtualFile;
import jetbrains.mps.workbench.nodesFs.MPSNodesVirtualFileSystem;
import jetbrains.mps.ide.editor.MPSFileNodeEditor;
import com.intellij.openapi.command.undo.UndoManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.junit.Test;
import jetbrains.mps.watching.ModelChangesWatcher;
import jetbrains.mps.TestMain;
import jetbrains.mps.nodeEditor.InspectorTool;

public class CommonChangesManagerTest {
  private static final File DESTINATION_PROJECT_DIR = new File(FileUtil.getTempDir(), "testConflicts");
  private static final File PROJECT_ARCHIVE = new File("testbench/modules/fugue.zip");
  private static final String PROJECT_FILE = "fugue.mpr";

  private CurrentDifferenceRegistry myRegistry;
  private Project myProject;
  private boolean myWaitCompleted;
  private final Object myWaitLock = new Object();
  private ChangeListManager myChangeListManager;
  private CurrentDifference myHtmlDiff;
  private CurrentDifference myUiDiff;
  private CurrentDifference myUtilDiff;
  private AbstractVcs myGitVcs;
  private com.intellij.openapi.project.Project myIdeaProject;
  private VirtualFile myUtilVirtualFile;

  public CommonChangesManagerTest() {
  }

  private void waitForSomething(Runnable waitScheduling) {
    myWaitCompleted = false;
    waitScheduling.run();
    while (!(myWaitCompleted)) {
      synchronized (myWaitLock) {
        try {
          myWaitLock.wait();
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }

  private void waitCompleted() {
    synchronized (myWaitLock) {
      myWaitCompleted = true;
      myWaitLock.notify();
    }
  }

  private void waitForChangesManager() {
    waitForSomething(new Runnable() {
      public void run() {
        myRegistry.getCommandQueue().addTask(new Runnable() {
          public void run() {
            waitCompleted();
          }
        });
      }
    });
  }

  private void waitForModelReplaced(final EditableSModelDescriptor modelDescriptor) {
    waitForSomething(new Runnable() {
      public void run() {
        modelDescriptor.addModelListener(new SModelAdapter() {
          @Override
          public void modelReplaced(SModelDescriptor descriptor) {
            descriptor.removeModelListener(this);
            waitCompleted();
          }
        });
      }
    });
  }

  private CurrentDifference getCurrentDifference(String shortName) {
    return myRegistry.getCurrentDifference((EditableSModelDescriptor) SModelRepository.getInstance().getModelDescriptor(SModelFqName.fromString("ru.geevee.fugue." + shortName)));
  }

  private void init() {
    myIdeaProject = ProjectHelper.toIdeaProject(myProject);
    myRegistry = CurrentDifferenceRegistry.getInstance(myIdeaProject);
    waitForChangesManager();

    myGitVcs = AllVcses.getInstance(myIdeaProject).getByName("Git");
    assert myGitVcs != null;

    myHtmlDiff = getCurrentDifference("html");
    myUiDiff = getCurrentDifference("ui");
    myUtilDiff = getCurrentDifference("util");

    myChangeListManager = ChangeListManager.getInstance(myIdeaProject);

    myUtilVirtualFile = VirtualFileUtils.getVirtualFile(myUtilDiff.getModelDescriptor().getModelFile());

    SReference.disableLogging();
  }

  private void checkAndEnable() {
    Assert.assertNull(myHtmlDiff.getChangeSet());
    Assert.assertNull(myUiDiff.getChangeSet());
    Assert.assertNull(myUtilDiff.getChangeSet());

    myHtmlDiff.setEnabled(true);
    myUiDiff.setEnabled(true);
    myUtilDiff.setEnabled(true);
    waitForChangesManager();

    Assert.assertTrue(ListSequence.fromList(check_orwzer_a0a9a6(myHtmlDiff.getChangeSet())).isNotEmpty());
    Assert.assertTrue(ListSequence.fromList(check_orwzer_a0a01a6(myUiDiff.getChangeSet())).isNotEmpty());
    Assert.assertNull(myUtilDiff.getChangeSet());
  }

  private void modifyModel() {
    runCommandAndWait(new Runnable() {
      public void run() {
        SModel model = myUtilDiff.getModelDescriptor().getSModel();
        SNode root = ListSequence.fromList(SModelOperations.getRoots(model, "jetbrains.mps.baseLanguage.structure.ClassConcept")).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode r) {
            return "ImageLoader".equals(SPropertyOperations.getString(r, "name"));
          }
        });
        SPropertyOperations.set(ListSequence.fromList(SLinkOperations.getTargets(root, "method", true)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode m) {
            return "getImageAttempts".equals(SPropertyOperations.getString(m, "name"));
          }
        }), "name", "getImageAttempts2");
        ListSequence.fromList(SLinkOperations.getTargets(root, "field", true)).clear();
      }
    });

    waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_orwzer_a0a3a7(myUtilDiff.getChangeSet())).isNotEmpty());
  }

  private void saveAndCommit() {
    runCommandAndWait(new Runnable() {
      public void run() {
        myUtilDiff.getModelDescriptor().save();
      }
    });

    myChangeListManager.ensureUpToDate(false);
    Change change = myChangeListManager.getChange(myUtilVirtualFile);
    assert change != null;
    myGitVcs.getCheckinEnvironment().commit(Arrays.asList(change), "dumb commit");
    VcsDirtyScopeManager.getInstance(myIdeaProject).fileDirty(myUtilVirtualFile);
    myChangeListManager.ensureUpToDate(false);

    waitForChangesManager();
    Assert.assertNull(myUtilDiff.getChangeSet());
  }

  private void uncommit() throws VcsException {
    GitUtils.uncommmit(myIdeaProject, myIdeaProject.getBaseDir());
    VcsDirtyScopeManager.getInstance(myIdeaProject).fileDirty(myUtilVirtualFile);
    myChangeListManager.ensureUpToDate(false);

    waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_orwzer_a0a5a9(myUtilDiff.getChangeSet())).isNotEmpty());
  }

  private SNode createNewRoot(SModel modelContent) {
    SNode root = (SNode) new SNode(modelContent, "jetbrains.mps.baseLanguage.structure.ClassConcept");
    SPropertyOperations.set(root, "name", "NewRoot");
    SModelOperations.addRootNode(modelContent, root);
    return root;
  }

  private void modifyExternally() throws IOException, ModelReadException {
    int changesBefore = ListSequence.fromList(myUtilDiff.getChangeSet().getModelChanges()).count();
    SModel modelContent = ModelPersistence.readModel(myUtilDiff.getModelDescriptor().getModelFile(), false);
    createNewRoot(modelContent);
    myUtilVirtualFile.setBinaryContent(ModelPersistence.modelToString(modelContent).getBytes(FileUtil.DEFAULT_CHARSET));
    waitForModelReplaced(myUtilDiff.getModelDescriptor());
    waitForChangesManager();
    Assert.assertEquals(changesBefore + 1, ListSequence.fromList(myUtilDiff.getChangeSet().getModelChanges()).count());
  }

  private void rollback() throws VcsException {
    List<VcsException> exceptions = ListSequence.fromList(new ArrayList<VcsException>());
    myGitVcs.getRollbackEnvironment().rollbackChanges(Arrays.asList(myChangeListManager.getChange(myUtilVirtualFile)), exceptions, RollbackProgressListener.EMPTY);
    if (ListSequence.fromList(exceptions).isNotEmpty()) {
      throw ListSequence.fromList(exceptions).first();
    }
    myChangeListManager.ensureUpToDate(false);

    waitForChangesManager();
    Assert.assertNull(myUtilDiff.getChangeSet());
  }

  private String getChangeSetString(ChangeSet changeSet) {
    return StringUtils.join(ListSequence.fromList(changeSet.getModelChanges()).select(new ISelector<ModelChange, String>() {
      public String select(ModelChange c) {
        return c.toString();
      }
    }).sort(new ISelector<String, Comparable<?>>() {
      public Comparable<?> select(String s) {
        return s;
      }
    }, true).toListSequence(), "|");
  }

  private void assertChangeSetIsCorrect(final ChangeSet changeSet) {
    ChangeSet rebuiltChangeSet = ModelAccess.instance().runReadAction(new Computable<ChangeSet>() {
      public ChangeSet compute() {
        return ChangeSetBuilder.buildChangeSet(changeSet.getOldModel(), changeSet.getNewModel());
      }
    });
    Assert.assertEquals(getChangeSetString(rebuiltChangeSet), getChangeSetString(changeSet));
  }

  private void waitAndCheck(CurrentDifference currentDifference) {
    waitForChangesManager();
    assertChangeSetIsCorrect(currentDifference.getChangeSet());
  }

  private void runCommandAndWait(Runnable r) {
    ModelAccess.instance().runCommandInEDT(r, myProject);
    ModelAccess.instance().flushEventQueue();
  }

  private void doSomethingAndUndo(CurrentDifference diff, _FunctionTypes._return_P0_E0<? extends SNode>... tasks) {
    String stringBefore = getChangeSetString(diff.getChangeSet());

    final List<SNodePointer> affectedNodePointers = ListSequence.fromList(new ArrayList<SNodePointer>());
    for (final _FunctionTypes._return_P0_E0<? extends SNode> t : tasks) {
      runCommandAndWait(new Runnable() {
        public void run() {
          SNode node = t.invoke();
          ListSequence.fromList(affectedNodePointers).addElement((node == null ?
            null :
            new SNodePointer(node)
          ));
        }
      });
      waitAndCheck(diff);
    }

    for (final SNodePointer np : ListSequence.fromList(affectedNodePointers).reversedList()) {
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
            FileEditor fe = null;
            if (np != null) {
              MPSNodeVirtualFile vf = MPSNodesVirtualFileSystem.getInstance().getFileFor(np);
              assert vf != null;
              fe = new MPSFileNodeEditor(myIdeaProject, vf);
            }
            UndoManager.getInstance(myIdeaProject).undo(fe);
          }
        });
      } catch (Throwable t) {
        throw new AssertionError(t);
      }
    }
    waitAndCheck(diff);
    Assert.assertEquals(stringBefore, getChangeSetString(diff.getChangeSet()));
  }

  private SNode getDocumentLayoutRoot() {
    SModel model = myUiDiff.getModelDescriptor().getSModel();
    return ListSequence.fromList(SModelOperations.getRoots(model, "jetbrains.mps.baseLanguage.structure.ClassConcept")).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode r) {
        return "DocumentLayout".equals(SPropertyOperations.getString(r, "name"));
      }
    });
  }

  private void removeModifiedRoot() {
    doSomethingAndUndo(myUiDiff, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNode root = getDocumentLayoutRoot();
        SNodeOperations.deleteNode(root);
        return (SNode) null;
      }
    });
  }

  private void addRoot() {
    final Wrappers._T<SNode> root = new Wrappers._T<SNode>();
    doSomethingAndUndo(myUiDiff, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SModel model = myUiDiff.getModelDescriptor().getSModel();
        root.value = createNewRoot(model);
        return (SNode) null;
      }
    }, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SPropertyOperations.set(root.value, "name", "NewRootName");
        return root.value;
      }
    });
  }

  private void changeProperty() {
    final Wrappers._T<SNode> method = new Wrappers._T<SNode>();
    doSomethingAndUndo(myUiDiff, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        method.value = ListSequence.fromList(SLinkOperations.getTargets(getDocumentLayoutRoot(), "method", true)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode m) {
            return "selectAll".equals(SPropertyOperations.getString(m, "name"));
          }
        });
        Assert.assertNotNull(method.value);
        SPropertyOperations.set(method.value, "name", "selectEverything");
        return SNodeOperations.getContainingRoot(method.value);
      }
    }, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SPropertyOperations.set(method.value, "name", "selectEverySinglePiece");
        return SNodeOperations.getContainingRoot(method.value);
      }
    });
  }

  private void changeReference() {
    final Wrappers._T<SNode> root = new Wrappers._T<SNode>();
    final Wrappers._T<SNode> method = new Wrappers._T<SNode>();
    doSomethingAndUndo(myUiDiff, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        root.value = getDocumentLayoutRoot();
        method.value = ListSequence.fromList(SLinkOperations.getTargets(root.value, "method", true)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode m) {
            return "getSize".equals(SPropertyOperations.getString(m, "name"));
          }
        });
        Assert.assertNotNull(method.value);
        SLinkOperations.setTarget(SNodeOperations.cast(SLinkOperations.getTarget(method.value, "returnType", true), "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", root.value, false);
        return root.value;
      }
    }, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SLinkOperations.setTarget(SNodeOperations.cast(SLinkOperations.getTarget(method.value, "returnType", true), "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", ListSequence.fromList(SLinkOperations.getTargets(root.value, "staticInnerClassifiers", true)).first(), false);
        return SNodeOperations.getContainingRoot(method.value);
      }
    });
  }

  private void moveNode() {
    final Wrappers._T<SNode> root = new Wrappers._T<SNode>();
    final Wrappers._T<SNode> field = new Wrappers._T<SNode>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        root.value = getDocumentLayoutRoot();
        field.value = ListSequence.fromList(SLinkOperations.getTargets(root.value, "field", true)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode f) {
            return "textPositions".equals(SPropertyOperations.getString(f, "name"));
          }
        });
      }
    });
    Assert.assertNotNull(field.value);

    _FunctionTypes._return_P0_E0<? extends SNode> moveUpTwice = new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNodeOperations.insertPrevSiblingChild(field.value, SNodeOperations.getPrevSibling(field.value));
        SNodeOperations.insertPrevSiblingChild(field.value, SNodeOperations.getPrevSibling(field.value));
        return SNodeOperations.getContainingRoot(field.value);
      }
    };
    _FunctionTypes._return_P0_E0<? extends SNode> moveDown = new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNodeOperations.insertNextSiblingChild(field.value, SNodeOperations.getNextSibling(field.value));
        return SNodeOperations.getContainingRoot(field.value);
      }
    };
    _FunctionTypes._return_P0_E0<? extends SNode> moveToOtherClass = new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNode inner = SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(root.value, "staticInnerClassifiers", true)).first(), "jetbrains.mps.baseLanguage.structure.ClassConcept");
        ListSequence.fromList(SLinkOperations.getTargets(inner, "field", true)).addElement(field.value);
        return SNodeOperations.getContainingRoot(field.value);
      }
    };

    // move node up by two 3 times, and down for 19 times 
    doSomethingAndUndo(myUiDiff, moveUpTwice, moveUpTwice, moveUpTwice, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveDown, moveToOtherClass);
  }

  @Test
  public void doTest() {
    ModelChangesWatcher.setForceProcessingEnabled(true);
    boolean result = TestMain.testOnProjectCopy(PROJECT_ARCHIVE, DESTINATION_PROJECT_DIR, PROJECT_FILE, new TestMain.ProjectRunnable() {
      public boolean execute(Project project) {
        try {
          myProject = project;
          init();

          checkAndEnable();
          modifyModel();
          saveAndCommit();
          uncommit();
          modifyExternally();
          rollback();

          removeModifiedRoot();
          addRoot();
          changeProperty();
          changeReference();
          moveNode();

          SwingUtilities.invokeAndWait(new Runnable() {
            public void run() {
              myIdeaProject.getComponent(InspectorTool.class).getInspector().editNode(null, null);
            }
          });

          return true;
        } catch (Throwable e) {
          e.printStackTrace();
          return false;
        }
      }
    }, "jetbrains.mps.vcs", "Git4Idea", "jetbrains.mps.ide.make");
    Assert.assertTrue(result);

    Assert.assertFalse(myRegistry.getCommandQueue().hadExceptions());
  }

  private static List<ModelChange> check_orwzer_a0a9a6(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }

  private static List<ModelChange> check_orwzer_a0a01a6(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }

  private static List<ModelChange> check_orwzer_a0a3a7(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }

  private static List<ModelChange> check_orwzer_a0a5a9(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
}
