package jetbrains.mps.vcs.changesmanager;

/*Generated by MPS */

import java.io.File;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.project.Project;
import com.intellij.openapi.vcs.changes.ChangeListManagerImpl;
import com.intellij.openapi.vcs.AbstractVcs;
import com.intellij.openapi.vfs.VirtualFile;
import java.util.Map;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.junit.Before;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.openapi.vcs.impl.projectlevelman.AllVcses;
import com.intellij.openapi.vcs.VcsShowConfirmationOption;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.watching.ModelChangesWatcher;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import com.intellij.openapi.vcs.VcsConfiguration;
import org.junit.After;
import java.lang.reflect.InvocationTargetException;
import javax.swing.SwingUtilities;
import jetbrains.mps.nodeEditor.InspectorTool;
import org.junit.Assert;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.smodel.SModelAdapter;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.vcs.changesmanager.roots.NodeFileStatusMapping;
import java.util.List;
import java.util.Arrays;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.intellij.openapi.vcs.changes.Change;
import com.intellij.openapi.vcs.changes.VcsDirtyScopeManager;
import com.intellij.openapi.vcs.VcsException;
import jetbrains.mps.vcs.concrete.GitUtils;
import java.io.IOException;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import java.util.ArrayList;
import com.intellij.openapi.vcs.rollback.RollbackProgressListener;
import jetbrains.mps.vcs.diff.ChangeSet;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.util.Computable;
import jetbrains.mps.vcs.diff.ChangeSetBuilder;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.SNodePointer;
import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.command.undo.UndoManager;
import org.junit.Test;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.Random;
import jetbrains.mps.vcs.diff.changes.NodeCopier;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.ModuleDependencyChange;
import jetbrains.mps.project.IModule;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.workbench.actions.model.DeleteModelHelper;
import org.junit.BeforeClass;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.TestMain;
import org.junit.AfterClass;

public class CommonChangesManagerTest {
  private static final File DESTINATION_PROJECT_DIR = new File(FileUtil.getTempDir(), "testConflicts");
  private static final File PROJECT_ARCHIVE = new File("testbench/modules/fugue.zip");
  private static final String PROJECT_FILE = "fugue.mpr";
  private static final String MODEL_PREFIX = "ru.geevee.fugue.";
  private static Project ourProject;
  private static boolean ourEnabled;

  private CurrentDifferenceRegistry myRegistry;
  private Project myProject;
  private boolean myWaitCompleted;
  private final Object myWaitLock = new Object();
  private ChangeListManagerImpl myChangeListManager;
  private CurrentDifference myHtmlDiff;
  private CurrentDifference myUiDiff;
  private CurrentDifference myUtilDiff;
  private AbstractVcs myGitVcs;
  private com.intellij.openapi.project.Project myIdeaProject;
  private VirtualFile myUtilVirtualFile;
  private Runnable myAfterReloadTask;
  private Map<String, FileStatus> myExpectedFileStatuses = MapSequence.fromMap(new HashMap<String, FileStatus>());

  public CommonChangesManagerTest() {
  }

  @Before
  public void init() {
    myProject = ourProject;
    myIdeaProject = ProjectHelper.toIdeaProject(myProject);
    myRegistry = CurrentDifferenceRegistry.getInstance(myIdeaProject);
    waitForChangesManager();

    myGitVcs = AllVcses.getInstance(myIdeaProject).getByName("Git");
    assert myGitVcs != null;

    myHtmlDiff = getCurrentDifference("html");
    myUiDiff = getCurrentDifference("ui");
    myUtilDiff = getCurrentDifference("util");

    myChangeListManager = ChangeListManagerImpl.getInstanceImpl(myIdeaProject);

    setAutoaddPolicy(VcsShowConfirmationOption.Value.DO_NOTHING_SILENTLY);

    myUtilVirtualFile = VirtualFileUtils.getVirtualFile(myUtilDiff.getModelDescriptor().getModelFile());

    ModelChangesWatcher.instance().addReloadListener(new CommonChangesManagerTest.MyReloadListener());

    myRegistry.getCommandQueue().setHadExceptions(false);

    MapSequence.fromMap(myExpectedFileStatuses).put("html.SAHParser", FileStatus.MODIFIED);
    MapSequence.fromMap(myExpectedFileStatuses).put("ui.DocumentLayout", FileStatus.MODIFIED);
    MapSequence.fromMap(myExpectedFileStatuses).put("ui.HTMLPanel", FileStatus.MODIFIED);

    if (!(ourEnabled)) {
      checkAndEnable();
      ourEnabled = true;
    }
  }

  private void setAutoaddPolicy(VcsShowConfirmationOption.Value value) {
    ProjectLevelVcsManager vcsManager = ProjectLevelVcsManager.getInstance(myIdeaProject);
    vcsManager.getStandardConfirmation(VcsConfiguration.StandardConfirmation.ADD, myGitVcs).setValue(value);
  }

  @After
  public void dispose() throws InvocationTargetException, InterruptedException {
    SwingUtilities.invokeAndWait(new Runnable() {
      public void run() {
        myIdeaProject.getComponent(InspectorTool.class).getInspector().editNode(null, null);
      }
    });
    Assert.assertFalse(myRegistry.getCommandQueue().hadExceptions());
  }

  private void waitForSomething(Runnable waitScheduling) {
    myWaitCompleted = false;
    waitScheduling.run();
    while (!(myWaitCompleted)) {
      synchronized (myWaitLock) {
        try {
          myWaitLock.wait();
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }

  private void waitCompleted() {
    synchronized (myWaitLock) {
      myWaitCompleted = true;
      myWaitLock.notify();
    }
  }

  private void waitForChangesManager() {
    waitForSomething(new Runnable() {
      public void run() {
        myRegistry.getCommandQueue().addTask(new Runnable() {
          public void run() {
            waitCompleted();
          }
        });
      }
    });
  }

  private void waitForModelReplaced(final EditableSModelDescriptor modelDescriptor) {
    waitForSomething(new Runnable() {
      public void run() {
        modelDescriptor.addModelListener(new SModelAdapter() {
          @Override
          public void modelReplaced(SModelDescriptor descriptor) {
            descriptor.removeModelListener(this);
            waitCompleted();
          }
        });
      }
    });
  }

  private CurrentDifference getCurrentDifference(String shortName) {
    return myRegistry.getCurrentDifference((EditableSModelDescriptor) SModelRepository.getInstance().getModelDescriptor(SModelFqName.fromString(MODEL_PREFIX + shortName)));
  }

  private void checkAndEnable() {
    Assert.assertNull(myHtmlDiff.getChangeSet());
    Assert.assertNull(myUiDiff.getChangeSet());
    Assert.assertNull(myUtilDiff.getChangeSet());

    myHtmlDiff.setEnabled(true);
    myUiDiff.setEnabled(true);
    myUtilDiff.setEnabled(true);
    waitForChangesManager();

    Assert.assertTrue(ListSequence.fromList(check_orwzer_a0a9a8(myHtmlDiff.getChangeSet())).isNotEmpty());
    Assert.assertTrue(ListSequence.fromList(check_orwzer_a0a01a8(myUiDiff.getChangeSet())).isNotEmpty());
    Assert.assertNull(myUtilDiff.getChangeSet());
  }

  private void checkRootStatuses() {
    final NodeFileStatusMapping fsm = myIdeaProject.getComponent(NodeFileStatusMapping.class);
    final List<EditableSModelDescriptor> interestingModels = Arrays.asList(myHtmlDiff.getModelDescriptor(), myUiDiff.getModelDescriptor(), myUtilDiff.getModelDescriptor());
    // query for first time 
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        ListSequence.fromList(interestingModels).translate(new ITranslator2<EditableSModelDescriptor, SNode>() {
          public Iterable<SNode> translate(EditableSModelDescriptor md) {
            return md.getSModel().roots();
          }
        }).visitAll(new IVisitor<SNode>() {
          public void visit(SNode r) {
            fsm.getStatus(r);
          }
        });
      }
    });
    // wait while statuses update 
    waitForChangesManager();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        for (SNode r : ListSequence.fromList(interestingModels).translate(new ITranslator2<EditableSModelDescriptor, SNode>() {
          public Iterable<SNode> translate(EditableSModelDescriptor md) {
            return md.getSModel().roots();
          }
        })) {
          String simpleName = NameUtil.shortNameFromLongName(r.getModel().getLongName()) + "." + r.getName();
          FileStatus expectedStatus = MapSequence.fromMap(myExpectedFileStatuses).get(simpleName);
          FileStatus actualStatus = fsm.getStatus(r);
          actualStatus = (FileStatus.NOT_CHANGED == actualStatus ?
            null :
            actualStatus
          );
          Assert.assertSame(expectedStatus, actualStatus);
        }
      }
    });
  }

  private void modifyModel() {
    runCommandAndWait(new Runnable() {
      public void run() {
        SModel model = myUtilDiff.getModelDescriptor().getSModel();
        SNode root = ListSequence.fromList(SModelOperations.getRoots(model, "jetbrains.mps.baseLanguage.structure.ClassConcept")).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode r) {
            return "ImageLoader".equals(SPropertyOperations.getString(r, "name"));
          }
        });
        SPropertyOperations.set(ListSequence.fromList(SLinkOperations.getTargets(root, "method", true)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode m) {
            return "getImageAttempts".equals(SPropertyOperations.getString(m, "name"));
          }
        }), "name", "getImageAttempts2");
        ListSequence.fromList(SLinkOperations.getTargets(root, "field", true)).clear();
      }
    });

    waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_orwzer_a0a3a01(myUtilDiff.getChangeSet())).isNotEmpty());
  }

  private void saveAndCommit() {
    runCommandAndWait(new Runnable() {
      public void run() {
        myUtilDiff.getModelDescriptor().save();
      }
    });

    myChangeListManager.ensureUpToDate(false);
    Change change = myChangeListManager.getChange(myUtilVirtualFile);
    assert change != null;
    myGitVcs.getCheckinEnvironment().commit(Arrays.asList(change), "dumb commit");
    VcsDirtyScopeManager.getInstance(myIdeaProject).fileDirty(myUtilVirtualFile);
    myChangeListManager.ensureUpToDate(false);

    waitForChangesManager();
    Assert.assertNull(myUtilDiff.getChangeSet());
  }

  private void uncommit() throws VcsException {
    GitUtils.uncommmit(myIdeaProject, myIdeaProject.getBaseDir());
    VcsDirtyScopeManager.getInstance(myIdeaProject).fileDirty(myUtilVirtualFile);
    myChangeListManager.ensureUpToDate(false);

    waitForChangesManager();
    Assert.assertTrue(ListSequence.fromList(check_orwzer_a0a5a21(myUtilDiff.getChangeSet())).isNotEmpty());
  }

  private SNode createNewRoot(SModel modelContent) {
    SNode root = (SNode) new SNode(modelContent, "jetbrains.mps.baseLanguage.structure.ClassConcept");
    SPropertyOperations.set(root, "name", "NewRoot");
    SModelOperations.addRootNode(modelContent, root);
    return root;
  }

  private void modifyExternally() throws IOException, ModelReadException {
    int changesBefore = ListSequence.fromList(myUtilDiff.getChangeSet().getModelChanges()).count();
    SModel modelContent = ModelPersistence.readModel(myUtilDiff.getModelDescriptor().getModelFile(), false);
    createNewRoot(modelContent);
    myUtilVirtualFile.setBinaryContent(ModelPersistence.modelToString(modelContent).getBytes(FileUtil.DEFAULT_CHARSET));
    waitForModelReplaced(myUtilDiff.getModelDescriptor());
    waitForChangesManager();
    Assert.assertEquals(changesBefore + 1, ListSequence.fromList(myUtilDiff.getChangeSet().getModelChanges()).count());
  }

  private void rollback() throws VcsException {
    List<VcsException> exceptions = ListSequence.fromList(new ArrayList<VcsException>());
    myGitVcs.getRollbackEnvironment().rollbackChanges(Arrays.asList(myChangeListManager.getChange(myUtilVirtualFile)), exceptions, RollbackProgressListener.EMPTY);
    if (ListSequence.fromList(exceptions).isNotEmpty()) {
      throw ListSequence.fromList(exceptions).first();
    }
    myChangeListManager.ensureUpToDate(false);

    waitForChangesManager();
    Assert.assertNull(myUtilDiff.getChangeSet());
  }

  private String getChangeSetString(ChangeSet changeSet) {
    return getChangeSetString(changeSet.getModelChanges());
  }

  private String getChangeSetString(List<ModelChange> modelChanges) {
    return StringUtils.join(ListSequence.fromList(modelChanges).select(new ISelector<ModelChange, String>() {
      public String select(ModelChange c) {
        return c.toString();
      }
    }).sort(new ISelector<String, Comparable<?>>() {
      public Comparable<?> select(String s) {
        return s;
      }
    }, true).toListSequence(), "|");
  }

  private void assertChangeSetIsCorrect(final ChangeSet changeSet) {
    ChangeSet rebuiltChangeSet = ModelAccess.instance().runReadAction(new Computable<ChangeSet>() {
      public ChangeSet compute() {
        return ChangeSetBuilder.buildChangeSet(changeSet.getOldModel(), changeSet.getNewModel());
      }
    });
    Assert.assertEquals(getChangeSetString(rebuiltChangeSet), getChangeSetString(changeSet));
  }

  private void waitAndCheck(CurrentDifference currentDifference) {
    waitForChangesManager();
    assertChangeSetIsCorrect(currentDifference.getChangeSet());
  }

  private void runCommandAndWait(Runnable r) {
    ModelAccess.instance().runCommandInEDT(r, myProject);
    ModelAccess.instance().flushEventQueue();
  }

  private void doSomethingAndUndo(CurrentDifference diff, _FunctionTypes._return_P0_E0<? extends SNode>... tasks) {
    doSomethingAndUndo(diff, false, tasks);
  }

  private void doSomethingAndUndo(CurrentDifference diff, boolean checkAfterEachUndo, _FunctionTypes._return_P0_E0<? extends SNode>... tasks) {
    doSomethingAndUndo(diff, checkAfterEachUndo, Arrays.asList(tasks));
  }

  private void doSomethingAndUndo(CurrentDifference diff, boolean checkAfterEachUndo, List<_FunctionTypes._return_P0_E0<? extends SNode>> tasks) {
    String stringBefore = getChangeSetString(diff.getChangeSet());

    final List<SNodePointer> affectedNodePointers = ListSequence.fromList(new ArrayList<SNodePointer>());
    for (final _FunctionTypes._return_P0_E0<? extends SNode> t : ListSequence.fromList(tasks)) {
      runCommandAndWait(new Runnable() {
        public void run() {
          SNode node = t.invoke();
          assert node.isRoot();
          ListSequence.fromList(affectedNodePointers).addElement((node == null ?
            null :
            new SNodePointer(node)
          ));
        }
      });
      waitAndCheck(diff);
    }

    undoAndCheck(diff, affectedNodePointers, checkAfterEachUndo);
    Assert.assertEquals(stringBefore, getChangeSetString(diff.getChangeSet()));
  }

  private void undoAndCheck(CurrentDifference diff, List<SNodePointer> affectedNodePointers, boolean checkAfterEachUndo) {
    for (final SNodePointer np : ListSequence.fromList(affectedNodePointers).reversedList()) {
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
            FileEditor fe = null;
            if (np != null) {
              fe = new DummyFileEditor(np);
            }
            UndoManager.getInstance(myIdeaProject).undo(fe);
            check_orwzer_a3a0a0a0a0a42(fe);
          }
        });
      } catch (Throwable t) {
        throw new AssertionError(t);
      }
      if (checkAfterEachUndo) {
        waitAndCheck(diff);
      }
    }
    if (!(checkAfterEachUndo)) {
      waitAndCheck(diff);
    }
  }

  private SNode getDocumentLayoutRoot() {
    SModel model = myUiDiff.getModelDescriptor().getSModel();
    return ListSequence.fromList(SModelOperations.getRoots(model, "jetbrains.mps.baseLanguage.structure.ClassConcept")).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode r) {
        return "DocumentLayout".equals(SPropertyOperations.getString(r, "name"));
      }
    });
  }

  @Test
  public void modifySaveCommit() throws VcsException {
    checkRootStatuses();
    modifyModel();
    saveAndCommit();
    uncommit();
  }

  @Test
  public void modifyExternallyRollback() throws ModelReadException, IOException, VcsException {
    modifyExternally();
    rollback();
  }

  @Test
  public void removeModifiedRoot() {
    doSomethingAndUndo(myUiDiff, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNode root = getDocumentLayoutRoot();
        SNodeOperations.deleteNode(root);
        return (SNode) null;
      }
    });
  }

  @Test
  public void addRoot() {
    final Wrappers._T<SNode> root = new Wrappers._T<SNode>();
    doSomethingAndUndo(myUiDiff, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SModel model = myUiDiff.getModelDescriptor().getSModel();
        root.value = createNewRoot(model);
        return (SNode) null;
      }
    }, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SPropertyOperations.set(root.value, "name", "NewRootName");
        return root.value;
      }
    });
  }

  @Test
  public void changeProperty() {
    final Wrappers._T<SNode> method = new Wrappers._T<SNode>();
    doSomethingAndUndo(myUiDiff, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        method.value = ListSequence.fromList(SLinkOperations.getTargets(getDocumentLayoutRoot(), "method", true)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode m) {
            return "selectAll".equals(SPropertyOperations.getString(m, "name"));
          }
        });
        Assert.assertNotNull(method.value);
        SPropertyOperations.set(method.value, "name", "selectEverything");
        return SNodeOperations.getContainingRoot(method.value);
      }
    }, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SPropertyOperations.set(method.value, "name", "selectEverySinglePiece");
        return SNodeOperations.getContainingRoot(method.value);
      }
    });
  }

  @Test
  public void changeReference() {
    final Wrappers._T<SNode> root = new Wrappers._T<SNode>();
    final Wrappers._T<SNode> method = new Wrappers._T<SNode>();
    doSomethingAndUndo(myUiDiff, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        root.value = getDocumentLayoutRoot();
        method.value = ListSequence.fromList(SLinkOperations.getTargets(root.value, "method", true)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode m) {
            return "getSize".equals(SPropertyOperations.getString(m, "name"));
          }
        });
        Assert.assertNotNull(method.value);
        SLinkOperations.setTarget(SNodeOperations.cast(SLinkOperations.getTarget(method.value, "returnType", true), "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", root.value, false);
        return root.value;
      }
    }, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SLinkOperations.setTarget(SNodeOperations.cast(SLinkOperations.getTarget(method.value, "returnType", true), "jetbrains.mps.baseLanguage.structure.ClassifierType"), "classifier", ListSequence.fromList(SLinkOperations.getTargets(root.value, "staticInnerClassifiers", true)).first(), false);
        return SNodeOperations.getContainingRoot(method.value);
      }
    });
  }

  @Test
  public void moveNode() {
    final Wrappers._T<SNode> root = new Wrappers._T<SNode>();
    final Wrappers._T<SNode> field = new Wrappers._T<SNode>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        root.value = getDocumentLayoutRoot();
        field.value = ListSequence.fromList(SLinkOperations.getTargets(root.value, "field", true)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode f) {
            return "textPositions".equals(SPropertyOperations.getString(f, "name"));
          }
        });
      }
    });
    Assert.assertNotNull(field.value);

    _FunctionTypes._return_P0_E0<? extends SNode> moveUpTwice = new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNodeOperations.insertPrevSiblingChild(field.value, SNodeOperations.getPrevSibling(field.value));
        SNodeOperations.insertPrevSiblingChild(field.value, SNodeOperations.getPrevSibling(field.value));
        return SNodeOperations.getContainingRoot(field.value);
      }
    };
    _FunctionTypes._return_P0_E0<? extends SNode> moveDown = new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNodeOperations.insertNextSiblingChild(field.value, SNodeOperations.getNextSibling(field.value));
        return SNodeOperations.getContainingRoot(field.value);
      }
    };
    _FunctionTypes._return_P0_E0<? extends SNode> moveToOtherClass = new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNode inner = SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(root.value, "staticInnerClassifiers", true)).first(), "jetbrains.mps.baseLanguage.structure.ClassConcept");
        ListSequence.fromList(SLinkOperations.getTargets(inner, "field", true)).addElement(field.value);
        return SNodeOperations.getContainingRoot(field.value);
      }
    };

    List<_FunctionTypes._return_P0_E0<? extends SNode>> tasks = ListSequence.fromList(new ArrayList<_FunctionTypes._return_P0_E0<? extends SNode>>());
    for (int i = 0; i < 3; i++) {
      ListSequence.fromList(tasks).addElement(moveUpTwice);
    }
    for (int i = 0; i < 19; i++) {
      ListSequence.fromList(tasks).addElement(moveDown);
    }
    ListSequence.fromList(tasks).addElement(moveToOtherClass);
    doSomethingAndUndo(myUiDiff, false, tasks);
  }

  @Test
  public void inlineVariable() {
    final Wrappers._T<SNode> root = new Wrappers._T<SNode>();
    final Wrappers._T<SNode> method = new Wrappers._T<SNode>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        root.value = getDocumentLayoutRoot();
        method.value = ListSequence.fromList(SLinkOperations.getTargets(root.value, "method", true)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode f) {
            return "getTextPosition".equals(SPropertyOperations.getString(f, "name"));
          }
        });
      }
    });
    doSomethingAndUndo(myUiDiff, true, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNode ifBefore = (SNode) new SNode(SNodeOperations.getModel(root.value), "jetbrains.mps.baseLanguage.structure.IfStatement");
        SNodeOperations.insertPrevSiblingChild(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method.value, "body", true), "statement", true)).first(), ifBefore);
        return root.value;
      }
    }, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNode foreachBody = SLinkOperations.getTarget(SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method.value, "body", true), "statement", true)).getElement(1), "jetbrains.mps.baseLanguage.structure.ForeachStatement"), "body", true);
        SNode declarationStatement = SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(foreachBody, "statement", true)).getElement(0), "jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement");
        final SNode declaration = SLinkOperations.getTarget(declarationStatement, "localVariableDeclaration", true);
        final SNode initializer = SLinkOperations.getTarget(declaration, "initializer", true);
        ListSequence.fromList(SNodeOperations.getDescendants(foreachBody, "jetbrains.mps.baseLanguage.structure.LocalVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode vr) {
            return SLinkOperations.getTarget(vr, "variableDeclaration", false) == declaration;
          }
        }).visitAll(new IVisitor<SNode>() {
          public void visit(SNode vr) {
            SNodeOperations.replaceWithAnother(vr, SNodeOperations.copyNode(initializer));
          }
        });
        SNodeOperations.deleteNode(declarationStatement);
        return root.value;
      }
    }, new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNodeOperations.deleteNode(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method.value, "body", true), "statement", true)).getElement(2));
        SNodeOperations.deleteNode(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method.value, "body", true), "statement", true)).getElement(1));
        return root.value;
      }
    });
  }

  @Test
  public void rollbackAllSerially() {
    Random random = new Random(239);
    String stringBeforeAll = getChangeSetString(myUiDiff.getChangeSet());
    final SModel model = myUiDiff.getModelDescriptor().getSModel();

    List<SNodePointer> affectedNodePointers = ListSequence.fromList(new ArrayList<SNodePointer>());

    while (true) {
      List<ModelChange> changesBefore = ListSequence.fromListWithValues(new ArrayList<ModelChange>(), myUiDiff.getChangeSet().getModelChanges());
      if (ListSequence.fromList(changesBefore).isEmpty()) {
        break;
      }
      final ModelChange changeToPick = ListSequence.fromList(changesBefore).getElement(random.nextInt(ListSequence.fromList(changesBefore).count()));
      runCommandAndWait(new Runnable() {
        public void run() {
          changeToPick.getOppositeChange().apply(model, new NodeCopier(model));
        }
      });
      waitAndCheck(myUiDiff);

      ListSequence.fromList(changesBefore).removeElement(changeToPick);
      Assert.assertEquals(getChangeSetString(changesBefore), getChangeSetString(myUiDiff.getChangeSet()));

      ListSequence.fromList(affectedNodePointers).addElement(new SNodePointer(myUiDiff.getModelDescriptor().getSModelReference(), changeToPick.getRootId()));
    }

    undoAndCheck(myUiDiff, affectedNodePointers, false);
    Assert.assertEquals(stringBeforeAll, getChangeSetString(myUiDiff.getChangeSet()));
  }

  @Test
  public void rollbackAllAtomically() {
    String stringBeforeAll = getChangeSetString(myUiDiff.getChangeSet());
    final SModel model = myUiDiff.getModelDescriptor().getSModel();

    List<SNodePointer> affectedRootPointers = ListSequence.fromList(myUiDiff.getChangeSet().getModelChanges()).select(new ISelector<ModelChange, SNodePointer>() {
      public SNodePointer select(ModelChange ch) {
        return new SNodePointer(myUiDiff.getModelDescriptor().getSModelReference(), ch.getRootId());
      }
    }).distinct().toListSequence();
    final List<ModelChange> oppositeChanges = ListSequence.fromList(myUiDiff.getChangeSet().getModelChanges()).select(new ISelector<ModelChange, ModelChange>() {
      public ModelChange select(ModelChange ch) {
        return ch.getOppositeChange();
      }
    }).toListSequence();
    runCommandAndWait(new Runnable() {
      public void run() {
        final NodeCopier nc = new NodeCopier(model);
        ListSequence.fromList(oppositeChanges).where(new IWhereFilter<ModelChange>() {
          public boolean accept(ModelChange ch) {
            return ch instanceof NodeGroupChange;
          }
        }).visitAll(new IVisitor<ModelChange>() {
          public void visit(ModelChange ch) {
            ((NodeGroupChange) ch).prepare();
          }
        });
        ListSequence.fromList(oppositeChanges).visitAll(new IVisitor<ModelChange>() {
          public void visit(ModelChange ch) {
            ch.apply(model, nc);
          }
        });
        nc.restoreIds(true);
      }
    });
    waitAndCheck(myUiDiff);
    Assert.assertTrue(ListSequence.fromList(myUiDiff.getChangeSet().getModelChanges()).isEmpty());

    undoAndCheck(myUiDiff, Arrays.asList(ListSequence.fromList(affectedRootPointers).first()), false);
    Assert.assertEquals(stringBeforeAll, getChangeSetString(myUiDiff.getChangeSet()));
  }

  private void checkOneAddedRoot(CurrentDifference newModelDiff) {
    waitForChangesManager();
    List<ModelChange> changes = newModelDiff.getChangeSet().getModelChanges();
    Assert.assertEquals(2, ListSequence.fromList(changes).count());
    Assert.assertTrue(ListSequence.fromList(changes).any(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange it) {
        return it instanceof AddRootChange;
      }
    }));
    Assert.assertTrue(ListSequence.fromList(changes).any(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange it) {
        return it instanceof ModuleDependencyChange;
      }
    }));
  }

  @Test
  public void createNewModel() {
    final Wrappers._T<CurrentDifference> newModelDiff = new Wrappers._T<CurrentDifference>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        String modelName = "newmodel";
        IModule module = myUiDiff.getModelDescriptor().getModule();
        module.createModel(SModelFqName.fromString(MODEL_PREFIX + modelName), module.getSModelRoots().get(0), null);
        newModelDiff.value = getCurrentDifference(modelName);
      }
    });
    final EditableSModelDescriptor md = newModelDiff.value.getModelDescriptor();
    ModelAccess.instance().runWriteInEDT(new Runnable() {
      public void run() {
        md.getSModel();
        md.save();
      }
    });
    ModelAccess.instance().flushEventQueue();

    VirtualFile vf = VirtualFileUtils.getVirtualFile(md.getModelFile());
    VcsDirtyScopeManager.getInstance(myIdeaProject).fileDirty(vf);
    myChangeListManager.ensureUpToDate(false);
    FileStatusManager.getInstance(myIdeaProject).fileStatusChanged(vf);

    newModelDiff.value.setEnabled(true);
    waitForChangesManager();
    Assert.assertTrue((int) ListSequence.fromList(newModelDiff.value.getChangeSet().getModelChanges()).count() == 0);

    runCommandAndWait(new Runnable() {
      public void run() {
        SModel m = md.getSModel();
        m.addLanguage(ModuleReference.fromString("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)"));
        createNewRoot(m);
      }
    });
    checkOneAddedRoot(newModelDiff.value);

    myChangeListManager.addUnversionedFiles(myChangeListManager.getDefaultChangeList(), Arrays.asList(vf));
    myChangeListManager.ensureUpToDate(false);
    checkOneAddedRoot(newModelDiff.value);
  }

  private void waitForReloadFinished() {
    waitForSomething(new Runnable() {
      public void run() {
        synchronized (CommonChangesManagerTest.this) {
          myAfterReloadTask = new Runnable() {
            public void run() {
              synchronized (CommonChangesManagerTest.this) {
                myAfterReloadTask = null;
              }
              waitCompleted();
            }
          };
        }
      }
    });
  }

  @Test
  public void deleteModelAndRollback() {
    setAutoaddPolicy(VcsShowConfirmationOption.Value.DO_ACTION_SILENTLY);

    final EditableSModelDescriptor md = myUiDiff.getModelDescriptor();
    String changeSetStringBefore = getChangeSetString(myUiDiff.getChangeSet());
    runCommandAndWait(new Runnable() {
      public void run() {
        DeleteModelHelper.deleteModel(myIdeaProject, md.getModule(), md, false, true);
      }
    });
    waitForChangesManager();

    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          UndoManager.getInstance(myIdeaProject).undo(null);
        }
      });
    } catch (Exception e) {
      e.printStackTrace();
      Assert.fail();
    }
    waitForReloadFinished();
    ModelAccess.instance().flushEventQueue();
    waitForChangesManager();
    myUiDiff = getCurrentDifference("ui");
    myUiDiff.setEnabled(true);
    waitForChangesManager();
    myChangeListManager.ensureUpToDate(false);
    waitForChangesManager();
    Assert.assertEquals(changeSetStringBefore, getChangeSetString(myUiDiff.getChangeSet()));

    setAutoaddPolicy(VcsShowConfirmationOption.Value.DO_NOTHING_SILENTLY);
  }

  @BeforeClass
  public static void setUp() {
    ModelChangesWatcher.setForceProcessingEnabled(true);
    SReference.disableLogging();

    ourProject = TestMain.startTestOnProjectCopy(PROJECT_ARCHIVE, DESTINATION_PROJECT_DIR, PROJECT_FILE, "jetbrains.mps.vcs", "Git4Idea", "jetbrains.mps.ide.make");
  }

  @AfterClass
  public static void tearDown() {
    TestMain.finishTestOnProjectCopy(ourProject, DESTINATION_PROJECT_DIR);
  }

  private static List<ModelChange> check_orwzer_a0a9a8(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }

  private static List<ModelChange> check_orwzer_a0a01a8(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }

  private static List<ModelChange> check_orwzer_a0a3a01(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }

  private static List<ModelChange> check_orwzer_a0a5a21(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }

  private static void check_orwzer_a3a0a0a0a0a42(FileEditor checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.dispose();
    }

  }

  private static void check_orwzer_a0a0a1a(Runnable checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.run();
    }

  }

  private class MyReloadListener implements ModelChangesWatcher.IReloadListener {
    public MyReloadListener() {
    }

    public void reloadStarted() {
    }

    public void reloadFinished() {
      synchronized (this) {
        check_orwzer_a0a0a1a(myAfterReloadTask);
      }
    }
  }
}
