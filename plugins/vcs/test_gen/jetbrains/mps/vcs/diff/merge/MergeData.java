package jetbrains.mps.vcs.diff.merge;

/*Generated by MPS */

import java.io.File;
import java.util.zip.ZipFile;
import java.io.IOException;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import java.util.zip.ZipOutputStream;
import java.io.FileOutputStream;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import java.io.InputStream;
import jetbrains.mps.util.ReadUtil;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.vcs.diff.ChangeSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class MergeData {
  private static final String CHANGES_MINE_TXT = "changes.mine.txt";
  private static final String CHANGES_REPOSITORY_TXT = "changes.repository.txt";

  private final File myZipFileFile;
  private final ZipFile myZipFile;
  private String myBaseModelString;
  private String myMineModelString;
  private String myRepositoryModelString;
  private String myResultModelString;
  private String myChangesMineString;
  private String myChangesRepositoryString;
  private final String myModelMpsBase;
  private final String myModelMpsMine;
  private final String myModelMpsRepository;
  private final String myModelMpsResult;

  public MergeData(File zipFile) throws IOException {
    myZipFileFile = zipFile;
    myZipFile = new ZipFile(myZipFileFile);
    Enumeration<? extends ZipEntry> entries = myZipFile.entries();

    String modelName = null;
    while (entries.hasMoreElements()) {
      ZipEntry entry = entries.nextElement();
      String entryName = entry.getName();
      if (entryName.endsWith(".mps.base")) {
        modelName = entryName.substring(0, entryName.length() - ".mps.base".length());
      }
    }
    assert modelName != null;
    myModelMpsBase = modelName + ".mps.base";
    myModelMpsRepository = modelName + ".mps.repository";
    myModelMpsMine = modelName + ".mps.mine";
    myModelMpsResult = modelName + ".mps.result";
  }

  public void loadCommonData() throws IOException {
    myBaseModelString = loadString(myModelMpsBase);
    myMineModelString = loadString(myModelMpsMine);
    myRepositoryModelString = loadString(myModelMpsRepository);
  }

  public void loadResultData() throws IOException {
    myResultModelString = loadString(myModelMpsResult);
    myChangesMineString = loadString(CHANGES_MINE_TXT);
    myChangesRepositoryString = loadString(CHANGES_REPOSITORY_TXT);
  }

  public void generateResultData() throws ModelReadException {
    SModel baseModel = ModelPersistence.readModel(myBaseModelString, false);
    SModel mineModel = ModelPersistence.readModel(myMineModelString, false);
    SModel repositoryModel = ModelPersistence.readModel(myRepositoryModelString, false);

    final MergeSession session = new MergeSession(baseModel, mineModel, repositoryModel);
    String resultModelString = null;
    if (Sequence.fromIterable(session.getAllChanges()).all(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange c) {
        return Sequence.fromIterable(session.getConflictedWith(c)).isEmpty();
      }
    })) {
      // no conflicts 
      session.applyChanges(Sequence.fromIterable(session.getAllChanges()).toListSequence());
      resultModelString = ModelPersistence.modelToString(session.getResultModel());
    }

    String changesMineString = dumpChangeSet(session.getMyChangeSet(), session);
    String changesRepositoryString = dumpChangeSet(session.getRepositoryChangeSet(), session);

    myResultModelString = resultModelString;
    myChangesMineString = changesMineString;
    myChangesRepositoryString = changesRepositoryString;
  }

  public void saveAndClose() throws IOException {
    myZipFile.close();
    ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(myZipFileFile));
    addFileToZos(zos, myModelMpsBase, myBaseModelString);
    addFileToZos(zos, myModelMpsMine, myMineModelString);
    addFileToZos(zos, myModelMpsRepository, myRepositoryModelString);
    if (myResultModelString != null) {
      addFileToZos(zos, myModelMpsRepository, myRepositoryModelString);
    }
    addFileToZos(zos, CHANGES_MINE_TXT, myChangesMineString);
    addFileToZos(zos, CHANGES_REPOSITORY_TXT, myChangesRepositoryString);
    zos.close();
  }

  @Nullable
  private String loadString(@NotNull String name) throws IOException {
    ZipEntry entry = myZipFile.getEntry(name);
    if (entry == null) {
      return null;
    }
    InputStream inputStream = myZipFile.getInputStream(entry);
    byte[] bytes = ReadUtil.read(inputStream);
    inputStream.close();
    return new String(bytes, FileUtil.DEFAULT_CHARSET).replace("\r\n", "\n");
  }

  public static String dumpChangeSet(ChangeSet changeSet, MergeSession session) {
    StringBuffer buf = new StringBuffer();
    for (ModelChange change : ListSequence.fromList(changeSet.getModelChanges()).sort(new ISelector<ModelChange, Comparable<?>>() {
      public Comparable<?> select(ModelChange c) {
        return c.toString();
      }
    }, true)) {
      buf.append(change).append("\n");
      for (ModelChange conflicting : Sequence.fromIterable(session.getConflictedWith(change)).sort(new ISelector<ModelChange, Comparable<?>>() {
        public Comparable<?> select(ModelChange c) {
          return c.toString();
        }
      }, true)) {
        buf.append("    ").append(conflicting).append("\n");
      }
    }
    return buf.toString();
  }

  private static void addFileToZos(ZipOutputStream zipOutputStream, String name, String content) throws IOException {
    zipOutputStream.putNextEntry(new ZipEntry(name));
    zipOutputStream.write(content.getBytes(FileUtil.DEFAULT_CHARSET));
    zipOutputStream.closeEntry();
  }
}
