package jetbrains.mps.vcs.annotation;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.leftHighlighter.AbstractLeftColumn;
import java.awt.Font;
import jetbrains.mps.nodeEditor.EditorSettings;
import java.util.List;
import java.util.Map;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.openapi.vcs.annotate.FileAnnotation;
import jetbrains.mps.smodel.SNode;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SModel;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.awt.Color;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.intellij.openapi.vcs.annotate.LineAnnotationAspect;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.ArrayList;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.Collections;
import com.intellij.openapi.vcs.history.VcsRevisionNumber;
import java.awt.event.MouseEvent;
import org.jetbrains.annotations.Nullable;
import java.awt.Cursor;

public class AnnotationColumn extends AbstractLeftColumn {
  private Font myFont = EditorSettings.getInstance().getDefaultEditorFont();
  private int myWidth = 0;
  private List<Integer> myPseudoLinesY;
  private List<Integer> myPseudoLinesToFileLines;
  private Map<SNodeId, Integer> myNodeIdToFileLine = MapSequence.fromMap(new HashMap<SNodeId, Integer>());
  private FileAnnotation myFileAnnotation;

  public AnnotationColumn(SNode root, FileAnnotation fileAnnotation, List<SNodeId> lineToId) {
    Set<SNodeId> descendantIds = SetSequence.fromSetWithValues(new HashSet<SNodeId>(), ListSequence.fromList(SNodeOperations.getDescendants(root, null, true, new String[]{})).select(new ISelector<SNode, SNodeId>() {
      public SNodeId select(SNode n) {
        return n.getSNodeId();
      }
    }));
    SModel model = SNodeOperations.getModel(root);
    for (int line = 0; line < ListSequence.fromList(lineToId).count(); line++) {
      SNode node = null;
      SNodeId id = ListSequence.fromList(lineToId).getElement(line);
      if (id != null && SetSequence.fromSet(descendantIds).contains(id)) {
        node = model.getNodeById(id);
      }
      if (node == null) {
        continue;
      }
      MapSequence.fromMap(myNodeIdToFileLine).put(id, line);
    }
    myFileAnnotation = fileAnnotation;
  }

  public String getName() {
    return "Annotation";
  }

  public void paint(Graphics graphics, EditorComponent component) {
    graphics.setFont(myFont);
    graphics.setColor(Color.BLACK);
    for (int i = 0; i < ListSequence.fromList(myPseudoLinesY).count(); i++) {
      String text = getTextForFileLine(ListSequence.fromList(myPseudoLinesToFileLines).getElement(i));
      graphics.drawString(text, 1, graphics.getFontMetrics().getAscent() + ListSequence.fromList(myPseudoLinesY).getElement(i));
    }
  }

  private String getTextForFileLine(final int fileLine) {
    final StringBuffer sb = new StringBuffer();
    Sequence.fromIterable(Sequence.fromArray(myFileAnnotation.getAspects())).visitAll(new IVisitor<LineAnnotationAspect>() {
      public void visit(LineAnnotationAspect a) {
        sb.append(" ").append(a.getValue(fileLine));
      }
    });
    return sb.substring(1);
  }

  public int getWidth() {
    return myWidth;
  }

  public void relayout(final EditorComponent component) {
    Iterable<EditorCell> nonTrivialCells = Sequence.fromIterable(AnnotationUtil.getCellDescendants(component.getRootCell())).where(new IWhereFilter<EditorCell>() {
      public boolean accept(EditorCell cell) {
        return cell.getWidth() * cell.getHeight() != 0;
      }
    });
    Set<Integer> yCoordinatesSet = SetSequence.fromSetWithValues(new HashSet<Integer>(), Sequence.fromIterable(nonTrivialCells).select(new ISelector<EditorCell, Integer>() {
      public Integer select(EditorCell cell) {
        return cell.getY();
      }
    }));
    myPseudoLinesY = SetSequence.fromSet(yCoordinatesSet).sort(new ISelector<Integer, Comparable<?>>() {
      public Comparable<?> select(Integer y) {
        return y;
      }
    }, true).toListSequence();
    myPseudoLinesToFileLines = ListSequence.fromList(new ArrayList<Integer>());
    ListSequence.fromList(myPseudoLinesY).visitAll(new IVisitor<Integer>() {
      public void visit(Integer t) {
        ListSequence.fromList(myPseudoLinesToFileLines).addElement(-1);
      }
    });
    myWidth = 0;
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        SModel model = component.getEditedNode().getModel();
        for (IMapping<SNodeId, Integer> nodeIdToFileLine : MapSequence.fromMap(myNodeIdToFileLine)) {
          final SNode node = model.getNodeById(nodeIdToFileLine.key());
          int fileLine = nodeIdToFileLine.value();

          EditorCell cell = ListSequence.fromList(SNodeOperations.getAncestors(node, null, true)).select(new ISelector<SNode, EditorCell>() {
            public EditorCell select(SNode n) {
              return component.findNodeCell(node);
            }
          }).findFirst(new IWhereFilter<EditorCell>() {
            public boolean accept(EditorCell c) {
              return c != null;
            }
          });
          if (cell == null) {
            continue;
          }

          int startPseudoLine = Collections.binarySearch(myPseudoLinesY, cell.getY());
          int endPseudoLine = Collections.binarySearch(myPseudoLinesY, cell.getY() + cell.getHeight());
          if (endPseudoLine < 0) {
            endPseudoLine = -endPseudoLine - 1;
          }
          for (int pseudoLine = startPseudoLine; pseudoLine < endPseudoLine; pseudoLine++) {
            int currentFileLine = ListSequence.fromList(myPseudoLinesToFileLines).getElement(pseudoLine);
            if (currentFileLine != -1) {
              VcsRevisionNumber currentRevision = myFileAnnotation.getLineRevisionNumber(currentFileLine);
              VcsRevisionNumber newRevision = myFileAnnotation.getLineRevisionNumber(fileLine);
              if (currentRevision == null) {
              } else if (newRevision == null || newRevision.compareTo(currentRevision) <= 0) {
                continue;
              }
            }
            ListSequence.fromList(myPseudoLinesToFileLines).setElement(pseudoLine, fileLine);
          }
          int widthCandidate = component.getGraphics().getFontMetrics(myFont).stringWidth(getTextForFileLine(fileLine)) + 3;
          myWidth = Math.max(myWidth, widthCandidate);
        }
      }
    });
  }

  @Override
  public String getTooltipText(MouseEvent event) {
    String result;
    int y = event.getY();
    int pseudoLine = Collections.binarySearch(myPseudoLinesY, y);
    if (pseudoLine < 0) {
      pseudoLine = -pseudoLine - 2;
    }
    if (pseudoLine >= 0 && pseudoLine < ListSequence.fromList(myPseudoLinesToFileLines).count()) {
      result = myFileAnnotation.getToolTip(ListSequence.fromList(myPseudoLinesToFileLines).getElement(pseudoLine));
    } else {
      result = null;
    }
    return result;
  }

  @Nullable
  @Override
  public Cursor getCursor(MouseEvent event, EditorComponent component) {
    return new Cursor(Cursor.HAND_CURSOR);
  }
}
