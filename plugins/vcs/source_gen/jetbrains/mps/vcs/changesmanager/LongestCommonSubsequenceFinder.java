package jetbrains.mps.vcs.changesmanager;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.apache.commons.lang.ObjectUtils;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;

public class LongestCommonSubsequenceFinder {
  @NotNull
  public static <E> int[][] findLongestCommonSubsequenceLengths(@NotNull List<E> a, @NotNull List<E> b) {
    // This method finds lengths of longest common subsequence for each 
    // i first elements of a and j first elements of b. This lengths are in result 
    // two-dimensional array at [i][j] position 
    int[][] lengths = new int[ListSequence.fromList(a).count() + 1][ListSequence.fromList(b).count() + 1];

    for (int i = 1; i < ListSequence.fromList(a).count() + 1; i++) {
      for (int j = 1; j < ListSequence.fromList(b).count() + 1; j++) {
        if (ObjectUtils.equals(ListSequence.fromList(a).getElement(i - 1), ListSequence.fromList(b).getElement(j - 1))) {
          lengths[i][j] = lengths[i - 1][j - 1] + 1;
        } else {
          lengths[i][j] = Math.max(lengths[i - 1][j], lengths[i][j - 1]);
        }
      }
    }

    return lengths;
  }

  @NotNull
  public static <E> List<Tuples._2<Integer, Integer>> findLongestCommonSubsequenceIndices(@NotNull List<E> a, @NotNull List<E> b) {
    // This method finds pairs of indices in a and b lists which are 
    // elements of longest common subsequence 
    int[][] lengths = findLongestCommonSubsequenceLengths(a, b);

    List<Tuples._2<Integer, Integer>> indices = ListSequence.fromList(new ArrayList<Tuples._2<Integer, Integer>>());
    int i = ListSequence.fromList(a).count();
    int j = ListSequence.fromList(b).count();
    while (i > 0 && j > 0) {
      if (ObjectUtils.equals(ListSequence.fromList(a).getElement(i - 1), ListSequence.fromList(b).getElement(j - 1))) {
        ListSequence.fromList(indices).addElement(MultiTuple.<Integer,Integer>from(i - 1, j - 1));
        i--;
        j--;
      } else {
        if (lengths[i][j - 1] == lengths[i][j]) {
          j--;
        } else {
          i--;
        }
      }
    }
    return ListSequence.fromList(indices).reversedList();
  }

  @NotNull
  public static <E> List<Tuples._2<Iterable<E>, Iterable<E>>> findDifferentSubsequences(@NotNull final List<E> a, @NotNull final List<E> b) {
    // This methods finds pairs of subsequences of original lists a and b 
    // which are not included into longest common subsequence 

    List<Tuples._2<Iterable<E>, Iterable<E>>> subsequences = ListSequence.fromList(new ArrayList<Tuples._2<Iterable<E>, Iterable<E>>>());

    List<Tuples._2<Integer, Integer>> commonSubsequenceIndices = findLongestCommonSubsequenceIndices(a, b);
    int i = 0;
    int j = 0;

    for (Tuples._2<Integer, Integer> f : ListSequence.fromList(commonSubsequenceIndices).concat(Sequence.fromIterable(new _FunctionTypes._return_P0_E0<Iterable<Tuples._2<Integer, Integer>>>() {
      public Iterable<Tuples._2<Integer, Integer>> invoke() {
        return new Iterable<Tuples._2<Integer, Integer>>() {
          public Iterator<Tuples._2<Integer, Integer>> iterator() {
            return new YieldingIterator<Tuples._2<Integer, Integer>>() {
              private int __CP__ = 0;

              protected boolean moveToNext() {
__loop__:
                do {
__switch__:
                  switch (this.__CP__) {
                    case -1:
                      assert false : "Internal error";
                      return false;
                    case 2:
                      this.__CP__ = 1;
                      this.yield(MultiTuple.<Integer,Integer>from(ListSequence.fromList(a).count(), ListSequence.fromList(b).count()));
                      return true;
                    case 0:
                      this.__CP__ = 2;
                      break;
                    default:
                      break __loop__;
                  }
                } while (true);
                return false;
              }
            };
          }
        };
      }
    }.invoke()))) {
      if (!(i == f._0() && j == f._1())) {
        ListSequence.fromList(subsequences).addElement(MultiTuple.<Iterable<E>,Iterable<E>>from(ListSequence.fromList(a).page(i, f._0()), ListSequence.fromList(b).page(j, f._1())));
      }
      i = f._0() + 1;
      j = f._1() + 1;
    }

    return subsequences;
  }
}
