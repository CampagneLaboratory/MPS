package jetbrains.mps.vcs.changesmanager;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.smodel.event.SModelListener;
import com.intellij.openapi.vcs.changes.ChangeListListener;
import java.util.Map;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.reloading.ReloadListener;
import jetbrains.mps.smodel.SModelRepositoryListener;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.project.Project;
import jetbrains.mps.reloading.ClassLoaderManager;
import jetbrains.mps.smodel.GlobalSModelEventsManager;
import com.intellij.openapi.vcs.changes.ChangeListManager;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.smodel.ModelLoadingState;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.vcs.changes.ChangeListAdapter;
import java.util.Collection;
import com.intellij.openapi.vcs.changes.Change;
import com.intellij.openapi.vcs.changes.ChangeList;
import jetbrains.mps.vcs.MPSVcsManager;
import jetbrains.mps.smodel.SModelAdapter;
import jetbrains.mps.reloading.ReloadAdapter;
import jetbrains.mps.smodel.SModelRepositoryAdapter;

public class CurrentDifferenceRegistry extends AbstractProjectComponent {
  private final SModelListener myGlobalModelListener = new CurrentDifferenceRegistry.MyGlobalSModelListener();
  private final ChangeListListener myChangeListListener = new CurrentDifferenceRegistry.MyChangeListListener();
  private final Map<SModelReference, CurrentDifference> myCurrentDifferences = MapSequence.fromMap(new HashMap<SModelReference, CurrentDifference>());
  private final ReloadListener myReloadListener = new CurrentDifferenceRegistry.MyReloadListener();
  private final SModelRepositoryListener myModelRepositoryListener = new CurrentDifferenceRegistry.MySModelRepositoryListener();
  private final SimpleCommandQueue myCommandQueue = new SimpleCommandQueue("ChangesManager command queue");

  public CurrentDifferenceRegistry(@NotNull Project project) {
    super(project);
  }

  public void projectOpened() {
    ClassLoaderManager.getInstance().addReloadHandler(myReloadListener);
    GlobalSModelEventsManager.getInstance().addGlobalModelListener(myGlobalModelListener);
    ChangeListManager.getInstance(myProject).addChangeListListener(myChangeListListener);
    SModelRepository.getInstance().addModelRepositoryListener(myModelRepositoryListener);

    updateLoadedModels();
  }

  public void projectClosed() {
    ClassLoaderManager.getInstance().removeReloadHandler(myReloadListener);
    GlobalSModelEventsManager.getInstance().removeGlobalModelListener(myGlobalModelListener);
    ChangeListManager.getInstance(myProject).removeChangeListListener(myChangeListListener);
    SModelRepository.getInstance().removeModelRepositoryListener(myModelRepositoryListener);

    synchronized (myCurrentDifferences) {
      for (CurrentDifference modelChangesManager : Sequence.fromIterable(MapSequence.fromMap(myCurrentDifferences).values())) {
        modelChangesManager.dispose();
      }
      MapSequence.fromMap(myCurrentDifferences).clear();
    }
    myCommandQueue.dispose();
  }

  private void updateModel(@NotNull EditableSModelDescriptor modelDescriptor) {
    synchronized (myCurrentDifferences) {
      SModelReference modelRef = modelDescriptor.getSModelReference();
      if (MapSequence.fromMap(myCurrentDifferences).containsKey(modelRef)) {
        MapSequence.fromMap(myCurrentDifferences).get(modelRef).getChangesTracker().scheduleFullUpdate();
        return;
      }
      CurrentDifference cd = new CurrentDifference(myProject, modelDescriptor);
      MapSequence.fromMap(myCurrentDifferences).put(modelRef, cd);
    }
  }

  private void updateModel(@Nullable VirtualFile file) {
    if (file == null) {
      return;
    }
    IFile iFile = VirtualFileUtils.toIFile(file);
    if (iFile == null) {
      return;
    }
    EditableSModelDescriptor modelDescriptor = SModelRepository.getInstance().findModel(iFile);
    if (modelDescriptor == null || modelDescriptor.getLoadingState() == ModelLoadingState.NOT_LOADED) {
      return;
    }
    updateModel(modelDescriptor);
  }

  public void updateLoadedModels() {
    for (SModelDescriptor md : ListSequence.fromList(SModelRepository.getInstance().getModelDescriptors())) {
      if (md instanceof EditableSModelDescriptor) {
        updateModel((EditableSModelDescriptor) md);
      }
    }
  }

  private void disposeModelChangesManager(@NotNull SModelReference modelReference) {
    synchronized (myCurrentDifferences) {
      if (MapSequence.fromMap(myCurrentDifferences).containsKey(modelReference)) {
        MapSequence.fromMap(myCurrentDifferences).get(modelReference).dispose();
        MapSequence.fromMap(myCurrentDifferences).removeKey(modelReference);
      }
    }
  }

  @NotNull
  public CurrentDifference getCurrentDifference(@NotNull EditableSModelDescriptor modelDescriptor) {
    synchronized (myCurrentDifferences) {
      SModelReference modelRef = modelDescriptor.getSModelReference();
      if (!(MapSequence.fromMap(myCurrentDifferences).containsKey(modelRef))) {
        MapSequence.fromMap(myCurrentDifferences).put(modelRef, new CurrentDifference(myProject, modelDescriptor));
      }
      return MapSequence.fromMap(myCurrentDifferences).get(modelRef);
    }
  }

  @NotNull
  public SimpleCommandQueue getCommandQueue() {
    return myCommandQueue;
  }

  public static CurrentDifferenceRegistry getInstance(Project project) {
    return project.getComponent(CurrentDifferenceRegistry.class);
  }

  private class MyChangeListListener extends ChangeListAdapter {
    public MyChangeListListener() {
    }

    private void processChanges(Collection<Change> changes) {
      for (Change change : Sequence.fromIterable(changes)) {
        updateModel(change.getVirtualFile());
      }
    }

    @Override
    public void changesAdded(Collection<Change> changes, ChangeList toList) {
      processChanges(changes);
    }

    @Override
    public void changesRemoved(Collection<Change> changes, ChangeList fromList) {
      processChanges(changes);
    }

    @Override
    public void changesMoved(Collection<Change> changes, ChangeList fromList, ChangeList toList) {
      processChanges(changes);
    }

    @Override
    public void unchangedFileStatusChanged() {
      for (VirtualFile virtualFile : ListSequence.fromList(MPSVcsManager.getInstance(myProject).getUnversionedFilesFromChangeListManager())) {
        updateModel(virtualFile);
      }
    }
  }

  private class MyGlobalSModelListener extends SModelAdapter {
    public MyGlobalSModelListener() {
    }

    public void modelReplaced(SModelDescriptor md) {
      if (md instanceof EditableSModelDescriptor) {
        updateModel(((EditableSModelDescriptor) md));
      }
    }

    public void modelLoadingStateChanged(SModelDescriptor md, ModelLoadingState oldState, ModelLoadingState newState) {
      if (md instanceof EditableSModelDescriptor) {
        updateModel(((EditableSModelDescriptor) md));
      }
      // TODO model can be unloaded 
    }
  }

  private class MyReloadListener extends ReloadAdapter {
    public MyReloadListener() {
    }

    @Override
    public void onAfterReload() {
      updateLoadedModels();
    }
  }

  private class MySModelRepositoryListener extends SModelRepositoryAdapter {
    public MySModelRepositoryListener() {
    }

    @Override
    public void beforeModelRemoved(SModelDescriptor descriptor) {
      if (descriptor instanceof EditableSModelDescriptor) {
        disposeModelChangesManager(descriptor.getSModelReference());
      }
    }
  }
}
