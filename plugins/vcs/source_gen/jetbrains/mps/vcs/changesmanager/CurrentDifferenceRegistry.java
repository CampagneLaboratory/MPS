package jetbrains.mps.vcs.changesmanager;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.smodel.event.SModelListener;
import java.util.Map;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SModelRepositoryListener;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.smodel.GlobalSModelEventsManager;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.vcs.FileStatusListener;
import jetbrains.mps.smodel.SModelAdapter;
import jetbrains.mps.smodel.SModelRepositoryAdapter;

public class CurrentDifferenceRegistry extends AbstractProjectComponent {
  private final SModelListener myGlobalModelListener = new CurrentDifferenceRegistry.MyGlobalSModelListener();
  private final Map<SModelReference, CurrentDifference> myCurrentDifferences = MapSequence.fromMap(new HashMap<SModelReference, CurrentDifference>());
  private final SModelRepositoryListener myModelRepositoryListener = new CurrentDifferenceRegistry.MySModelRepositoryListener();
  private final SimpleCommandQueue myCommandQueue = new SimpleCommandQueue("ChangesManager command queue");
  private CurrentDifferenceBroadcaster myGlobalBroadcaster = new CurrentDifferenceBroadcaster(myCommandQueue);
  private CurrentDifferenceRegistry.MyFileStatusListener myFileStatusListener = new CurrentDifferenceRegistry.MyFileStatusListener();

  public CurrentDifferenceRegistry(@NotNull Project project, ProjectLevelVcsManager vcsManager, FileStatusManager fileStatusManager) {
    super(project);
  }

  public void projectOpened() {
    GlobalSModelEventsManager.getInstance().addGlobalModelListener(myGlobalModelListener);
    FileStatusManager.getInstance(myProject).addFileStatusListener(myFileStatusListener);
    SModelRepository.getInstance().addModelRepositoryListener(myModelRepositoryListener);

    updateLoadedModels();
  }

  public void projectClosed() {
    GlobalSModelEventsManager.getInstance().removeGlobalModelListener(myGlobalModelListener);
    FileStatusManager.getInstance(myProject).removeFileStatusListener(myFileStatusListener);
    SModelRepository.getInstance().removeModelRepositoryListener(myModelRepositoryListener);

    synchronized (myCurrentDifferences) {
      for (CurrentDifference modelChangesManager : Sequence.fromIterable(MapSequence.fromMap(myCurrentDifferences).values())) {
        modelChangesManager.dispose();
      }
      MapSequence.fromMap(myCurrentDifferences).clear();
    }
    myCommandQueue.dispose();
  }

  public Project getProject() {
    return myProject;
  }

  private void updateModel(@NotNull EditableSModelDescriptor modelDescriptor) {
    synchronized (myCurrentDifferences) {
      SModelReference modelRef = modelDescriptor.getSModelReference();
      if (MapSequence.fromMap(myCurrentDifferences).containsKey(modelRef)) {
        MapSequence.fromMap(myCurrentDifferences).get(modelRef).getChangesTracker().scheduleFullUpdate();
        return;
      }
      CurrentDifference cd = new CurrentDifference(this, modelDescriptor);
      MapSequence.fromMap(myCurrentDifferences).put(modelRef, cd);
    }
  }

  private void updateModel(@Nullable VirtualFile file) {
    if (file == null) {
      return;
    }
    IFile iFile = VirtualFileUtils.toIFile(file);
    if (iFile == null) {
      return;
    }
    EditableSModelDescriptor modelDescriptor = SModelRepository.getInstance().findModel(iFile);
    if (modelDescriptor == null || modelDescriptor.getLoadingState() == ModelLoadingState.NOT_LOADED) {
      return;
    }
    updateModel(modelDescriptor);
  }

  public void updateLoadedModels() {
    for (SModelDescriptor md : ListSequence.fromList(SModelRepository.getInstance().getModelDescriptors())) {
      if (md instanceof EditableSModelDescriptor) {
        updateModel((EditableSModelDescriptor) md);
      }
    }
  }

  private void disposeModelChangesManager(@NotNull SModelReference modelReference) {
    synchronized (myCurrentDifferences) {
      if (MapSequence.fromMap(myCurrentDifferences).containsKey(modelReference)) {
        MapSequence.fromMap(myCurrentDifferences).get(modelReference).dispose();
        MapSequence.fromMap(myCurrentDifferences).removeKey(modelReference);
      }
    }
  }

  @NotNull
  public CurrentDifference getCurrentDifference(@NotNull EditableSModelDescriptor modelDescriptor) {
    synchronized (myCurrentDifferences) {
      SModelReference modelRef = modelDescriptor.getSModelReference();
      if (!(MapSequence.fromMap(myCurrentDifferences).containsKey(modelRef))) {
        MapSequence.fromMap(myCurrentDifferences).put(modelRef, new CurrentDifference(this, modelDescriptor));
      }
      return MapSequence.fromMap(myCurrentDifferences).get(modelRef);
    }
  }

  public void addGlobalDifferenceListener(@NotNull CurrentDifferenceListener listener) {
    myGlobalBroadcaster.addDifferenceListener(listener);
  }

  public void removeGlobalDifferenceListener(@NotNull CurrentDifferenceListener listener) {
    myGlobalBroadcaster.removeDifferenceListener(listener);
  }

  @NotNull
  public SimpleCommandQueue getCommandQueue() {
    return myCommandQueue;
  }

  /*package*/ CurrentDifferenceBroadcaster getGlobalBroadcaster() {
    return myGlobalBroadcaster;
  }

  public static CurrentDifferenceRegistry getInstance(Project project) {
    return project.getComponent(CurrentDifferenceRegistry.class);
  }

  private class MyFileStatusListener implements FileStatusListener {
    public MyFileStatusListener() {
    }

    public void fileStatusesChanged() {
      updateLoadedModels();
    }

    public void fileStatusChanged(@NotNull VirtualFile vf) {
      updateModel(vf);
    }
  }

  private class MyGlobalSModelListener extends SModelAdapter {
    public MyGlobalSModelListener() {
    }

    public void modelReplaced(SModelDescriptor md) {
      if (md instanceof EditableSModelDescriptor) {
        updateModel(((EditableSModelDescriptor) md));
      }
    }

    public void modelLoadingStateChanged(SModelDescriptor md, ModelLoadingState oldState, ModelLoadingState newState) {
      if (md instanceof EditableSModelDescriptor) {
        updateModel(((EditableSModelDescriptor) md));
      }
      // TODO model can be unloaded 
    }
  }

  private class MySModelRepositoryListener extends SModelRepositoryAdapter {
    public MySModelRepositoryListener() {
    }

    @Override
    public void beforeModelRemoved(SModelDescriptor descriptor) {
      if (descriptor instanceof EditableSModelDescriptor) {
        disposeModelChangesManager(descriptor.getSModelReference());
      }
    }
  }
}
