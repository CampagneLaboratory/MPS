package jetbrains.mps.vcs.changesmanager;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.SModelDescriptor;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.Change;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.SModel;
import java.util.Set;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import com.intellij.openapi.vcs.FileStatus;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.workbench.nodesFs.MPSNodesVirtualFileSystem;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.vcs.diff.changes.NewNodeChange;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ICollectionSequence;
import jetbrains.mps.vcs.diff.changes.DeleteNodeChange;
import jetbrains.mps.vcs.diff.changes.MoveNodeChange;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.lang.structure.behavior.LinkDeclaration_Behavior;
import jetbrains.mps.vcs.diff.changes.SetNodeChange;
import jetbrains.mps.vcs.diff.changes.AddNodeChange;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.Arrays;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.vfs.IFile;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import com.intellij.openapi.vcs.impl.VcsFileStatusProvider;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import jetbrains.mps.vcs.ModelUtils;
import jetbrains.mps.vcs.diff.DiffBuilder;
import jetbrains.mps.workbench.nodesFs.MPSNodeVirtualFile;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.AttributesRolesUtil;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration_Behavior;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.vcs.diff.changes.SubstituteNodeChange;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.SModelAdapter;
import org.apache.commons.lang.ObjectUtils;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.vcs.diff.changes.ModelImportChange;
import jetbrains.mps.smodel.event.SModelImportEvent;
import jetbrains.mps.vcs.diff.changes.UsedLanguagesChange;
import jetbrains.mps.smodel.event.SModelLanguageEvent;
import jetbrains.mps.vcs.diff.changes.UsedDevkitsChange;
import jetbrains.mps.smodel.event.SModelDevKitEvent;
import jetbrains.mps.lang.structure.structure.PropertyDeclaration;
import jetbrains.mps.smodel.PropertySupport;
import jetbrains.mps.vcs.diff.changes.DeleteReferenceChange;
import jetbrains.mps.smodel.event.SModelRootEvent;

public class ModelChangesManager {
  protected static Log log = LogFactory.getLog(ModelChangesManager.class);

  private final Project myProject;
  private SimpleCommandQueue myCommandQueue;
  private SModelDescriptor myModelDescriptor;
  private List<Change> myChangeList = ListSequence.fromList(new ArrayList<Change>());
  private ModelChangesManager.MyModelListener myModelListener = new ModelChangesManager.MyModelListener();
  private final List<ChangeListener> myChangeListeners = ListSequence.fromList(new ArrayList<ChangeListener>());
  private SModel myBaseVersionModel = null;
  private Set<SNodeId> myAddedNodeIds = SetSequence.fromSet(new HashSet<SNodeId>());
  private Map<SNodeId, Integer> myChangesCountsForRoots = MapSequence.fromMap(new HashMap<SNodeId, Integer>());
  private Map<Change, SNodeId> myRootForChange = MapSequence.fromMap(new HashMap<Change, SNodeId>());
  private Map<Tuples._2<SNodeId, String>, List<Change>> myMultipleChildChanges = MapSequence.fromMap(new HashMap<Tuples._2<SNodeId, String>, List<Change>>());
  private boolean myEnabled = false;
  private FileStatus myFileStatus;
  private Map<SNodeId, SNodeId> myRollbackReplaceCache = MapSequence.fromMap(new HashMap<SNodeId, SNodeId>());

  public ModelChangesManager(@NotNull Project project, @NotNull SModelDescriptor modelDescriptor) {
    myProject = project;
    myCommandQueue = ChangesManager.getInstance(project).getCommandQueue();
    myModelDescriptor = modelDescriptor;
    modelDescriptor.addModelListener(myModelListener);
    myCommandQueue.addTask(new Runnable() {
      public void run() {
        update(null);
      }
    });
  }

  private SModel getModel() {
    final Wrappers._T<SModel> model = new Wrappers._T<SModel>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        model.value = myModelDescriptor.getSModel();
      }
    });
    return model.value;
  }

  private boolean isEmpty() {
    return ListSequence.fromList(getChangeList()).isEmpty();
  }

  @NotNull
  public List<Change> getChangeList() {
    myCommandQueue.assertSoftlyIsCommandThread();
    return ListSequence.fromListWithValues(new ArrayList<Change>(), myChangeList);
  }

  public void addChangeListener(@NotNull ChangeListener listener) {
    synchronized (myChangeListeners) {
      ListSequence.fromList(myChangeListeners).addElement(listener);
    }
  }

  public void removeChangeListener(@NotNull ChangeListener listener) {
    synchronized (myChangeListeners) {
      ListSequence.fromList(myChangeListeners).removeElement(listener);
    }
  }

  @NotNull
  private List<ChangeListener> copyListeners() {
    synchronized (myChangeListeners) {
      return ListSequence.fromListWithValues(new ArrayList<ChangeListener>(), myChangeListeners);
    }
  }

  private void fireChangeAdded(@NotNull Change change) {
    myCommandQueue.assertSoftlyIsCommandThread();
    for (ChangeListener listener : ListSequence.fromList(copyListeners())) {
      try {
        listener.changeAdded(change, getModel());
      } catch (Throwable t) {
        if (log.isErrorEnabled()) {
          log.error("Exception on firing changeAdded event", t);
        }
      }
    }
  }

  private void fireChangeRemoved(@NotNull Change change) {
    myCommandQueue.assertSoftlyIsCommandThread();
    for (ChangeListener listener : ListSequence.fromList(copyListeners())) {
      try {
        listener.changeRemoved(change, getModel());
      } catch (Throwable t) {
        if (log.isErrorEnabled()) {
          log.error("Exception on firing changeRemoved event", t);
        }
      }
    }
  }

  private void fireFileStatusChanged(@Nullable FileStatus newFileStatus) {
    myCommandQueue.assertSoftlyIsCommandThread();
    for (ChangeListener listener : ListSequence.fromList(copyListeners())) {
      try {
        listener.fileStatusChanged(newFileStatus, getModel());
      } catch (Throwable t) {
        if (log.isErrorEnabled()) {
          log.error("Exception on firing fileStatusChanged event", t);
        }
      }
    }
  }

  public void fireChangeUpdateStarted() {
    myCommandQueue.assertSoftlyIsCommandThread();
    for (ChangeListener listener : ListSequence.fromList(copyListeners())) {
      try {
        listener.changeUpdateStarted();
      } catch (Throwable t) {
        if (log.isErrorEnabled()) {
          log.error("Exception on firing changeUpdateStarted event", t);
        }
      }
    }
  }

  public void fireChangeUpdateFinished() {
    myCommandQueue.assertSoftlyIsCommandThread();
    for (ChangeListener listener : ListSequence.fromList(copyListeners())) {
      try {
        listener.changeUpdateFinished();
      } catch (Throwable t) {
        if (log.isErrorEnabled()) {
          log.error("Exception on firing changeUpdateFinished event", t);
        }
      }
    }
  }

  private boolean isAncestorAlreadyAdded(@NotNull List<SNode> pathToRoot) {
    return ListSequence.fromList(pathToRoot).any(new IWhereFilter<SNode>() {
      public boolean accept(SNode node) {
        return SetSequence.fromSet(myAddedNodeIds).contains(node.getSNodeId());
      }
    });
  }

  private void fileStatusChangedForRootNode(@Nullable SNode rootNode) {
    if (rootNode == null) {
      return;
    }
    RootNodeFileStatusManager.getInstance(myProject).nodeFileStatusChanged(rootNode);
    FileStatusManager.getInstance(myProject).fileStatusChanged(MPSNodesVirtualFileSystem.getInstance().getFileFor(rootNode));
  }

  private void fileStatusChangedForRootNodes(@NotNull SModel model) {
    for (SNode root : ListSequence.fromList(SModelOperations.getRoots(model, null))) {
      fileStatusChangedForRootNode(root);
    }
  }

  private void addRootInfoForChange(@NotNull Change change, @Nullable SNodeId affectedRootId, @NotNull SModel model) {
    myCommandQueue.assertSoftlyIsCommandThread();
    if (affectedRootId == null) {
      return;
    }
    MapSequence.fromMap(myRootForChange).put(change, affectedRootId);
    if (MapSequence.fromMap(myChangesCountsForRoots).containsKey(affectedRootId)) {
      MapSequence.fromMap(myChangesCountsForRoots).put(affectedRootId, MapSequence.fromMap(myChangesCountsForRoots).get(affectedRootId) + 1);
    } else {
      MapSequence.fromMap(myChangesCountsForRoots).put(affectedRootId, 1);
    }
    fileStatusChangedForRootNode(model.getNodeById(affectedRootId));
  }

  private void removeRootInfoForChange(@NotNull Change change) {
    myCommandQueue.assertSoftlyIsCommandThread();
    SNodeId rootId = MapSequence.fromMap(myRootForChange).get(change);
    if (rootId != null && MapSequence.fromMap(myChangesCountsForRoots).containsKey(rootId)) {
      MapSequence.fromMap(myChangesCountsForRoots).put(rootId, MapSequence.fromMap(myChangesCountsForRoots).get(rootId) - 1);
    }
    MapSequence.fromMap(myRootForChange).removeKey(change);
    fileStatusChangedForRootNode((rootId == null ?
      null :
      getModel().getNodeById(rootId)
    ));
  }

  private void addChange(@NotNull Change change, @Nullable SNode affectedRoot, boolean silent) {
    myCommandQueue.assertSoftlyIsCommandThread();
    if (myBaseVersionModel == null && !(isNewModel())) {
      if (log.isErrorEnabled()) {
        log.error("", new AssertionError("adding change to model without base version"));
      }
      return;
    }
    ListSequence.fromList(myChangeList).addElement(change);
    if (myFileStatus == FileStatus.NOT_CHANGED) {
      setFileStatus(FileStatus.MODIFIED);
    }
    if (change instanceof NewNodeChange) {
      SetSequence.fromSet(myAddedNodeIds).addElement(change.getAffectedNodeId());
    }
    if (affectedRoot != null) {
      addRootInfoForChange(change, affectedRoot.getSNodeId(), SNodeOperations.getModel(affectedRoot));
    }
    if (!(silent)) {
      fireChangeAdded(change);
    }
  }

  private void addChange(@NotNull Change change, @Nullable SNode affectedRoot) {
    addChange(change, affectedRoot, false);
  }

  private void removeChange(@NotNull Change change, boolean silent) {
    myCommandQueue.assertSoftlyIsCommandThread();
    if (myBaseVersionModel == null && !(isNewModel())) {
      if (log.isErrorEnabled()) {
        log.error("", new AssertionError("removing change from model without base version"));
      }
      return;
    }
    if (change instanceof NewNodeChange) {
      SetSequence.fromSet(myAddedNodeIds).removeElement(change.getAffectedNodeId());
    }
    removeRootInfoForChange(change);
    ListSequence.fromList(myChangeList).removeElement(change);
    if (isEmpty() && myFileStatus == FileStatus.MODIFIED) {
      setFileStatus(FileStatus.NOT_CHANGED);
    }
    if (!(silent)) {
      fireChangeRemoved(change);
    }
  }

  private <C extends Change> int removeChanges(@NotNull final Class<C> changeClass, @NotNull final _FunctionTypes._return_P1_E0<? extends Boolean, ? super C> condition, boolean silent) {
    List<Change> toRemove = ListSequence.fromList(getChangeList()).where(new IWhereFilter<Change>() {
      public boolean accept(Change ch) {
        return changeClass.isInstance(ch) && condition.invoke((C) ch);
      }
    }).toListSequence();

    for (Change change : ListSequence.fromList(toRemove)) {
      removeChange(change, silent);
    }

    return ListSequence.fromList(toRemove).count();
  }

  private <C extends Change> int removeChanges(@NotNull Class<C> changeClass, @NotNull _FunctionTypes._return_P1_E0<? extends Boolean, ? super C> condition) {
    return removeChanges(changeClass, condition, false);
  }

  private <C extends Change> int removeAllChanges() {
    return removeChanges(Change.class, new _FunctionTypes._return_P1_E0<Boolean, Change>() {
      public Boolean invoke(Change change) {
        return true;
      }
    }, false);
  }

  private void setFileStatus(FileStatus fileStatus) {
    myFileStatus = fileStatus;
    if (isNewModel()) {
      removeAllChanges();
      fillWithAddRootChange();
    }
    fileStatusChangedForRootNodes(getModel());
    fireFileStatusChanged(fileStatus);
  }

  public void dispose() {
    myCommandQueue.assertSoftlyIsCommandThread();
    for (Change change : ListSequence.fromList(getChangeList())) {
      fireChangeRemoved(change);
    }
    if (myModelListener != null) {
      myModelDescriptor.removeModelListener(myModelListener);
      myModelListener = null;
    }
  }

  private void mergeChanges() {
    myCommandQueue.assertSoftlyIsCommandThread();
    // Note: this method does not notify ChangeListeners, so it should be invoked only during initialization 

    final Wrappers._T<List<Change>> changeList = new Wrappers._T<List<Change>>(ListSequence.fromList(new ArrayList<Change>()));
    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<ICollectionSequence<Change>>() {
      public ICollectionSequence<Change> invoke() {
        SModel model = getModel();
        final Set<SNodeId> addedNodes = SetSequence.fromSet(new HashSet<SNodeId>());
        final Set<SNodeId> removedNodes = SetSequence.fromSet(new HashSet<SNodeId>());
        Set<SNodeId> hasRemovedParent = SetSequence.fromSet(new HashSet<SNodeId>());
        for (Change change : ListSequence.fromList(myChangeList)) {
          if (change instanceof NewNodeChange) {
            SetSequence.fromSet(addedNodes).addElement(change.getAffectedNodeId());
          } else if (change instanceof DeleteNodeChange) {
            SNodeId parent = change.getAffectedNodeId();
            SetSequence.fromSet(removedNodes).addElement(parent);
            for (SNodeId child : ListSequence.fromList(((DeleteNodeChange) change).getChildren())) {
              SetSequence.fromSet(hasRemovedParent).addElement(child);
            }
          } else if (change instanceof MoveNodeChange) {
            SetSequence.fromSet(addedNodes).addElement(change.getAffectedNodeId());
            SetSequence.fromSet(addedNodes).addSequence(ListSequence.fromList(SModelUtils.getNodeIds(SNodeOperations.getDescendants(((SNode) model.getNodeById(change.getAffectedNodeId())), null, false, new String[]{}))));
            SNodeId parentId = change.getAffectedNodeId();
            SetSequence.fromSet(removedNodes).addElement(parentId);
            // TODO update hasRemovedParent 
          }
        }

        for (Change change : ListSequence.fromList(myChangeList)) {
          if (change instanceof NewNodeChange) {
            SNode node = model.getNodeById(change.getAffectedNodeId());
            assert node != null;
            if (!(ListSequence.fromList(SNodeOperations.getAncestors(node, null, false)).any(new IWhereFilter<SNode>() {
              public boolean accept(SNode a) {
                return SetSequence.fromSet(addedNodes).contains(a.getSNodeId());
              }
            }))) {
              ListSequence.fromList(changeList.value).addElement(change);
            }
          } else if (change instanceof DeleteNodeChange) {
            if (!(SetSequence.fromSet(hasRemovedParent).contains(change.getAffectedNodeId()))) {
              ListSequence.fromList(changeList.value).addElement(change);
            }
          } else if (change instanceof SetPropertyChange || change instanceof SetReferenceChange) {
            SNodeId nodeId = change.getAffectedNodeId();
            SNode node = model.getNodeById(nodeId);
            if (!(ListSequence.fromList(SNodeOperations.getAncestors(node, null, true)).any(new IWhereFilter<SNode>() {
              public boolean accept(SNode a) {
                return SetSequence.fromSet(addedNodes).contains(a.getSNodeId()) || SetSequence.fromSet(removedNodes).contains(a.getSNodeId());
              }
            }))) {
              ListSequence.fromList(changeList.value).addElement(change);
            }
          } else if (change instanceof MoveNodeChange) {
            // Split into NewNodeChange and DeleteNodeChange 
            SNodeId nodeId = change.getAffectedNodeId();
            SNode node = model.getNodeById(nodeId);
            SNode parent = SNodeOperations.getParent(node);
            String conceptFqName = node.getConceptFqName();

            // adding NewNodeChange if needed 
            if (parent == null || !(SetSequence.fromSet(addedNodes).contains(parent.getSNodeId()))) {
              if (parent == null) {
                ListSequence.fromList(changeList.value).addElement(new AddRootChange(conceptFqName, nodeId));
              } else if (LinkDeclaration_Behavior.call_isSingular_1213877254557(SNodeOperations.getContainingLinkDeclaration(node))) {
                SNode thisNodeInBase = myBaseVersionModel.getNodeById(nodeId);
                if (thisNodeInBase != null && parent.getSNodeId().equals(check_fh1co9_a0a0a1a0a0h0c0a6a0e0y(SNodeOperations.getParent(thisNodeInBase))) && SNodeOperations.getContainingLinkRole(node).equals(SNodeOperations.getContainingLinkRole(thisNodeInBase))) {
                  continue;
                }
                ListSequence.fromList(changeList.value).addElement(new SetNodeChange(conceptFqName, nodeId, SNodeOperations.getContainingLinkRole(node), parent.getSNodeId(), check_fh1co9_e0a0a2a0a0h0c0a6a0e0y(check_fh1co9_a4a0a0c0a0a7a2a0g0a4a42(myBaseVersionModel.getNodeById(SNodeOperations.getParent(node).getSNodeId()), node)), SNodeOperations.getContainingLinkRole(SNodeOperations.getPrevSibling(node))));
              } else {
                // TODO null in prevSibling and prevRole 
                ListSequence.fromList(changeList.value).addElement(new AddNodeChange(conceptFqName, nodeId, SNodeOperations.getContainingLinkRole(node), parent.getSNodeId(), null, null));
              }
            }


            // adding DeleteNodeChange if needed 
            if (!(SetSequence.fromSet(hasRemovedParent).contains(nodeId))) {
              ListSequence.fromList(changeList.value).addElement(new DeleteNodeChange(nodeId, new ArrayList<SNodeId>()));
            }
          } else {
            ListSequence.fromList(changeList.value).addElement(change);
          }
        }
        final List<SetNodeChange> setNodeChanges = ListSequence.fromList(changeList.value).<SetNodeChange>translate(new ITranslator2<Change, SetNodeChange>() {
          public Iterable<SetNodeChange> translate(final Change ch) {
            return new Iterable<SetNodeChange>() {
              public Iterator<SetNodeChange> iterator() {
                return new YieldingIterator<SetNodeChange>() {
                  private int __CP__ = 0;

                  protected boolean moveToNext() {
__loop__:
                    do {
__switch__:
                      switch (this.__CP__) {
                        case -1:
                          assert false : "Internal error";
                          return false;
                        case 2:
                          if (ch instanceof SetNodeChange && ((SetNodeChange) ch).getOldChildId() != null) {
                            this.__CP__ = 3;
                            break;
                          }
                          this.__CP__ = 1;
                          break;
                        case 4:
                          this.__CP__ = 1;
                          this.yield((SetNodeChange) ch);
                          return true;
                        case 0:
                          this.__CP__ = 2;
                          break;
                        case 3:
                          this.__CP__ = 4;
                          break;
                        default:
                          break __loop__;
                      }
                    } while (true);
                    return false;
                  }
                };
              }
            };
          }
        }).toListSequence();
        ListSequence.fromList(changeList.value).removeWhere(new IWhereFilter<Change>() {
          public boolean accept(final Change ch) {
            return ch instanceof DeleteNodeChange && ListSequence.fromList(setNodeChanges).any(new IWhereFilter<SetNodeChange>() {
              public boolean accept(SetNodeChange snCh) {
                return snCh.getOldChildId().equals(ch.getAffectedNodeId());
              }
            });
          }
        });
        changeList.value = ListSequence.fromList(changeList.value).<Change>select(new ISelector<Change, Change>() {
          public Change select(Change ch) {
            Change newCh = ch;
            if (ch instanceof DeleteNodeChange) {
              SNode deletedNode = myBaseVersionModel.getNodeById(ch.getAffectedNodeId());
              if (LinkDeclaration_Behavior.call_isSingular_1213877254557(SNodeOperations.getContainingLinkDeclaration(deletedNode))) {
                newCh = new DeleteNodeChange(ch.getAffectedNodeId(), ((DeleteNodeChange) ch).getChildren(), check_fh1co9_c0a0a0b0b0a0a0a9a0e0y(SNodeOperations.getParent(deletedNode)), SNodeOperations.getContainingLinkRole(deletedNode), -1);
              }
            }
            return newCh;
          }
        }).toListSequence();
        ListSequence.fromList(myChangeList).clear();
        return ListSequence.fromList(myChangeList).addSequence(ListSequence.fromList(changeList.value));
        // avoid returning value 
      }
    }));
  }

  private void updateChangesCountsForRootsAndMultipleChildChanges() {
    myCommandQueue.assertSoftlyIsCommandThread();
    MapSequence.fromMap(myRootForChange).clear();
    MapSequence.fromMap(myMultipleChildChanges).clear();
    SModel model = getModel();
    for (Change change : ListSequence.fromList(getChangeList())) {
      SNodeId nodeId = change.getAffectedNodeId();
      if (nodeId == null) {
        continue;
      }
      SNode node = model.getNodeById(nodeId);
      if (node == null || change instanceof DeleteNodeChange) {
        node = myBaseVersionModel.getNodeById(nodeId);
      }
      assert node != null;
      addRootInfoForChange(change, SNodeOperations.getContainingRoot(node).getSNodeId(), model);

      if (change instanceof AddNodeChange || change instanceof DeleteNodeChange) {
        SNode parentNode = SNodeOperations.getParent(node);
        if (!(LinkDeclaration_Behavior.call_isSingular_1213877254557(SNodeOperations.getContainingLinkDeclaration(node))) && parentNode != null) {
          Tuples._2<SNodeId, String> pair = MultiTuple.<SNodeId,String>from(parentNode.getSNodeId(), SNodeOperations.getContainingLinkRole(node));
          if (MapSequence.fromMap(myMultipleChildChanges).containsKey(pair)) {
            ListSequence.fromList(MapSequence.fromMap(myMultipleChildChanges).get(pair)).addElement(change);
          } else {
            MapSequence.fromMap(myMultipleChildChanges).put(pair, ListSequence.fromListWithValues(new ArrayList<Change>(), Arrays.asList(change)));
          }
        }
      }
    }
  }

  private void updateAddedNodesSet() {
    SetSequence.fromSet(myAddedNodeIds).clear();
    for (Change change : ListSequence.fromList(myChangeList)) {
      if (change instanceof NewNodeChange) {
        SetSequence.fromSet(myAddedNodeIds).addElement(change.getAffectedNodeId());
      }
    }
  }

  private boolean checkLoaded() {
    myCommandQueue.assertSoftlyIsCommandThread();
    if (myEnabled && isEmpty()) {
      update(true);
    }
    return myBaseVersionModel != null;
  }

  private void fillWithAddRootChange() {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        for (SNode root : ListSequence.fromList(SModelOperations.getRoots(getModel(), null))) {
          addChange(new AddRootChange(root.getConceptFqName(), root.getSNodeId()), root);
        }
      }
    });
  }

  private void clearCaches() {
    SetSequence.fromSet(myAddedNodeIds).clear();
    MapSequence.fromMap(myChangesCountsForRoots).clear();
    MapSequence.fromMap(myRootForChange).clear();
    MapSequence.fromMap(myMultipleChildChanges).clear();
  }

  private void update(boolean forceLoadBaseVersion) {
    myCommandQueue.assertSoftlyIsCommandThread();
    removeAllChanges();
    clearCaches();

    if (!(myModelDescriptor instanceof EditableSModelDescriptor)) {
      return;
    }
    IFile modelFile = ((EditableSModelDescriptor) myModelDescriptor).getModelFile();
    if (modelFile == null || !(modelFile.exists())) {
      return;
    }
    VirtualFile modelVFile = VirtualFileUtils.getVirtualFile(modelFile);

    assert myProject.getComponent(VcsFileStatusProvider.class) != null;

    myBaseVersionModel = null;
    if (myProject.getComponent(ProjectLevelVcsManager.class).getVcsFor(modelVFile) == null) {
      return;
    }
    FileStatus status = myProject.getComponent(VcsFileStatusProvider.class).getFileStatus(modelVFile);
    setFileStatus(status);
    if (!(myEnabled)) {
      return;
    }
    if (!(forceLoadBaseVersion) && FileStatus.NOT_CHANGED == status) {
      return;
    }
    if (FileStatus.ADDED == status || FileStatus.UNKNOWN == status) {
      return;
    }
    try {
      String content = VCSUtils.getBaseVersionContent(modelVFile, myProject);
      if (content == null && status != FileStatus.NOT_CHANGED && status != FileStatus.UNKNOWN) {
        if (log.isErrorEnabled()) {
          log.error("Base version content is null while file status is " + status);
        }
      }
      if (content == null) {
        return;
      }
      myBaseVersionModel = ModelUtils.readModel(content, modelVFile.toString());
      final Wrappers._T<List<Change>> changeList = new Wrappers._T<List<Change>>();
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          myChangeList = new DiffBuilder(myBaseVersionModel, getModel()).getChanges();
          mergeChanges();
          updateChangesCountsForRootsAndMultipleChildChanges();
          refreshAllMultipleChildChanges();
          changeList.value = myChangeList;
          updateAddedNodesSet();
        }
      });
      fileStatusChangedForRootNodes(getModel());

      for (Change change : ListSequence.fromList(changeList.value)) {
        fireChangeAdded(change);
      }

      FileStatusManager statusManager = FileStatusManager.getInstance(myProject);
      assert statusManager != null;
      SModel model = getModel();
      for (Change change : ListSequence.fromList(changeList.value)) {
        if (change instanceof AddRootChange) {
          SNode node = model.getNodeById(change.getAffectedNodeId());
          MPSNodeVirtualFile virtualFile = MPSNodesVirtualFileSystem.getInstance().getFileFor(node);
          statusManager.fileStatusChanged(virtualFile);
        }
      }
    } catch (Exception exception) {
      if (log.isWarnEnabled()) {
        log.warn("Exception during updating changes for model " + myModelDescriptor.getLongName(), exception);
      }
    }
  }

  public void setEnabled(final boolean enabled) {
    myCommandQueue.runTask(new Runnable() {
      public void run() {
        if (myEnabled != enabled) {
          myEnabled = enabled;
          if (enabled) {
            if (log.isDebugEnabled()) {
              log.debug("Enabled for " + myModelDescriptor.getLongName());
            }
            fireChangeUpdateStarted();
            update(false);
            fireChangeUpdateFinished();
          }
        }
      }
    });
  }

  public boolean isEnabled() {
    myCommandQueue.assertSoftlyIsCommandThread();
    return myEnabled;
  }

  public void update(final FileStatus newFileStatus) {
    myCommandQueue.runTask(new Runnable() {
      public void run() {
        fireChangeUpdateStarted();
        if (newFileStatus == null || myFileStatus != newFileStatus) {
          update(false);
        }
        fireChangeUpdateFinished();
      }
    });
  }

  @Nullable
  public SNodeId getBaseParentId(@NotNull SNodeId child) {
    myCommandQueue.assertSoftlyIsCommandThread();
    return check_fh1co9_a1a43(check_fh1co9_a0b0ib(check_fh1co9_a0a1a43(myBaseVersionModel, child)));
  }

  public boolean isAddedNode(@NotNull SNodePointer node) {
    myCommandQueue.assertSoftlyIsCommandThread();
    return SetSequence.fromSet(myAddedNodeIds).contains(node.getNodeId());
  }

  private void refreshAllMultipleChildChanges() {
    myCommandQueue.assertSoftlyIsCommandThread();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        SModel model = getModel();
        for (Tuples._2<SNodeId, String> nodeIdRolePair : SetSequence.fromSet(MapSequence.fromMap(myMultipleChildChanges).keySet()).toListSequence()) {
          refreshMultipleChildChanges(model.getNodeById(nodeIdRolePair._0()), nodeIdRolePair._1(), true);
        }

      }
    });
  }

  private List<SNode> getCurrentChildren(@NotNull SNode parentNode, @NotNull String role) {
    if (AttributesRolesUtil.isAttributeRole(role)) {
      return parentNode.getChildren(role);
    }
    return SNodeOperations.getChildren(parentNode, AbstractConceptDeclaration_Behavior.call_findLinkDeclaration_1213877394467(SNodeOperations.getConceptDeclaration(parentNode), role));
  }

  private void refreshMultipleChildChanges(SNode parentNode, String role, boolean silent) {
    refreshMultipleChildChanges(parentNode, role, getCurrentChildren(parentNode, role), silent);
  }

  private void refreshMultipleChildChanges(SNode parentNode, String role, List<SNode> currentChildren, boolean silent) {
    myCommandQueue.assertSoftlyIsCommandThread();
    if ((parentNode == null)) {
      return;
    }
    Tuples._2<SNodeId, String> pair = MultiTuple.<SNodeId,String>from(parentNode.getSNodeId(), role);

    if (!(MapSequence.fromMap(myMultipleChildChanges).containsKey(pair))) {
      MapSequence.fromMap(myMultipleChildChanges).put(pair, ListSequence.fromList(new ArrayList<Change>()));
    }

    // Step 1: delete old changes for this link 
    for (Change change : ListSequence.fromList(MapSequence.fromMap(myMultipleChildChanges).get(pair)).toListSequence()) {
      removeChange(change, silent);
    }
    ListSequence.fromList(MapSequence.fromMap(myMultipleChildChanges).get(pair)).clear();

    // Step 2: find longest common subsequence of children 
    List<SNodeId> currentChildrenIds = SModelUtils.getNodeIds(currentChildren);
    List<SNodeId> baseChildrenIds = SModelUtils.getNodeIds(check_fh1co9_a0a21a93(myBaseVersionModel.getNodeById(parentNode.getSNodeId()), role));
    List<Tuples._2<Iterable<SNodeId>, Iterable<SNodeId>>> differentSubsequences = LongestCommonSubsequenceFinder.findDifferentSubsequences(baseChildrenIds, currentChildrenIds);

    // Step 3: add new changes 
    List<Change> changesToAdd = ListSequence.fromList(new ArrayList<Change>());
    for (Tuples._2<Iterable<SNodeId>, Iterable<SNodeId>> nodeGroups : ListSequence.fromList(differentSubsequences)) {
      List<SNodeId> baseNodeGroup = Sequence.fromIterable(nodeGroups._0()).toListSequence();
      List<SNodeId> currentNodeGroup = Sequence.fromIterable(nodeGroups._1()).toListSequence();
      int commonGroupSize = Math.min(ListSequence.fromList(baseNodeGroup).count(), ListSequence.fromList(currentNodeGroup).count());

      for (int i = 0; i < commonGroupSize; i++) {
        SNodeId baseNodeId = ListSequence.fromList(baseNodeGroup).getElement(i);
        final SNodeId currentNodeId = ListSequence.fromList(currentNodeGroup).getElement(i);
        SNode node = ListSequence.fromList(currentChildren).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode n) {
            return currentNodeId.equals(n.getSNodeId());
          }
        });
        assert node != null;

        // TODO null in prevSibling and prevRole 
        ListSequence.fromList(changesToAdd).addElement(new SubstituteNodeChange(node.getConceptFqName(), currentNodeId, role, parentNode.getSNodeId(), null, null, baseNodeId));
      }

      if (commonGroupSize == ListSequence.fromList(baseNodeGroup).count()) {
        for (final SNodeId nodeId : ListSequence.fromList(currentNodeGroup).skip(commonGroupSize)) {
          SNode node = ListSequence.fromList(currentChildren).findFirst(new IWhereFilter<SNode>() {
            public boolean accept(SNode n) {
              return nodeId.equals(n.getSNodeId());
            }
          });
          assert node != null;
          // TODO null in prevSibling and prevRole 
          ListSequence.fromList(changesToAdd).addElement(new AddNodeChange(node.getConceptFqName(), nodeId, role, parentNode.getSNodeId(), null, null));
        }
      } else {
        int currentIndex = 0;
        if (ListSequence.fromList(currentNodeGroup).isNotEmpty()) {
          currentIndex = ListSequence.fromList(currentChildrenIds).indexOf(ListSequence.fromList(currentNodeGroup).last()) + 1;
        } else {
          int indexInBase = ListSequence.fromList(baseChildrenIds).indexOf(ListSequence.fromList(baseNodeGroup).first());
          if (indexInBase != 0) {
            indexInBase--;
            currentIndex = ListSequence.fromList(currentChildrenIds).indexOf(ListSequence.fromList(baseChildrenIds).getElement(indexInBase)) + 1;
          }
        }
        for (SNodeId nodeId : ListSequence.fromList(baseNodeGroup).skip(commonGroupSize)) {
          ListSequence.fromList(changesToAdd).addElement(new DeleteNodeChange(nodeId, new ArrayList<SNodeId>(), parentNode.getSNodeId(), SNodeOperations.getContainingLinkRole(((SNode) myBaseVersionModel.getNodeById(nodeId))), currentIndex));
        }
      }
    }
    for (Change change : ListSequence.fromList(changesToAdd)) {
      addChange(change, SNodeOperations.getContainingRoot(parentNode), silent);
      ListSequence.fromList(MapSequence.fromMap(myMultipleChildChanges).get(pair)).addElement(change);
    }
  }

  public boolean isChangedRootNode(@NotNull SNodePointer node) {
    myCommandQueue.assertSoftlyIsCommandThread();
    return MapSequence.fromMap(myChangesCountsForRoots).containsKey(node.getNodeId()) && MapSequence.fromMap(myChangesCountsForRoots).get(node.getNodeId()) != 0;
  }

  @Nullable
  public FileStatus getFileStatus() {
    myCommandQueue.assertSoftlyIsCommandThread();
    return myFileStatus;
  }

  public boolean isNewModel() {
    myCommandQueue.assertSoftlyIsCommandThread();
    return myFileStatus == FileStatus.ADDED || myFileStatus == FileStatus.UNKNOWN;
  }

  @Nullable
  private SNode getBaseNode(@NotNull SNodeId childId, @Nullable SNode nodeToBeReplaced) {
    // This method gets node with given id from base version model to put in place 
    // where it was deleted in current model. When it may result in node id overlapping , 
    // it resets other nodes with overlapping ids, making this node and its children ids 
    // be the same as in base version model. 
    SNode baseNode = myBaseVersionModel.getNodeById(childId);
    SNode copyOfBaseNode = CopyUtil.copyAndPreserveId(baseNode);
    SModel model = getModel();
    List<SNode> nodesToChangeId = ListSequence.fromList(new ArrayList<SNode>());
    for (SNode descendant : ListSequence.fromList(SNodeOperations.getDescendants(baseNode, null, true, new String[]{}))) {
      // If rollbacking this change may end with node id overlapping, rollbacking should be cancelled 
      SNode maybeOverlappedNode = model.getNodeById(descendant.getSNodeId());
      if (maybeOverlappedNode != null) {
        if (nodeToBeReplaced != null && nodeToBeReplaced.isAncestorOf(maybeOverlappedNode)) {
          continue;
        }
        ListSequence.fromList(nodesToChangeId).addElement(maybeOverlappedNode);
      }
    }
    for (SNode node : ListSequence.fromList(SModelUtils.getDominators(nodesToChangeId))) {
      resetNodeId(node);
    }
    return copyOfBaseNode;
  }

  public void rollbackChanges(@NotNull Iterable<Change> changes) {
    Iterable<Change> sortedChanges = Sequence.fromIterable(changes).sort(new ISelector<Change, Comparable<?>>() {
      public Comparable<?> select(Change ch) {
        return ListSequence.fromList(myChangeList).indexOf(ch);
      }
    }, false);
    Sequence.fromIterable(sortedChanges).visitAll(new IVisitor<Change>() {
      public void visit(Change ch) {
        rollbackChangeCore(ch);
      }
    });
    MapSequence.fromMap(myRollbackReplaceCache).clear();
  }

  public void rollbackChange(@NotNull Change change) {
    rollbackChangeCore(change);
    MapSequence.fromMap(myRollbackReplaceCache).clear();
  }

  private void resetNodeId(@NotNull SNode node) {
    SNode copyOfNode = CopyUtil.copy(node);
    SNode parent = node.getParent();
    if (parent == null) {
      return;
    } else {
      MapSequence.fromMap(myRollbackReplaceCache).put(node.getSNodeId(), copyOfNode.getSNodeId());
      parent.replaceChild(node, copyOfNode);
      node.delete();
    }
  }

  private void rollbackChangeCore(@NotNull Change change) {
    // This method should be invoked inside command 
    assert ModelAccess.instance().canWrite();
    if (change instanceof NewNodeChange) {
      if (change instanceof AddRootChange) {
        return;
      } else {
        SNodeId nodeId = change.getAffectedNodeId();
        if (MapSequence.fromMap(myRollbackReplaceCache).containsKey(nodeId)) {
          nodeId = MapSequence.fromMap(myRollbackReplaceCache).get(nodeId);
        }
        SNode node = getModel().getNodeById(nodeId);
        if (node == null) {
          return;
        }
        SNodeId baseNodeId = null;
        if (change instanceof SubstituteNodeChange) {
          baseNodeId = ((SubstituteNodeChange) change).getOldChildId();
        } else if (change instanceof SetNodeChange) {
          baseNodeId = ((SetNodeChange) change).getOldChildId();
        }
        if (baseNodeId == null) {
          node.delete();
        } else {
          SNode parent = node.getParent();
          assert parent != null;

          SNode baseNode = getBaseNode(baseNodeId, node);
          if (baseNode != null) {
            MapSequence.fromMap(myRollbackReplaceCache).put(node.getSNodeId(), baseNode.getSNodeId());
            parent.replaceChild(node, baseNode);
            node.delete();
          }
        }
      }
    } else if (change instanceof DeleteNodeChange) {
      DeleteNodeChange deleteChange = (DeleteNodeChange) change;
      SNode parent = check_fh1co9_a0b0a2a74(myBaseVersionModel.getNodeById(change.getAffectedNodeId()));
      parent = getModel().getNodeById(check_fh1co9_a0a0c0a2a74(parent));
      SNode oldNode = getBaseNode(change.getAffectedNodeId(), null);
      if (deleteChange.getRole() != null && oldNode != null) {
        if (deleteChange.getNextChildIndex() == -1) {
          parent.setChild(deleteChange.getRole(), oldNode);
        } else {
          SNode anchorChild = null;
          if (deleteChange.getNextChildIndex() != 0) {
            anchorChild = check_fh1co9_a0a0b0a0a4a0c0vb(parent.getChildren(deleteChange.getRole()), deleteChange);
            anchorChild = getModel().getNodeById(check_fh1co9_a0a0b0b0a0a4a0c0vb(anchorChild));
          }
          parent.insertChild(anchorChild, deleteChange.getRole(), oldNode);
        }
      }
    } else if (change instanceof SetPropertyChange) {
      String role = ((SetPropertyChange) change).getProperty();
      SNode node = getModel().getNodeById(change.getAffectedNodeId());
      assert node != null;
      node.setProperty(role, check_fh1co9_b0a3a1c0vb(myBaseVersionModel.getNodeById(node.getSNodeId()), role));
    } else if (change instanceof SetReferenceChange) {
      String role = ((SetReferenceChange) change).getRole();
      SNode node = getModel().getNodeById(change.getAffectedNodeId());
      assert node != null;
      SReference br = check_fh1co9_a0d0c2a74(myBaseVersionModel.getNodeById(node.getSNodeId()), role);
      if (br == null) {
        node.setReferent(role, null);
      } else {
        if (br instanceof StaticReference) {
          StaticReference newReference = new StaticReference(role, node, br.getTargetSModelReference(), br.getTargetNodeId(), br.getResolveInfo());
          node.removeReferent(role);
          node.addReference(newReference);
        } else {
          if (log.isErrorEnabled()) {
            log.error("Model " + myModelDescriptor.getSModelReference().getSModelFqName() + " has non-static references");
          }
        }
      }
    }
  }

  private static SNodeId check_fh1co9_a0a0a1a0a0h0c0a6a0e0y(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static SNodeId check_fh1co9_e0a0a2a0a0h0c0a6a0e0y(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static SNode check_fh1co9_a4a0a0c0a0a7a2a0g0a4a42(SNode p, SNode node) {
    if (null == p) {
      return null;
    }
    return p.getChild(SNodeOperations.getContainingLinkRole(node));
  }

  private static SNodeId check_fh1co9_c0a0a0b0b0a0a0a9a0e0y(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static SNodeId check_fh1co9_a1a43(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static SNode check_fh1co9_a0b0ib(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getParent();
  }

  private static SNode check_fh1co9_a0a1a43(SModel p, SNodeId child) {
    if (null == p) {
      return null;
    }
    return p.getNodeById(child);
  }

  private static List<SNode> check_fh1co9_a0a21a93(SNode p, String role) {
    if (null == p) {
      return null;
    }
    return p.getChildren(role);
  }

  private static SNode check_fh1co9_a0b0a2a74(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getParent();
  }

  private static SNodeId check_fh1co9_a0a0c0a2a74(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static SNode check_fh1co9_a0a0b0a0a4a0c0vb(List<SNode> p, DeleteNodeChange deleteChange) {
    if (null == p) {
      return null;
    }
    return p.get(deleteChange.getNextChildIndex() - 1);
  }

  private static SNodeId check_fh1co9_a0a0b0b0a0a4a0c0vb(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static String check_fh1co9_b0a3a1c0vb(SNode p, String role) {
    if (null == p) {
      return null;
    }
    return p.getProperty(role);
  }

  private static SReference check_fh1co9_a0d0c2a74(SNode p, String role) {
    if (null == p) {
      return null;
    }
    return p.getReference(role);
  }

  private static SNodeId check_fh1co9_a0a1a3a2a2a(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static SNodeId check_fh1co9_b0a1a3a2a2a(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static String check_fh1co9_a0h0a3a0a0b0m0(SNode p, SModelPropertyEvent e) {
    if (null == p) {
      return null;
    }
    return p.getProperty(e.getPropertyName());
  }

  private static SNode check_fh1co9_a0j0a3a0a0b0o0(SNode p, SReference reference) {
    if (null == p) {
      return null;
    }
    return p.getReferent(reference.getRole());
  }

  private static SNodeId check_fh1co9_c0a0a0a0j0a3a0a0c0r0(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static SNodeId check_fh1co9_a0a0a0c0i0a3a0a0c0t0(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static SNodeId check_fh1co9_e0a0f0i0a3a0a0c0t0(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }

  private static SNode check_fh1co9_a4a0a5a8a0d0a0a2a91a(SNode p, SModelChildEvent e) {
    if (null == p) {
      return null;
    }
    return p.getChild(e.getChildRole());
  }

  private class MyModelListener extends SModelAdapter {
    public MyModelListener() {
    }

    private void removeChildChanges(@NotNull final SNodeId nodeId) {
      removeChanges(NewNodeChange.class, new _FunctionTypes._return_P1_E0<Boolean, NewNodeChange>() {
        public Boolean invoke(NewNodeChange ch) {
          return nodeId.equals(ch.getNodeParent());
        }
      });
      removeChanges(DeleteNodeChange.class, new _FunctionTypes._return_P1_E0<Boolean, DeleteNodeChange>() {
        public Boolean invoke(DeleteNodeChange ch) {
          return nodeId.equals(ch.getParentId());
        }
      });
    }

    private void recursivelyChildRemoved(SNode subtreeRoot) {
      myCommandQueue.assertSoftlyIsCommandThread();
      SModel model = SNodeOperations.getModel(subtreeRoot);
      for (SNode node : ListSequence.fromList(SNodeOperations.getDescendants(subtreeRoot, null, false, new String[]{})).reversedList()) {
        processChildRemoved(new SModelChildEvent(model, false, SNodeOperations.getParent(node), SNodeOperations.getContainingLinkRole(node), SNodeOperations.getIndexInParent(node), node), false);
      }
    }

    private void recursivelyChildAdded(SNode subtreeRoot) {
      myCommandQueue.assertSoftlyIsCommandThread();
      SModel model = SNodeOperations.getModel(subtreeRoot);
      for (SNode node : ListSequence.fromList(SNodeOperations.getDescendants(subtreeRoot, null, true, new String[]{}))) {
        if (node != subtreeRoot) {
          processChildAdded(new SModelChildEvent(model, true, SNodeOperations.getParent(node), SNodeOperations.getContainingLinkRole(node), SNodeOperations.getIndexInParent(node), node), false);
        }
        // Processing deleted children 
        SNode baseParent = myBaseVersionModel.getNodeById(node.getSNodeId());
        for (SNode baseChild : ListSequence.fromList(SNodeOperations.getChildren(baseParent))) {
          SNode thisChild = model.getNodeById(baseChild.getSNodeId());
          if (!(SNodeOperations.getParent(thisChild) == node && ObjectUtils.equals(SNodeOperations.getContainingLinkRole(thisChild), SNodeOperations.getContainingLinkRole(baseChild))) && ObjectUtils.equals(check_fh1co9_a0a1a3a2a2a(SNodeOperations.getPrevSibling(thisChild)), check_fh1co9_b0a1a3a2a2a(SNodeOperations.getPrevSibling(baseChild)))) {
            processChildRemoved(new SModelChildEvent(model, false, node, SNodeOperations.getContainingLinkRole(baseChild), SNodeOperations.getIndexInParent(baseChild), baseChild), false);
          }
        }
        for (IMapping<String, String> property : MapSequence.fromMap(node.getProperties())) {
          propertyChanged(new SModelPropertyEvent(model, property.key(), node, null, property.value()));
        }
        for (SReference reference : ListSequence.fromList(node.getReferences())) {
          referenceAdded(new SModelReferenceEvent(model, reference, true));
        }
      }
    }

    private void checkAndAddImportChange(final ModelImportChange modelImportChange) {
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          if (!(checkLoaded())) {
            return;
          }
          fireChangeUpdateStarted();
          if (removeChanges(ModelImportChange.class, new _FunctionTypes._return_P1_E0<Boolean, ModelImportChange>() {
            public Boolean invoke(ModelImportChange ch) {
              return modelImportChange.isOppositeTo(ch);
            }
          }) == 0) {
            // No change was deleted, new change is addable 
            addChange(modelImportChange, null);
          }
          fireChangeUpdateFinished();
        }
      });
    }

    @Override
    public void importRemoved(SModelImportEvent e) {
      checkAndAddImportChange(new ModelImportChange(e.getModelDescriptor().getSModelReference(), true));
    }

    @Override
    public void importAdded(SModelImportEvent e) {
      checkAndAddImportChange(new ModelImportChange(e.getModelDescriptor().getSModelReference(), false));
    }

    private void checkAndAddUsedLanguagesChange(final UsedLanguagesChange usedLanguagesChange) {
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          if (!(checkLoaded())) {
            return;
          }
          fireChangeUpdateStarted();
          if (removeChanges(UsedLanguagesChange.class, new _FunctionTypes._return_P1_E0<Boolean, UsedLanguagesChange>() {
            public Boolean invoke(UsedLanguagesChange ch) {
              return usedLanguagesChange.isOppositeTo(ch);
            }
          }) == 0) {
            // No change was deleted, change is addable 
            addChange(usedLanguagesChange, null);
          }
          fireChangeUpdateFinished();
        }
      });
    }

    @Override
    public void languageAdded(SModelLanguageEvent e) {
      checkAndAddUsedLanguagesChange(new UsedLanguagesChange(e.getLanguageNamespace(), false));
    }

    @Override
    public void languageRemoved(SModelLanguageEvent e) {
      checkAndAddUsedLanguagesChange(new UsedLanguagesChange(e.getLanguageNamespace(), true));
    }

    private void checkAndAddUsedDevkitsChange(final UsedDevkitsChange usedDevkitsChange) {
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          if (!(checkLoaded())) {
            return;
          }

          fireChangeUpdateStarted();
          if (removeChanges(UsedDevkitsChange.class, new _FunctionTypes._return_P1_E0<Boolean, UsedDevkitsChange>() {
            public Boolean invoke(UsedDevkitsChange ch) {
              return usedDevkitsChange.isOppositeTo(ch);
            }
          }) == 0) {
            // No change was deleted, change is addable 
            addChange(usedDevkitsChange, null);
          }
          fireChangeUpdateFinished();
        }
      });
    }

    @Override
    public void devkitAdded(SModelDevKitEvent e) {
      checkAndAddUsedDevkitsChange(new UsedDevkitsChange(e.getDevkitNamespace(), false));
    }

    @Override
    public void devkitRemoved(SModelDevKitEvent e) {
      checkAndAddUsedDevkitsChange(new UsedDevkitsChange(e.getDevkitNamespace(), true));
    }

    @Override
    public void propertyChanged(final SModelPropertyEvent e) {
      final List<SNode> pathToRoot = SModelUtils.getPathToRoot(e.getNode());
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          if (!(checkLoaded())) {
            return;
          }

          fireChangeUpdateStarted();
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              if (isAncestorAlreadyAdded(pathToRoot)) {
                return;
              }

              final SNodeId nodeId = e.getNode().getSNodeId();

              // Remove old change for the same property if needed 
              removeChanges(SetPropertyChange.class, new _FunctionTypes._return_P1_E0<Boolean, SetPropertyChange>() {
                public Boolean invoke(SetPropertyChange ch) {
                  return nodeId.equals(ch.getAffectedNodeId()) && e.getPropertyName().equals(ch.getProperty());
                }
              });

              String baseValue = check_fh1co9_a0h0a3a0a0b0m0(myBaseVersionModel.getNodeById(nodeId), e);
              PropertyDeclaration propertyDeclaration = e.getNode().getPropertyDeclaration(e.getPropertyName());
              if (propertyDeclaration == null) {
                if (ObjectUtils.equals(baseValue, e.getNewPropertyValue())) {
                  return;
                }
              } else {
                PropertySupport propertySupport = PropertySupport.getPropertySupport(propertyDeclaration);
                String baseInternalValue = propertySupport.toInternalValue(baseValue);
                String newInternalValue = propertySupport.toInternalValue(e.getNewPropertyValue());
                if (ObjectUtils.equals(baseInternalValue, newInternalValue)) {
                  return;
                }
              }

              addChange(new SetPropertyChange(nodeId, e.getPropertyName(), e.getNewPropertyValue()), e.getAffectedRoot());
            }
          });
          fireChangeUpdateFinished();
        }
      });
    }

    @Override
    public void referenceRemoved(final SModelReferenceEvent e) {
      final List<SNode> pathToRoot = SModelUtils.getPathToRoot(e.getReference().getSourceNode());
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          if (!(checkLoaded())) {
            return;
          }

          fireChangeUpdateStarted();
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              if (isAncestorAlreadyAdded(pathToRoot)) {
                return;
              }

              final SNodeId sourceNodeId = e.getReference().getSourceNode().getSNodeId();

              // Remove SetReferenceChange for this reference if needed 
              removeChanges(SetReferenceChange.class, new _FunctionTypes._return_P1_E0<Boolean, SetReferenceChange>() {
                public Boolean invoke(SetReferenceChange ch) {
                  return ch.getAffectedNodeId().equals(sourceNodeId) && ch.getRole().equals(e.getReference().getRole());
                }
              });

              addChange(new DeleteReferenceChange(sourceNodeId, e.getModel(), e.getReference()), e.getAffectedRoot());
            }
          });
          fireChangeUpdateFinished();
        }
      });
    }

    @Override
    public void referenceAdded(final SModelReferenceEvent e) {
      final List<SNode> pathToRoot = SModelUtils.getPathToRoot(e.getReference().getSourceNode());
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          if (!(checkLoaded())) {
            return;
          }

          fireChangeUpdateStarted();
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              final SReference reference = e.getReference();
              if (isAncestorAlreadyAdded(pathToRoot)) {
                return;
              }

              final SNodeId sourceNodeId = reference.getSourceNode().getSNodeId();

              // Remove SetReferenceChange for this reference if needed 
              removeChanges(SetReferenceChange.class, new _FunctionTypes._return_P1_E0<Boolean, SetReferenceChange>() {
                public Boolean invoke(SetReferenceChange ch) {
                  return ch.getAffectedNodeId().equals(sourceNodeId) && ch.getRole().equals(reference.getRole());
                }
              });

              // Do not add change for this reference, if it is actually unchanged 
              SNode baseTargetNode = check_fh1co9_a0j0a3a0a0b0o0(myBaseVersionModel.getNodeById(sourceNodeId), reference);
              if (baseTargetNode != null && new SNodePointer(baseTargetNode).equals(new SNodePointer(reference.getTargetSModelReference(), reference.getTargetNodeId()))) {
                return;
              }

              addChange(new SetReferenceChange(sourceNodeId, e.getModel(), e.getReference(), e.getReference().getTargetNode()), e.getAffectedRoot());
            }
          });
          fireChangeUpdateFinished();
        }
      });
    }

    @Override
    public void rootAdded(final SModelRootEvent e) {
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          if (!(checkLoaded()) && !(isNewModel())) {
            return;
          }

          fireChangeUpdateStarted();
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              removeChanges(AddRootChange.class, new _FunctionTypes._return_P1_E0<Boolean, AddRootChange>() {
                public Boolean invoke(AddRootChange ch) {
                  return ch.getAffectedNodeId().equals(e.getRoot().getSNodeId());
                }
              });
              if (removeChanges(DeleteNodeChange.class, new _FunctionTypes._return_P1_E0<Boolean, DeleteNodeChange>() {
                public Boolean invoke(DeleteNodeChange ch) {
                  return ch.getAffectedNodeId().equals(e.getRoot().getSNodeId());
                }
              }) == 0) {
                addChange(new AddRootChange(e.getRoot().getConceptFqName(), e.getRoot().getSNodeId()), e.getRoot());
              }
              if (!(isNewModel())) {
                recursivelyChildAdded(e.getRoot());
              }
            }
          });
          fireChangeUpdateFinished();
        }
      });
    }

    @Override
    public void rootRemoved(final SModelRootEvent e) {
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          if (!(checkLoaded()) && !(isNewModel())) {
            return;
          }

          fireChangeUpdateStarted();
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              recursivelyChildRemoved(e.getRoot());
              removeChanges(Change.class, new _FunctionTypes._return_P1_E0<Boolean, Change>() {
                public Boolean invoke(Change ch) {
                  return !(ch instanceof NewNodeChange || ch instanceof DeleteNodeChange) && ObjectUtils.equals(ch.getAffectedNodeId(), e.getRoot().getSNodeId());
                }
              });
              removeChildChanges(e.getRoot().getSNodeId());
              if (removeChanges(AddRootChange.class, new _FunctionTypes._return_P1_E0<Boolean, AddRootChange>() {
                public Boolean invoke(AddRootChange ch) {
                  return ObjectUtils.equals(ch.getAffectedNodeId(), e.getRoot().getSNodeId());
                }
              }) == 0) {
                addChange(new DeleteNodeChange(e.getRoot().getSNodeId(), SModelUtils.getNodeIds(e.getRoot().getChildren())), e.getRoot());
              }
            }
          });
          fireChangeUpdateFinished();
        }
      });
    }

    private void processChildRemoved(final SModelChildEvent e, final boolean recursively) {
      final List<SNode> pathToRoot = SModelUtils.getPathToRoot(e.getParent());
      final List<SNode> currentChildren = getCurrentChildren(e.getParent(), e.getChildRole());
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          if (!(checkLoaded())) {
            return;
          }

          fireChangeUpdateStarted();
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              if (recursively) {
                recursivelyChildRemoved(e.getChild());
              }
              if (isAncestorAlreadyAdded(pathToRoot)) {
                return;
              }
              removeChanges(Change.class, new _FunctionTypes._return_P1_E0<Boolean, Change>() {
                public Boolean invoke(Change ch) {
                  return !(ch instanceof NewNodeChange || ch instanceof DeleteNodeChange) && ObjectUtils.equals(ch.getAffectedNodeId(), e.getChild().getSNodeId());
                }
              });
              removeChildChanges(e.getChild().getSNodeId());

              // This method is optimized to order of raising model events: before raising 
              // childRemoved() event for node it raises childRemoved() and similar events for all its children 

              boolean isSingle = SModelUtils.isChildInSingleRole(e);
              if (removeChanges(NewNodeChange.class, new _FunctionTypes._return_P1_E0<Boolean, NewNodeChange>() {
                public Boolean invoke(NewNodeChange ch) {
                  return ch.getAffectedNodeId().equals(e.getChild().getSNodeId());
                }
              }) == 0) {
                if (isSingle) {
                  addChange(new DeleteNodeChange(e.getChild().getSNodeId(), SModelUtils.getNodeIds(e.getChild().getChildren()), check_fh1co9_c0a0a0a0j0a3a0a0c0r0(e.getParent()), e.getChildRole(), -1), e.getAffectedRoot());
                } else {
                  refreshMultipleChildChanges(e.getParent(), e.getChildRole(), currentChildren, false);
                }
              } else {
                if (isSingle) {
                  final SNode baseParent = myBaseVersionModel.getNodeById(e.getParent().getSNodeId());
                  if (baseParent != null) {
                    ModelAccess.instance().runReadAction(new Runnable() {
                      public void run() {
                        SNode baseChild = baseParent.getChild(e.getChildRole());
                        if (baseChild != null) {
                          addChange(new DeleteNodeChange(baseChild.getSNodeId(), SModelUtils.getNodeIds(baseChild.getChildren()), baseParent.getSNodeId(), e.getChildRole(), -1), e.getAffectedRoot());
                        }
                      }
                    });
                  }
                } else {
                  refreshMultipleChildChanges(e.getParent(), e.getChildRole(), currentChildren, false);
                }
              }
            }
          });
          fireChangeUpdateFinished();
        }
      });
    }

    @Override
    public void childRemoved(SModelChildEvent event) {
      processChildRemoved(event, true);
    }

    private void processChildAdded(final SModelChildEvent e, final boolean recursively) {
      final List<SNode> pathToRoot = SModelUtils.getPathToRoot(e.getParent());
      final List<SNode> currentChildren = getCurrentChildren(e.getParent(), e.getChildRole());
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          if (!(checkLoaded())) {
            return;
          }

          fireChangeUpdateStarted();
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              if (isAncestorAlreadyAdded(pathToRoot)) {
                return;
              }

              SNode child = e.getChild();
              String prevRole = null;
              SNode prevSibling = child.prevSibling();
              if (prevSibling != null) {
                prevRole = prevSibling.getRole_();
              }

              boolean isSingle = SModelUtils.isChildInSingleRole(e);
              if (isSingle) {
                if (removeChanges(DeleteNodeChange.class, new _FunctionTypes._return_P1_E0<Boolean, DeleteNodeChange>() {
                  public Boolean invoke(DeleteNodeChange ch) {
                    return ch.getAffectedNodeId().equals(e.getChild().getSNodeId()) && ObjectUtils.equals(ch.getParentId(), e.getParent().getSNodeId());
                  }
                }) != 0) {
                  return;
                }
                SNode thisNodeInBase = myBaseVersionModel.getNodeById(e.getChild().getSNodeId());
                if (thisNodeInBase != null) {
                  if (e.getParent().getSNodeId().equals(check_fh1co9_a0a0a0c0i0a3a0a0c0t0(SNodeOperations.getParent(thisNodeInBase))) && e.getChildRole().equals(SNodeOperations.getContainingLinkRole(thisNodeInBase))) {
                    return;
                  }
                }
                removeChanges(DeleteNodeChange.class, new _FunctionTypes._return_P1_E0<Boolean, DeleteNodeChange>() {
                  public Boolean invoke(DeleteNodeChange ch) {
                    return ObjectUtils.equals(ch.getParentId(), e.getParent().getSNodeId()) && e.getChildRole().equals(ch.getRole());
                  }
                });
                removeChanges(SetNodeChange.class, new _FunctionTypes._return_P1_E0<Boolean, SetNodeChange>() {
                  public Boolean invoke(SetNodeChange ch) {
                    return ObjectUtils.equals(ch.getNodeParent(), e.getParent().getSNodeId()) && e.getChildRole().equals(ch.getNodeRole());
                  }
                });
                addChange(new SetNodeChange(child.getConceptFqName(), child.getSNodeId(), e.getChildRole(), e.getParent().getSNodeId(), check_fh1co9_e0a0f0i0a3a0a0c0t0(check_fh1co9_a4a0a5a8a0d0a0a2a91a(myBaseVersionModel.getNodeById(e.getParent().getSNodeId()), e)), prevRole), e.getAffectedRoot());
              } else {
                refreshMultipleChildChanges(e.getParent(), e.getChildRole(), currentChildren, false);
              }
              if (recursively) {
                recursivelyChildAdded(e.getChild());
              }
            }
          });
          fireChangeUpdateFinished();
        }
      });
    }

    @Override
    public void childAdded(SModelChildEvent event) {
      processChildAdded(event, true);
    }
  }
}
