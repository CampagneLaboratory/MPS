package jetbrains.mps.vcs.changesmanager.tree;

/*Generated by MPS */

import jetbrains.mps.vcs.changesmanager.CurrentDifferenceAdapter;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.smodel.SNode;

public class ForestMapChangesUpdater extends CurrentDifferenceAdapter {
  private FeatureForestMap<ModelChange> myMap;
  private Map<ModelChange, Feature[]> myChangeToFeaturesMap = MapSequence.fromMap(new HashMap<ModelChange, Feature[]>());

  public ForestMapChangesUpdater(FeatureForestMap<ModelChange> map) {
    myMap = map;
  }

  @Override
  public void changeAdded(@NotNull final ModelChange change) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Feature[] features = getFeaturesForChange(change);
        MapSequence.fromMap(myChangeToFeaturesMap).put(change, features);
        for (Feature f : MapSequence.fromMap(myChangeToFeaturesMap).get(change)) {
          myMap.put(f, change);
        }
      }
    });
  }

  @Override
  public void changeRemoved(@NotNull ModelChange change) {
    Sequence.fromIterable(Sequence.fromArray(MapSequence.fromMap(myChangeToFeaturesMap).get(change))).visitAll(new IVisitor<Feature>() {
      public void visit(Feature f) {
        myMap.removeKey(f);
      }
    });
    MapSequence.fromMap(myChangeToFeaturesMap).removeKey(change);
  }

  private static Feature[] getFeaturesForChange(@NotNull ModelChange change) {
    ModelAccess.assertLegalRead();
    List<Feature> result = ListSequence.fromList(new ArrayList<Feature>());
    SModelReference modelReference = change.getChangeSet().getNewModel().getSModelReference();
    if (change instanceof AddRootChange) {
      AddRootChange arc = ((AddRootChange) change);
      ListSequence.fromList(result).addElement(new NodeFeature(new SNodePointer(modelReference, arc.getRootId())));
    } else if (change instanceof SetPropertyChange) {
      SetPropertyChange spc = ((SetPropertyChange) change);
      ListSequence.fromList(result).addElement(new PropertyFeature(new SNodePointer(modelReference, spc.getAffectedNodeId()), spc.getPropertyName()));
    } else if (change instanceof SetReferenceChange) {
      SetReferenceChange src = ((SetReferenceChange) change);
      ListSequence.fromList(result).addElement(new ReferenceFeature(new SNodePointer(modelReference, src.getAffectedNodeId()), src.getRole()));
    } else if (change instanceof NodeGroupChange) {
      NodeGroupChange ngc = ((NodeGroupChange) change);
      SNodeId parentId = ngc.getParentNodeId();
      int begin = ngc.getResultBegin();
      int end = ngc.getResultEnd();
      String role = ngc.getRole();
      if (begin == end) {
        ListSequence.fromList(result).addElement(new DeletedChildFeature(new SNodePointer(modelReference, parentId), role, begin));
      } else {
        List<SNode> changeChildren = change.getChangeSet().getNewModel().getNodeById(parentId).getChildren(role);
        for (int i = begin; i < end; i++) {
          ListSequence.fromList(result).addElement(new NodeFeature(new SNodePointer(modelReference, ListSequence.fromList(changeChildren).getElement(i).getSNodeId())));
        }
      }
    }
    return ListSequence.fromList(result).toGenericArray(Feature.class);
  }
}
