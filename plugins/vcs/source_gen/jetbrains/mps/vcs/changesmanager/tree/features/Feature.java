package jetbrains.mps.vcs.changesmanager.tree.features;

/*Generated by MPS */

import jetbrains.mps.smodel.SNodePointer;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;


/**
 * Feature is either node, node's property, node's reference, node's property list,
 * or node's reference list (see subclasses)
 */
public abstract class Feature {
  protected final SNodePointer myNodePointer;
  private int myHashCode;

  protected Feature(@NotNull SNodePointer nodePointer) {
    myNodePointer = nodePointer;
  }

  @NotNull
  public SNodePointer getNodePointer() {
    return myNodePointer;
  }

  @Nullable
  public abstract Feature getParent();

  @Override
  public int hashCode() {
    if (myHashCode == 0) {
      myHashCode = toString().hashCode();
      if (myHashCode == 0) {
        assert false : "Feature hash code cannot be 0";
      }
    }
    return myHashCode;
  }

  @Override
  public boolean equals(Object object) {
    if (this.getClass() == object.getClass()) {
      Feature that = ((Feature) object);
      if (this.myHashCode == that.myHashCode) {
        if (this.myNodePointer.equals(that.myNodePointer)) {
          return true;
        }
      }
    }
    return false;
  }

  @NotNull
  public abstract String toString();

  public Feature[] getAncestors() {
    List<Feature> features = ListSequence.fromList(new ArrayList<Feature>());
    for (Feature current = getParent(); current != null; current = current.getParent()) {
      ListSequence.fromList(features).addElement(current);
    }
    return ListSequence.fromList(features).toGenericArray(Feature.class);
  }

  @NotNull
  protected static String nodePointerToString(@NotNull SNodePointer nodePointer) {
    return nodePointer.getModelReference().toString() + "|" + nodePointer.getNodeId();
  }
}
