package jetbrains.mps.vcs.changesmanager.tree;

/*Generated by MPS */

import jetbrains.mps.ide.ui.tree.TreeMessageOwner;
import java.util.Map;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.ide.ui.tree.TreeMessage;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import jetbrains.mps.vcs.changesmanager.SimpleCommandQueue;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.ide.ui.tree.MPSTree;
import com.intellij.util.ui.update.MergingUpdateQueue;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.smodel.GlobalSModelEventsManager;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.vcs.changesmanager.tree.features.Feature;
import org.apache.log4j.Priority;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.vcs.changesmanager.tree.features.ModelFeature;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.intellij.util.ui.update.Update;
import jetbrains.mps.make.IMakeService;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import com.intellij.openapi.project.Project;
import jetbrains.mps.vcs.changesmanager.BaseVersionUtil;
import jetbrains.mps.vcs.platform.util.ConflictsUtil;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.persistence.DataSource;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.extapi.persistence.FileDataSource;
import jetbrains.mps.persistence.FilePerRootDataSource;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.ide.ui.tree.MPSTreeNodeListener;
import com.intellij.openapi.vcs.FileStatusListener;
import jetbrains.mps.smodel.SModelFileTracker;
import jetbrains.mps.smodel.SModelAdapter;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.intellij.util.containers.MultiMap;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class TreeHighlighter implements TreeMessageOwner {
  private Map<FileStatus, TreeMessage> myTreeMessages = MapSequence.fromMap(new HashMap<FileStatus, TreeMessage>());
  private CurrentDifferenceRegistry myRegistry;
  private SimpleCommandQueue myCommandQueue;
  private FeatureForestMap<ModelChange> myMap;
  private MPSTree myTree;
  private TreeNodeFeatureExtractor myFeatureExtractor;
  private boolean myInitialized;
  private TreeHighlighter.MyTreeNodeListener myTreeNodeListener = new TreeHighlighter.MyTreeNodeListener();
  private TreeHighlighter.MyFeatureForestMapListener myFeatureListener = new TreeHighlighter.MyFeatureForestMapListener();
  private TreeHighlighter.MyFileStatusListener myFileStatusListener = new TreeHighlighter.MyFileStatusListener();
  private TreeHighlighter.MyModelListener myGlobalModelListener;
  private final TreeHighlighter.FeaturesHolder myFeaturesHolder = new TreeHighlighter.FeaturesHolder();
  private MergingUpdateQueue myQueue = new MergingUpdateQueue("MPS Changes Manager RehighlightAll Watcher Queue", 500, true, null);

  public TreeHighlighter(@NotNull CurrentDifferenceRegistry registry, @NotNull FeatureForestMapSupport featureForestMapSupport, @NotNull MPSTree tree, @NotNull TreeNodeFeatureExtractor featureExtractor, boolean removeNodesOnModelDisposal) {
    myRegistry = registry;
    myCommandQueue = registry.getCommandQueue();
    myMap = featureForestMapSupport.getMap();
    myTree = tree;
    myFeatureExtractor = featureExtractor;
    if (removeNodesOnModelDisposal) {
      myGlobalModelListener = new TreeHighlighter.MyModelListener();
    }
  }

  public synchronized void init() {
    if (myInitialized) {
      return;
    }
    myInitialized = true;

    myMap.addListener(myFeatureListener);
    myTree.addTreeNodeListener(myTreeNodeListener);
    FileStatusManager.getInstance(myRegistry.getProject()).addFileStatusListener(myFileStatusListener);
    if (myGlobalModelListener != null) {
      GlobalSModelEventsManager.getInstance().addGlobalModelListener(myGlobalModelListener);
    }

    ModelAccess.instance().runReadInEDT(new Runnable() {
      public void run() {
        registerNodeRecursively(myTree.getRootNode());
      }
    });
  }

  public synchronized void dispose() {
    if (!(myInitialized)) {
      return;
    }
    myInitialized = false;

    if (myGlobalModelListener != null) {
      GlobalSModelEventsManager.getInstance().removeGlobalModelListener(myGlobalModelListener);
    }
    FileStatusManager.getInstance(myRegistry.getProject()).removeFileStatusListener(myFileStatusListener);
    myTree.removeTreeNodeListener(myTreeNodeListener);
    myMap.removeListener(myFeatureListener);
    myQueue.dispose();
  }

  private void registerNodeRecursively(@NotNull MPSTreeNode node) {
    registerNode(node);
    for (MPSTreeNode child : Sequence.fromIterable(node)) {
      registerNodeRecursively(child);
    }
  }

  private void registerNode(@NotNull final MPSTreeNode node) {
    final Feature feature = myFeatureExtractor.getFeature(node);
    if (feature != null) {
      synchronized (myFeaturesHolder) {
        myFeaturesHolder.putNodeWithFeature(feature, node);
      }
      myCommandQueue.runTask(new Runnable() {
        public void run() {
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              synchronized (myFeaturesHolder) {
                // check if node isn't already removed from tree 
                if (myFeaturesHolder.getNodesByFeature(feature).contains(node)) {
                  rehighlightNode(node, feature);
                }
              }
            }
          });
        }
      });
    }
  }

  private void unregisterNode(@NotNull MPSTreeNode node) {
    Feature feature = myFeatureExtractor.getFeature(node);
    if (feature != null) {
      synchronized (myFeaturesHolder) {
        if (myFeaturesHolder.getNodesByFeature(feature).contains(node)) {
          myFeaturesHolder.removeNodeWithFeature(feature, node);
        } else {
          if (LOG.isEnabledFor(Priority.ERROR)) {
            LOG.error("trying to remove tree node which was not registered: " + node.getClass().getName() + " " + feature);
          }
        }
      }
      unhighlightNode(node);
    }
  }

  private void unhighlightNode(@NotNull MPSTreeNode node) {
    node.removeTreeMessages(this, true);
  }

  private void rehighlightNode(@NotNull MPSTreeNode node, @NotNull Feature feature) {
    unhighlightNode(node);

    SModel model = SModelRepository.getInstance().getModelDescriptor(feature.getModelReference());
    if (model instanceof EditableSModel && !(model.isReadOnly())) {
      if (feature instanceof ModelFeature) {
        // do not try to compute changes in case we need only model status 
        TreeMessage message = getMessage((ModelFeature) feature);
        if (message != null) {
          node.addTreeMessage(message);
        }
        return;
      }

      EditableSModel emd = (EditableSModel) model;
      myRegistry.getCurrentDifference(emd).setEnabled(true);

      ModelChange change = myMap.get(feature);
      if (change == null) {
        change = myMap.getAddedAncestorValue(feature);
      }
      if (change != null) {
        node.addTreeMessage(getMessage(change, emd));
      } else if (myMap.isAncestorOfAddedFeature(feature)) {
        node.addTreeMessage(getMessage(FileStatus.MODIFIED));
      }
    }
  }

  private void rehighlightFeature(@NotNull Feature feature) {
    for (MPSTreeNode node : CollectionSequence.fromCollection(myFeaturesHolder.getNodesByFeature(feature))) {
      rehighlightNode(node, feature);
    }
  }

  private void rehighlightFeatureAndDescendants(@NotNull final Feature feature) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        synchronized (myFeaturesHolder) {
          rehighlightFeature(feature);
          SModelReference modelRef = feature.getModelReference();
          for (Feature anotherFeature : ListSequence.fromList(myFeaturesHolder.getFeaturesByModelReference(modelRef))) {
            if (Sequence.fromIterable(Sequence.fromArray(anotherFeature.getAncestors())).any(new IWhereFilter<Feature>() {
              public boolean accept(Feature a) {
                return feature.equals(a);
              }
            })) {
              rehighlightFeature(anotherFeature);
            }
          }
        }
      }
    });
  }


  private final Update rehighlightAllFeaturesUpdate = new Update(this) {
    @Override
    public void run() {
      if (myRegistry.getProject().isDisposed()) {
        return;
      }

      if (IMakeService.INSTANCE.isSessionActive()) {
        // re-queue, it will be executed in next batch after delay 
        rehighlightAllFeaturesLater();
      } else {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            rehighlightAllFeaturesNow();
          }
        });
      }
    }
  };

  private void rehighlightAllFeaturesLater() {
    myQueue.queue(rehighlightAllFeaturesUpdate);
  }

  private void rehighlightAllFeaturesNow() {
    ModelAccess.assertLegalRead();
    synchronized (myFeaturesHolder) {
      for (Feature f : ListSequence.fromList(myFeaturesHolder.getAllModelFeatures())) {
        rehighlightFeatureAndDescendants(f);
      }
    }
  }



  @NotNull
  private TreeMessage getMessage(@NotNull FileStatus fileStatus) {
    if (!(MapSequence.fromMap(myTreeMessages).containsKey(fileStatus))) {
      MapSequence.fromMap(myTreeMessages).put(fileStatus, new TreeMessage(fileStatus.getColor(), null, this));
    }
    return MapSequence.fromMap(myTreeMessages).get(fileStatus);
  }

  @NotNull
  private TreeMessage getMessage(@NotNull ModelChange modelChange, @NotNull EditableSModel modelDescriptor) {
    switch (modelChange.getType()) {
      case ADD:
        if (modelChange instanceof AddRootChange) {
          Project project = myRegistry.getProject();
          FileStatus modelStatus = getModelFileStatus(modelDescriptor, project);
          if (BaseVersionUtil.isAddedFileStatus(modelStatus)) {
            return getMessage(modelStatus);
          } else if (ConflictsUtil.isModelOrModuleConflicting(modelDescriptor, project)) {
            return getMessage(FileStatus.MERGED_WITH_CONFLICTS);
          }
        }
        return getMessage(FileStatus.ADDED);
      case CHANGE:
        return getMessage(FileStatus.MODIFIED);
      default:
        assert false;
        return getMessage(FileStatus.MERGED_WITH_CONFLICTS);
    }
  }

  @Nullable
  private TreeMessage getMessage(@NotNull ModelFeature modelFeature) {
    SModel md = SModelRepository.getInstance().getModelDescriptor(modelFeature.getModelReference());
    if (md instanceof EditableSModel) {
      FileStatus status = getModelFileStatus((EditableSModel) md, myRegistry.getProject());
      return (status == null ? null : getMessage(status));
    } else {
      return null;
    }
  }

  @Nullable
  private static FileStatus getModelFileStatus(@NotNull EditableSModel ed, @NotNull Project project) {
    DataSource ds = ed.getSource();
    IFile file = null;
    if (ds instanceof FileDataSource) {
      file = ((FileDataSource) ds).getFile();
    } else if (ds instanceof FilePerRootDataSource) {
      file = ((FilePerRootDataSource) ds).getFile(FilePerRootDataSource.HEADER_FILE);
    }
    VirtualFile vf = VirtualFileUtils.getVirtualFile(file);
    return (vf == null ? null : FileStatusManager.getInstance(project).getStatus(vf));
  }

  private class MyTreeNodeListener implements MPSTreeNodeListener {
    public MyTreeNodeListener() {
    }

    @Override
    public void treeNodeAdded(MPSTreeNode node, MPSTree tree) {
      registerNode(node);
    }

    @Override
    public void treeNodeRemoved(MPSTreeNode node, MPSTree tree) {
      unregisterNode(node);
    }

    @Override
    public void treeNodeUpdated(MPSTreeNode node, MPSTree tree) {
    }

    @Override
    public void beforeTreeDisposed(MPSTree tree) {
      TreeHighlighterFactory.getInstance(myRegistry.getProject()).unhighlightTree(myTree);
    }
  }

  private class MyFeatureForestMapListener implements FeatureForestMapListener {
    public MyFeatureForestMapListener() {
    }

    @Override
    public void featureStateChanged(Feature feature) {
      rehighlightFeatureAndDescendants(feature);
    }
  }

  private class MyFileStatusListener implements FileStatusListener {
    public MyFileStatusListener() {
    }

    @Override
    public void fileStatusChanged(@NotNull VirtualFile file) {
      IFile ifile = VirtualFileUtils.toIFile(file);
      SModel emd = SModelFileTracker.getInstance().findModel(ifile);
      if (emd != null) {
        rehighlightFeatureAndDescendants(new ModelFeature(emd.getReference()));
      }
    }

    @Override
    public void fileStatusesChanged() {
      rehighlightAllFeaturesLater();
    }
  }

  private class MyModelListener extends SModelAdapter {
    public MyModelListener() {
    }

    @Override
    public void beforeModelDisposed(SModel model) {
      SModelReference modelRef = model.getReference();
      List<MPSTreeNode> obsoleteTreeNodes = ListSequence.fromList(new ArrayList<MPSTreeNode>());
      synchronized (myFeaturesHolder) {
        for (Feature f : ListSequence.fromList(myFeaturesHolder.getFeaturesByModelReference(modelRef))) {
          if (!(f instanceof ModelFeature)) {
            ListSequence.fromList(obsoleteTreeNodes).addSequence(CollectionSequence.fromCollection(myFeaturesHolder.getNodesByFeature(f)));
            myFeaturesHolder.removeFeature(f);
          }
        }
      }
      ListSequence.fromList(obsoleteTreeNodes).visitAll(new IVisitor<MPSTreeNode>() {
        public void visit(MPSTreeNode tn) {
          unhighlightNode(tn);
        }
      });
    }
  }

  private class FeaturesHolder {
    private final MultiMap<Feature, MPSTreeNode> myFeatureToNodes = new MultiMap<Feature, MPSTreeNode>();
    private final MultiMap<SModelReference, Feature> myModelRefToFeatures = new MultiMap<SModelReference, Feature>();

    public FeaturesHolder() {
    }

    public void putNodeWithFeature(Feature feature, MPSTreeNode node) {
      myFeatureToNodes.putValue(feature, node);
      myModelRefToFeatures.putValue(feature.getModelReference(), feature);
    }

    public void removeNodeWithFeature(Feature feature, MPSTreeNode node) {
      myFeatureToNodes.removeValue(feature, node);
      if (myFeatureToNodes.get(feature).isEmpty()) {
        myModelRefToFeatures.removeValue(feature.getModelReference(), feature);
      }
    }

    public void removeFeature(Feature feature) {
      myFeatureToNodes.remove(feature);
      myModelRefToFeatures.removeValue(feature.getModelReference(), feature);
    }

    public Collection<MPSTreeNode> getNodesByFeature(Feature feature) {
      return myFeatureToNodes.get(feature);
    }

    public List<Feature> getFeaturesByModelReference(SModelReference modelRef) {
      List<Feature> features = ListSequence.fromList(new ArrayList<Feature>());
      ListSequence.fromList(features).addSequence(CollectionSequence.fromCollection(myModelRefToFeatures.get(modelRef)));
      return features;
    }

    public List<Feature> getAllModelFeatures() {
      List<Feature> features = ListSequence.fromList(new ArrayList<Feature>());
      for (Feature f : SetSequence.fromSet(myFeatureToNodes.keySet())) {
        if (f instanceof ModelFeature) {
          ListSequence.fromList(features).addElement(f);
        }
      }
      return features;
    }
  }

  protected static Logger LOG = LogManager.getLogger(TreeHighlighter.class);
}
