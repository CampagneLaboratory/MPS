package jetbrains.mps.vcs.changesmanager.roots;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import java.util.Map;
import jetbrains.mps.smodel.SNodePointer;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceListener;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.workbench.nodesFs.MPSNodesVirtualFileSystem;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.vcs.changesmanager.CurrentDifference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.vcs.diff.ChangeSet;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceAdapter;
import jetbrains.mps.smodel.SModel;
import java.util.ArrayList;
import jetbrains.mps.util.Computable;
import jetbrains.mps.internal.collections.runtime.IListSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class NodeFileStatusMapping extends AbstractProjectComponent {
  private CurrentDifferenceRegistry myRegistry;
  private Map<SNodePointer, FileStatus> myFileStatusMap = MapSequence.fromMap(new HashMap<SNodePointer, FileStatus>());
  private CurrentDifferenceListener myGlobalListener = new NodeFileStatusMapping.MyGlobalListener();

  public NodeFileStatusMapping(Project project, CurrentDifferenceRegistry registry) {
    super(project);
    myRegistry = registry;
  }

  @Override
  public void projectOpened() {
    myRegistry.addGlobalDifferenceListener(myGlobalListener);
  }

  @Override
  public void projectClosed() {
    myRegistry.removeGlobalDifferenceListener(myGlobalListener);
  }

  private void invalidateNodeStatus(@NotNull final SNodePointer nodePointer) {
    myRegistry.getCommandQueue().runTask(new Runnable() {
      public void run() {
        calcStatus(nodePointer);
        FileStatusManager.getInstance(myProject).fileStatusChanged(MPSNodesVirtualFileSystem.getInstance().getFileFor(nodePointer));
      }
    });
  }

  private void calcStatus(@NotNull final SNodePointer root) {
    final Wrappers._T<FileStatus> status = new Wrappers._T<FileStatus>(null);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        SModelDescriptor modelDescriptor = SModelRepository.getInstance().getModelDescriptor(root.getModelReference());
        if (modelDescriptor instanceof EditableSModelDescriptor) {
          CurrentDifference diff = myRegistry.getCurrentDifference((EditableSModelDescriptor) modelDescriptor);
          // TODO change this stupid logic 
          if (ListSequence.fromList(check_onkh7z_a0a2a1a0b0d(diff.getChangeSet())).count() != 0) {
            status.value = FileStatus.MODIFIED;
          } else {
            status.value = FileStatus.NOT_CHANGED;
          }
        }
      }
    });
    synchronized (myFileStatusMap) {
      MapSequence.fromMap(myFileStatusMap).put(root, status.value);
    }
  }

  @Nullable
  public FileStatus getStatus(@NotNull final SNode root) {
    final Wrappers._T<SNodePointer> nodePointer = new Wrappers._T<SNodePointer>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        nodePointer.value = new SNodePointer(root);
        myRegistry.getCommandQueue().runTask(new Runnable() {
          public void run() {
            ModelAccess.instance().runReadAction(new Runnable() {
              public void run() {
                SModelDescriptor modelDescriptor = null;
                if (!(root.isDisposed() || SNodeOperations.getModel(root).isDisposed())) {
                  modelDescriptor = SNodeOperations.getModel(root).getModelDescriptor();
                }
                if (modelDescriptor instanceof EditableSModelDescriptor) {
                  myRegistry.getCurrentDifference((EditableSModelDescriptor) modelDescriptor).setEnabled(true);
                }
              }
            });
          }
        });
      }
    });
    synchronized (myFileStatusMap) {
      return MapSequence.fromMap(myFileStatusMap).get(nodePointer.value);
    }
  }

  private static List<ModelChange> check_onkh7z_a0a2a1a0b0d(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }

  private class MyGlobalListener extends CurrentDifferenceAdapter {
    private List<SModel> myAffectedModels = ListSequence.fromList(new ArrayList<SModel>());

    private MyGlobalListener() {
    }

    @Override
    public void changeUpdateFinished() {
      List<SNodePointer> nodePointers = ModelAccess.instance().runReadAction(new Computable<IListSequence<SNodePointer>>() {
        public IListSequence<SNodePointer> compute() {
          return ListSequence.fromList(myAffectedModels).translate(new ITranslator2<SModel, SNode>() {
            public Iterable<SNode> translate(SModel m) {
              return m.roots();
            }
          }).select(new ISelector<SNode, SNodePointer>() {
            public SNodePointer select(SNode r) {
              return new SNodePointer(r);
            }
          }).toListSequence();
        }
      });
      ListSequence.fromList(myAffectedModels).clear();
      // TODO change this stupid logic 
      ListSequence.fromList(nodePointers).visitAll(new IVisitor<SNodePointer>() {
        public void visit(SNodePointer np) {
          invalidateNodeStatus(np);
        }
      });
    }

    @Override
    public void changeAdded(@NotNull ModelChange change) {
      ListSequence.fromList(myAffectedModels).addElement(change.getChangeSet().getNewModel());
    }

    @Override
    public void changeRemoved(@NotNull ModelChange change) {
      ListSequence.fromList(myAffectedModels).addElement(change.getChangeSet().getNewModel());
    }
  }
}
