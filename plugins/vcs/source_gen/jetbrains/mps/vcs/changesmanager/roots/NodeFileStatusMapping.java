package jetbrains.mps.vcs.changesmanager.roots;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import java.util.Map;
import jetbrains.mps.smodel.SNodePointer;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceListener;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.workbench.nodesFs.MPSNodesVirtualFileSystem;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.editorTabs.EditorTabDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.plugins.projectplugins.ProjectPluginManager;
import jetbrains.mps.util.Computable;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.vcs.ConflictsUtil;
import jetbrains.mps.vcs.changesmanager.CurrentDifference;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.vcs.changesmanager.BaseVersionUtil;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.vcs.diff.ChangeSet;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceAdapter;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class NodeFileStatusMapping extends AbstractProjectComponent {
  private final CurrentDifferenceRegistry myRegistry;
  private final Map<SNodePointer, FileStatus> myFileStatusMap = MapSequence.fromMap(new HashMap<SNodePointer, FileStatus>());
  private final CurrentDifferenceListener myGlobalListener = new NodeFileStatusMapping.MyGlobalListener();

  public NodeFileStatusMapping(Project project, CurrentDifferenceRegistry registry) {
    super(project);
    myRegistry = registry;
  }

  @Override
  public void projectOpened() {
    myRegistry.addGlobalDifferenceListener(myGlobalListener);
  }

  @Override
  public void projectClosed() {
    myRegistry.removeGlobalDifferenceListener(myGlobalListener);
  }

  private void statusChanged(@NotNull final SNodePointer nodePointer) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        FileStatusManager fsm = FileStatusManager.getInstance(myProject);
        MPSNodesVirtualFileSystem nvfs = MPSNodesVirtualFileSystem.getInstance();
        SNode currentNode = nodePointer.getNode();
        if (currentNode == null) {
          return;
        }
        fsm.fileStatusChanged(nvfs.getFileFor(nodePointer));
        for (EditorTabDescriptor d : ListSequence.fromList(myProject.getComponent(ProjectPluginManager.class).getTabDescriptors())) {
          SNode baseNode = d.getBaseNode(currentNode);
          if (baseNode != null && baseNode != currentNode) {
            fsm.fileStatusChanged(nvfs.getFileFor(baseNode));
            break;
          }
        }
      }
    });
  }

  private void updateNodeStatus(@NotNull final SNodePointer nodePointer) {
    myRegistry.getCommandQueue().runTask(new Runnable() {
      public void run() {
        if (calcStatus(nodePointer)) {
          statusChanged(nodePointer);
        }
      }
    });
  }

  private boolean calcStatus(@NotNull final SNodePointer root) {
    FileStatus status = ModelAccess.instance().runReadAction(new Computable<FileStatus>() {
      public FileStatus compute() {
        SModelDescriptor modelDescriptor = SModelRepository.getInstance().getModelDescriptor(root.getModelReference());
        if (modelDescriptor instanceof EditableSModelDescriptor) {
          EditableSModelDescriptor emd = (EditableSModelDescriptor) modelDescriptor;
          if (ConflictsUtil.isModelOrModuleConflicting(emd, myProject)) {
            return FileStatus.MERGED_WITH_CONFLICTS;
          }
          CurrentDifference diff = myRegistry.getCurrentDifference(emd);
          List<ModelChange> modelChanges = check_onkh7z_a0d0b0a0a0a0e(diff.getChangeSet());
          final SNodeId rootId = root.getNodeId();
          List<ModelChange> rootChanges = ListSequence.fromList(modelChanges).where(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange ch) {
              return rootId.equals(ch.getRootId());
            }
          }).toListSequence();
          if (ListSequence.fromList(rootChanges).count() != 0) {
            if (ListSequence.fromList(rootChanges).first() instanceof AddRootChange) {
              VirtualFile vf = VirtualFileUtils.getVirtualFile(emd.getModelFile());
              if (vf != null) {
                FileStatus modelStatus = FileStatusManager.getInstance(myProject).getStatus(vf);
                if (BaseVersionUtil.isAddedFileStatus(modelStatus)) {
                  return modelStatus;
                }
              }
              return FileStatus.ADDED;
            }
            return FileStatus.MODIFIED;
          }
        }
        return FileStatus.NOT_CHANGED;
      }
    });
    synchronized (myFileStatusMap) {
      if (MapSequence.fromMap(myFileStatusMap).get(root) != status) {
        MapSequence.fromMap(myFileStatusMap).put(root, status);
        return true;
      } else {
        return false;
      }
    }
  }

  @Nullable
  public FileStatus getStatus(@NotNull final SNode root) {
    final Wrappers._T<SNodePointer> nodePointer = new Wrappers._T<SNodePointer>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        nodePointer.value = new SNodePointer(root);
        myRegistry.getCommandQueue().runTask(new Runnable() {
          public void run() {
            ModelAccess.instance().runReadAction(new Runnable() {
              public void run() {
                SModelDescriptor modelDescriptor = null;
                if (!(root.isDisposed() || SNodeOperations.getModel(root).isDisposed())) {
                  modelDescriptor = SNodeOperations.getModel(root).getModelDescriptor();
                }
                if (modelDescriptor instanceof EditableSModelDescriptor) {
                  myRegistry.getCurrentDifference((EditableSModelDescriptor) modelDescriptor).setEnabled(true);
                }
              }
            });
          }
        });
      }
    });
    synchronized (myFileStatusMap) {
      return MapSequence.fromMap(myFileStatusMap).get(nodePointer.value);
    }
  }

  @Nullable
  public FileStatus getStatus(@NotNull SNodePointer nodePointer) {
    synchronized (myFileStatusMap) {
      return MapSequence.fromMap(myFileStatusMap).get(nodePointer);
    }
  }

  private static List<ModelChange> check_onkh7z_a0d0b0a0a0a0e(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }

  private class MyGlobalListener extends CurrentDifferenceAdapter {
    private List<SNodePointer> myAffectedRoots = ListSequence.fromList(new ArrayList<SNodePointer>());

    private MyGlobalListener() {
    }

    @Override
    public void changeUpdateFinished() {
      ListSequence.fromList(myAffectedRoots).visitAll(new IVisitor<SNodePointer>() {
        public void visit(SNodePointer np) {
          updateNodeStatus(np);
        }
      });
      ListSequence.fromList(myAffectedRoots).clear();
    }

    private void addAffectedRoot(@NotNull ModelChange change) {
      if (change.getRootId() != null) {
        ListSequence.fromList(myAffectedRoots).addElement(new SNodePointer(change.getChangeSet().getNewModel().getSModelReference(), change.getRootId()));
      }
    }

    @Override
    public void changeAdded(@NotNull ModelChange change) {
      addAffectedRoot(change);
    }

    @Override
    public void changeRemoved(@NotNull ModelChange change) {
      addAffectedRoot(change);
    }
  }
}
