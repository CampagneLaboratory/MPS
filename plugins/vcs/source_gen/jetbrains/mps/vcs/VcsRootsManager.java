package jetbrains.mps.vcs;

/*Generated by MPS */

import com.intellij.openapi.components.ProjectComponent;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import java.util.Set;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.util.containers.ConcurrentHashSet;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.smodel.SModelAdapter;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.vcs.ui.VcsIdeSettings;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import com.intellij.openapi.vcs.AbstractVcs;
import java.util.Arrays;
import java.util.HashSet;
import com.intellij.openapi.vcs.VcsDirectoryMapping;
import java.util.Collections;
import jetbrains.mps.smodel.GlobalSModelEventsManager;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.project.IModule;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.project.SModelRoot;
import com.intellij.openapi.vfs.LocalFileSystem;
import com.intellij.openapi.startup.StartupManager;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;
import org.jetbrains.annotations.Nullable;

public class VcsRootsManager implements ProjectComponent {
  private final Project myProject;
  private final ProjectLevelVcsManager myVcsManager;
  private final Set<VirtualFile> myExcludedRoots = new ConcurrentHashSet<VirtualFile>();
  private final List<VcsRootsManager.VcsRootsListener> myVcsRootsListeners = new ArrayList<VcsRootsManager.VcsRootsListener>();
  private final SModelAdapter myGlobalSModelListener = new SModelAdapter() {
    @Override
    public void modelSaved(SModelDescriptor sm) {
      if (VcsSettingsHolder.instance().getSettings().getDiscoverVcsRootsSafe().equals(VcsIdeSettings.VcsRootsDiscoveryPolicy.DO_NOTING) || ApplicationManager.getApplication().isUnitTestMode()) {
        return;
      }
      try {
        if (!((sm instanceof EditableSModelDescriptor))) {
          return;
        }
        IFile modelFile = ((EditableSModelDescriptor) sm).getModelFile();
        if (modelFile == null) {
          return;
        }
        VirtualFile file = VirtualFileUtils.getVirtualFile(modelFile.getParent());
        if (file == null) {
          return;
        }
        AbstractVcs vcs = myVcsManager.findVersioningVcs(file);
        if (vcs == null || !(Arrays.asList(myVcsManager.getAllActiveVcss()).contains(vcs))) {
          return;
        }
        if (myVcsManager.getVcsRootFor(file) != null) {
          return;
        }
        VirtualFile root = file;
        while ((root.getParent() != null) && vcs.isVersionedDirectory(root.getParent())) {
          root = root.getParent();
        }
        Set<VirtualFile> currentRoots = new HashSet<VirtualFile>(Arrays.asList(myVcsManager.getAllVersionedRoots()));
        if ((root != null) && (!(myExcludedRoots.contains(root))) && (!(currentRoots.contains(root)))) {
          if (VcsSettingsHolder.instance().getSettings().getDiscoverVcsRootsSafe().equals(VcsIdeSettings.VcsRootsDiscoveryPolicy.NOTIFY)) {
            fireModelOutsideVcsRootsChanged(root, sm);
          } else
          if (VcsSettingsHolder.instance().getSettings().getDiscoverVcsRootsSafe().equals(VcsIdeSettings.VcsRootsDiscoveryPolicy.ADD)) {
            List<VcsDirectoryMapping> mappings = createMappings(Collections.singletonMap(myVcsManager.findVersioningVcs(root), Collections.singleton(file)));
            mergeWithCurrentOnes(mappings);
            myVcsManager.setDirectoryMappings(mappings);
          }
        }
      } catch (IllegalArgumentException e) {
      }
    }
  };

  public VcsRootsManager(Project project, ProjectLevelVcsManager manager) {
    myProject = project;
    myVcsManager = manager;
  }

  public void projectOpened() {
    if (VcsSettingsHolder.instance().getSettings().getDiscoverVcsRootsSafe().equals(VcsIdeSettings.VcsRootsDiscoveryPolicy.ADD)) {
      if (!(ApplicationManager.getApplication().isUnitTestMode())) {
        addDirectoryMappings();
      }
    }
    GlobalSModelEventsManager.getInstance().addGlobalModelListener(myGlobalSModelListener);
  }

  private void fireModelOutsideVcsRootsChanged(VirtualFile vcsRoot, SModelDescriptor modelDescriptor) {
    for (VcsRootsManager.VcsRootsListener listener : myVcsRootsListeners) {
      listener.modelOutsideVcsRootsChanged(vcsRoot, modelDescriptor);
    }
  }

  public void projectClosed() {
    GlobalSModelEventsManager.getInstance().removeGlobalModelListener(myGlobalSModelListener);
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "VCS Roots Manager";
  }

  public void initComponent() {
  }

  public void disposeComponent() {
  }

  private void addDirectoryMappings() {
    MPSProject mpsProject = myProject.getComponent(MPSProject.class);
    List<IModule> allModules = mpsProject.getModules();
    final Map<AbstractVcs, Set<VirtualFile>> vcss = new HashMap<AbstractVcs, Set<VirtualFile>>();
    for (IModule module : allModules) {
      if (module.isPackaged()) {
        continue;
      }
      IFile descriptor = module.getDescriptorFile();
      if (descriptor == null) {
        continue;
      }
      VirtualFile file = VirtualFileUtils.getVirtualFile(descriptor.getParent());
      discoverMappingsForFile(vcss, file);
      List<SModelRoot> modelRoots = module.getSModelRoots();
      for (SModelRoot root : modelRoots) {
        discoverMappingsForFile(vcss, LocalFileSystem.getInstance().findFileByPath(root.getPath()));
      }
    }
    StartupManager.getInstance(myProject).registerPostStartupActivity(new Runnable() {
      public void run() {
        final List<VcsDirectoryMapping> vcsMappings = createMappings(vcss);
        mergeWithCurrentOnes(vcsMappings);
        myVcsManager.setDirectoryMappings(vcsMappings);
      }
    });
  }

  private List<VcsDirectoryMapping> createMappings(Map<AbstractVcs, Set<VirtualFile>> vcss) {
    final List<VcsDirectoryMapping> vcsMappings = new ArrayList<VcsDirectoryMapping>();
    for (AbstractVcs vcs : vcss.keySet()) {
      Set<VirtualFile> files = vcss.get(vcs);
      Collection<String> roots = getRoots(files);
      for (String path : roots) {
        vcsMappings.add(new VcsDirectoryMapping(path, vcs.getName()));
      }
    }
    return vcsMappings;
  }

  private void mergeWithCurrentOnes(List<VcsDirectoryMapping> vcsMappings) {
    for (VcsDirectoryMapping oldMapping : myVcsManager.getDirectoryMappings()) {
      String oldDir = oldMapping.getDirectory();
      boolean matched = false;
      for (VcsDirectoryMapping newMapping : vcsMappings) {
        if (newMapping.getDirectory().equals(oldDir)) {
          matched = true;
        }
      }
      if (!(matched)) {
        vcsMappings.add(oldMapping);
      }
    }
  }

  private void discoverMappingsForFile(Map<AbstractVcs, Set<VirtualFile>> vcss, VirtualFile file) {
    if (file == null) {
      return;
    }
    AbstractVcs vcs = myVcsManager.findVersioningVcs(file);
    if (vcs == null) {
      return;
    }
    VirtualFile parent = file;
    while (true) {
      if (parent == null) {
        break;
      }
      if (vcs.isVersionedDirectory(parent)) {
        file = parent;
        parent = parent.getParent();
      } else {
        break;
      }
    }
    Set<VirtualFile> files = vcss.get(vcs);
    if (files == null) {
      files = new HashSet<VirtualFile>();
      vcss.put(vcs, files);
    }
    files.add(file);
  }

  private Collection<String> getRoots(Set<VirtualFile> files) {
    Iterator<VirtualFile> it = files.iterator();
    Set<VirtualFile> roots = new HashSet<VirtualFile>();
    while (it.hasNext()) {
      boolean matched = false;
      VirtualFile file2 = it.next();
      for (VirtualFile file1 : roots) {
        VirtualFile container = getMaxContainingPath(file1, file2);
        if (container != null) {
          roots.remove(file1);
          roots.add(container);
          matched = true;
          break;
        }
      }
      if (!(matched)) {
        roots.add(file2);
      }
    }
    List<String> rootPaths = new LinkedList<String>();
    for (VirtualFile f : roots) {
      rootPaths.add(f.getPath());
    }
    return rootPaths;
  }

  @Nullable
  public VirtualFile getMaxContainingPath(VirtualFile file1, VirtualFile file2) {
    AbstractVcs vcs1 = myVcsManager.findVersioningVcs(file1);
    if ((vcs1 == null) || !(vcs1.equals(myVcsManager.findVersioningVcs(file2)))) {
      return null;
    }
    if (VcsRootsManager.isParent(file1, file2)) {
      return file1;
    }
    if (VcsRootsManager.isParent(file2, file1)) {
      return file2;
    }
    VirtualFile parent1 = file1.getParent();
    VirtualFile parent2 = file2.getParent();
    if ((parent1 == null) && (parent2 == null)) {
      return null;
    } else
    if (parent1 == null) {
      return getMaxContainingPath(file1, parent2);
    } else
    if (parent2 == null) {
      return getMaxContainingPath(parent1, file2);
    }
    return getMaxContainingPath(parent1, parent2);
  }

  public void addListener(VcsRootsManager.VcsRootsListener listener) {
    myVcsRootsListeners.add(listener);
  }

  public void removeListener(VcsRootsManager.VcsRootsListener listener) {
    myVcsRootsListeners.remove(listener);
  }

  public void addNewVcsRoot(VirtualFile vcsRoot) {
    List<VcsDirectoryMapping> vcsDirectoryMappings = new ArrayList<VcsDirectoryMapping>(myVcsManager.getDirectoryMappings());
    AbstractVcs versioningVcs = myVcsManager.findVersioningVcs(vcsRoot);
    assert versioningVcs != null;
    vcsDirectoryMappings.add(new VcsDirectoryMapping(vcsRoot.getPath(), versioningVcs.getName()));
    myVcsManager.setDirectoryMappings(vcsDirectoryMappings);
  }

  public boolean isExcluded(VirtualFile vcsRoot) {
    return myExcludedRoots.contains(vcsRoot);
  }

  public void addExcludedRoot(VirtualFile vcsRoot) {
    myExcludedRoots.add(vcsRoot);
  }

  public static boolean isParent(VirtualFile parent, VirtualFile child) {
    if (!(parent.isDirectory())) {
      return false;
    }
    if (parent.getPath().equals(child.getPath())) {
      return true;
    }
    VirtualFile parentOfChild = child.getParent();
    if (parentOfChild == null) {
      return false;
    }
    return VcsRootsManager.isParent(parent, parentOfChild);
  }

  public static interface VcsRootsListener {
    public void modelOutsideVcsRootsChanged(VirtualFile vcsRoot, SModelDescriptor sm);
  }
}
