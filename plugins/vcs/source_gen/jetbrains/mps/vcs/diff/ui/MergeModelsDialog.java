package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import jetbrains.mps.ide.dialogs.BaseDialog;
import javax.swing.Icon;
import com.intellij.openapi.util.IconLoader;
import jetbrains.mps.ide.projectPane.Icons;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.vcs.diff.MergeContext;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import jetbrains.mps.smodel.SModel;
import com.intellij.openapi.wm.WindowManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import javax.swing.JScrollPane;
import javax.swing.JComponent;
import jetbrains.mps.ide.dialogs.DialogDimensionsSettings;
import jetbrains.mps.ide.ui.MPSTree;
import jetbrains.mps.ide.ui.MPSTreeNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.icons.IconManager;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.awt.Color;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;

public class MergeModelsDialog extends BaseDialog {
  public static final Icon APPLY_NON_CONFLICTS = IconLoader.getIcon("/diff/applyNotConflicts.png", Icons.class);

  private Project myProject;
  private IOperationContext myOperationContext;
  private MergeContext myMergeContext;
  private MergeModelsDialog.MergeModelsTree myMergeModelsTree;
  private JPanel myPanel = new JPanel(new BorderLayout());
  private boolean myCancelled = false;

  public MergeModelsDialog(Project project, IOperationContext operationContext, SModel baseModel, SModel mineModel, SModel repositoryModel) {
    super(WindowManager.getInstance().getFrame(project), "Merging " + SModelOperations.getModelName(baseModel));
    myProject = project;
    myOperationContext = operationContext;
    myMergeContext = new MergeContext(baseModel, mineModel, repositoryModel);
    myMergeModelsTree = new MergeModelsDialog.MergeModelsTree();

    DefaultActionGroup actionGroup = ActionUtils.groupFromActions(new MergeNonConflictingRoots(myMergeContext, this));
    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, actionGroup, true);
    toolbar.updateActionsImmediately();
    myPanel.add(toolbar.getComponent(), BorderLayout.NORTH);
    myPanel.add(new JScrollPane(myMergeModelsTree), BorderLayout.CENTER);
  }

  protected JComponent getMainComponent() {
    return myPanel;
  }

  @Override
  public DialogDimensionsSettings.DialogDimensions getDefaultDimensionSettings() {
    return new DialogDimensionsSettings.DialogDimensions(10, 10, 500, 700);
  }

  @BaseDialog.Button(position = 0, name = "OK", mnemonic = 'O', defaultButton = true)
  public void ok() {
    dispose();
  }

  @BaseDialog.Button(position = 1, name = "Cancel", mnemonic = 'C')
  public void cancel() {
    myCancelled = true;
    dispose();
  }

  public SModel getResultModel() {
    return (myCancelled ?
      null :
      myMergeContext.getResultModel()
    );
  }

  /*package*/ void rebuildLater() {
    myMergeModelsTree.rebuildLater();
  }

  /*package*/ IOperationContext getOperationContext() {
    return myOperationContext;
  }

  public static boolean isNewMergeEnabled() {
    return "true".equals(System.getProperty("mps.newmerge"));
  }

  private class MergeModelsTree extends MPSTree {
    public MergeModelsTree() {
      rebuildNow();
      expandAll();
    }

    protected MPSTreeNode rebuild() {
      final MergeModelsDialog.MyModelTreeNode modelNode = new MergeModelsDialog.MyModelTreeNode();
      SetSequence.fromSet(myMergeContext.getAffectedRoots()).<MergeModelsDialog.MyRootTreeNode>select(new ISelector<SNodeId, MergeModelsDialog.MyRootTreeNode>() {
        public MergeModelsDialog.MyRootTreeNode select(SNodeId r) {
          return new MergeModelsDialog.MyRootTreeNode(r);
        }
      }).sort(new ISelector<MergeModelsDialog.MyRootTreeNode, Comparable<?>>() {
        public Comparable<?> select(MergeModelsDialog.MyRootTreeNode rtn) {
          return rtn.myPresentations;
        }
      }, true).visitAll(new IVisitor<MergeModelsDialog.MyRootTreeNode>() {
        public void visit(MergeModelsDialog.MyRootTreeNode rtn) {
          modelNode.add(rtn);
        }
      });
      return modelNode;
    }

    @Override
    public void rebuildNow() {
      super.rebuildNow();
      expandAll();
    }
  }

  private class MyModelTreeNode extends MPSTreeNode {
    public MyModelTreeNode() {
      super(myOperationContext);
      setNodeIdentifier("model");
    }

    @Override
    protected void doUpdatePresentation() {
      setText(myMergeContext.getResultModel().getLongName());
      setIcon(Icons.MODEL_ICON);
    }
  }

  private class MyRootTreeNode extends MPSTreeNode {
    private SNodeId myRootId;
    private String myPresentations;

    public MyRootTreeNode(SNodeId rootId) {
      super(myOperationContext);
      myRootId = rootId;
      setNodeIdentifier("" + myRootId);

      List<String> presentations = ListSequence.fromList(new ArrayList<String>());
      Icon icon = null;
      for (SModel model : Sequence.fromIterable(Sequence.fromArray(new SModel[]{myMergeContext.getBaseModel(), myMergeContext.getMyModel(), myMergeContext.getRepositoryModel()}))) {
        SNode root = model.getNodeById(myRootId);
        if (root != null) {
          String presentation = root.getPresentation();
          if (!(ListSequence.fromList(presentations).contains(presentation))) {
            ListSequence.fromList(presentations).addElement(presentation);
          }
          if (icon == null) {
            icon = IconManager.getIconFor(root);
          }
        }
      }
      myPresentations = StringUtils.join(presentations, " / ");
      setIcon(icon);
    }

    @Override
    protected void doUpdatePresentation() {
      List<ModelChange> changes = ListSequence.fromList(myMergeContext.getChangesForRoot(myRootId)).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return !(myMergeContext.isChangeResolved(ch));
        }
      }).toListSequence();
      Iterable<ModelChange> conflictedChanges = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return Sequence.fromIterable(myMergeContext.getConflictedWith(ch)).isNotEmpty();
        }
      });

      boolean deleted = false;
      if (Sequence.fromIterable(conflictedChanges).isNotEmpty()) {
        setColor(Color.RED);
      } else if (ListSequence.fromList(changes).isEmpty()) {
        deleted = myMergeContext.getResultModel().getNodeById(myRootId) == null;
      } else if (ListSequence.fromList(changes).all(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return ch instanceof AddRootChange;
        }
      })) {
        setColor(FileStatus.ADDED.getColor());
      } else if (ListSequence.fromList(changes).all(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return ch instanceof DeleteRootChange;
        }
      })) {
        setColor(FileStatus.DELETED.getColor());
      } else if (ListSequence.fromList(changes).isNotEmpty()) {
        setColor(FileStatus.MODIFIED.getColor());
      }

      int conflictedCount = Sequence.fromIterable(conflictedChanges).count();
      int nonConflctedCount = ListSequence.fromList(changes).count() - conflictedCount;
      if (Sequence.fromIterable(conflictedChanges).isNotEmpty()) {
        setAdditionalText(nonConflctedCount + "+" + conflictedCount);
        setTooltipText(NameUtil.formatNumericalString(nonConflctedCount, "non-conficting change") + ", " + NameUtil.formatNumericalString(conflictedCount, "conficting change"));
      } else if (ListSequence.fromList(changes).isNotEmpty()) {
        setAdditionalText("" + nonConflctedCount);
        setTooltipText(NameUtil.formatNumericalString(nonConflctedCount, "non-conficting change"));
      }

      List<String> presentations = ListSequence.fromList(new ArrayList<String>());
      Icon icon = null;
      for (SModel model : Sequence.fromIterable(Sequence.fromArray(new SModel[]{myMergeContext.getBaseModel(), myMergeContext.getMyModel(), myMergeContext.getRepositoryModel()}))) {
        SNode root = model.getNodeById(myRootId);
        if (root != null) {
          String presentation = root.getPresentation();
          if (!(ListSequence.fromList(presentations).contains(presentation))) {
            ListSequence.fromList(presentations).addElement(presentation);
          }
          if (icon == null) {
            icon = IconManager.getIconFor(root);
          }
        }
      }
      setText((deleted ?
        String.format("<html><s>%s</s></html>", myPresentations) :
        myPresentations
      ));
    }

    @Override
    public void doubleClick() {
      final Wrappers._T<MergeRootsDialog> mergeRootsDialog = new Wrappers._T<MergeRootsDialog>();
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          mergeRootsDialog.value = new MergeRootsDialog(MergeModelsDialog.this, myMergeContext, myRootId, myPresentations);
        }
      });
      mergeRootsDialog.value.showDialog();
      mergeRootsDialog.value.toFront();
    }
  }
}
