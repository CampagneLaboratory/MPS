package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import jetbrains.mps.ide.dialogs.BaseDialog;
import jetbrains.mps.vcs.diff.MergeContext;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.ModelAccess;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.ui.Messages;
import jetbrains.mps.util.NameUtil;

public class MergeConfirmation {
  public static final int RETURN = 0;
  public static final int SAVE_AS_IS = 1;
  public static final int RESOLVE_AUTOMATICALLY = 2;

  private MergeConfirmation() {
  }

  public static void showMergeConfirmationAndTakeAction(BaseDialog dialog, MergeContext mergeContext, Iterable<ModelChange> allRelevantChanges, final _FunctionTypes._void_P0_E0 resolveTask, final _FunctionTypes._void_P0_E0 saveAndCloseTask) {
    int result = MergeConfirmation.showMergeConfirmationIfNeeded(dialog, mergeContext, allRelevantChanges);
    if (result == RETURN) {
    } else if (result == SAVE_AS_IS) {
      saveAndCloseTask.invoke();
    } else if (result == RESOLVE_AUTOMATICALLY) {
      ModelAccess.instance().runWriteActionInCommand(new Runnable() {
        public void run() {
          resolveTask.invoke();
          saveAndCloseTask.invoke();
        }
      });
    }
  }

  public static int showMergeConfirmationIfNeeded(BaseDialog dialog, final MergeContext mergeContext, Iterable<ModelChange> allRelevantChanges) {
    List<ModelChange> changes = Sequence.fromIterable(allRelevantChanges).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(mergeContext.isChangeResolved(ch));
      }
    }).toListSequence();
    Iterable<ModelChange> conflictedChanges = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return Sequence.fromIterable(mergeContext.getConflictedWith(ch)).isNotEmpty();
      }
    });
    if (Sequence.fromIterable(conflictedChanges).count() != 0) {
      if (Messages.showYesNoDialog(dialog, String.format("You have %s left. You should resolve them manually.\n" + "Are you sure want to close merge roots dialog without resolving them?", NameUtil.formatNumericalString(Sequence.fromIterable(conflictedChanges).count(), "unresolved conflicting changes")), "Unresolved Conflicting Changes", Messages.getWarningIcon()) == 0) {
        return SAVE_AS_IS;
      } else {
        return RETURN;
      }
    } else if (ListSequence.fromList(changes).count() != 0) {
      int answer = Messages.showYesNoCancelDialog(dialog, String.format("You have %s left. Do you want to resolve them automatically?", NameUtil.formatNumericalString(ListSequence.fromList(changes).count(), "unresolved changes")), "Unresolved Changes", Messages.getQuestionIcon());
      if (answer == 0) {
        return RESOLVE_AUTOMATICALLY;
      } else if (answer == 1) {
        // Do nothing, leave unresolved changes as is 
        return SAVE_AS_IS;
      } else {
        return RETURN;
      }
    }
    return SAVE_AS_IS;
  }
}
