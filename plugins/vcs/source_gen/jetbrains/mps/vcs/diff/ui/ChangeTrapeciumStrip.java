package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import javax.swing.JComponent;
import jetbrains.mps.vcs.diff.MergeContext;
import jetbrains.mps.vcs.diff.changes.ChangeSet;
import java.util.List;
import java.awt.Dimension;
import java.util.Map;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.util.DisjointSets;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Set;
import java.awt.Graphics;
import jetbrains.mps.vcs.diff.changes.ChangeType;
import java.awt.Color;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class ChangeTrapeciumStrip extends JComponent {
  private static final int WIDTH = 30;

  private MergeContext myMergeContext;
  private ChangeSet myChangeSet;
  private DiffEditorComponent myLeftEditorComponent;
  private DiffEditorComponent myRightEditorComponent;
  private List<ChangeTrapeciumStrip.ChangeGroup> myChangeGroups = null;

  public ChangeTrapeciumStrip(MergeContext mergeContext, ChangeSet changeSet, DiffEditorComponent leftEditorComponent, DiffEditorComponent rightEditorComponent) {
    myMergeContext = mergeContext;
    myChangeSet = changeSet;
    myLeftEditorComponent = leftEditorComponent;
    myRightEditorComponent = rightEditorComponent;
    myLeftEditorComponent.getViewport().addChangeListener(new ChangeTrapeciumStrip.MyViewportChangeListener());
    myRightEditorComponent.getViewport().addChangeListener(new ChangeTrapeciumStrip.MyViewportChangeListener());
    setMinimumSize(new Dimension(WIDTH, 1));
    setPreferredSize(new Dimension(WIDTH, 1));
  }

  private void ensureChangeGroupsInitialized() {
    if (myChangeGroups != null) {
      return;
    }

    final Map<ModelChange, Integer> leftStarts = MapSequence.fromMap(new HashMap<ModelChange, Integer>());
    final Map<ModelChange, Integer> leftEnds = MapSequence.fromMap(new HashMap<ModelChange, Integer>());
    final Map<ModelChange, Integer> rightStarts = MapSequence.fromMap(new HashMap<ModelChange, Integer>());
    final Map<ModelChange, Integer> rightEnds = MapSequence.fromMap(new HashMap<ModelChange, Integer>());
    for (ModelChange change : ListSequence.fromList(myChangeSet.getModelChanges())) {
      ChangeEditorMessage leftMessage = myLeftEditorComponent.getMessageForChange(change);
      ChangeEditorMessage rightMessage = myRightEditorComponent.getMessageForChange(change);

      assert leftMessage == null && rightMessage == null || leftMessage != null && rightMessage != null;
      if (leftMessage == null) {
        continue;
      }

      MapSequence.fromMap(leftStarts).put(change, leftMessage.getStart(myLeftEditorComponent));
      MapSequence.fromMap(leftEnds).put(change, MapSequence.fromMap(leftStarts).get(change) + leftMessage.getHeight(myLeftEditorComponent));
      MapSequence.fromMap(rightStarts).put(change, rightMessage.getStart(myRightEditorComponent));
      MapSequence.fromMap(rightEnds).put(change, MapSequence.fromMap(rightStarts).get(change) + rightMessage.getHeight(myRightEditorComponent));
    }
    DisjointSets<ModelChange> ds = new DisjointSets<ModelChange>(MapSequence.fromMap(leftStarts).keySet());
    for (ModelChange a : SetSequence.fromSet(MapSequence.fromMap(leftStarts).keySet())) {
      for (ModelChange b : SetSequence.fromSet(MapSequence.fromMap(leftStarts).keySet())) {
        if (!(MapSequence.fromMap(leftEnds).get(a) < MapSequence.fromMap(leftStarts).get(b) || MapSequence.fromMap(leftEnds).get(b) < MapSequence.fromMap(leftStarts).get(a))) {
          ds.unite(a, b);
        }
        if (!(MapSequence.fromMap(rightEnds).get(a) < MapSequence.fromMap(rightStarts).get(b) || MapSequence.fromMap(rightEnds).get(b) < MapSequence.fromMap(rightStarts).get(a))) {
          ds.unite(a, b);
        }
      }
    }
    myChangeGroups = ListSequence.fromListWithValues(new ArrayList<ChangeTrapeciumStrip.ChangeGroup>(), Sequence.fromIterable(ds.getSets()).<ChangeTrapeciumStrip.ChangeGroup>select(new ISelector<Set<ModelChange>, ChangeTrapeciumStrip.ChangeGroup>() {
      public ChangeTrapeciumStrip.ChangeGroup select(Set<ModelChange> s) {
        return new ChangeTrapeciumStrip.ChangeGroup(leftStarts, leftEnds, rightStarts, rightEnds, SetSequence.fromSet(s).toListSequence());
      }
    }));
  }

  @Override
  protected void paintComponent(Graphics g) {
    ensureChangeGroupsInitialized();
    for (ChangeTrapeciumStrip.ChangeGroup group : ListSequence.fromList(myChangeGroups)) {
      int leftStart = group.myLeftStart;
      int leftEnd = group.myLeftEnd;
      int rightStart = group.myRightStart;
      int rightEnd = group.myRightEnd;

      int leftOffset = -myLeftEditorComponent.getViewport().getViewPosition().y + myLeftEditorComponent.getExternalComponent().getY();
      int rightOffset = -myRightEditorComponent.getViewport().getViewPosition().y + myRightEditorComponent.getExternalComponent().getY();

      leftStart += leftOffset;
      leftEnd += leftOffset;
      rightStart += rightOffset;
      rightEnd += rightOffset;

      int[] xx = new int[]{0, getWidth(), getWidth(), 0};
      int[] yy = new int[]{leftStart, rightStart, rightEnd, leftEnd};

      g.setColor((group.myConflicted ?
        ChangeType.CONFLICT_COLOR :
        group.myChangeType.getColor()
      ));
      g.fillPolygon(xx, yy, 4);
      g.setColor(Color.GRAY);
      g.drawLine(0, leftStart, getWidth() - 1, rightStart);
      g.drawLine(0, leftEnd, getWidth() - 1, rightEnd);
    }
  }

  private class MyViewportChangeListener implements ChangeListener {
    private MyViewportChangeListener() {
    }

    public void stateChanged(ChangeEvent event) {
      repaint();
    }
  }

  private class ChangeGroup {
    private int myLeftStart;
    private int myLeftEnd;
    private int myRightStart;
    private int myRightEnd;
    private List<ModelChange> myChanges;
    private ChangeType myChangeType;
    private boolean myConflicted;

    private ChangeGroup(final Map<ModelChange, Integer> leftStarts, final Map<ModelChange, Integer> leftEnds, final Map<ModelChange, Integer> rightStarts, final Map<ModelChange, Integer> rightEnds, List<ModelChange> changes) {
      myLeftStart = ListSequence.fromList(changes).<Integer>select(new ISelector<ModelChange, Integer>() {
        public Integer select(ModelChange ch) {
          return MapSequence.fromMap(leftStarts).get(ch);
        }
      }).reduceLeft(new ILeftCombinator<Integer, Integer>() {
        public Integer combine(Integer a, Integer b) {
          return Math.min(a, b);
        }
      });
      myLeftEnd = ListSequence.fromList(changes).<Integer>select(new ISelector<ModelChange, Integer>() {
        public Integer select(ModelChange ch) {
          return MapSequence.fromMap(leftEnds).get(ch);
        }
      }).reduceLeft(new ILeftCombinator<Integer, Integer>() {
        public Integer combine(Integer a, Integer b) {
          return Math.max(a, b);
        }
      });
      myRightStart = ListSequence.fromList(changes).<Integer>select(new ISelector<ModelChange, Integer>() {
        public Integer select(ModelChange ch) {
          return MapSequence.fromMap(rightStarts).get(ch);
        }
      }).reduceLeft(new ILeftCombinator<Integer, Integer>() {
        public Integer combine(Integer a, Integer b) {
          return Math.min(a, b);
        }
      });
      myRightEnd = ListSequence.fromList(changes).<Integer>select(new ISelector<ModelChange, Integer>() {
        public Integer select(ModelChange ch) {
          return MapSequence.fromMap(rightEnds).get(ch);
        }
      }).reduceLeft(new ILeftCombinator<Integer, Integer>() {
        public Integer combine(Integer a, Integer b) {
          return Math.max(a, b);
        }
      });

      myChanges = changes;
      myChangeType = ListSequence.fromList(changes).<ChangeType>select(new ISelector<ModelChange, ChangeType>() {
        public ChangeType select(ModelChange ch) {
          return ch.getType();
        }
      }).reduceLeft(new ILeftCombinator<ChangeType, ChangeType>() {
        public ChangeType combine(ChangeType a, ChangeType b) {
          return (a == b ?
            a :
            ChangeType.CHANGE
          );
        }
      });
      myConflicted = ListSequence.fromList(changes).any(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return Sequence.fromIterable(myMergeContext.getConflictedWith(ch)).isNotEmpty();
        }
      });
    }
  }
}
