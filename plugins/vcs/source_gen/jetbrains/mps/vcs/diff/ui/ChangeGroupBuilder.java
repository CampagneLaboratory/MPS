package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import jetbrains.mps.vcs.diff.MergeContext;
import jetbrains.mps.vcs.diff.changes.ChangeSet;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.Map;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.util.DisjointSets;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Set;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class ChangeGroupBuilder {
  private MergeContext myMergeContext;
  private ChangeSet myChangeSet;
  private boolean myInspector = false;
  private DiffEditorComponent myLeftEditorComponent;
  private DiffEditorComponent myRightEditorComponent;
  private List<ChangeGroup> myChangeGroups = null;
  private List<ChangeGroupInvalidateListener> myInvalidateListeners = ListSequence.fromList(new ArrayList<ChangeGroupInvalidateListener>());

  public ChangeGroupBuilder(MergeContext mergeContext, ChangeSet changeSet, DiffEditorComponent leftEditorComponent, DiffEditorComponent rightEditorComponent, boolean inspector) {
    myMergeContext = mergeContext;
    myChangeSet = changeSet;
    myLeftEditorComponent = leftEditorComponent;
    myRightEditorComponent = rightEditorComponent;
    myInspector = inspector;
    if (myInspector) {
      EditorComponent.RebuildListener rebuildListener = new EditorComponent.RebuildListener() {
        public void editorRebuilt(EditorComponent editor) {
          invalidate();
        }
      };
      myLeftEditorComponent.getInspector().addRebuildListener(rebuildListener);
      myRightEditorComponent.getInspector().addRebuildListener(rebuildListener);
    }
  }

  public EditorComponent getLeftComponent() {
    return (myInspector ?
      myLeftEditorComponent.getInspector() :
      myLeftEditorComponent
    );
  }

  public EditorComponent getRightComponent() {
    return (myInspector ?
      myRightEditorComponent.getInspector() :
      myRightEditorComponent
    );
  }

  private void calculateChangeGroups() {
    final Map<ModelChange, Integer> leftStarts = MapSequence.fromMap(new HashMap<ModelChange, Integer>());
    final Map<ModelChange, Integer> leftEnds = MapSequence.fromMap(new HashMap<ModelChange, Integer>());
    final Map<ModelChange, Integer> rightStarts = MapSequence.fromMap(new HashMap<ModelChange, Integer>());
    final Map<ModelChange, Integer> rightEnds = MapSequence.fromMap(new HashMap<ModelChange, Integer>());
    for (ModelChange change : ListSequence.fromList(myChangeSet.getModelChanges())) {
      ChangeEditorMessage leftMessage = myLeftEditorComponent.getMessageForChange(change);
      ChangeEditorMessage rightMessage = myRightEditorComponent.getMessageForChange(change);

      assert leftMessage == null && rightMessage == null || leftMessage != null && rightMessage != null;
      if (leftMessage == null) {
        continue;
      }

      int leftHeight = leftMessage.getHeight(getLeftComponent());
      int rightHeight = rightMessage.getHeight(getRightComponent());
      assert leftHeight == -1 && rightHeight == -1 || leftHeight != -1 && rightHeight != -1;
      if (leftHeight == -1) {
        continue;
      }

      MapSequence.fromMap(leftStarts).put(change, leftMessage.getStart(getLeftComponent()));
      MapSequence.fromMap(leftEnds).put(change, MapSequence.fromMap(leftStarts).get(change) + leftHeight);
      MapSequence.fromMap(rightStarts).put(change, rightMessage.getStart(getRightComponent()));
      MapSequence.fromMap(rightEnds).put(change, MapSequence.fromMap(rightStarts).get(change) + rightHeight);
    }
    DisjointSets<ModelChange> ds = new DisjointSets<ModelChange>(MapSequence.fromMap(leftStarts).keySet());
    for (ModelChange a : SetSequence.fromSet(MapSequence.fromMap(leftStarts).keySet())) {
      for (ModelChange b : SetSequence.fromSet(MapSequence.fromMap(leftStarts).keySet())) {
        if (!(MapSequence.fromMap(leftEnds).get(a) - 1 < MapSequence.fromMap(leftStarts).get(b) || MapSequence.fromMap(leftEnds).get(b) - 1 < MapSequence.fromMap(leftStarts).get(a))) {
          ds.unite(a, b);
        }
        if (!(MapSequence.fromMap(rightEnds).get(a) - 1 < MapSequence.fromMap(rightStarts).get(b) || MapSequence.fromMap(rightEnds).get(b) - 1 < MapSequence.fromMap(rightStarts).get(a))) {
          ds.unite(a, b);
        }
      }
    }
    myChangeGroups = ListSequence.fromListWithValues(new ArrayList<ChangeGroup>(), Sequence.fromIterable(ds.getSets()).<ChangeGroup>select(new ISelector<Set<ModelChange>, ChangeGroup>() {
      public ChangeGroup select(Set<ModelChange> s) {
        return new ChangeGroup(leftStarts, leftEnds, rightStarts, rightEnds, SetSequence.fromSet(s).toListSequence(), myMergeContext);
      }
    }));
    myChangeGroups = ListSequence.fromList(myChangeGroups).sort(new ISelector<ChangeGroup, Comparable<?>>() {
      public Comparable<?> select(ChangeGroup g) {
        return g.getLeftStart();
      }
    }, true).toListSequence();
  }

  public void addInvalidateListener(@NotNull ChangeGroupInvalidateListener listener) {
    ListSequence.fromList(myInvalidateListeners).addElement(listener);
  }

  public void removeInvalidateListener(@NotNull ChangeGroupInvalidateListener listener) {
    ListSequence.fromList(myInvalidateListeners).removeElement(listener);
  }

  public List<ChangeGroup> getChangeGroups() {
    if (myChangeGroups == null) {
      calculateChangeGroups();
    }
    return myChangeGroups;
  }

  public void invalidate() {
    myChangeGroups = null;
    ListSequence.fromList(myInvalidateListeners).visitAll(new IVisitor<ChangeGroupInvalidateListener>() {
      public void visit(ChangeGroupInvalidateListener it) {
        it.changeGroupsInvalidated();
      }
    });
  }

  public DiffEditorComponent getLeftDiffEditorComponent() {
    return myLeftEditorComponent;
  }

  public DiffEditorComponent getRightDiffEditorComponent() {
    return myRightEditorComponent;
  }

  public MergeContext getMergeContext() {
    return myMergeContext;
  }
}
