package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.messageTargets.EditorMessageWithTarget;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.nodeEditor.EditorMessageOwner;
import jetbrains.mps.errors.MessageStatus;
import java.awt.Color;
import jetbrains.mps.vcs.diff.changes.ChangeType;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.errors.messageTargets.MessageTargetEnum;
import org.apache.commons.lang.ObjectUtils;
import jetbrains.mps.errors.messageTargets.ChildrenMessageTarget;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.nodeEditor.EditorMessage;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Vertical;
import jetbrains.mps.nodeEditor.style.StyleAttributes;
import java.awt.Rectangle;
import jetbrains.mps.ide.util.ColorAndGraphicsUtil;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.vcs.diff.changes.NodeChange;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import jetbrains.mps.errors.messageTargets.PropertyMessageTarget;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import jetbrains.mps.errors.messageTargets.ReferenceMessageTarget;
import jetbrains.mps.vcs.diff.changes.InsertNodeGroupChange;
import jetbrains.mps.vcs.diff.changes.DeleteNodeGroupChange;
import jetbrains.mps.vcs.diff.changes.ReplaceNodeGroupChange;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.NotNull;
import java.util.Set;

public class ChangeEditorMessage extends EditorMessageWithTarget {
  private ModelChange myChange;

  public ChangeEditorMessage(SModel editedModel, ModelChange change, EditorMessageOwner owner) {
    super(computeNode(editedModel, change), MessageStatus.OK, computeMessageTarget(editedModel, change), null, "", owner);
    myChange = change;
  }

  public boolean isConflicted() {
    return false;
  }

  @Override
  public Color getColor() {
    return (isConflicted() ?
      ChangeType.CONFLICT_COLOR :
      myChange.getType().getColor()
    );
  }

  public ModelChange getChange() {
    return myChange;
  }

  @Override
  public boolean isBackground() {
    return true;
  }

  @Override
  public void paint(Graphics graphics, EditorComponent component, EditorCell cell) {
    boolean targetIsNode = myMessageTarget.getTarget() == MessageTargetEnum.NODE;
    if (ObjectUtils.equals(getNode(), cell.getSNode()) && targetIsNode || myMessageTarget.getTarget() == MessageTargetEnum.CHILDREN && check_myu41h_a0a0b0e(((ChildrenMessageTarget) myMessageTarget).getChildren(), cell) || !(targetIsNode) && !(cell instanceof EditorCell_Collection)) {
      cell.paintSelection(graphics, getColor(), false);

      // This is a workaround for case when any change message is going to be painted over 
      // "conflicted" red frame. In this case, we repaint conflicted red frame again 
      EditorCell_Collection parent = cell.getParent();
      if (parent != null && parent.getChildCount() == 1) {
        EditorMessage messageToRepaint = ListSequence.fromList(((List<EditorMessage>) parent.getMessages())).findFirst(new IWhereFilter<EditorMessage>() {
          public boolean accept(EditorMessage m) {
            return m instanceof ChangeEditorMessage && ((ChangeEditorMessage) m).isConflicted();
          }
        });
        if (messageToRepaint != null) {
          messageToRepaint.paint(graphics, component, parent);
        }
      }
    } else {
      if (myMessageTarget.getTarget() == MessageTargetEnum.CHILDREN && eq_myu41h_a0a0a0b0e(myMessageTarget.getRole(), cell.getRole())) {
        int beginIndex = ((ChildrenMessageTarget) myMessageTarget).getBeginIndex();
        int endIndex = ((ChildrenMessageTarget) myMessageTarget).getEndIndex();
        if (beginIndex != endIndex) {
          assert cell instanceof EditorCell_Collection;
          EditorCell_Collection collectionCell = ((EditorCell_Collection) cell);
          int beginCellIndex = getChildCellIndex(collectionCell, beginIndex);
          int endCellIndex = getChildCellIndex(collectionCell, endIndex - 1) + 1;
          for (int i = beginCellIndex; i < endCellIndex; i++) {
            collectionCell.getChildAt(i).paintSelection(graphics, getColor(), false);
          }
          return;
        } else {
          // This is delete node change 
          if (beginIndex != -1) {
            EditorCell_Collection collectionCell = ((EditorCell_Collection) cell);

            if (!(hasChildrenWithDifferentNode(cell))) {
              cell.paintSelection(graphics, getColor(), false);
              return;
            }

            boolean vertical = collectionCell.getCellLayout() instanceof CellLayout_Vertical || cell.getStyle().get(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE);
            Rectangle bounds = cell.getBounds();
            int cellIndex = getChildCellIndex(collectionCell, beginIndex);
            if (vertical) {
              int y;
              if (-1 < cellIndex && cellIndex < collectionCell.getChildCount()) {
                y = collectionCell.getChildAt(cellIndex).getY();
              } else {
                y = ((int) collectionCell.getChildAt(collectionCell.getChildCount() - 1).getBounds().getMaxY());
              }
              graphics.setColor(getColor());
              graphics.drawLine(bounds.x, y, bounds.x + bounds.width, y);
            } else {
              // horizontal collection: draw vertical line 
              int x;
              if (-1 < cellIndex && cellIndex < collectionCell.getChildCount()) {
                x = collectionCell.getChildAt(cellIndex).getX();
              } else {
                x = ((int) collectionCell.getChildAt(collectionCell.getChildCount() - 1).getBounds().getMaxX());
              }
              int y1 = bounds.y;
              int y2 = bounds.y + bounds.height;

              graphics.setColor(getColor());
              graphics.drawLine(x, y1, x, y2);
              graphics.fillPolygon(new int[]{x, x - 3, x + 3}, new int[]{y1 - 2, y1 - 5, y1 - 5}, 3);
              graphics.fillPolygon(new int[]{x, x - 3, x + 3}, new int[]{y2 + 2, y2 + 5, y2 + 5}, 3);

              graphics.setColor(ColorAndGraphicsUtil.brightenColor(getColor(), 0.8f));
              graphics.drawPolygon(new int[]{x, x - 3, x + 3}, new int[]{y1 - 2, y1 - 5, y1 - 5}, 3);
              graphics.drawPolygon(new int[]{x, x - 3, x + 3}, new int[]{y2 + 2, y2 + 5, y2 + 5}, 3);
            }
            return;
          }

        }
      }
      graphics.setColor((isConflicted() ?
        ChangeType.CONFLICT_COLOR :
        ChangeType.CHANGE.getColor()
      ));
      Rectangle bounds = cell.getBounds();
      graphics.drawRect(bounds.x + 1, bounds.y + 1, bounds.width - 2, bounds.height - 2);
    }
  }

  private Tuples._2<Integer, Integer> getVerticalBounds(EditorComponent editorComponent) {
    EditorCell cell = getCell(editorComponent);
    assert myMessageTarget.getTarget() == MessageTargetEnum.CHILDREN;
    ChildrenMessageTarget cmt = ((ChildrenMessageTarget) myMessageTarget);
    if (!(hasChildrenWithDifferentNode(cell) && eq_myu41h_a0a0a3a5(cmt.getRole(), cell.getRole())) || check_myu41h_a0d0f(cmt.getChildren(), cell)) {
      return MultiTuple.<Integer,Integer>from(super.getStart(editorComponent), super.getHeight(editorComponent));
    } else {

    }
    EditorCell_Collection collectionCell = ((EditorCell_Collection) cell);
    int beginCellIndex = getChildCellIndex(collectionCell, cmt.getBeginIndex());
    int endCellIndex = getChildCellIndex(collectionCell, cmt.getEndIndex() - 1) + 1;
    endCellIndex = Math.max(beginCellIndex, endCellIndex);
    int lastCellIndex = collectionCell.getChildCount() - 1;

    int minY;
    int maxY;
    if (beginCellIndex > lastCellIndex) {
      Rectangle lastCellBounds = collectionCell.getChildAt(lastCellIndex).getBounds();
      minY = (isVertical(cell) ?
        (int) lastCellBounds.getMaxY() :
        (int) lastCellBounds.getMinY()
      );
      maxY = (int) lastCellBounds.getMaxY();
      /*
        if (maxY == minY) {
          maxY++;
        }
      */
    } else {
      minY = (int) collectionCell.getChildAt(beginCellIndex).getBounds().getMinY();
      maxY = (isVertical(cell) ?
        minY + 1 :
        (int) collectionCell.getCellAt(beginCellIndex).getBounds().getMaxY()
      );
    }
    for (int i = beginCellIndex; i < endCellIndex; i++) {
      minY = Math.min(minY, (int) collectionCell.getChildAt(i).getBounds().getMinY());
      maxY = Math.max(maxY, (int) collectionCell.getChildAt(i).getBounds().getMaxY());
    }
    return MultiTuple.<Integer,Integer>from(minY, maxY - minY);
  }

  @Override
  public int getStart(EditorComponent component) {
    if (myMessageTarget.getTarget() == MessageTargetEnum.CHILDREN) {
      return (int) getVerticalBounds(component)._0();
    } else {
      return super.getStart(component);
    }
  }

  @Override
  public int getHeight(EditorComponent component) {
    if (myMessageTarget.getTarget() == MessageTargetEnum.CHILDREN) {
      return (int) getVerticalBounds(component)._1();
    } else {
      return super.getHeight(component);
    }
  }

  private static SNode computeNode(SModel editedModel, ModelChange change) {
    SNodeId id;
    if (change instanceof AddRootChange || change instanceof DeleteRootChange) {
      id = change.getRootId();
    } else if (change instanceof NodeChange) {
      id = ((NodeChange) change).getAffectedNodeId();
    } else if (change instanceof NodeGroupChange) {
      id = ((NodeGroupChange) change).getParentNodeId();
    } else {
      return null;
    }
    return editedModel.getNodeById(id);
  }

  private static MessageTarget computeMessageTarget(SModel editedModel, ModelChange change) {
    if (change instanceof AddRootChange || change instanceof DeleteRootChange) {
      return new NodeMessageTarget();
    } else if (change instanceof SetPropertyChange) {
      return new PropertyMessageTarget(((SetPropertyChange) change).getPropertyName());
    } else if (change instanceof SetReferenceChange) {
      return new ReferenceMessageTarget(((SetReferenceChange) change).getRole());
    } else if (change instanceof NodeGroupChange) {
      SModel changeModel = change.getChangeSet().getNewModel();
      NodeGroupChange nodeGroupChange = ((NodeGroupChange) change);
      boolean reversed = changeModel != editedModel;
      if (reversed) {
        changeModel = change.getChangeSet().getOldModel();
      }
      SNodeId parentId = nodeGroupChange.getParentNodeId();
      String role = nodeGroupChange.getRole();
      List<SNode> changeChildren = changeModel.getNodeById(parentId).getChildren(role);
      int changeBegin = -1;
      int changeEnd = -1;

      if (reversed) {
        changeBegin = nodeGroupChange.getBegin();
        changeEnd = nodeGroupChange.getEnd();
      } else {
        if (change instanceof InsertNodeGroupChange) {
          InsertNodeGroupChange insertChange = (InsertNodeGroupChange) change;
          changeBegin = insertChange.getResultBegin();
          changeEnd = insertChange.getResultEnd();
        } else if (change instanceof DeleteNodeGroupChange) {
          changeBegin = ((DeleteNodeGroupChange) change).getResultPosition();
          changeEnd = changeBegin;
        } else if (change instanceof ReplaceNodeGroupChange) {
          ReplaceNodeGroupChange replaceChange = (ReplaceNodeGroupChange) change;
          changeBegin = replaceChange.getResultBegin();
          changeEnd = replaceChange.getResultEnd();
        } else {
          assert false;
        }
      }

      SNodeId beginId = (changeBegin < changeChildren.size() ?
        changeChildren.get(changeBegin).getSNodeId() :
        null
      );
      SNodeId endId = (changeEnd < changeChildren.size() ?
        changeChildren.get(changeEnd).getSNodeId() :
        null
      );
      int currentChildrenSize = editedModel.getNodeById(parentId).getChildren(role).size();

      int beginIndex = (beginId == null ?
        currentChildrenSize :
        SNodeOperations.getIndexInParent(((SNode) editedModel.getNodeById(beginId)))
      );
      int endIndex = (endId == null ?
        currentChildrenSize :
        SNodeOperations.getIndexInParent(((SNode) editedModel.getNodeById(endId)))
      );

      assert 0 <= beginIndex && beginIndex <= endIndex && endIndex <= currentChildrenSize;
      return new ChildrenMessageTarget(role, beginIndex, endIndex, changeChildren);
    }
    return null;
  }

  private static boolean hasChildrenWithDifferentNode(EditorCell cell) {
    if (cell instanceof EditorCell_Collection) {
      final EditorCell_Collection collectionCell = (EditorCell_Collection) cell;
      return Sequence.fromIterable(((Iterable<EditorCell>) collectionCell)).any(new IWhereFilter<EditorCell>() {
        public boolean accept(EditorCell child) {
          return child.getSNode() != collectionCell.getSNode();
        }
      });
    } else {
      return false;
    }
  }

  private static boolean isVertical(EditorCell cell) {
    return cell instanceof EditorCell_Collection && (((EditorCell_Collection) cell).getCellLayout() instanceof CellLayout_Vertical || cell.getStyle().get(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE));
  }

  private static int getChildCellIndex(@NotNull EditorCell_Collection collectionCell, int nodeIndex) {
    if (nodeIndex == -1) {
      return -1;
    }
    int currentNodeIndex = -1;
    for (int i = 0; i < collectionCell.getChildCount(); i++) {
      if (collectionCell.getChildAt(i).getSNode() != collectionCell.getSNode()) {
        currentNodeIndex++;
      }
      if (currentNodeIndex == nodeIndex) {
        return i;
      }
    }
    if (currentNodeIndex == nodeIndex - 1) {
      return collectionCell.getChildCount();
    }
    assert false;
    return -1;
  }

  private static boolean check_myu41h_a0a0b0e(Set<SNode> checkedDotOperand, EditorCell cell) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.contains(cell.getSNode());
    }
    return false;
  }

  private static boolean check_myu41h_a0d0f(Set<SNode> checkedDotOperand, EditorCell cell) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.contains(cell.getSNode());
    }
    return false;
  }

  private static boolean eq_myu41h_a0a0a0b0e(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  private static boolean eq_myu41h_a0a0a3a5(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }
}
