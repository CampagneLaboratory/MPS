package jetbrains.mps.vcs.diff.ui.common;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.vcs.diff.ChangeSet;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.util.DisjointSets;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public abstract class ChangeGroupBuilder {
  private ChangeEditorMessage.ConflictChecker myConflictChecker;
  protected boolean myInspector = false;
  private List<ChangeGroup> myChangeGroups = null;
  private List<ChangeGroupInvalidateListener> myInvalidateListeners = ListSequence.fromList(new ArrayList<ChangeGroupInvalidateListener>());

  public ChangeGroupBuilder(@Nullable ChangeEditorMessage.ConflictChecker conflictChecker, boolean inspector) {
    myConflictChecker = conflictChecker;
    myInspector = inspector;
  }

  @NotNull
  public abstract EditorComponent getLeftComponent();

  @NotNull
  public abstract EditorComponent getRightComponent();

  protected abstract List<ChangeEditorMessage> getLeftMessages(ModelChange change);

  protected abstract List<ChangeEditorMessage> getRightMessages(ModelChange change);

  @Nullable
  protected abstract ChangeSet getChangeSet();

  private void calculateChangeGroups() {
    final Map<ModelChange, Bounds> left = MapSequence.fromMap(new HashMap<ModelChange, Bounds>());
    final Map<ModelChange, Bounds> right = MapSequence.fromMap(new HashMap<ModelChange, Bounds>());
    for (ModelChange change : ListSequence.fromList(check_a1l5hi_a2a5(getChangeSet(), this))) {
      Bounds leftBounds = findBounds(getLeftMessages(change), getLeftComponent());
      Bounds rightBounds = findBounds(getRightMessages(change), getRightComponent());

      if (leftBounds.length() <= 0 && rightBounds.length() <= 0) {
        continue;
      }

      MapSequence.fromMap(left).put(change, leftBounds);
      MapSequence.fromMap(right).put(change, rightBounds);
    }
    Set<ModelChange> changes = MapSequence.fromMap(left).keySet();
    DisjointSets<ModelChange> ds = new DisjointSets<ModelChange>(changes);
    for (ModelChange a : SetSequence.fromSet(changes)) {
      for (ModelChange b : SetSequence.fromSet(changes)) {
        if (!((int) MapSequence.fromMap(left).get(a).end() - 1 < (int) MapSequence.fromMap(left).get(b).start() || (int) MapSequence.fromMap(left).get(b).end() - 1 < (int) MapSequence.fromMap(left).get(a).start())) {
          ds.unite(a, b);
        }
        if (!((int) MapSequence.fromMap(right).get(a).end() - 1 < (int) MapSequence.fromMap(right).get(b).start() || (int) MapSequence.fromMap(right).get(b).end() - 1 < (int) MapSequence.fromMap(right).get(a).start())) {
          ds.unite(a, b);
        }
      }
    }
    myChangeGroups = ListSequence.fromList(new ArrayList<ChangeGroup>());
    for (Set<ModelChange> s : Sequence.fromIterable(ds.getSets())) {
      Bounds lb = SetSequence.fromSet(s).select(new ISelector<ModelChange, Bounds>() {
        public Bounds select(ModelChange ch) {
          return MapSequence.fromMap(left).get(ch);
        }
      }).reduceLeft(new ILeftCombinator<Bounds, Bounds>() {
        public Bounds combine(Bounds a, Bounds b) {
          return a.merge(b);
        }
      });
      Bounds rb = SetSequence.fromSet(s).select(new ISelector<ModelChange, Bounds>() {
        public Bounds select(ModelChange ch) {
          return MapSequence.fromMap(right).get(ch);
        }
      }).reduceLeft(new ILeftCombinator<Bounds, Bounds>() {
        public Bounds combine(Bounds a, Bounds b) {
          return a.merge(b);
        }
      });
      ListSequence.fromList(myChangeGroups).addElement(new ChangeGroup(lb, rb, SetSequence.fromSet(s).toListSequence(), myConflictChecker));
    }
    myChangeGroups = ListSequence.fromList(myChangeGroups).sort(new ISelector<ChangeGroup, Comparable<?>>() {
      public Comparable<?> select(ChangeGroup g) {
        return (int) g.getLeftBounds().start();
      }
    }, true).toListSequence();
  }

  public void addInvalidateListener(@NotNull ChangeGroupInvalidateListener listener) {
    ListSequence.fromList(myInvalidateListeners).addElement(listener);
  }

  public void removeInvalidateListener(@NotNull ChangeGroupInvalidateListener listener) {
    ListSequence.fromList(myInvalidateListeners).removeElement(listener);
  }

  @NotNull
  public List<ChangeGroup> getChangeGroups() {
    if (myChangeGroups == null) {
      calculateChangeGroups();
    }
    assert myChangeGroups != null;
    return myChangeGroups;
  }

  public void invalidate() {
    myChangeGroups = null;
    ListSequence.fromList(myInvalidateListeners).visitAll(new IVisitor<ChangeGroupInvalidateListener>() {
      public void visit(ChangeGroupInvalidateListener it) {
        it.changeGroupsInvalidated();
      }
    });
  }

  public int getEditorVerticalOffset() {
    if (myInspector) {
      return 0;
    } else {
      assert getLeftComponent().getExternalComponent().getY() == getRightComponent().getExternalComponent().getY();
      return getLeftComponent().getExternalComponent().getY();
    }
  }

  private static Bounds findBounds(Iterable<ChangeEditorMessage> messages, final EditorComponent editorComponent) {
    Bounds bounds = null;
    if (Sequence.fromIterable(messages).isNotEmpty()) {
      bounds = Sequence.fromIterable(messages).select(new ISelector<ChangeEditorMessage, Bounds>() {
        public Bounds select(ChangeEditorMessage m) {
          return m.getBounds(editorComponent);
        }
      }).where(new IWhereFilter<Bounds>() {
        public boolean accept(Bounds b) {
          return b.length() > 0;
        }
      }).reduceLeft(new ILeftCombinator<Bounds, Bounds>() {
        public Bounds combine(Bounds a, Bounds b) {
          return a.merge(b);
        }
      });
    }
    if (bounds == null || bounds.length() <= 0) {
      int y = editorComponent.getRootCell().getY();
      return new Bounds(y, y);
    } else {
      return bounds;
    }
  }

  private static List<ModelChange> check_a1l5hi_a2a5(ChangeSet checkedDotOperand, ChangeGroupBuilder checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
}
