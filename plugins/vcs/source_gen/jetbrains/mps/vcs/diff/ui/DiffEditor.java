package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.EditorMessageOwner;
import javax.swing.JPanel;
import jetbrains.mps.nodeEditor.inspector.InspectorEditorComponent;
import java.util.Map;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.SNode;
import java.awt.Dimension;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.awt.BorderLayout;
import javax.swing.JLabel;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.nodeEditor.EditorComponent;
import javax.swing.JComponent;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import java.util.List;
import jetbrains.mps.smodel.event.SModelEvent;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;

public class DiffEditor implements EditorMessageOwner {
  private DiffEditor.MainEditorComponent myMainEditorComponent;
  private JPanel myTopComponent;
  private InspectorEditorComponent myInspector;
  private Map<ModelChange, ChangeEditorMessage> myChangeToMessage = MapSequence.fromMap(new HashMap<ModelChange, ChangeEditorMessage>());

  public DiffEditor(IOperationContext context, SNode node, String contentTitle) {
    myMainEditorComponent = new DiffEditor.MainEditorComponent(context);
    myMainEditorComponent.editNode(node, myMainEditorComponent.getOperationContext());
    myInspector = new InspectorEditorComponent();
    myInspector.getExternalComponent().setPreferredSize(new Dimension());

    if (SNodeOperations.getModel(node) != null) {
      setReadOnly(SNodeOperations.getModel(node).isNotEditable());
    }

    myTopComponent = new JPanel(new BorderLayout());
    JLabel title = new JLabel(contentTitle);
    title.setToolTipText(contentTitle);
    myTopComponent.add(title, BorderLayout.NORTH);
    myTopComponent.add(myMainEditorComponent.getExternalComponent(), BorderLayout.CENTER);
    myTopComponent.setPreferredSize(new Dimension());
  }

  public void inspect(SNode node) {
    myInspector.inspectNode(node, myMainEditorComponent.getOperationContext());
    myInspector.getHighlightManager().repaintAndRebuildEditorMessages();
  }

  public void setReadOnly(final boolean readOnly) {
    Sequence.fromIterable(getEditorComponents()).visitAll(new IVisitor<EditorComponent>() {
      public void visit(EditorComponent ec) {
        ec.setReadOnly(readOnly);
      }
    });
  }

  public JComponent getTopComponent() {
    return myTopComponent;
  }

  public DiffEditor.MainEditorComponent getMainEditor() {
    return myMainEditorComponent;
  }

  public InspectorEditorComponent getInspector() {
    return myInspector;
  }

  public EditorComponent getEditorComponent(boolean inspector) {
    return (inspector ?
      myInspector :
      myMainEditorComponent
    );
  }

  public void highlightChange(final ChangeEditorMessage message) {
    if (message.getNode() == null) {
      return;
    }
    MapSequence.fromMap(myChangeToMessage).put(message.getChange(), message);
    Sequence.fromIterable(getEditorComponents()).visitAll(new IVisitor<EditorComponent>() {
      public void visit(EditorComponent ec) {
        ec.getHighlightManager().mark(message);
      }
    });
  }

  public void repaintAndRebuildEditorMessages() {
    Sequence.fromIterable(getEditorComponents()).visitAll(new IVisitor<EditorComponent>() {
      public void visit(EditorComponent ec) {
        ec.getHighlightManager().repaintAndRebuildEditorMessages();
      }
    });
  }

  public ChangeEditorMessage getMessageForChange(ModelChange change) {
    return MapSequence.fromMap(myChangeToMessage).get(change);
  }

  public void unhighlightAllChanges() {
    Sequence.fromIterable(getEditorComponents()).visitAll(new IVisitor<EditorComponent>() {
      public void visit(EditorComponent ec) {
        ec.getHighlightManager().clearForOwner(DiffEditor.this);
      }
    });
    MapSequence.fromMap(myChangeToMessage).clear();
  }

  private Iterable<EditorComponent> getEditorComponents() {
    return Sequence.fromArray(new EditorComponent[]{myMainEditorComponent, myInspector});
  }

  public class MainEditorComponent extends EditorComponent {
    public MainEditorComponent(IOperationContext operationContext) {
      super(operationContext);
    }

    public EditorCell createRootCell(List<SModelEvent> events) {
      if (getEditedNode() == null || getEditedNode().isDeleted()) {
        EditorContext editorContext = getEditorContext();
        return new EditorCell_Constant(editorContext, getEditedNode(), "");
      }
      return getEditorContext().createRootCell(getEditedNode(), events);
    }
  }
}
