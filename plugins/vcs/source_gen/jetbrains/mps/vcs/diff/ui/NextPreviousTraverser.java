package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import javax.swing.Icon;
import com.intellij.openapi.util.IconLoader;
import jetbrains.mps.ide.projectPane.Icons;
import java.util.List;
import jetbrains.mps.nodeEditor.EditorComponent;
import com.intellij.openapi.actionSystem.ActionToolbar;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.selection.SelectionListener;
import jetbrains.mps.nodeEditor.selection.Selection;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Arrays;
import com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.workbench.action.BaseAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;

public class NextPreviousTraverser {
  private static final Icon PREVIOUS_ICON = IconLoader.getIcon("/actions/previousOccurence.png", Icons.class);
  private static final Icon NEXT_ICON = IconLoader.getIcon("/actions/nextOccurence.png", Icons.class);

  private List<ChangeGroupBuilder> myChangeGroupBuilders;
  private EditorComponent myLastEditor;
  private NextPreviousTraverser.TheAction myPreviousAction = new NextPreviousTraverser.TheAction(true);
  private NextPreviousTraverser.TheAction myNextAction = new NextPreviousTraverser.TheAction(false);
  private ActionToolbar myActionToolbar = null;

  public NextPreviousTraverser(@NotNull List<ChangeGroupBuilder> changeGroupBuilders, @NotNull EditorComponent firstEditor) {
    myChangeGroupBuilders = changeGroupBuilders;
    myLastEditor = firstEditor;

    final SelectionListener selectionListener = new SelectionListener() {
      public void selectionChanged(EditorComponent editorComponent, Selection oldSelection, Selection newSelection) {
        myLastEditor = editorComponent;
        updateToolbar();
      }
    };
    ListSequence.fromList(myChangeGroupBuilders).visitAll(new IVisitor<ChangeGroupBuilder>() {
      public void visit(ChangeGroupBuilder cgb) {
        cgb.addInvalidateListener(new ChangeGroupInvalidateListener() {
          public void changeGroupsInvalidated() {
            updateToolbar();
          }
        });
      }
    });
    SetSequence.fromSet(SetSequence.fromSetWithValues(new HashSet<EditorComponent>(), ListSequence.fromList(myChangeGroupBuilders).<EditorComponent>translate(new ITranslator2<ChangeGroupBuilder, EditorComponent>() {
      public Iterable<EditorComponent> translate(ChangeGroupBuilder b) {
        return Arrays.asList(b.getLeftComponent(), b.getRightComponent());
      }
    }))).visitAll(new IVisitor<EditorComponent>() {
      public void visit(EditorComponent ec) {
        ec.getSelectionManager().addSelectionListener(selectionListener);
      }
    });
  }

  public void setActionToolbar(ActionToolbar actionToolbar) {
    myActionToolbar = actionToolbar;
  }

  private void updateToolbar() {
    if (myActionToolbar != null) {
      ApplicationManager.getApplication().invokeLater(new Runnable() {
        public void run() {
          myActionToolbar.updateActionsImmediately();
        }
      });
    }
  }

  @Nullable
  private ChangeGroupBuilder getBuilderAsLeft() {
    return ListSequence.fromList(myChangeGroupBuilders).findFirst(new IWhereFilter<ChangeGroupBuilder>() {
      public boolean accept(ChangeGroupBuilder b) {
        return b.getLeftComponent() == myLastEditor;
      }
    });
  }

  @Nullable
  private ChangeGroupBuilder getBuilderAsRight() {
    return ListSequence.fromList(myChangeGroupBuilders).findFirst(new IWhereFilter<ChangeGroupBuilder>() {
      public boolean accept(ChangeGroupBuilder b) {
        return b.getRightComponent() == myLastEditor;
      }
    });
  }

  private int findNeighbourGroupAsLeftOrRight(final int currentY, boolean previous, final boolean left) {
    assert ListSequence.fromList(myChangeGroupBuilders).any(new IWhereFilter<ChangeGroupBuilder>() {
      public boolean accept(ChangeGroupBuilder b) {
        return b.getLeftComponent() == myLastEditor || b.getRightComponent() == myLastEditor;
      }
    });

    ChangeGroupBuilder builder = (left ?
      getBuilderAsLeft() :
      getBuilderAsRight()
    );
    if (builder == null) {
      return -1;
    }
    List<ChangeGroup> changeGroups = builder.getChangeGroups();
    ChangeGroup changeGroup;
    if (previous) {
      changeGroup = ListSequence.fromList(changeGroups).findLast(new IWhereFilter<ChangeGroup>() {
        public boolean accept(ChangeGroup cg) {
          return (int) cg.getBounds(left).end() < currentY;
        }
      });
    } else {
      changeGroup = ListSequence.fromList(changeGroups).findFirst(new IWhereFilter<ChangeGroup>() {
        public boolean accept(ChangeGroup cg) {
          return (int) cg.getBounds(left).start() > currentY;
        }
      });
    }
    return (changeGroup == null ?
      -1 :
      (int) changeGroup.getBounds(left).start()
    );
  }

  private int getNeighbourGroupY(boolean previous) {
    // -1 means that group is not available 

    int currentY = myLastEditor.getViewport().getViewPosition().y;
    EditorCell selectedCell = myLastEditor.getSelectedCell();
    if (selectedCell != null) {
      currentY = selectedCell.getY();
    }
    int asLeft = findNeighbourGroupAsLeftOrRight(currentY, previous, true);
    int asRight = findNeighbourGroupAsLeftOrRight(currentY, previous, false);
    if (asLeft != -1 && asRight != -1) {
      return (previous ?
        Math.max(asLeft, asRight) :
        Math.min(asLeft, asRight)
      );
    } else {
      return Math.max(asLeft, asRight);
    }
  }

  public BaseAction previousAction() {
    return myPreviousAction;
  }

  public BaseAction nextAction() {
    return myNextAction;
  }

  private void goToChangeGroup(int y) {
    myLastEditor.changeSelection(myLastEditor.findCellWeak(1, y + 1));
  }

  private class TheAction extends BaseAction {
    private boolean myPrevious;

    private TheAction(boolean previous) {
      super("Go to " + ((previous ?
        "Previous" :
        "Next"
      )) + " Change", null, (previous ?
        NextPreviousTraverser.PREVIOUS_ICON :
        NextPreviousTraverser.NEXT_ICON
      ));
      setDisableOnNoProject(false);
      setExecuteOutsideCommand(true);
      myPrevious = previous;
    }

    protected void doExecute(AnActionEvent event, Map<String, Object> map) {
      assert getNeighbourGroupY(myPrevious) != -1;
      goToChangeGroup(getNeighbourGroupY(myPrevious));
    }

    @Override
    protected void doUpdate(AnActionEvent event, Map<String, Object> map) {
      event.getPresentation().setEnabled(getNeighbourGroupY(myPrevious) != -1);
    }
  }
}
