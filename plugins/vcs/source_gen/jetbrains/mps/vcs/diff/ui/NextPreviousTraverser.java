package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import javax.swing.Icon;
import com.intellij.openapi.util.IconLoader;
import jetbrains.mps.ide.projectPane.Icons;
import java.util.List;
import jetbrains.mps.nodeEditor.EditorComponent;
import com.intellij.openapi.actionSystem.ActionToolbar;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.selection.SelectionListener;
import jetbrains.mps.nodeEditor.selection.Selection;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Arrays;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.workbench.action.BaseAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;

public class NextPreviousTraverser {
  private static final Icon PREVIOUS_ICON = IconLoader.getIcon("/actions/previousOccurence.png", Icons.class);
  private static final Icon NEXT_ICON = IconLoader.getIcon("/actions/nextOccurence.png", Icons.class);

  private List<ChangeGroupBuilder> myChangeGroupBuilders;
  private EditorComponent myLastEditor;
  private NextPreviousTraverser.TheAction myPreviousAction = new NextPreviousTraverser.TheAction(true);
  private NextPreviousTraverser.TheAction myNextAction = new NextPreviousTraverser.TheAction(false);
  private ActionToolbar myActionToolbar = null;

  public NextPreviousTraverser(@NotNull List<ChangeGroupBuilder> changeGroupBuilders, @NotNull EditorComponent firstEditor) {
    myChangeGroupBuilders = changeGroupBuilders;
    myLastEditor = firstEditor;

    final SelectionListener selectionListener = new SelectionListener() {
      public void selectionChanged(EditorComponent editorComponent, Selection oldSelection, Selection newSelection) {
        myLastEditor = editorComponent;
        updateToolbar();
      }
    };
    ListSequence.fromList(myChangeGroupBuilders).visitAll(new IVisitor<ChangeGroupBuilder>() {
      public void visit(ChangeGroupBuilder cgb) {
        cgb.addInvalidateListener(new ChangeGroupInvalidateListener() {
          public void changeGroupsInvalidated() {
            updateToolbar();
          }
        });
      }
    });
    SetSequence.fromSet(SetSequence.fromSetWithValues(new HashSet<EditorComponent>(), ListSequence.fromList(myChangeGroupBuilders).<EditorComponent>translate(new ITranslator2<ChangeGroupBuilder, EditorComponent>() {
      public Iterable<EditorComponent> translate(ChangeGroupBuilder b) {
        return Arrays.asList(b.getLeftComponent(), b.getRightComponent());
      }
    }))).visitAll(new IVisitor<EditorComponent>() {
      public void visit(EditorComponent ec) {
        ec.getSelectionManager().addSelectionListener(selectionListener);
      }
    });
  }

  public void setActionToolbar(ActionToolbar actionToolbar) {
    myActionToolbar = actionToolbar;
  }

  private void updateToolbar() {
    if (myActionToolbar != null) {
      ApplicationManager.getApplication().invokeLater(new Runnable() {
        public void run() {
          myActionToolbar.updateActionsImmediately();
        }
      });
    }
  }

  private void assertKnownEditor() {
    assert ListSequence.fromList(myChangeGroupBuilders).any(new IWhereFilter<ChangeGroupBuilder>() {
      public boolean accept(ChangeGroupBuilder b) {
        return b.getLeftComponent() == myLastEditor || b.getRightComponent() == myLastEditor;
      }
    });
  }

  private ChangeGroupBuilder getBuilder() {
    assertKnownEditor();
    return ListSequence.fromList(myChangeGroupBuilders).findFirst(new IWhereFilter<ChangeGroupBuilder>() {
      public boolean accept(ChangeGroupBuilder b) {
        return b.getLeftComponent() == myLastEditor || b.getRightComponent() == myLastEditor;
      }
    });
  }

  private boolean isEditorLeft() {
    assertKnownEditor();
    return ListSequence.fromList(myChangeGroupBuilders).any(new IWhereFilter<ChangeGroupBuilder>() {
      public boolean accept(ChangeGroupBuilder b) {
        return b.getLeftComponent() == myLastEditor;
      }
    });
  }

  @Nullable
  private ChangeGroup getNeighbourGroup(boolean previous) {
    // TODO consider result editor 
    final Wrappers._int currentY = new Wrappers._int(myLastEditor.getViewport().getViewPosition().y);
    EditorCell selectedCell = myLastEditor.getSelectedCell();
    if (selectedCell != null) {
      currentY.value = selectedCell.getY();
    }
    final boolean isLeft = isEditorLeft();
    List<ChangeGroup> changeGroups = getBuilder().getChangeGroups();
    if (previous) {
      return ListSequence.fromList(changeGroups).findLast(new IWhereFilter<ChangeGroup>() {
        public boolean accept(ChangeGroup cg) {
          return (int) cg.getBounds(isLeft).end() < currentY.value;
        }
      });
    } else {
      return ListSequence.fromList(changeGroups).findFirst(new IWhereFilter<ChangeGroup>() {
        public boolean accept(ChangeGroup cg) {
          return (int) cg.getBounds(isLeft).start() > currentY.value;
        }
      });
    }
  }

  public BaseAction previousAction() {
    return myPreviousAction;
  }

  public BaseAction nextAction() {
    return myNextAction;
  }

  private void goToChangeGroup(@NotNull ChangeGroup group) {
    int y = (int) ((isEditorLeft() ?
      group.getLeftBounds() :
      group.getRightBounds()
    )).start();
    EditorCell cell = myLastEditor.findCellWeak(1, y + 1);
    myLastEditor.changeSelection(cell);
  }

  private class TheAction extends BaseAction {
    private boolean myPrevious;

    private TheAction(boolean previous) {
      super("Go to " + ((previous ?
        "Previous" :
        "Next"
      )) + " Change", null, (previous ?
        NextPreviousTraverser.PREVIOUS_ICON :
        NextPreviousTraverser.NEXT_ICON
      ));
      setDisableOnNoProject(false);
      setExecuteOutsideCommand(true);
      myPrevious = previous;
    }

    protected void doExecute(AnActionEvent event, Map<String, Object> map) {
      assert getNeighbourGroup(myPrevious) != null;
      goToChangeGroup(getNeighbourGroup(myPrevious));
    }

    @Override
    protected void doUpdate(AnActionEvent event, Map<String, Object> map) {
      event.getPresentation().setEnabled(getNeighbourGroup(myPrevious) != null);
    }
  }
}
