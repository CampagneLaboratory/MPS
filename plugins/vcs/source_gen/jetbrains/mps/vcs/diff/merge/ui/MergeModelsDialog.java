package jetbrains.mps.vcs.diff.merge.ui;

/*Generated by MPS */

import jetbrains.mps.ide.dialogs.BaseDialog;
import javax.swing.Icon;
import com.intellij.openapi.util.IconLoader;
import jetbrains.mps.ide.projectPane.Icons;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.vcs.diff.merge.MergeContext;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import jetbrains.mps.smodel.SModel;
import com.intellij.openapi.diff.DiffRequest;
import com.intellij.openapi.wm.WindowManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import jetbrains.mps.workbench.action.ActionUtils;
import jetbrains.mps.vcs.diff.ui.InvokeTextDiffAction;
import com.intellij.openapi.actionSystem.Separator;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import javax.swing.JScrollPane;
import javax.swing.JComponent;
import jetbrains.mps.ide.dialogs.DialogDimensionsSettings;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.SNodeId;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.vcs.diff.ui.DiffModelTree;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.workbench.action.BaseAction;
import java.util.Arrays;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.ChangeType;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;

public class MergeModelsDialog extends BaseDialog {
  public static final Icon APPLY_NON_CONFLICTS = IconLoader.getIcon("/diff/applyNotConflicts.png", Icons.class);

  private Project myProject;
  private IOperationContext myOperationContext;
  private MergeContext myMergeContext;
  private MergeModelsDialog.MergeModelsTree myMergeTree;
  private JPanel myPanel = new JPanel(new BorderLayout());
  private boolean myApplyChanges = false;
  private boolean myRootsDialogInvoked = false;
  private String[] myContentTitles;

  public MergeModelsDialog(Project project, IOperationContext operationContext, SModel baseModel, SModel mineModel, SModel repositoryModel, DiffRequest request) {
    super(WindowManager.getInstance().getFrame(project), "Merging " + SModelOperations.getModelName(baseModel));
    myContentTitles = request.getContentTitles();
    assert myContentTitles.length == 3;
    myProject = project;
    myOperationContext = operationContext;
    myMergeContext = new MergeContext(baseModel, mineModel, repositoryModel);
    myMergeTree = new MergeModelsDialog.MergeModelsTree();
    myMergeTree.setMultipleRootNames(true);

    DefaultActionGroup actionGroup = ActionUtils.groupFromActions(new InvokeTextDiffAction("Merge as Text (Use Carefully!)", "Merge models using text merge for XML contents", this, request), new MergeNonConflictingRoots(myMergeContext, this), Separator.getInstance(), AcceptYoursTheirs.yoursInstance(this), AcceptYoursTheirs.theirsInstance(this));
    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, actionGroup, true);
    toolbar.updateActionsImmediately();
    myPanel.add(toolbar.getComponent(), BorderLayout.NORTH);
    myPanel.add(new JScrollPane(myMergeTree), BorderLayout.CENTER);
  }

  protected JComponent getMainComponent() {
    return myPanel;
  }

  @Override
  public DialogDimensionsSettings.DialogDimensions getDefaultDimensionSettings() {
    return new DialogDimensionsSettings.DialogDimensions(10, 10, 500, 700);
  }

  @BaseDialog.Button(position = 0, name = "OK", mnemonic = 'O', defaultButton = true)
  public void ok() {
    MergeConfirmation.showMergeConfirmationAndTakeAction(this, myMergeContext, myMergeContext.getAllChanges(), new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        myMergeContext.applyAllChangesForNonConflictingRoots();
      }
    }, new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        myApplyChanges = true;
        dispose();
      }
    });
  }

  @BaseDialog.Button(position = 1, name = "Cancel", mnemonic = 'C')
  public void cancel() {
    dispose();
  }

  public SModel getResultModel() {
    return (myApplyChanges ?
      myMergeContext.getResultModel() :
      null
    );
  }

  /*package*/ void rebuildLater() {
    myMergeTree.rebuildLater();
  }

  /*package*/ IOperationContext getOperationContext() {
    return myOperationContext;
  }

  @Nullable
  public SNodeId getNeighbourRoot(@NotNull SNodeId rootId, boolean next) {
    return myMergeTree.getNeighbourRoot(rootId, next);
  }

  public void invokeMergeRoots(final SNodeId rootId) {
    if (myRootsDialogInvoked) {
      return;
    }
    myRootsDialogInvoked = true;
    final Wrappers._T<MergeRootsDialog> mergeRootsDialog = new Wrappers._T<MergeRootsDialog>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        mergeRootsDialog.value = new MergeRootsDialog(MergeModelsDialog.this, myMergeContext, rootId, myMergeTree.getNameForRoot(rootId));
      }
    });
    mergeRootsDialog.value.showDialog();
    mergeRootsDialog.value.toFront();
  }

  public void acceptVersionForSelectedRoots(boolean mine) {
    final List<ModelChange> changesToApply = ListSequence.fromList(new ArrayList<ModelChange>());
    final List<ModelChange> changesToExclude = ListSequence.fromList(new ArrayList<ModelChange>());
    for (DiffModelTree.RootTreeNode rtn : Sequence.fromIterable(Sequence.fromArray(myMergeTree.getSelectedNodes(DiffModelTree.RootTreeNode.class, null)))) {
      for (ModelChange change : ListSequence.fromList(myMergeContext.getChangesForRoot(rtn.getRootId()))) {
        if (!(myMergeContext.isChangeResolved(change))) {
          if (mine == myMergeContext.isMyChange(change)) {
            ListSequence.fromList(changesToApply).addElement(change);
          } else {
            ListSequence.fromList(changesToExclude).addElement(change);
          }
        }
      }
    }
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        myMergeContext.applyChanges(changesToApply);
        myMergeContext.excludeChanges(changesToExclude);
        myMergeTree.rebuildNow();
      }
    });
  }

  /*package*/ void rootsDialogClosed() {
    myRootsDialogInvoked = false;
  }

  /*package*/ String[] getContentTitles() {
    return myContentTitles;
  }

  public static boolean isNewMergeEnabled() {
    return !("false".equals(System.getProperty("mps.newmerge")));
  }

  private class MergeModelsTree extends DiffModelTree {
    private MergeModelsTree() {
      super(myOperationContext);
    }

    protected Iterable<BaseAction> getRootActions(final SNodeId rootId) {
      MergeModelsDialog md = MergeModelsDialog.this;
      return Arrays.asList(new InvokeMergeRootsAction(md, rootId), AcceptYoursTheirs.yoursInstance(md), AcceptYoursTheirs.theirsInstance(md));
    }

    protected void updateRootCustomPresentation(DiffModelTree.RootTreeNode rootTreeNode) {
      List<ModelChange> changes = ListSequence.fromList(myMergeContext.getChangesForRoot(rootTreeNode.getRootId())).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return !(myMergeContext.isChangeResolved(ch));
        }
      }).toListSequence();

      int conflictedCount = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return Sequence.fromIterable(myMergeContext.getConflictedWith(ch)).isNotEmpty();
        }
      }).count();
      int nonConflictedCount = ListSequence.fromList(changes).count() - conflictedCount;
      ChangeType compositeChangeType = null;
      if (conflictedCount != 0) {
        compositeChangeType = ChangeType.CONFLICTED;

        rootTreeNode.setAdditionalText("with conflicts");
        String text = NameUtil.formatNumericalString(conflictedCount, "conficting change");
        if (nonConflictedCount == 0) {
          rootTreeNode.setTooltipText(text);
        } else {
          rootTreeNode.setTooltipText(text + " of " + ListSequence.fromList(changes).count() + " total");
        }
      } else {
        if (nonConflictedCount == 0) {
          if (myMergeContext.getResultModel().getNodeById(rootTreeNode.getRootId()) == null) {
            rootTreeNode.setText(String.format("<html><s>%s</s></html>", rootTreeNode.getText()));
          }
        } else {
          compositeChangeType = ChangeType.CHANGE;
          if (ListSequence.fromList(changes).all(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange ch) {
              return ch instanceof AddRootChange || ch instanceof DeleteRootChange;
            }
          })) {
            compositeChangeType = ListSequence.fromList(changes).first().getType();
          }

          int myChangesCount = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange ch) {
              return myMergeContext.isMyChange(ch);
            }
          }).count();
          if (myChangesCount == nonConflictedCount) {
            rootTreeNode.setAdditionalText("local");
          } else if (myChangesCount == 0) {
            rootTreeNode.setAdditionalText("remote");
          } else {
            rootTreeNode.setAdditionalText("both modified");
          }
          rootTreeNode.setTooltipText(NameUtil.formatNumericalString(nonConflictedCount, " change"));
        }
      }

      if (compositeChangeType != null) {
        rootTreeNode.setColor(compositeChangeType.getTreeColor());
      }
    }

    protected Iterable<SModel> getModels() {
      return Arrays.asList(myMergeContext.getBaseModel(), myMergeContext.getMyModel(), myMergeContext.getRepositoryModel());
    }

    protected Iterable<SNodeId> getAffectedRoots() {
      return myMergeContext.getAffectedRoots();
    }
  }
}
