package jetbrains.mps.vcs.diff;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import jetbrains.mps.vcs.diff.changes.ChangeSet;
import java.util.Map;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.vcs.diff.changes.ChangeSetBuilder;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.smodel.SNodeId;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.vcs.diff.changes.NodeChange;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.apache.commons.lang.ObjectUtils;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import jetbrains.mps.smodel.CopyUtil;
import java.util.ArrayList;

public class MergeContext {
  private SModel myBaseModel;
  private SModel myMyModel;
  private SModel myRepositoryModel;
  private SModel myResultModel;
  private ChangeSet myMineChangeSet;
  private ChangeSet myRepositoryChangeSet;
  private Map<ModelChange, ModelChange> myConflictingChanges = MapSequence.fromMap(new HashMap<ModelChange, ModelChange>());
  private Map<ModelChange, ModelChange> mySymmetricChanges = MapSequence.fromMap(new HashMap<ModelChange, ModelChange>());

  public MergeContext(final SModel base, final SModel mine, final SModel repository) {
    myBaseModel = base;
    myMyModel = mine;
    myRepositoryModel = repository;
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        myMineChangeSet = ChangeSetBuilder.buildChangeSet(base, mine);
        myRepositoryChangeSet = ChangeSetBuilder.buildChangeSet(base, repository);
      }
    });
  }

  private void addConflict(ModelChange ch1, ModelChange ch2) {
    assert ch1.getChangeSet() != ch2.getChangeSet();
    MapSequence.fromMap(myConflictingChanges).put(ch1, ch2);
    MapSequence.fromMap(myConflictingChanges).put(ch2, ch1);
  }

  private void addSymmetric(ModelChange ch1, ModelChange ch2) {
    assert ch1.getChangeSet() != ch2.getChangeSet();
    MapSequence.fromMap(mySymmetricChanges).put(ch1, ch2);
    MapSequence.fromMap(mySymmetricChanges).put(ch2, ch1);
  }

  private void collectGroupChangesWithOthersConflicts(Map<Tuples._2<SNodeId, String>, List<NodeGroupChange>> arrangedChanges, ChangeSet thisChangeSet, ChangeSet otherChangeSet) {
    final Map<SNodeId, DeleteRootChange> deleteRootChanges = MapSequence.fromMap(new HashMap<SNodeId, DeleteRootChange>());
    Sequence.fromIterable(thisChangeSet.getModelChanges(DeleteRootChange.class)).visitAll(new IVisitor<DeleteRootChange>() {
      public void visit(DeleteRootChange d) {
        MapSequence.fromMap(deleteRootChanges).put(d.getNodeId(), d);
      }
    });
    for (NodeChange change : Sequence.fromIterable(otherChangeSet.getModelChanges(NodeChange.class))) {
      if (!(MapSequence.fromMap(myConflictingChanges).containsKey(change))) {
        SNode node = myBaseModel.getNodeById(change.getAffectedNodeId());
        while (node != null) {
          SNodeId nodeId = node.getSNodeId();
          if (SNodeOperations.getParent(node) == null) {
            DeleteRootChange conflicting = MapSequence.fromMap(deleteRootChanges).get(nodeId);
            if (conflicting != null) {
              addConflict(change, conflicting);
            }
          } else {
            Tuples._2<SNodeId, String> nodeRole = MultiTuple.<SNodeId,String>from(SNodeOperations.getParent(node).getSNodeId(), SNodeOperations.getContainingLinkRole(node));
            final int index = SNodeOperations.getIndexInParent(node);
            NodeGroupChange conflicting = ListSequence.fromList(MapSequence.fromMap(arrangedChanges).get(nodeRole)).findFirst(new IWhereFilter<NodeGroupChange>() {
              public boolean accept(NodeGroupChange ch) {
                return ch.getBegin() <= index && index < ch.getEnd();
              }
            });
            if (conflicting != null) {
              addConflict(change, conflicting);
              break;
            }
          }
          node = SNodeOperations.getParent(node);
        }
      }
    }
  }

  private Map<Tuples._2<SNodeId, String>, SetPropertyChange> arrangePropertyChanges(ChangeSet changeSet) {
    Map<Tuples._2<SNodeId, String>, SetPropertyChange> propertyChangesMap = MapSequence.fromMap(new HashMap<Tuples._2<SNodeId, String>, SetPropertyChange>());
    for (SetPropertyChange spc : Sequence.fromIterable(changeSet.getModelChanges(SetPropertyChange.class))) {
      MapSequence.fromMap(propertyChangesMap).put(MultiTuple.<SNodeId,String>from(spc.getAffectedNodeId(), spc.getPropertyName()), spc);
    }
    return propertyChangesMap;
  }

  private void collectPropertyConflicts() {
    Map<Tuples._2<SNodeId, String>, SetPropertyChange> minePropertyChanges = arrangePropertyChanges(myMineChangeSet);
    Map<Tuples._2<SNodeId, String>, SetPropertyChange> repositoryPropertyChanges = arrangePropertyChanges(myRepositoryChangeSet);
    for (Tuples._2<SNodeId, String> nodeName : SetSequence.fromSet(MapSequence.fromMap(minePropertyChanges).keySet()).intersect(SetSequence.fromSet(MapSequence.fromMap(repositoryPropertyChanges).keySet()))) {
      SetPropertyChange mineChange = MapSequence.fromMap(minePropertyChanges).get(nodeName);
      SetPropertyChange repositoryChange = MapSequence.fromMap(repositoryPropertyChanges).get(nodeName);
      if (ObjectUtils.equals(mineChange.getNewValue(), repositoryChange.getNewValue())) {
        addSymmetric(mineChange, repositoryChange);
      } else {
        addConflict(mineChange, repositoryChange);
      }
    }
  }

  private Map<Tuples._2<SNodeId, String>, SetReferenceChange> arrangeReferenceChanges(ChangeSet changeSet) {
    Map<Tuples._2<SNodeId, String>, SetReferenceChange> referenceChangesMap = MapSequence.fromMap(new HashMap<Tuples._2<SNodeId, String>, SetReferenceChange>());
    for (SetReferenceChange spc : Sequence.fromIterable(changeSet.getModelChanges(SetReferenceChange.class))) {
      MapSequence.fromMap(referenceChangesMap).put(MultiTuple.<SNodeId,String>from(spc.getAffectedNodeId(), spc.getRole()), spc);
    }
    return referenceChangesMap;
  }

  private void collectReferenceConflicts() {
    Map<Tuples._2<SNodeId, String>, SetReferenceChange> mineReferenceChanges = arrangeReferenceChanges(myMineChangeSet);
    Map<Tuples._2<SNodeId, String>, SetReferenceChange> repositoryReferenceChanges = arrangeReferenceChanges(myRepositoryChangeSet);
    for (Tuples._2<SNodeId, String> nodeName : SetSequence.fromSet(MapSequence.fromMap(mineReferenceChanges).keySet()).intersect(SetSequence.fromSet(MapSequence.fromMap(repositoryReferenceChanges).keySet()))) {
      SetReferenceChange mineChange = MapSequence.fromMap(mineReferenceChanges).get(nodeName);
      SetReferenceChange repositoryChange = MapSequence.fromMap(repositoryReferenceChanges).get(nodeName);
      if (ObjectUtils.equals(mineChange.getTargetNodeId(), repositoryChange.getTargetNodeId()) && ObjectUtils.equals(mineChange.getTargetModelReference(), repositoryChange.getTargetModelReference()) && ObjectUtils.equals(mineChange.getResolveInfo(), repositoryChange.getResolveInfo())) {
        addSymmetric(mineChange, repositoryChange);
      } else {
        addConflict(mineChange, repositoryChange);
      }
    }
  }

  private void collectConflicts() {
    Map<Tuples._2<SNodeId, String>, List<NodeGroupChange>> mineGroupChanges = arrangeNodeGroupChanges(myMineChangeSet);
    Map<Tuples._2<SNodeId, String>, List<NodeGroupChange>> repositoryGroupChanges = arrangeNodeGroupChanges(myRepositoryChangeSet);
    for (Tuples._2<SNodeId, String> nodeRole : SetSequence.fromSet(MapSequence.fromMap(mineGroupChanges).keySet()).intersect(SetSequence.fromSet(MapSequence.fromMap(repositoryGroupChanges).keySet()))) {
      List<NodeGroupChange> mine = MapSequence.fromMap(mineGroupChanges).get(nodeRole);
      List<NodeGroupChange> repository = MapSequence.fromMap(repositoryGroupChanges).get(nodeRole);
      // This is a quadratic algorithm, it can be optimized to linear, 
      // but it is left for simplicity 
      for (NodeGroupChange m : ListSequence.fromList(mine)) {
        for (NodeGroupChange r : ListSequence.fromList(repository)) {
          if (!(m.getEnd() < r.getBegin() || m.getBegin() > r.getEnd())) {
            addConflict(m, r);
            // TODO check for symmetry 
          }
        }
      }
    }

    collectGroupChangesWithOthersConflicts(mineGroupChanges, myMineChangeSet, myRepositoryChangeSet);
    collectGroupChangesWithOthersConflicts(repositoryGroupChanges, myRepositoryChangeSet, myMineChangeSet);

    collectPropertyConflicts();
    collectReferenceConflicts();
  }

  public void rebuildAll() {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        collectConflicts();
        myResultModel = CopyUtil.copyModel(myBaseModel);
      }
    });
  }

  private static Map<Tuples._2<SNodeId, String>, List<NodeGroupChange>> arrangeNodeGroupChanges(ChangeSet changeSet) {
    Map<Tuples._2<SNodeId, String>, List<NodeGroupChange>> nodeRoleToGroupChanges = MapSequence.fromMap(new HashMap<Tuples._2<SNodeId, String>, List<NodeGroupChange>>());
    for (NodeGroupChange change : Sequence.fromIterable(changeSet.getModelChanges(NodeGroupChange.class))) {
      Tuples._2<SNodeId, String> nodeRole = MultiTuple.<SNodeId,String>from(change.getParentNodeId(), change.getRole());
      if (!(MapSequence.fromMap(nodeRoleToGroupChanges).containsKey(nodeRole))) {
        MapSequence.fromMap(nodeRoleToGroupChanges).put(nodeRole, ListSequence.fromList(new ArrayList<NodeGroupChange>()));
      }
      ListSequence.fromList(MapSequence.fromMap(nodeRoleToGroupChanges).get(nodeRole)).addElement(change);
    }
    return nodeRoleToGroupChanges;
  }
}
