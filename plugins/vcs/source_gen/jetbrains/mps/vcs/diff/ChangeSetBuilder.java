package jetbrains.mps.vcs.diff;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.SNode;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.smodel.PropertySupport;
import com.intellij.openapi.application.ApplicationManager;
import org.apache.commons.lang.ObjectUtils;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.util.LongestCommonSubsequenceFinder;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.vcs.diff.changes.DependencyChange;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISequence;
import jetbrains.mps.vcs.diff.changes.ImportedModelChange;
import jetbrains.mps.vcs.diff.changes.ModuleDependencyChange;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.vcs.diff.changes.DoNotGenerateOptionChange;
import jetbrains.mps.vcs.diff.changes.ModelVersionChange;
import jetbrains.mps.internal.collections.runtime.ISetSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class ChangeSetBuilder {
  private SModel myOldModel;
  private SModel myNewModel;
  private ChangeSetImpl myChangeSet;
  private List<ModelChange> myNewChanges = ListSequence.fromList(new ArrayList<ModelChange>());

  private ChangeSetBuilder(SModel oldModel, SModel newModel) {
    this(new ChangeSetImpl(oldModel, newModel));
  }

  private ChangeSetBuilder(ChangeSetImpl changeSet) {
    myOldModel = changeSet.getOldModel();
    myNewModel = changeSet.getNewModel();
    myChangeSet = changeSet;
  }

  private void buildPropertyChanges(SNode oldNode, SNode newNode) {
    Set<String> oldProperties = (Set<String>) oldNode.getPropertyNames();
    Set<String> newProperties = (Set<String>) newNode.getPropertyNames();
    for (String name : SetSequence.fromSet(oldProperties).union(SetSequence.fromSet(newProperties))) {
      buildPropertyChanges(oldNode, newNode, name);
    }
  }

  public void buildPropertyChanges(SNode oldNode, SNode newNode, String name) {
    PropertySupport propertySupport = new ChangeSetBuilder.DefaultPropertySupport();
    if (ApplicationManager.getApplication() != null) {
      SNode propertyDeclaration = oldNode.getPropertyDeclaration(name);
      if (propertyDeclaration != null) {
        propertySupport = PropertySupport.getPropertySupport(propertyDeclaration);
      }
    }

    String oldPresentableValue = propertySupport.fromInternalValue(oldNode.getProperty(name));
    String newPresentableValue = propertySupport.fromInternalValue(newNode.getProperty(name));
    if (!(ObjectUtils.equals(oldPresentableValue, newPresentableValue))) {
      ListSequence.fromList(myNewChanges).addElement(new SetPropertyChange(myChangeSet, oldNode.getSNodeId(), name, newNode.getProperty(name)));
    }
  }

  private void buildReferenceChanges(SNode oldNode, SNode newNode) {
    Set<String> oldReferences = (Set<String>) oldNode.getReferenceRoles();
    Set<String> newReferences = (Set<String>) newNode.getReferenceRoles();
    for (String role : SetSequence.fromSet(oldReferences).union(SetSequence.fromSet(newReferences))) {
      buildReferenceChanges(oldNode, newNode, role);
    }
  }

  public void buildReferenceChanges(SNode oldNode, SNode newNode, String role) {
    SReference oldReference = oldNode.getReference(role);
    SReference newReference = newNode.getReference(role);
    SNodeId oldTargetId = (oldReference instanceof DynamicReference ?
      null :
      check_nbyrtw_a0a2a3(oldReference)
    );
    SNodeId newTargetId = (newReference instanceof DynamicReference ?
      null :
      check_nbyrtw_a0a3a3(newReference)
    );
    if (eq_nbyrtw_a0a0e0d(oldTargetId, newTargetId) && eq_nbyrtw_a0a0e0d_0(check_nbyrtw_a0a0e0d(oldReference), check_nbyrtw_a0a0e0d_0(newReference)) && eq_nbyrtw_a0a4a3(check_nbyrtw_a0a4a3(oldReference), check_nbyrtw_a0a4a3_0(newReference))) {
      // same references 
    } else {
      SModelReference targetModel = check_nbyrtw_a0a0a4a3(newReference);
      if (eq_nbyrtw_a0b0a4a3(SNodeOperations.getModel(newNode).getSModelReference(), targetModel)) {
        // This is internal reference 
        targetModel = null;
      }
      ListSequence.fromList(myNewChanges).addElement(new SetReferenceChange(myChangeSet, oldNode.getSNodeId(), role, targetModel, newTargetId, check_nbyrtw_f0a0a2a0e0d(newReference)));
    }
  }

  private void buildNodeChanges(SNode oldNode) {
    SNodeId nodeId = oldNode.getSNodeId();
    SNode newNode = myNewModel.getNodeById(nodeId);

    buildPropertyChanges(oldNode, newNode);
    buildReferenceChanges(oldNode, newNode);

    for (String role : SetSequence.fromSetWithValues(new HashSet<String>(), ListSequence.fromList(SNodeOperations.getChildren(oldNode)).concat(ListSequence.fromList(SNodeOperations.getChildren(newNode))).select(new ISelector<SNode, String>() {
      public String select(SNode ch) {
        return SNodeOperations.getContainingLinkRole(ch);
      }
    }))) {
      buildNodeRoleChanges(oldNode, newNode, role);
    }
  }

  public void buildNodeRoleChanges(SNode oldNode, SNode newNode, String role) {
    final List<SNode> oldChildren = oldNode.getChildren(role);
    List<SNode> newChildren = newNode.getChildren(role);
    List<SNodeId> oldIds = ListSequence.fromList(oldChildren).select(new ISelector<SNode, SNodeId>() {
      public SNodeId select(SNode n) {
        return n.getSNodeId();
      }
    }).toListSequence();
    List<SNodeId> newIds = ListSequence.fromList(newChildren).select(new ISelector<SNode, SNodeId>() {
      public SNodeId select(SNode n) {
        return n.getSNodeId();
      }
    }).toListSequence();
    LongestCommonSubsequenceFinder<SNodeId> finder = new LongestCommonSubsequenceFinder<SNodeId>(oldIds, newIds);

    // Finding insertings, deletings and replacings 
    List<Tuples._2<Tuples._2<Integer, Integer>, Tuples._2<Integer, Integer>>> differentIndices = finder.getDifferentIndices();
    for (Tuples._2<Tuples._2<Integer, Integer>, Tuples._2<Integer, Integer>> indices : ListSequence.fromList(differentIndices)) {
      Tuples._2<Integer, Integer> oldIndices = indices._0();
      Tuples._2<Integer, Integer> newIndices = indices._1();
      ListSequence.fromList(myNewChanges).addElement(new NodeGroupChange(myChangeSet, oldNode.getSNodeId(), role, (int) oldIndices._0(), (int) oldIndices._1(), (int) newIndices._0(), (int) newIndices._1()));
    }

    // Finding changes for children 
    List<Tuples._2<Integer, Integer>> commonIndices = finder.getCommonIndices();
    ListSequence.fromList(commonIndices).select(new ISelector<Tuples._2<Integer, Integer>, SNode>() {
      public SNode select(Tuples._2<Integer, Integer> in) {
        return ListSequence.fromList(oldChildren).getElement((int) in._0());
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode child) {
        buildNodeChanges(child);
      }
    });
  }

  private <D> void buildAddedAndDeletedChanges(_FunctionTypes._return_P1_E0<? extends Iterable<D>, ? super SModel> referencesExtractor, final _FunctionTypes._return_P2_E0<? extends DependencyChange, ? super D, ? super Boolean> changeCreator) {
    Iterable<D> added;
    Iterable<D> deleted;
    {
      Tuples._2<Iterable<D>, Iterable<D>> _tmp_nbyrtw_c0g = getAddedAndDeleted(referencesExtractor);
      added = _tmp_nbyrtw_c0g._0();
      deleted = _tmp_nbyrtw_c0g._1();
    }
    ListSequence.fromList(myNewChanges).addSequence(Sequence.fromIterable(added).select(new ISelector<D, DependencyChange>() {
      public DependencyChange select(D r) {
        return changeCreator.invoke(r, false);
      }
    }));
    ListSequence.fromList(myNewChanges).addSequence(Sequence.fromIterable(deleted).select(new ISelector<D, DependencyChange>() {
      public DependencyChange select(D r) {
        return changeCreator.invoke(r, true);
      }
    }));
  }

  private void buildModelImports() {
    _FunctionTypes._return_P1_E0<? extends Iterable<SModelReference>, ? super SModel> importedModelsExtractor = new _FunctionTypes._return_P1_E0<ISequence<SModelReference>, SModel>() {
      public ISequence<SModelReference> invoke(SModel model) {
        return ListSequence.fromList(((List<SModel.ImportElement>) model.importedModels())).select(new ISelector<SModel.ImportElement, SModelReference>() {
          public SModelReference select(SModel.ImportElement ie) {
            return ie.getModelReference();
          }
        });
      }
    };
    _FunctionTypes._return_P2_E0<? extends ImportedModelChange, ? super SModelReference, ? super Boolean> changeCreator = new _FunctionTypes._return_P2_E0<ImportedModelChange, SModelReference, Boolean>() {
      public ImportedModelChange invoke(SModelReference mr, Boolean deleted) {
        return new ImportedModelChange(myChangeSet, mr, deleted);
      }
    };
    buildAddedAndDeletedChanges(importedModelsExtractor, changeCreator);
  }

  private void buildModuleDependencies(final ModuleDependencyChange.DependencyType dependencyType, _FunctionTypes._return_P1_E0<? extends Iterable<ModuleReference>, ? super SModel> referencesExtractor) {
    _FunctionTypes._return_P2_E0<? extends ModuleDependencyChange, ? super ModuleReference, ? super Boolean> changeCreator = new _FunctionTypes._return_P2_E0<ModuleDependencyChange, ModuleReference, Boolean>() {
      public ModuleDependencyChange invoke(ModuleReference mr, Boolean deleted) {
        return new ModuleDependencyChange(myChangeSet, mr, dependencyType, deleted);
      }
    };
    buildAddedAndDeletedChanges(referencesExtractor, changeCreator);
  }

  private void buildMetadataChanges() {
    buildModelImports();

    buildModuleDependencies(ModuleDependencyChange.DependencyType.USED_LANG, new _FunctionTypes._return_P1_E0<List<ModuleReference>, SModel>() {
      public List<ModuleReference> invoke(SModel model) {
        return model.importedLanguages();
      }
    });
    buildModuleDependencies(ModuleDependencyChange.DependencyType.USED_DEVKIT, new _FunctionTypes._return_P1_E0<List<ModuleReference>, SModel>() {
      public List<ModuleReference> invoke(SModel model) {
        return model.importedDevkits();
      }
    });
    buildModuleDependencies(ModuleDependencyChange.DependencyType.LANG_ENGAGED_ON_GENERATION, new _FunctionTypes._return_P1_E0<List<ModuleReference>, SModel>() {
      public List<ModuleReference> invoke(SModel model) {
        return model.engagedOnGenerationLanguages();
      }
    });

    if (myNewModel.getSModelHeader().isDoNotGenerate() != myOldModel.getSModelHeader().isDoNotGenerate()) {
      ListSequence.fromList(myNewChanges).addElement(new DoNotGenerateOptionChange(myChangeSet));
    }
    if (myNewModel.getSModelHeader().getVersion() != myOldModel.getSModelHeader().getVersion()) {
      ListSequence.fromList(myNewChanges).addElement(new ModelVersionChange(myChangeSet));
    }
  }

  private Iterable<SNodeId> generateRootChanges() {
    // Returns common root ids 

    _FunctionTypes._return_P1_E0<? extends Set<SNodeId>, ? super SModel> rootIds = new _FunctionTypes._return_P1_E0<ISetSequence<SNodeId>, SModel>() {
      public ISetSequence<SNodeId> invoke(SModel m) {
        return SetSequence.fromSetWithValues(new HashSet<SNodeId>(), ListSequence.fromList(SModelOperations.getRoots(m, null)).select(new ISelector<SNode, SNodeId>() {
          public SNodeId select(SNode node) {
            return node.getSNodeId();
          }
        }));
      }
    };
    Set<SNodeId> oldRootIds = rootIds.invoke(myOldModel);
    Set<SNodeId> newRootIds = rootIds.invoke(myNewModel);

    ListSequence.fromList(myNewChanges).addSequence(SetSequence.fromSet(newRootIds).subtract(SetSequence.fromSet(oldRootIds)).select(new ISelector<SNodeId, AddRootChange>() {
      public AddRootChange select(SNodeId r) {
        return new AddRootChange(myChangeSet, r);
      }
    }));
    ListSequence.fromList(myNewChanges).addSequence(SetSequence.fromSet(oldRootIds).subtract(SetSequence.fromSet(newRootIds)).select(new ISelector<SNodeId, DeleteRootChange>() {
      public DeleteRootChange select(SNodeId r) {
        return new DeleteRootChange(myChangeSet, r);
      }
    }));

    return SetSequence.fromSet(oldRootIds).intersect(SetSequence.fromSet(newRootIds));
  }

  private void buildChanges(boolean withOpposite) {
    Iterable<SNodeId> commonRootIds = generateRootChanges();
    for (SNodeId rootId : Sequence.fromIterable(commonRootIds)) {
      buildNodeChanges(myOldModel.getNodeById(rootId));
    }

    buildMetadataChanges();

    if (withOpposite) {
      myChangeSet.buildOppositeChangeSet();
    }
  }

  public void commit() {
    ListSequence.fromList(myNewChanges).visitAll(new IVisitor<ModelChange>() {
      public void visit(ModelChange it) {
        myChangeSet.add(it);
      }
    });
    ListSequence.fromList(myNewChanges).clear();
  }

  public List<ModelChange> getNewChanges() {
    return myNewChanges;
  }

  private <D> Tuples._2<Iterable<D>, Iterable<D>> getAddedAndDeleted(Iterable<D> oldItems, Iterable<D> newItems) {
    Set<D> oldSet = SetSequence.fromSetWithValues(new HashSet<D>(), oldItems);
    Set<D> newSet = SetSequence.fromSetWithValues(new HashSet<D>(), newItems);
    return MultiTuple.<Iterable<D>,Iterable<D>>from(SetSequence.fromSet(newSet).subtract(SetSequence.fromSet(oldSet)), SetSequence.fromSet(oldSet).subtract(SetSequence.fromSet(newSet)));
  }

  private <D> Tuples._2<Iterable<D>, Iterable<D>> getAddedAndDeleted(_FunctionTypes._return_P1_E0<? extends Iterable<D>, ? super SModel> itemsExtractor) {
    return getAddedAndDeleted(itemsExtractor.invoke(myOldModel), itemsExtractor.invoke(myNewModel));
  }

  public static ChangeSet buildChangeSet(SModel oldModel, SModel newModel) {
    return buildChangeSet(oldModel, newModel, false);
  }

  public static ChangeSet buildChangeSet(SModel oldModel, SModel newModel, boolean withOpposite) {
    ChangeSetBuilder builder = new ChangeSetBuilder(oldModel, newModel);
    builder.buildChanges(withOpposite);
    builder.commit();
    return builder.myChangeSet;
  }

  public static void rebuildChangeSet(ChangeSet changeSet) {
    ChangeSetImpl impl = (ChangeSetImpl) changeSet;
    impl.clear();
    impl.clearOppositeChangeSet();
    ChangeSetBuilder builder = new ChangeSetBuilder(impl);
    builder.buildChanges(true);
    builder.commit();
  }

  public static ChangeSetBuilder createBuilder(ChangeSet changeSet) {
    return new ChangeSetBuilder((ChangeSetImpl) changeSet);
  }

  private static SNodeId check_nbyrtw_a0a2a3(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTargetNodeId();
    }
    return null;
  }

  private static SNodeId check_nbyrtw_a0a3a3(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTargetNodeId();
    }
    return null;
  }

  private static SModelReference check_nbyrtw_a0a0e0d(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTargetSModelReference();
    }
    return null;
  }

  private static SModelReference check_nbyrtw_a0a0e0d_0(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTargetSModelReference();
    }
    return null;
  }

  private static String check_nbyrtw_a0a4a3(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getResolveInfo();
    }
    return null;
  }

  private static String check_nbyrtw_a0a4a3_0(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getResolveInfo();
    }
    return null;
  }

  private static SModelReference check_nbyrtw_a0a0a4a3(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTargetSModelReference();
    }
    return null;
  }

  private static String check_nbyrtw_f0a0a2a0e0d(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getResolveInfo();
    }
    return null;
  }

  private static boolean eq_nbyrtw_a0a0e0d(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  private static boolean eq_nbyrtw_a0a0e0d_0(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  private static boolean eq_nbyrtw_a0a4a3(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  private static boolean eq_nbyrtw_a0b0a4a3(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  private static class DefaultPropertySupport extends PropertySupport {
    private DefaultPropertySupport() {
    }

    protected boolean canSetValue(String string) {
      return true;
    }
  }
}
