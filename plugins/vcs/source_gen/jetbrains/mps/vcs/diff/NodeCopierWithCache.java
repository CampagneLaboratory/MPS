package jetbrains.mps.vcs.diff;

/*Generated by MPS */

import jetbrains.mps.vcs.diff.changes.NodeCopier;
import java.util.Map;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;

public class NodeCopierWithCache implements NodeCopier {
  private Map<SNodeId, SNodeId> myIdReplacementCache = MapSequence.fromMap(new HashMap<SNodeId, SNodeId>());
  private SModel myModel;

  public NodeCopierWithCache(SModel model) {
    myModel = model;
  }

  public SNode copyNode(SNode sourceNode) {
    SNode copy = CopyUtil.copyAndPreserveId(sourceNode);
    for (SNode node : ListSequence.fromList(SNodeOperations.getDescendants(copy, null, true, new String[]{}))) {
      SNodeId nodeId = node.getSNodeId();
      if (myModel.getNodeById(nodeId) != null) {
        SNodeId replacedId = SModel.generateUniqueId();
        node.setId(replacedId);
        if (!(MapSequence.fromMap(myIdReplacementCache).containsKey(nodeId))) {
          MapSequence.fromMap(myIdReplacementCache).put(nodeId, replacedId);
        }
      }
    }
    return copy;
  }

  public void restoreIds() {
    for (SNodeId id : SetSequence.fromSet(MapSequence.fromMap(myIdReplacementCache).keySet())) {
      if (myModel.getNodeById(id) == null) {
        // node id is free now! 
        SNodeId replacedId = MapSequence.fromMap(myIdReplacementCache).get(id);
        assert replacedId != null;
        SNode replacedNode = myModel.getNodeById(replacedId);
        assert replacedNode != null;

        SNode copy = CopyUtil.copyAndPreserveId(replacedNode);
        copy.setId(id);
        if (SNodeOperations.getParent(replacedNode) == null) {
          assert false;
        } else {
          SNodeOperations.replaceWithAnother(replacedNode, copy);
        }

        MapSequence.fromMap(myIdReplacementCache).put(id, null);
      }
    }
  }

  public Map<SNodeId, SNodeId> getState() {
    final Map<SNodeId, SNodeId> state = MapSequence.fromMap(new HashMap<SNodeId, SNodeId>(MapSequence.fromMap(myIdReplacementCache).count()));
    MapSequence.fromMap(myIdReplacementCache).visitAll(new IVisitor<IMapping<SNodeId, SNodeId>>() {
      public void visit(IMapping<SNodeId, SNodeId> m) {
        MapSequence.fromMap(state).put(m.key(), m.value());
      }
    });
    return state;
  }

  public void setState(Map<SNodeId, SNodeId> state, SModel model) {
    myIdReplacementCache = state;
    myModel = model;
  }
}
