package jetbrains.mps.vcs.diff.changes;

/*Generated by MPS */

import jetbrains.mps.smodel.SNodeId;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.ArrayList;

public abstract class NodeGroupChange extends ModelChange {
  private SNodeId myParentNodeId;
  private String myRole;

  public NodeGroupChange(@NotNull ChangeSet changeSet, @NotNull SNodeId parentNodeId, @NotNull String role) {
    super(changeSet);
    myParentNodeId = parentNodeId;
    myRole = role;
  }

  @NotNull
  public SNodeId getParentNodeId() {
    return myParentNodeId;
  }

  @NotNull
  public String getRole() {
    return myRole;
  }

  public abstract int getBegin();

  public abstract int getEnd();

  @Nullable
  private SNode deleteOldNodesAndReturnAnchor(@NotNull final SModel model) {
    SNode parent = getChangeSet().getOldModel().getNodeById(myParentNodeId);
    assert parent != null;
    Iterable<SNode> originalNodesToDelete = ListSequence.fromList(((List<SNode>) parent.getChildren(myRole))).page(getBegin(), getEnd());
    SNodeId anchorId = check_yjf6x2_a0d0e(SNodeOperations.getPrevSibling(Sequence.fromIterable(originalNodesToDelete).first()));
    SNode anchor = (anchorId == null ?
      null :
      model.getNodeById(anchorId)
    );
    Sequence.fromIterable(originalNodesToDelete).visitAll(new IVisitor<SNode>() {
      public void visit(SNode n) {
        model.getNodeById(n.getSNodeId()).delete();
      }
    });
    return anchor;
  }

  protected Tuples._2<Integer, Integer> getNodesToInsert() {
    return MultiTuple.<Integer,Integer>from(0, 0);
  }

  public void apply(@NotNull SModel model, @NotNull NodeCopier nodeCopier) {
    SNode parent = model.getNodeById(myParentNodeId);
    SNode anchor = deleteOldNodesAndReturnAnchor(model);
    List<SNode> nodesToAdd = ListSequence.fromList(new ArrayList<SNode>());
    List<SNode> newChildren = getChangeSet().getNewModel().getNodeById(myParentNodeId).getChildren(myRole);
    for (int i = getNodesToInsert()._0(); i < getNodesToInsert()._1(); i++) {
      ListSequence.fromList(nodesToAdd).addElement(nodeCopier.copyNode(newChildren.get(i)));
    }
    for (SNode newNode : ListSequence.fromList(nodesToAdd).reversedList()) {
      parent.insertChild(anchor, myRole, newNode);
    }
  }

  @Nullable
  @Override
  public SNodeId getRootId() {
    return getChangeSet().getOldModel().getNodeById(myParentNodeId).getContainingRoot().getSNodeId();
  }

  protected static String nodeRange(int begin, int end) {
    return (begin + 1 == end ?
      String.format("node #%d", begin) :
      String.format("nodes #%d-%d", begin, end - 1)
    );
  }

  private static SNodeId check_yjf6x2_a0d0e(SNode p) {
    if (null == p) {
      return null;
    }
    return p.getSNodeId();
  }
}
