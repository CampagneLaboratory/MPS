package jetbrains.mps.vcs.mergedriver;

/*Generated by MPS */

import java.io.File;
import java.io.FileInputStream;
import java.io.OutputStream;
import jetbrains.mps.util.ReadUtil;
import jetbrains.mps.util.FileUtil;
import java.io.IOException;

/*package*/ class SimpleMerger extends AbstractFileMerger {
  /*package*/ SimpleMerger() {
  }

  protected int mergeFiles(File baseFile, File localFile, File latestFile) {
    FileInputStream baseIS = null;
    FileInputStream localIS = null;
    FileInputStream latestIS = null;
    OutputStream out = null;
    try {
      baseIS = new FileInputStream(baseFile);
      localIS = new FileInputStream(localFile);
      latestIS = new FileInputStream(latestFile);

      byte[] baseContent = ReadUtil.read(baseIS);
      byte[] localContent = ReadUtil.read(localIS);
      byte[] latestContent = ReadUtil.read(latestIS);
      FileUtil.closeFileSafe(localIS);

      out = getResultStream(localFile);

      String baseAsString = contentAsString(baseContent);
      String localAsString = contentAsString(localContent);
      String latestAsString = contentAsString(latestContent);

      if (baseAsString.equals(localAsString)) {
        out.write(latestContent);
        return MERGED;
      }
      if (baseAsString.equals(latestAsString) || localAsString.equals(latestAsString)) {
        out.write(localContent);
        return MERGED;
      }
      out.write(localContent);
      return CONFLICTS;
    } catch (IOException e) {
      e.printStackTrace();
      return FATAL_ERROR;
    } finally {
      FileUtil.closeFileSafe(baseIS);
      FileUtil.closeFileSafe(localIS);
      FileUtil.closeFileSafe(latestIS);
      FileUtil.closeFileSafe(out);
    }
  }

  private static String contentAsString(byte[] bytes) {
    return new String(bytes, FileUtil.DEFAULT_CHARSET).replace("\r\n", "\n");
  }
}
