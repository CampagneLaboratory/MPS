package jetbrains.mps.vcs;

/*Generated by MPS */

import jetbrains.mps.ide.editor.warningPanel.EditorWarningsProvider;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.ide.editor.warningPanel.WarningPanel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SNode;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.SModelDescriptor;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.util.NameUtil;
import com.intellij.openapi.vcs.AbstractVcsHelper;
import java.util.Arrays;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import com.intellij.openapi.vcs.FileStatus;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.SModel;

public class ConflictingModelsEditorWarningsProvider implements EditorWarningsProvider {
  public ConflictingModelsEditorWarningsProvider() {
  }

  @Nullable
  public WarningPanel getWarningPanel(@NotNull SNode node, @NotNull final Project project) {
    SModelDescriptor md = check_smgm7b_a0a0a(node.getModel());
    final VirtualFile modelFile = getModelFileIfConflicting(md, project);
    final VirtualFile moduleFile = getModuleFileIfConflicting(check_smgm7b_a0a2a0(md), project);
    if (moduleFile != null) {
      String type = getModuleType(md.getModule());
      assert type != null;
      if (modelFile != null) {
        // conflicting model and module 
        return new WarningPanel(String.format("You are viewing model which is not merged yet. It is owned by %s, which is merged neither." + " You need to merge %s and model (this order is important).", type, type), "Merge Module and Model", new Runnable() {
          public void run() {
            invokeMergeDialog(project, moduleFile, modelFile);
          }
        });
      } else {
        // conflicting module 
        return new WarningPanel(String.format("You are viewing model owned by %s which is not merged yet. You need to merge it before editing.", type, type), "Merge " + NameUtil.capitalize(type), new Runnable() {
          public void run() {
            invokeMergeDialog(project, moduleFile);
          }
        });
      }
    } else {
      if (modelFile != null) {
        // conflicting model 
        return new WarningPanel("You are viewing model which is not merged yet. You may see very old version of it." + " You need to merge it before editing, otherwise your changes will be lost.", "Merge Model", new Runnable() {
          public void run() {
            invokeMergeDialog(project, modelFile);
          }
        });
      } else {
        return null;
      }
    }
  }

  private void invokeMergeDialog(Project project, VirtualFile... interestingFiles) {
    AbstractVcsHelper.getInstance(project).showMergeDialog(Arrays.asList(interestingFiles));
  }

  @Nullable
  private static String getModuleType(@NotNull IModule module) {
    if (module instanceof Language) {
      return "language";
    } else if (module instanceof Solution) {
      return "solution";
    } else if (module instanceof Generator) {
      return "generator";
    }
    return null;
  }

  private static VirtualFile getModelFileIfConflicting(@Nullable SModelDescriptor md, @NotNull Project project) {
    if (md instanceof EditableSModelDescriptor) {
      VirtualFile vf = VirtualFileUtils.getVirtualFile(((EditableSModelDescriptor) md).getModelFile());
      if (vf != null) {
        FileStatus status = FileStatusManager.getInstance(project).getStatus(vf);
        if (FileStatus.MERGED_WITH_CONFLICTS == status || FileStatus.MERGED_WITH_BOTH_CONFLICTS == status) {
          return vf;
        }
      }
    }
    return null;
  }

  private static VirtualFile getModuleFileIfConflicting(@Nullable IModule module, @NotNull Project project) {
    if (module instanceof Generator) {
      module = ((Generator) module).getSourceLanguage();
    }
    VirtualFile vf = VirtualFileUtils.getVirtualFile(check_smgm7b_a0a1a2(module));
    if (vf != null) {
      FileStatus status = FileStatusManager.getInstance(project).getStatus(vf);
      if (FileStatus.MERGED_WITH_CONFLICTS == status || FileStatus.MERGED_WITH_BOTH_CONFLICTS == status) {
        return vf;
      }
    }
    return null;
  }

  private static IFile check_smgm7b_a0a1a2(IModule checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getDescriptorFile();
    }
    return null;
  }

  private static SModelDescriptor check_smgm7b_a0a0a(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }

  private static IModule check_smgm7b_a0a2a0(SModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }
}
