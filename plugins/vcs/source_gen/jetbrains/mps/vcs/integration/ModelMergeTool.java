package jetbrains.mps.vcs.integration;

/*Generated by MPS */

import com.intellij.openapi.diff.impl.mergeTool.MergeTool;
import jetbrains.mps.logging.Logger;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import com.intellij.openapi.diff.DiffRequest;
import com.intellij.openapi.diff.DiffTool;
import com.intellij.openapi.diff.impl.mergeTool.MergeRequestImpl;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vfs.LocalFileSystem;
import java.io.File;
import jetbrains.mps.vcs.MergeBackupUtil;
import com.intellij.openapi.diff.DiffContent;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.vcs.diff.merge.ui.MergeModelsDialog;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import com.intellij.openapi.ui.Messages;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.project.ModuleContext;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.vcs.diff.ui.OldMergeModelsDialog;
import java.io.IOException;
import jetbrains.mps.fileTypes.MPSFileTypeFactory;
import com.intellij.openapi.ui.DialogWrapper;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.FileUtil;
import org.jetbrains.annotations.Nullable;
import java.lang.reflect.Method;

public class ModelMergeTool extends MergeTool {
  private static final Logger LOG = Logger.getLogger(ModelMergeTool.class);
  public static final int CURRENT = 0;
  public static final int ORIGINAL = 1;
  public static final int LAST_REVISION = 2;
  protected static Log log = LogFactory.getLog(ModelMergeTool.class);

  public ModelMergeTool() {
  }

  private void showTextMerge(DiffRequest request) {
    DiffTool ideaMergeTool = new MergeTool();
    if (ideaMergeTool.canShow(request)) {
      ideaMergeTool.show(request);
    }
  }

  public void show(final DiffRequest request) {
    MergeRequestImpl mrequest = (MergeRequestImpl) request;
    try {
      VirtualFile file = getFileFromMergeRequest(mrequest);
      if (file == null) {
        if (log.isErrorEnabled()) {
          log.error("No file");
        }
        file = LocalFileSystem.getInstance().findFileByPath("/");
      }
      File backupFile = MergeBackupUtil.zipModel(request.getContents(), file);
      DiffContent[] contents = mrequest.getContents();
      final SModel baseModel;
      final SModel mineModel;
      final SModel newModel;
      try {
        baseModel = ModelPersistence.readModel(contents[ORIGINAL].getDocument().getText(), false);
        mineModel = ModelPersistence.readModel(new String(contents[CURRENT].getBytes(), "UTF-8"), false);
        newModel = ModelPersistence.readModel(new String(contents[LAST_REVISION].getBytes(), "UTF-8"), false);
      } catch (ModelReadException e) {
        if (log.isWarnEnabled()) {
          log.warn("Couldn't read model, invoking text merge", e);
        }
        super.show(request);
        return;
      }

      if (isNewMergeEnabled()) {
        final MergeModelsDialog dialog = new MergeModelsDialog(baseModel, mineModel, newModel, mrequest);
        SwingUtilities.invokeLater(new Runnable() {
          public void run() {
            dialog.toFront();
          }
        });
        dialog.showDialog();
        if (dialog.getResultModel() != null) {
          String asString = ModelPersistence.modelToString(dialog.getResultModel());
          resolved(mrequest, asString);
          MergeBackupUtil.packMergeResult(backupFile, file.getName(), asString);
        }
      } else {
        SModelDescriptor modelDescriptor = SModelRepository.getInstance().getModelDescriptor(baseModel.getSModelReference());
        if (modelDescriptor == null) {
          modelDescriptor = SModelRepository.getInstance().getModelDescriptor(mineModel.getSModelFqName());
        }
        String errorMsg = null;
        if (modelDescriptor == null) {
          errorMsg = "Model " + mineModel.getLongName() + " is not in model repository.";
        } else if (modelDescriptor.getModule() == null) {
          errorMsg = "Model " + mineModel.getLongName() + " is not owned by any module.";
        }
        if (errorMsg != null) {
          int result = Messages.showYesNoDialog(request.getProject(), errorMsg + " If you want to merge it using MPS merger," + " you need to cancel it now and invoke merge tool from project where this model" + "is owned by any visible module. Also, you can use text merge.\n" + "Do you want to use text merge tool?", "Can't Merge Model", Messages.getErrorIcon());
          if (result == 0) {
            showTextMerge(request);
          }
          return;
        }
        assert modelDescriptor != null;
        IOperationContext context = new ModuleContext(modelDescriptor.getModule(), ProjectHelper.toMPSProject(request.getProject()));
        final OldMergeModelsDialog dialog = new OldMergeModelsDialog(context, baseModel, mineModel, newModel);

        SwingUtilities.invokeLater(new Runnable() {
          public void run() {
            dialog.toFront();
          }
        });
        dialog.showDialog();
        if (dialog.getResultModel() != null) {
          resolved(mrequest, ModelPersistence.modelToString(dialog.getResultModel()));
        }
      }
    } catch (IOException e) {
      LOG.error(e);
    }
  }

  public boolean canShow(DiffRequest request) {
    return super.canShow(request) && request.getContents()[ORIGINAL].getContentType() == MPSFileTypeFactory.MODEL_FILE_TYPE;
  }

  public static boolean isNewMergeEnabled() {
    return !("false".equals(System.getProperty("mps.newmerge")));
  }

  private static void resolved(MergeRequestImpl req, final String result) {
    req.setResult(DialogWrapper.OK_EXIT_CODE);
    final VirtualFile modelFile = getFileFromMergeRequest(req);
    ModelAccess.instance().runWriteInEDT(new Runnable() {
      public void run() {
        try {
          modelFile.setBinaryContent(result.getBytes(FileUtil.DEFAULT_CHARSET));
        } catch (IOException e) {
          if (log.isErrorEnabled()) {
            log.error("", e);
          }
        }
      }
    });
  }

  @Nullable
  private static VirtualFile getFileFromMergeRequest(MergeRequestImpl mergeRequest) throws SecurityException {
    // This is a hacky method which accesses private nested class MergeRequestImpl.MergeContent 
    // using reflection. Alternative way would require patching IDEA platform. 
    // TODO rewrite eature request filed: IDEA-75603 
    DiffContent resultContent = mergeRequest.getResultContent();
    try {
      Class<?> mergeContentClass = Class.forName("com.intellij.openapi.diff.impl.mergeTool.MergeRequestImpl$MergeContent");
      if (mergeContentClass.isInstance(resultContent)) {
        Method getFileMethod = mergeContentClass.getMethod("getFile");
        getFileMethod.setAccessible(true);
        Object file = getFileMethod.invoke(resultContent);
        assert file == null || file instanceof VirtualFile;
        return ((VirtualFile) file);
      }
    } catch (Exception e) {
      if (log.isErrorEnabled()) {
        log.error("", e);
      }
    }
    return null;
  }
}
