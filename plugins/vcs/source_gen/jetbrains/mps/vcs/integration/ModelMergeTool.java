package jetbrains.mps.vcs.integration;

/*Generated by MPS */

import com.intellij.openapi.diff.impl.mergeTool.MergeTool;
import jetbrains.mps.logging.Logger;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import com.intellij.openapi.diff.DiffRequest;
import com.intellij.openapi.diff.impl.mergeTool.MergeRequestImpl;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vfs.LocalFileSystem;
import java.io.File;
import jetbrains.mps.vcs.MergeBackupUtil;
import com.intellij.openapi.diff.DiffContent;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.vcs.diff.ui.merge.MergeModelsDialog;
import javax.swing.SwingUtilities;
import java.io.IOException;
import jetbrains.mps.fileTypes.MPSFileTypeFactory;
import com.intellij.openapi.ui.DialogWrapper;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.annotations.Nullable;
import java.lang.reflect.Method;

public class ModelMergeTool extends MergeTool {
  private static final Logger LOG = Logger.getLogger(ModelMergeTool.class);
  public static final int CURRENT = 0;
  public static final int ORIGINAL = 1;
  public static final int LAST_REVISION = 2;
  protected static Log log = LogFactory.getLog(ModelMergeTool.class);

  public ModelMergeTool() {
  }

  public void show(final DiffRequest request) {
    MergeRequestImpl mrequest = (MergeRequestImpl) request;
    try {
      VirtualFile file = getFileFromMergeRequest(mrequest);
      if (file == null) {
        if (log.isErrorEnabled()) {
          log.error("No file");
        }
        file = LocalFileSystem.getInstance().findFileByPath("/");
      }
      File backupFile = MergeBackupUtil.zipModel(request.getContents(), file);
      DiffContent[] contents = mrequest.getContents();
      final SModel baseModel;
      final SModel mineModel;
      final SModel newModel;
      try {
        baseModel = ModelPersistence.readModel(contents[ORIGINAL].getDocument().getText(), false);
        mineModel = ModelPersistence.readModel(new String(contents[CURRENT].getBytes(), FileUtil.DEFAULT_CHARSET), false);
        newModel = ModelPersistence.readModel(new String(contents[LAST_REVISION].getBytes(), FileUtil.DEFAULT_CHARSET), false);
      } catch (ModelReadException e) {
        if (log.isWarnEnabled()) {
          log.warn("Couldn't read model, invoking text merge", e);
        }
        super.show(request);
        return;
      }

      final MergeModelsDialog dialog = new MergeModelsDialog(baseModel, mineModel, newModel, mrequest);
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          dialog.toFront();
        }
      });
      dialog.showDialog();
      if (dialog.getResultModel() != null) {
        String asString = ModelPersistence.modelToString(dialog.getResultModel());
        resolved(mrequest, asString);
        MergeBackupUtil.packMergeResult(backupFile, file.getName(), asString);
      }
    } catch (IOException e) {
      LOG.error(e);
    }
  }

  public boolean canShow(DiffRequest request) {
    return super.canShow(request) && request.getContents()[ORIGINAL].getContentType() == MPSFileTypeFactory.MODEL_FILE_TYPE;
  }

  private static void resolved(MergeRequestImpl req, final String result) {
    req.setResult(DialogWrapper.OK_EXIT_CODE);
    final VirtualFile modelFile = getFileFromMergeRequest(req);
    ModelAccess.instance().runWriteInEDT(new Runnable() {
      public void run() {
        try {
          modelFile.setBinaryContent(result.getBytes(FileUtil.DEFAULT_CHARSET));
        } catch (IOException e) {
          if (log.isErrorEnabled()) {
            log.error("", e);
          }
        }
      }
    });
  }

  @Nullable
  private static VirtualFile getFileFromMergeRequest(MergeRequestImpl mergeRequest) throws SecurityException {
    // This is a hacky method which accesses private nested class MergeRequestImpl.MergeContent 
    // using reflection. Alternative way would require patching IDEA platform. 
    // TODO rewrite eature request filed: IDEA-75603 
    DiffContent resultContent = mergeRequest.getResultContent();
    try {
      Class<?> mergeContentClass = Class.forName("com.intellij.openapi.diff.impl.mergeTool.MergeRequestImpl$MergeContent");
      if (mergeContentClass.isInstance(resultContent)) {
        Method getFileMethod = mergeContentClass.getMethod("getFile");
        getFileMethod.setAccessible(true);
        Object file = getFileMethod.invoke(resultContent);
        assert file == null || file instanceof VirtualFile;
        return ((VirtualFile) file);
      }
    } catch (Exception e) {
      if (log.isErrorEnabled()) {
        log.error("", e);
      }
    }
    return null;
  }
}
