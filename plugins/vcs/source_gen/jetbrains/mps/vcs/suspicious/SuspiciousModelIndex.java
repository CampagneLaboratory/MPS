package jetbrains.mps.vcs.suspicious;

/*Generated by MPS */

import com.intellij.openapi.components.ApplicationComponent;
import com.intellij.openapi.project.ProjectManager;
import jetbrains.mps.watching.ModelChangesWatcher;
import com.intellij.openapi.vfs.VirtualFileManager;
import jetbrains.mps.smodel.DefaultSModelDescriptor;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.MPSCore;
import jetbrains.mps.smodel.SuspiciousModelHandler;
import java.util.List;
import java.util.Collection;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.openapi.application.ModalityState;
import java.util.Map;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import java.util.LinkedList;
import java.util.ArrayList;
import com.intellij.openapi.vcs.AbstractVcsHelper;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import jetbrains.mps.vcs.MPSVcsManager;

public class SuspiciousModelIndex implements ApplicationComponent {
  private final ProjectManager myProjectManager;
  private final ModelChangesWatcher myWatcher;
  private final VirtualFileManager myVirtualFileManager;
  private TaskQueue<Conflictable> myTaskQueue;

  public SuspiciousModelIndex(ProjectManager manager, ModelChangesWatcher watcher, VirtualFileManager vfManager) {
    myProjectManager = manager;
    myWatcher = watcher;
    myVirtualFileManager = vfManager;
  }

  public void addModel(DefaultSModelDescriptor model, boolean isInConflict) {
    myTaskQueue.addTask(new ConflictableModelAdapter(model, isInConflict));
  }

  public void addModule(AbstractModule abstractModule, boolean inConflict) {
    myTaskQueue.addTask(new ConflictableModuleAdapter(abstractModule, inConflict));
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "Suspicious Model Index";
  }

  public void initComponent() {
    if (MPSCore.getInstance().isTestMode()) {
      return;
    }
    myTaskQueue = new SuspiciousModelIndex.MyTaskQueue(myProjectManager, myWatcher, myVirtualFileManager);
    SuspiciousModelHandler.setHandler(new SuspiciousModelHandler() {
      public void handleSuspiciousModel(DefaultSModelDescriptor model, boolean inConflict) {
        addModel(model, inConflict);
      }

      public void handleSuspiciousModule(AbstractModule module, boolean inConflict) {
        addModule(module, inConflict);
      }
    });
  }

  public void disposeComponent() {
    if (MPSCore.getInstance().isTestMode()) {
      return;
    }
    myTaskQueue.dispose();
  }

  public void mergeModels(List<Conflictable> models) {
    final Collection<Conflictable> merged = showMergeDialog(models);
    if (merged.isEmpty()) {
      ModelChangesWatcher.instance().tryToResumeTasksProcessing();
      return;
    }
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        try {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              for (Conflictable conflictable : merged) {
                conflictable.reloadFromDisk();
              }
            }
          });
        } finally {
          ModelChangesWatcher.instance().tryToResumeTasksProcessing();
        }
      }
    }, ModalityState.NON_MODAL);
  }

  private Collection<Conflictable> showMergeDialog(List<Conflictable> conflictableList) {
    final Map<Project, List<VirtualFile>> toMerge = new HashMap<Project, List<VirtualFile>>();
    Map<VirtualFile, Conflictable> fileToConflictable = new LinkedHashMap<VirtualFile, Conflictable>();
    Set<Conflictable> toReload = new HashSet<Conflictable>();
    for (Conflictable conflictable : conflictableList) {
      IFile ifile = conflictable.getFile();
      if (isInConflict(ifile)) {
        VirtualFile vfile = VirtualFileUtils.getVirtualFile(ifile);
        Conflictable prev = fileToConflictable.put(vfile, conflictable);
        if (prev == null) {
          Project project = getProjectForFile(vfile);
          List<VirtualFile> files = toMerge.get(project);
          if (files == null) {
            files = new LinkedList<VirtualFile>();
            toMerge.put(project, files);
          }
          files.add(vfile);
        }
      } else
      if (conflictable.isConflictDetected() || conflictable.needReloading()) {
        toReload.add(conflictable);
      }
    }
    ModelChangesWatcher.instance().suspendTasksProcessing();
    for (final Project project : toMerge.keySet()) {
      final List<VirtualFile> virtualFileList = new ArrayList<VirtualFile>();
      ApplicationManager.getApplication().invokeAndWait(new Runnable() {
        public void run() {
          virtualFileList.addAll(AbstractVcsHelper.getInstance(project).showMergeDialog(toMerge.get(project)));
        }
      }, ModalityState.defaultModalityState());
      for (VirtualFile vfile : virtualFileList) {
        Conflictable conflictable = fileToConflictable.get(vfile);
        if (conflictable != null) {
          toReload.add(conflictable);
        }
      }
    }
    return toReload;
  }

  public static SuspiciousModelIndex instance() {
    return ApplicationManager.getApplication().getComponent(SuspiciousModelIndex.class);
  }

  @Nullable
  private static Project getProjectForFile(VirtualFile f) {
    for (Project project : ProjectManager.getInstance().getOpenProjects()) {
      if (project.isDisposed()) {
        continue;
      }
      if (ProjectLevelVcsManager.getInstance(project).getVcsFor(f) != null) {
        return project;
      }
    }
    return null;
  }

  private static boolean isInConflict(IFile ifile) {
    VirtualFile vfile = VirtualFileUtils.getVirtualFile(ifile);
    if ((vfile != null) && (vfile.exists())) {
      for (Project project : ProjectManager.getInstance().getOpenProjects()) {
        if (MPSVcsManager.getInstance(project).isInConflict(vfile)) {
          return true;
        }
      }
    }
    return false;
  }

  private class MyTaskQueue extends TaskQueue<Conflictable> {
    public MyTaskQueue(ProjectManager manager, ModelChangesWatcher watcher, VirtualFileManager virtualFileManager) {
      super(manager, watcher, virtualFileManager);
    }

    @Override
    protected boolean isProcessingAllowed() {
      return super.isProcessingAllowed() && !(ModelAccess.instance().canRead());
    }

    protected void processTask(final List<Conflictable> tasks) {
      mergeModels(tasks);
    }
  }
}
