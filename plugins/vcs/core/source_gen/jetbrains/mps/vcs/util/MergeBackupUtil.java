package jetbrains.mps.vcs.util;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import com.intellij.openapi.diff.DiffContent;
import com.intellij.openapi.vfs.VirtualFile;
import java.io.File;
import java.io.IOException;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.project.MPSExtentions;
import org.jetbrains.annotations.NotNull;
import java.text.SimpleDateFormat;
import java.util.Date;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.SModelRepository;
import com.intellij.util.io.ZipUtil;
import com.intellij.openapi.application.PathManager;
import java.io.FilenameFilter;
import jetbrains.mps.util.UnzipUtil;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;

public class MergeBackupUtil {
  protected static Log log = LogFactory.getLog(MergeBackupUtil.class);

  public MergeBackupUtil() {
    // Used in MergeProviderDecorator 
  }

  private static void writeContentsToFile(DiffContent contents, VirtualFile file, File tmpDir, String suffix) throws IOException {
    writeContentsToFile(new String(contents.getBytes(), FileUtil.DEFAULT_CHARSET), file.getName(), tmpDir, suffix);
  }

  public static File zipModel(DiffContent[] contents, VirtualFile file) throws IOException {
    File tmpDir = FileUtil.createTmpDir();
    writeContentsToFile(contents[MergeConstants.ORIGINAL].getDocument().getText(), file.getName(), tmpDir, MergeVersion.BASE.getSuffix());
    writeContentsToFile(contents[MergeConstants.CURRENT], file, tmpDir, MergeVersion.MINE.getSuffix());
    writeContentsToFile(contents[MergeConstants.LAST_REVISION], file, tmpDir, MergeVersion.REPOSITORY.getSuffix());
    File zipfile = chooseZipFileForModelFile(VirtualFileUtils.toIFile(file));
    zipfile.getParentFile().mkdirs();
    FileUtil.zip(tmpDir, zipfile);
    FileUtil.delete(tmpDir);
    return zipfile;
  }

  public static File zipModel(String[] contents, @Nullable SModelFqName modelFqName) throws IOException {
    String shortFileName = "unknown.mps";
    if (modelFqName != null) {
      shortFileName = NameUtil.shortNameFromLongName(modelFqName.getLongName()) + MPSExtentions.DOT_MODEL;
    }
    File tmp = FileUtil.createTmpDir();
    writeContentsToFile(contents[MergeConstants.ORIGINAL], shortFileName, tmp, MergeVersion.BASE.getSuffix());
    writeContentsToFile(contents[MergeConstants.CURRENT], shortFileName, tmp, MergeVersion.MINE.getSuffix());
    writeContentsToFile(contents[MergeConstants.LAST_REVISION], shortFileName, tmp, MergeVersion.REPOSITORY.getSuffix());
    File zipfile = chooseZipFileForModelLongName("unknown.mps", check_fhutfy_b0a6a2(modelFqName));
    zipfile.getParentFile().mkdirs();
    FileUtil.zip(tmp, zipfile);
    FileUtil.delete(tmp);
    return zipfile;
  }

  public static void writeContentsToFile(String contents, String name, File tmpDir, String suffix) throws IOException {
    File file = new File(tmpDir.getAbsolutePath() + File.separator + name + "." + suffix);
    FileUtil.writeFile(file, contents);
  }

  public static File chooseZipFileForModelLongName(@NotNull String defaultFileName, @Nullable String modelLongName) {
    String fileName = defaultFileName;
    if (modelLongName != null) {
      fileName = modelLongName + MPSExtentions.DOT_MODEL;
    }
    String prefix = getMergeBackupDirPath() + File.separator + fileName;
    prefix = prefix + "." + new SimpleDateFormat("yyyy-MM-dd_HH-mm").format(new Date());
    File zipfile = new File(prefix + ".zip");
    int i = 0;
    while (zipfile.exists()) {
      zipfile = new File(prefix + "." + i + ".zip");
      i++;
    }
    return zipfile;
  }

  public static File chooseZipFileForModelFile(IFile file) {
    return chooseZipFileForModelLongName(file.getName(), check_fhutfy_b0a0f(SModelRepository.getInstance().findModel(file)));
  }

  public static void packMergeResult(File file, String fileName, String resultContent) {
    try {
      File tmp = FileUtil.createTmpDir();
      ZipUtil.extract(file, tmp, null);
      //  copy merge result 
      FileUtil.writeFile(new File(tmp + File.separator + fileName + ".result"), resultContent);
      //  copy logfiles 
      File logsDir = new File(PathManager.getLogPath());
      File[] logfiles = logsDir.listFiles(new FilenameFilter() {
        public boolean accept(File dir, String name) {
          return name.matches("mpsvcs\\.log(\\.1)*") || name.matches("idea\\.log(\\.1)*");
        }
      });
      File tmpLogDir = new File(tmp + File.separator + "logs");
      tmpLogDir.mkdir();
      for (File logfile : logfiles) {
        FileUtil.copyFile(logfile, new File(tmpLogDir + File.separator + logfile.getName()));
      }
      FileUtil.zip(tmp, file);
      FileUtil.delete(tmp);
    } catch (IOException e) {
      if (log.isErrorEnabled()) {
        log.error("", e);
      }
    }
  }

  public static String getMergeBackupDirPath() {
    return PathManager.getSystemPath() + File.separator + "merge-backup";
  }

  @Nullable
  public static String[] loadZippedModelsAsText(File zipfile, ModelVersion[] versions) throws IOException {
    File tmpdir = FileUtil.createTmpDir();
    UnzipUtil.unzip(zipfile, tmpdir);
    String[] models = new String[versions.length];
    int index = 0;
    for (final ModelVersion v : versions) {
      File file;
      File[] files = tmpdir.listFiles(new FilenameFilter() {
        public boolean accept(File dir, String name) {
          return name.endsWith(MPSExtentions.DOT_MODEL + "." + v.getSuffix());
        }
      });
      if (files == null || files.length != 1) {
        if (log.isErrorEnabled()) {
          log.error("Wrong zip contents");
        }
      }
      file = files[0];
      char[] fileText = com.intellij.openapi.util.io.FileUtil.loadFileText(file);
      models[index] = new String(fileText);
      index++;
    }
    FileUtil.delete(tmpdir);
    return models;
  }

  @Nullable
  public static SModel[] loadZippedModels(File zipfile, ModelVersion[] versions) throws IOException, ModelReadException {
    String[] modelsAsText = loadZippedModelsAsText(zipfile, versions);
    if (modelsAsText == null) {
      return null;
    }
    SModel[] models = new SModel[modelsAsText.length];
    for (int i = 0; i < models.length; i++) {
      models[i] = ModelPersistence.readModel(modelsAsText[i], false);
    }
    return models;
  }

  public static Iterable<File> findZipFilesForModelFile(final String modelFileName) {
    File[] files = new File(MergeBackupUtil.getMergeBackupDirPath()).listFiles(new FilenameFilter() {
      public boolean accept(File dir, String name) {
        return name.contains(modelFileName) && name.endsWith(".zip");
      }
    });
    return Sequence.fromIterable(Sequence.fromArray(files)).sort(new ISelector<File, Comparable<?>>() {
      public Comparable<?> select(File f) {
        return f.getName();
      }
    }, false);
  }

  private static String check_fhutfy_b0a6a2(SModelFqName checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getLongName();
    }
    return null;
  }

  private static String check_fhutfy_b0a0f(EditableSModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getLongName();
    }
    return null;
  }
}
