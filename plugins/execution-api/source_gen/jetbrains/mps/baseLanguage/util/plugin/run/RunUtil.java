package jetbrains.mps.baseLanguage.util.plugin.run;

/*Generated by MPS */

import jetbrains.mps.util.annotation.ToRemove;
import com.intellij.openapi.project.Project;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.generator.ModelGenerationStatusManager;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.make.IMakeService;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.resources.ModelsToResources;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

/**
 * In run configurations to be replaced with "Make" before task
 * Any usages of this class should be inlined in the code.
 */
@Deprecated
@ToRemove(version = 3.0)
public class RunUtil {
  @Deprecated
  public RunUtil() {
  }

  public static boolean makeBeforeRun(Project project, final List<SNode> nodes) {
    if (ThreadUtils.isEventDispatchThread()) {
      throw new RuntimeException("Can't run make from the event dispatch thread");
    }

    final Wrappers._T<List<SModel>> descriptors = new Wrappers._T<List<SModel>>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        descriptors.value = ListSequence.fromListWithValues(new ArrayList<SModel>(), ListSequence.fromList(nodes).select(new ISelector<SNode, SModel>() {
          public SModel select(SNode it) {
            return (SModel) SNodeOperations.getModel(it);
          }
        }).distinct().where(new IWhereFilter<SModel>() {
          public boolean accept(SModel it) {
            return ModelGenerationStatusManager.getInstance().generationRequired(it);
          }
        }));
      }
    });

    if (ListSequence.fromList(descriptors.value).isEmpty()) {
      return true;
    }

    MakeSession session = new MakeSession(new ProjectOperationContext(ProjectHelper.toMPSProject(project)), null, true);
    if (IMakeService.INSTANCE.get().openNewSession(session)) {
      Future<IResult> future = IMakeService.INSTANCE.get().make(session, new ModelsToResources(new ProjectOperationContext(ProjectHelper.toMPSProject(project)), descriptors.value).resources(false));
      IResult result = null;
      try {
        result = future.get();
      } catch (CancellationException ignore) {
      } catch (InterruptedException ignore) {
      } catch (ExecutionException ignore) {
      }
      return result != null && result.isSucessful();
    }
    return true;
  }
}
