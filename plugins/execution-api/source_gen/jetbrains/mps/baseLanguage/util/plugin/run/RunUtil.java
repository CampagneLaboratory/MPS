package jetbrains.mps.baseLanguage.util.plugin.run;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.generator.ModelGenerationStatusManager;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.make.IMakeService;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.resources.ModelsToResources;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

/**
 * In run configurations to be replaced with "Make" before task
 * and in Make before task with something
 */
@Deprecated
public class RunUtil {
  @Deprecated
  public RunUtil() {
  }

  public static boolean makeBeforeRun(Project project, SNode... nodes) {
    return makeBeforeRun(project, Sequence.fromIterable(Sequence.fromArray(nodes)).toListSequence());
  }

  public static boolean makeBeforeRun(Project project, final List<SNode> nodes) {
    if (ThreadUtils.isEventDispatchThread()) {
      throw new RuntimeException("Can't run make from the event dispatch thread");
    }

    final Wrappers._T<List<SModel>> descriptors = new Wrappers._T<List<SModel>>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        descriptors.value = ListSequence.fromListWithValues(new ArrayList<SModel>(), ListSequence.fromList(nodes).select(new ISelector<SNode, SModelDescriptor>() {
          public SModelDescriptor select(SNode it) {
            return SNodeOperations.getModel(it).getModelDescriptor();
          }
        }).distinct().where(new IWhereFilter<SModelDescriptor>() {
          public boolean accept(SModelDescriptor it) {
            return ModelGenerationStatusManager.getInstance().generationRequired(it);
          }
        }));
      }
    });
    return makeModels(project, descriptors.value);
  }

  public static boolean makePointersBeforeRun(Project project, List<SNodeReference> nodes) {
    if (ThreadUtils.isEventDispatchThread()) {
      throw new RuntimeException("Can't run make from the event dispatch thread");
    }
    return makeModels(project, ListSequence.fromListWithValues(new ArrayList<SModel>(), ListSequence.fromList(nodes).where(new IWhereFilter<SNodeReference>() {
      public boolean accept(SNodeReference it) {
        return it != null;
      }
    }).select(new ISelector<SNodeReference, SModelDescriptor>() {
      public SModelDescriptor select(SNodeReference it) {
        return ((SNodePointer) it).getModel();
      }
    }).distinct().where(new IWhereFilter<SModelDescriptor>() {
      public boolean accept(SModelDescriptor it) {
        return ModelGenerationStatusManager.getInstance().generationRequired(it);
      }
    })));
  }

  private static boolean makeModels(Project project, Iterable<SModel> models) {
    if (Sequence.fromIterable(models).isEmpty()) {
      return true;
    }

    MakeSession session = new MakeSession(new ProjectOperationContext(ProjectHelper.toMPSProject(project)), null, true);
    if (IMakeService.INSTANCE.get().openNewSession(session)) {
      Future<IResult> future = IMakeService.INSTANCE.get().make(session, new ModelsToResources(new ProjectOperationContext(ProjectHelper.toMPSProject(project)), models).resources(false));
      IResult result = null;
      try {
        result = future.get();
      } catch (CancellationException ignore) {
      } catch (InterruptedException ignore) {
      } catch (ExecutionException ignore) {
      }
      return result != null && result.isSucessful();
    }
    return true;
  }
}
