package jetbrains.mps.lang.editor.figures.sandbox;

/*Generated by MPS */

import jetbrains.jetpad.projectional.view.GroupView;
import jetbrains.jetpad.projectional.diagram.base.GridDirection;
import jetbrains.jetpad.projectional.view.RectView;
import jetbrains.jetpad.projectional.cell.view.CellView;
import jetbrains.jetpad.projectional.cell.TextCell;
import jetbrains.jetpad.model.property.Property;
import jetbrains.jetpad.model.property.ValueProperty;
import jetbrains.jetpad.model.collections.list.ObservableList;
import jetbrains.jetpad.model.collections.list.ObservableArrayList;
import jetbrains.jetpad.projectional.view.ViewPropertySpec;
import jetbrains.jetpad.geometry.Vector;
import jetbrains.jetpad.projectional.view.ViewPropertyKind;
import jetbrains.jetpad.values.Color;
import jetbrains.jetpad.projectional.cell.support.TextEditing;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.mapper.Synchronizers;
import jetbrains.jetpad.mapper.MapperFactory;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.jetpad.projectional.diagram.view.RootTrait;
import jetbrains.jetpad.projectional.diagram.view.MoveHandler;
import jetbrains.jetpad.geometry.Rectangle;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.nodeEditor.cells.jetpad.BlockViewPortLayouter;
import java.util.Iterator;
import jetbrains.mps.nodeEditor.cells.jetpad.ConnectionPointView;

public class BlockInstanceView extends GroupView {
  private GridDirection myDir = GridDirection.RIGHT;

  public GroupView inputs = new GroupView();
  public GroupView outputs = new GroupView();
  private RectView myRectView;
  private CellView myCellView;
  private TextCell myTextCell;
  public Property<Integer> x = new ValueProperty<Integer>(0);
  public Property<Integer> y = new ValueProperty<Integer>(0);
  public Property<String> text = new ValueProperty<String>("");
  public ObservableList<String> inputPortNames = new ObservableArrayList<String>();
  public ObservableList<String> outputPortNames = new ObservableArrayList<String>();
  /*package*/ static final ViewPropertySpec<Vector> MINIMAL_SIZE = new ViewPropertySpec<Vector>("minimalSize", ViewPropertyKind.RELAYOUT, new Vector(75, 75));



  public BlockInstanceView() {
    children().add(inputs);
    children().add(outputs);
    children().add(myRectView = createRectView());
    children().add(myCellView = createCellView());

    initSynchronizers();
    initMoveFeedbackHandler();
  }

  private RectView createRectView() {
    RectView rectView = new RectView();
    rectView.background().set(Color.LIGHT_GRAY);
    rectView.dimension().set(new Vector(75, 75));
    return rectView;
  }

  private CellView createCellView() {
    CellView cellView = new CellView(new GroupView());
    myTextCell = new TextCell();
    myTextCell.addTrait(TextEditing.textEditing());
    cellView.cell.set(myTextCell);
    return cellView;
  }

  private void initSynchronizers() {
    new Mapper<BlockInstanceView, BlockInstanceView>(this, this) {


      @Override
      protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
        configuration.add(Synchronizers.forProperty(getSource().x, new Runnable() {
          public void run() {
            getTarget().moveTo(new Vector(getSource().x.get(), getSource().y.get()));
            BlockInstanceView.this.invalidate();
          }
        }));
        configuration.add(Synchronizers.forProperty(getSource().y, new Runnable() {
          public void run() {
            getTarget().moveTo(new Vector(getSource().x.get(), getSource().y.get()));
            BlockInstanceView.this.invalidate();
          }
        }));


        configuration.add(Synchronizers.forProperties(getSource().text, getSource().myTextCell.text()));

        configuration.add(Synchronizers.forObservableRole(this, getSource().inputPortNames, getTarget().inputs.children(), new MapperFactory<String, View>() {
          public Mapper<? extends String, ? extends View> createMapper(String inputName) {
            return new BlockInstanceView.PortMapper(inputName, Color.LIGHT_MAGENTA);
          }
        }));
        configuration.add(Synchronizers.forObservableRole(this, getSource().outputPortNames, getTarget().outputs.children(), new MapperFactory<String, View>() {
          public Mapper<? extends String, ? extends View> createMapper(String inputName) {
            return new BlockInstanceView.PortMapper(inputName, Color.LIGHT_BLUE);
          }
        }));
      }
    }.attachRoot();
  }

  private void initMoveFeedbackHandler() {
    this.prop(RootTrait.MOVE_HANDLER).set(new MoveHandler() {
      public void move(Vector delta) {
        x.set(x.get() + delta.x);
        y.set(y.get() + delta.y);
      }
    });
  }

  public Property<Vector> dimension() {
    return myRectView.dimension();
  }

  @Override
  protected void doValidate(View.ValidationContext context) {
    super.doValidate(context);
    Rectangle labelRect = myCellView.bounds().get();
    myRectView.dimension().set(prop(MINIMAL_SIZE).get().max(labelRect.dimension));
    layoutPorts(inputs.children(), myDir.opposite());
    layoutPorts(outputs.children(), myDir);
    super.doValidate(context);
  }

  private void layoutPorts(List<View> views, GridDirection dir) {
    List<Vector> viewDimensions = new ArrayList<Vector>(views.size());
    for (View v : views) {
      viewDimensions.add(v.bounds().get().dimension);
    }
    Rectangle bounds = new Rectangle(myRectView.bounds().get().origin, myRectView.dimension().get());
    List<Vector> viewOrigins = new BlockViewPortLayouter(bounds).layoutPorts(viewDimensions, dir);
    Iterator<Vector> originIter = viewOrigins.iterator();
    for (View v : views) {
      v.moveTo(originIter.next());
    }
  }



  private class PortMapper extends Mapper<String, ConnectionPointView> {
    private PortMapper(String name, Color color) {
      super(name, new ConnectionPointView());
      getTarget().prop(ConnectionPointView.ID).set(name);
      RectView rectangle = new RectView();
      getTarget().children().add(rectangle);
      rectangle.background().set(color);
      rectangle.dimension().set(new Vector(10, 10));
    }
  }
}
