package jetbrains.mps.lang.editor.figures.sandbox;

/*Generated by MPS */

import jetbrains.jetpad.projectional.view.PolygonView;
import jetbrains.mps.lang.editor.diagram.runtime.jetpad.views.ResizableContentView;
import jetbrains.jetpad.projectional.view.PolyLineView;
import jetbrains.jetpad.cell.TextCell;
import jetbrains.jetpad.projectional.view.TextView;
import jetbrains.jetpad.model.property.Property;
import jetbrains.jetpad.model.property.ValueProperty;
import jetbrains.jetpad.values.Color;
import jetbrains.jetpad.cell.view.CellView;
import jetbrains.jetpad.cell.text.TextEditing;
import jetbrains.jetpad.projectional.view.RectView;
import jetbrains.jetpad.geometry.Vector;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.mapper.Synchronizers;
import jetbrains.jetpad.model.property.WritableProperty;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.jetpad.geometry.Rectangle;

public class PolygonContentView extends PolygonView implements ResizableContentView {
  private static final int FOLDING_SIZE = 6;
  private static final int WIDTH = 40;
  private static final int HEIGHT = 50;
  private PolyLineView myPolyLine = new PolyLineView();
  private TextCell myCell = new TextCell();
  private TextView myMetaText = new TextView();
  public Property<Integer> contentWidth = new ValueProperty<Integer>(WIDTH);
  public Property<Integer> contentHeight = new ValueProperty<Integer>(HEIGHT);

  public PolygonContentView() {
    color().set(Color.LIGHT_BLUE);
    children().add(myPolyLine);
    CellView myCellView = new CellView();
    myCell.addTrait(TextEditing.textEditing());
    myCell.textColor().set(Color.GRAY);
    myCellView.cell.set(myCell);
    children().add(myCellView);
    RectView space = new RectView();
    space.background().set(Color.LIGHT_BLUE);
    space.dimension().set(new Vector(0, 5));
    children().add(space);
    myMetaText.bold().set(true);
    children().add(myMetaText);
    initPoints();
    new Mapper<PolygonContentView, PolygonContentView>(this, this) {
      @Override
      protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
        super.registerSynchronizers(configuration);
        configuration.add(Synchronizers.forProperty(contentWidth, new Runnable() {
          public void run() {
            adjustPoints(contentWidth.get(), contentHeight.get());
          }
        }));
        configuration.add(Synchronizers.forProperty(contentWidth, new WritableProperty<Integer>() {
          public void set(Integer value) {
            setPreferredSize(value, null);
          }
        }));
        configuration.add(Synchronizers.forProperty(contentHeight, new Runnable() {
          public void run() {
            adjustPoints(contentWidth.get(), contentHeight.get());
          }
        }));
        configuration.add(Synchronizers.forProperty(contentHeight, new WritableProperty<Integer>() {
          public void set(Integer value) {
            setPreferredSize(null, value);
          }
        }));
      }
    }.attachRoot();
  }

  @Override
  protected void doValidate(View.ValidationContext context) {
    super.doValidate(context);
    Vector prefSize = prop(PREFERRED_SIZE).get();
    int width = prefSize.x;
    int height = FOLDING_SIZE;
    for (View nextChild : ListSequence.fromList(children())) {
      if (nextChild == myPolyLine || !((nextChild.visible().get()))) {
        continue;
      }
      Rectangle childBounds = nextChild.bounds().get();
      width = Math.max(width, childBounds.dimension.x + FOLDING_SIZE);
      height += childBounds.dimension.y;
    }
    if (height < prefSize.y) {
      height = prefSize.y;
    }
    int yOffset = bounds().get().origin.y + FOLDING_SIZE / 2;
    int xOrigin = bounds().get().origin.x;
    for (View nextChild : ListSequence.fromList(children())) {
      if (nextChild == myPolyLine || !((nextChild.visible().get()))) {
        continue;
      }
      Rectangle childBounds = nextChild.bounds().get();
      nextChild.moveTo(new Vector(xOrigin + (width - childBounds.dimension.x) / 2, yOffset));
      yOffset += childBounds.dimension.y;
    }
    contentWidth.set(width);
    contentHeight.set(height);
    if (!(myPolyLine.valid().get())) {
      // Calling super.doValidate() once again because myPolyLine can be invalidated as a result of setting 
      // myPreferredSize property 
      super.validate();
    }
  }

  private void initPoints() {
    points.add(new Vector(FOLDING_SIZE, 0));
    points.add(new Vector(WIDTH, 0));
    points.add(new Vector(WIDTH, HEIGHT));
    points.add(new Vector(0, HEIGHT));
    points.add(new Vector(0, FOLDING_SIZE));
    points.add(new Vector(FOLDING_SIZE, 0));

    myPolyLine.points.add(new Vector(FOLDING_SIZE, 0));
    myPolyLine.points.add(new Vector(WIDTH, 0));
    myPolyLine.points.add(new Vector(WIDTH, HEIGHT));
    myPolyLine.points.add(new Vector(0, HEIGHT));
    myPolyLine.points.add(new Vector(0, FOLDING_SIZE));
    myPolyLine.points.add(new Vector(FOLDING_SIZE, 0));
  }

  private void adjustPoints(int width, int height) {
    points.set(1, new Vector(width, 0).add(getBounds().origin));
    points.set(2, new Vector(width, height).add(getBounds().origin));
    points.set(3, new Vector(0, height).add(getBounds().origin));

    myPolyLine.points.set(1, new Vector(width, 0).add(myPolyLine.getBounds().origin));
    myPolyLine.points.set(2, new Vector(width, height).add(myPolyLine.getBounds().origin));
    myPolyLine.points.set(3, new Vector(0, height).add(myPolyLine.getBounds().origin));
  }

  public Property<String> text() {
    return myCell.text();
  }

  public Property<String> metaText() {
    return myMetaText.text();
  }

  private void setPreferredSize(Integer width, Integer height) {
    assert width != null || height != null;
    Vector prefSize = prop(ResizableContentView.PREFERRED_SIZE).get();
    int x = (width != null ? width : (prefSize != null ? prefSize.x : 0));
    int y = (height != null ? height : (prefSize != null ? prefSize.y : 0));
    prop(ResizableContentView.PREFERRED_SIZE).set(new Vector(x, y));
  }
}
