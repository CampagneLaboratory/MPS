package jetbrains.mps.lang.editor.figures.sandbox;

/*Generated by MPS */

import jetbrains.jetpad.projectional.view.PolygonView;
import jetbrains.jetpad.projectional.view.PolyLineView;
import jetbrains.jetpad.model.property.Property;
import jetbrains.jetpad.geometry.Vector;
import jetbrains.jetpad.model.property.ValueProperty;
import jetbrains.jetpad.cell.TextCell;
import jetbrains.jetpad.projectional.view.TextView;
import jetbrains.jetpad.values.Color;
import jetbrains.jetpad.cell.view.CellView;
import jetbrains.jetpad.cell.text.TextEditing;
import jetbrains.jetpad.projectional.view.RectView;
import jetbrains.jetpad.model.event.EventHandler;
import jetbrains.jetpad.model.property.PropertyChangeEvent;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.jetpad.geometry.Rectangle;

public class PolygonContentView extends PolygonView {
  private static final int FOLDING_SIZE = 6;
  private static final int WIDTH = 40;
  private static final int HEIGHT = 50;
  private PolyLineView myPolyLine = new PolyLineView();
  private Property<Vector> myPreferredSize = new ValueProperty<Vector>(new Vector(0, 0));
  private TextCell myCell = new TextCell();
  private TextView myMetaText = new TextView();

  public PolygonContentView() {
    color().set(Color.LIGHT_BLUE);
    children().add(myPolyLine);
    CellView myCellView = new CellView();
    myCell.addTrait(TextEditing.textEditing());
    myCell.textColor().set(Color.GRAY);
    myCellView.cell.set(myCell);
    children().add(myCellView);
    RectView space = new RectView();
    space.background().set(Color.LIGHT_BLUE);
    space.dimension().set(new Vector(0, 5));
    children().add(space);
    myMetaText.bold().set(true);
    children().add(myMetaText);
    myPreferredSize.addHandler(new EventHandler<PropertyChangeEvent<Vector>>() {
      public void onEvent(PropertyChangeEvent<Vector> event) {
        adjustPoints(event.getNewValue().x, event.getNewValue().y);
      }
    });
    initSynchronizers();
  }

  private void initSynchronizers() {
    new Mapper<PolygonContentView, PolygonContentView>(this, this) {
      @Override
      protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
        super.registerSynchronizers(configuration);
      }
    }.attachRoot();
  }

  @Override
  protected void doValidate(View.ValidationContext context) {
    super.doValidate(context);
    int width = WIDTH;
    int height = FOLDING_SIZE;
    for (View nextChild : ListSequence.fromList(children())) {
      if (nextChild == myPolyLine || !((nextChild.visible().get()))) {
        continue;
      }
      Rectangle childBounds = nextChild.bounds().get();
      width = Math.max(width, childBounds.dimension.x + FOLDING_SIZE);
      height += childBounds.dimension.y;
    }
    if (height < HEIGHT) {
      height = HEIGHT;
    }
    int yOffset = bounds().get().origin.y + FOLDING_SIZE / 2;
    int xOrigin = bounds().get().origin.x;
    for (View nextChild : ListSequence.fromList(children())) {
      if (nextChild == myPolyLine || !((nextChild.visible().get()))) {
        continue;
      }
      Rectangle childBounds = nextChild.bounds().get();
      nextChild.moveTo(new Vector(xOrigin + (width - childBounds.dimension.x) / 2, yOffset));
      yOffset += childBounds.dimension.y;
    }
    myPreferredSize.set(new Vector(width, height));
    if (!(myPolyLine.valid().get())) {
      // Calling super.doValidate() once again because myPolyLine can be invalidated as a result of setting 
      // myPreferredSize property 
      super.doValidate(context);
    }
  }

  private void adjustPoints(int width, int height) {
    points.clear();
    points.add(new Vector(FOLDING_SIZE, 0));
    points.add(new Vector(width, 0));
    points.add(new Vector(width, height));
    points.add(new Vector(0, height));
    points.add(new Vector(0, FOLDING_SIZE));
    points.add(new Vector(FOLDING_SIZE, 0));
    myPolyLine.points.clear();
    myPolyLine.points.add(new Vector(FOLDING_SIZE, 0));
    myPolyLine.points.add(new Vector(width, 0));
    myPolyLine.points.add(new Vector(width, height));
    myPolyLine.points.add(new Vector(0, height));
    myPolyLine.points.add(new Vector(0, FOLDING_SIZE));
    myPolyLine.points.add(new Vector(FOLDING_SIZE, 0));
  }

  @Override
  protected Rectangle calculateBounds() {
    // TODO: remove this method (bug in JetPad) 
    Vector min = null;
    Vector max = null;

    for (Vector p : points) {
      min = (min == null ? p : min.min(p));
      max = (max == null ? p : max.max(p));
    }

    if (min == null) {
      return null;
    } else {
      return new Rectangle(min, max.sub(min));
    }
  }

  public Property<String> text() {
    return myCell.text();
  }

  public Property<String> metaText() {
    return myMetaText.text();
  }
}
