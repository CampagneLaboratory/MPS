package jetbrains.mps.lang.editor.figures.sandbox;

/*Generated by MPS */

import jetbrains.jetpad.projectional.view.PolygonView;
import jetbrains.jetpad.projectional.view.PolyLineView;
import jetbrains.jetpad.cell.TextCell;
import jetbrains.jetpad.projectional.view.TextView;
import jetbrains.jetpad.model.property.Property;
import jetbrains.jetpad.model.property.ValueProperty;
import jetbrains.mps.nodeEditor.cells.jetpad.JetpadUtils;
import jetbrains.jetpad.geometry.Vector;
import jetbrains.jetpad.values.Color;
import jetbrains.jetpad.cell.view.CellView;
import jetbrains.jetpad.cell.text.TextEditing;
import jetbrains.jetpad.projectional.view.RectView;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.mapper.Synchronizers;
import jetbrains.jetpad.model.property.WritableProperty;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.jetpad.geometry.Rectangle;

public class PolygonContentView extends PolygonView {
  private static final int FOLDING_SIZE = 6;
  private static final int WIDTH = 40;
  private static final int HEIGHT = 50;
  private PolyLineView myPolyLine = new PolyLineView();
  private TextCell myCell = new TextCell();
  private TextView myMetaText = new TextView();
  private Property<Integer> myModelWidth = new ValueProperty<Integer>();
  private Property<Integer> myModelHeight = new ValueProperty<Integer>();

  public PolygonContentView() {
    prop(JetpadUtils.PREFERRED_SIZE).set(new Vector(WIDTH, HEIGHT));
    color().set(Color.LIGHT_BLUE);
    children().add(myPolyLine);
    CellView myCellView = new CellView();
    myCell.addTrait(TextEditing.textEditing());
    myCell.textColor().set(Color.GRAY);
    myCellView.cell.set(myCell);
    children().add(myCellView);
    RectView space = new RectView();
    space.background().set(Color.LIGHT_BLUE);
    space.dimension().set(new Vector(0, 5));
    children().add(space);
    myMetaText.bold().set(true);
    children().add(myMetaText);
    new Mapper<PolygonContentView, PolygonContentView>(this, this) {
      @Override
      protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
        super.registerSynchronizers(configuration);
        configuration.add(Synchronizers.forProperty(myModelWidth, new WritableProperty<Integer>() {
          public void set(Integer value) {
            if (value == null) {
              return;
            }
            Property<Vector> prop = prop(JetpadUtils.PREFERRED_SIZE);
            int x = value;
            int y = (prop.get() != null ? prop.get().y : 0);
            prop.set(new Vector(x, y));
          }
        }));
        configuration.add(Synchronizers.forProperty(myModelHeight, new WritableProperty<Integer>() {
          public void set(Integer value) {
            if (value == null) {
              return;
            }
            Property<Vector> prop = prop(JetpadUtils.PREFERRED_SIZE);
            int x = (prop.get() != null ? prop.get().x : 0);
            int y = value;
            prop.set(new Vector(x, y));
          }
        }));
        configuration.add(Synchronizers.forProperty(prop(JetpadUtils.PREFERRED_SIZE), new WritableProperty<Vector>() {
          public void set(Vector prefSize) {
            myModelWidth.set(prefSize.x);
            myModelHeight.set(prefSize.y);
          }
        }));
        configuration.add(Synchronizers.forProperty(prop(JetpadUtils.PREFERRED_SIZE), new WritableProperty<Vector>() {
          public void set(Vector prefSize) {
            adjustPoints(prefSize.x, prefSize.y);
          }
        }));
      }
    }.attachRoot();
  }

  @Override
  protected void doValidate(View.ValidationContext context) {
    super.doValidate(context);
    Vector prefSize = prop(JetpadUtils.PREFERRED_SIZE).get();
    int width = prefSize.x;
    int height = FOLDING_SIZE;
    for (View nextChild : ListSequence.fromList(children())) {
      if (nextChild == myPolyLine || !((nextChild.visible().get()))) {
        continue;
      }
      Rectangle childBounds = nextChild.bounds().get();
      width = Math.max(width, childBounds.dimension.x + FOLDING_SIZE);
      height += childBounds.dimension.y;
    }
    if (height < prefSize.y) {
      height = prefSize.y;
    }
    int yOffset = bounds().get().origin.y + FOLDING_SIZE / 2;
    int xOrigin = bounds().get().origin.x;
    for (View nextChild : ListSequence.fromList(children())) {
      if (nextChild == myPolyLine || !((nextChild.visible().get()))) {
        continue;
      }
      Rectangle childBounds = nextChild.bounds().get();
      nextChild.moveTo(new Vector(xOrigin + (width - childBounds.dimension.x) / 2, yOffset));
      yOffset += childBounds.dimension.y;
    }
    prop(JetpadUtils.PREFERRED_SIZE).set(new Vector(width, height));
    if (!(myPolyLine.valid().get())) {
      // Calling super.doValidate() once again because myPolyLine can be invalidated as a result of setting 
      // myPreferredSize property 
      super.validate();
    }
  }

  private void adjustPoints(int width, int height) {
    points.clear();
    points.add(new Vector(FOLDING_SIZE, 0));
    points.add(new Vector(width, 0));
    points.add(new Vector(width, height));
    points.add(new Vector(0, height));
    points.add(new Vector(0, FOLDING_SIZE));
    points.add(new Vector(FOLDING_SIZE, 0));
    myPolyLine.points.clear();
    myPolyLine.points.add(new Vector(FOLDING_SIZE, 0));
    myPolyLine.points.add(new Vector(width, 0));
    myPolyLine.points.add(new Vector(width, height));
    myPolyLine.points.add(new Vector(0, height));
    myPolyLine.points.add(new Vector(0, FOLDING_SIZE));
    myPolyLine.points.add(new Vector(FOLDING_SIZE, 0));
  }

  public Property<String> text() {
    return myCell.text();
  }

  public Property<String> metaText() {
    return myMetaText.text();
  }

  public Property<Integer> modelWidth() {
    return myModelWidth;
  }

  public Property<Integer> modelHeight() {
    return myModelHeight;
  }
}
