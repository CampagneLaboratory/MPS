package jetbrains.mps.testHybridEditor.diagram.editor;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.jetpad.AbstractJetpadEditor;
import java.util.Collection;
import java.util.Collections;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.nodeEditor.cells.jetpad.BlockCell;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.mps.nodeEditor.cells.jetpad.mappers.MPSBlockMapper;
import jetbrains.jetpad.mapper.Synchronizers;
import jetbrains.mps.nodeEditor.cells.jetpad.model.MPSBlock;
import jetbrains.jetpad.mapper.MapperFactory;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.jetpad.geometry.Vector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.nodeEditor.cells.jetpad.InputPortCell;
import jetbrains.mps.nodeEditor.cells.jetpad.OutputPortCell;
import jetbrains.mps.diagram.layoutView.CenterVerticalLayoutView;
import jetbrains.jetpad.projectional.view.TextView;
import jetbrains.jetpad.projectional.view.RectView;
import jetbrains.jetpad.values.Color;

public class BlockEditor extends AbstractJetpadEditor {
  @Override
  public Collection<String> getContextHints() {
    return Collections.singletonList("jetbrains.mps.testHybridEditor.editor.HybridHints.diagram");
  }

  @Override
  public EditorCell createEditorCell(EditorContext context, SNode node) {
    BlockCell blockCell = new BlockCell(context, node) {
      public void registerAditionalSynchronizers(Mapper.SynchronizersConfiguration configuration, MPSBlockMapper mapper) {
        configuration.add(Synchronizers.forConstantRole(mapper, (MPSBlock) mapper.getSource(), mapper.getTarget().contentView.children(), new MapperFactory<MPSBlock, View>() {
          public Mapper<? extends MPSBlock, ? extends View> createMapper(MPSBlock block) {
            return new BlockEditor.ContentMapper(block);
          }
        }));
      }
    };
    blockCell.getBlock().location.set(new Vector(SPropertyOperations.getInteger(node, "x"), SPropertyOperations.getInteger(node, "y")));

    createInputPorts(context, node, blockCell);
    createOutputPorts(context, node, blockCell);
    blockCell.setBig(true);

    return blockCell;
  }

  private void createInputPorts(EditorContext context, SNode node, BlockCell blockCell) {
    for (SNode port : ListSequence.fromList(SLinkOperations.getTargets(node, "inputPorts", true))) {
      InputPortCell portCell = (InputPortCell) context.createNodeCell(port);
      blockCell.addEditorCell(portCell);
      blockCell.getBlock().inputs.add(portCell.getPort());
    }
  }

  private void createOutputPorts(EditorContext context, SNode node, BlockCell blockCell) {
    for (SNode port : ListSequence.fromList(SLinkOperations.getTargets(node, "outputPorts", true))) {
      OutputPortCell portCell = (OutputPortCell) context.createNodeCell(port);
      blockCell.addEditorCell(portCell);
      blockCell.getBlock().outputs.add(portCell.getPort());
    }
  }



  private class ContentMapper extends Mapper<MPSBlock, BlockEditor.ContentView> {
    private ContentMapper(MPSBlock block) {
      super(block, new BlockEditor.ContentView());
    }



    @Override
    protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
      super.registerSynchronizers(configuration);

      configuration.add(Synchronizers.forProperty(stringProperty(getSource().getBlockCell().getSNode(), "name"), getTarget().label.text()));
    }
  }



  private class ContentView extends CenterVerticalLayoutView {
    private TextView label = new TextView();
    private RectView rect = new RectView();

    private ContentView() {
      background().set(Color.DARK_BLUE);
      children().add(label);
      children().add(rect);
      rect.background().set(Color.CYAN);
      rect.dimension().set(new Vector(100, 20));
    }
  }
}
