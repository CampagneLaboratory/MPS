package jetbrains.mps.testHybridEditor.diagram.editor;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.jetpad.AbstractJetpadEditor;
import java.util.Collection;
import java.util.Collections;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.nodeEditor.cells.jetpad.BlockCell;
import jetbrains.mps.nodeEditor.cells.jetpad.WritableModelProperty;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.jetpad.model.property.ReadableProperty;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.projectional.diagram.view.DiagramNodeView;
import jetbrains.mps.diagram.dataflow.view.BlockView;
import jetbrains.jetpad.mapper.Synchronizers;
import jetbrains.jetpad.geometry.Vector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.jetpad.mapper.MapperFactory;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.mps.nodeEditor.cells.jetpad.InputPortCell;
import jetbrains.mps.nodeEditor.cells.jetpad.OutputPortCell;
import jetbrains.jetpad.values.Color;
import jetbrains.jetpad.projectional.diagram.view.RootTrait;
import jetbrains.jetpad.projectional.diagram.view.MoveHandler;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.diagram.layoutView.CenterVerticalLayoutView;
import jetbrains.jetpad.projectional.view.TextView;
import jetbrains.jetpad.projectional.view.RectView;

public class BlockEditor extends AbstractJetpadEditor {
  @Override
  public Collection<String> getContextHints() {
    return Collections.singletonList("jetbrains.mps.testHybridEditor.editor.HybridHints.diagram");
  }

  @Override
  public EditorCell createEditorCell(final EditorContext context, final SNode node) {
    final BlockCell blockCell = new BlockCell(context, node) {
      private final WritableModelProperty<Integer> myXPropery = new WritableModelProperty<Integer>(getCellId() + "_" + node.getNodeId().toString(), getContext().getOperationContext().getProject()) {
        protected Integer getModelPropertyValue() {
          return SPropertyOperations.getInteger(node, "x");
        }

        protected void setModelPropertyValue(Integer x) {
          SPropertyOperations.set(node, "x", "" + (x));
        }
      };
      private final WritableModelProperty<Integer> myYPropery = new WritableModelProperty<Integer>(getCellId() + "_" + node.getNodeId().toString(), getContext().getOperationContext().getProject()) {
        protected Integer getModelPropertyValue() {
          return SPropertyOperations.getInteger(node, "y");
        }

        protected void setModelPropertyValue(Integer y) {
          SPropertyOperations.set(node, "y", "" + (y));
        }
      };

      public ReadableProperty<Integer> getXProperty() {
        return myXPropery;
      }

      public ReadableProperty<Integer> getYProperty() {
        return myYPropery;
      }

      protected void initPorts() {
      }

      public Mapper<SNode, DiagramNodeView> createMapper() {
        final BlockCell bc = this;
        final Mapper<SNode, DiagramNodeView> mapper = new Mapper<SNode, DiagramNodeView>(node, new BlockView()) {
          @Override
          protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
            super.registerSynchronizers(configuration);
            configuration.add(Synchronizers.forProperty(bc.getXProperty(), new Runnable() {
              public void run() {
                getTarget().moveTo(new Vector(bc.getXProperty().get(), bc.getYProperty().get()));
                getTarget().invalidate();
              }
            }));
            configuration.add(Synchronizers.forProperty(bc.getYProperty(), new Runnable() {
              public void run() {
                getTarget().moveTo(new Vector(bc.getXProperty().get(), bc.getYProperty().get()));
                getTarget().invalidate();
              }
            }));
            configuration.add(Synchronizers.forSimpleRole(this, SLinkOperations.getTargets(node, "inputPorts", true), getTarget().inputs.children(), new MapperFactory<SNode, View>() {
              public Mapper<? extends SNode, ? extends View> createMapper(SNode mapperNode) {
                EditorCell portCell = context.createNodeCell(mapperNode);
                if (portCell instanceof InputPortCell) {
                  addEditorCell(portCell);
                  return ((InputPortCell) portCell).getMapper();
                }
                return null;
              }
            }));
            configuration.add(Synchronizers.forSimpleRole(this, SLinkOperations.getTargets(node, "outputPorts", true), getTarget().outputs.children(), new MapperFactory<SNode, View>() {
              public Mapper<? extends SNode, ? extends View> createMapper(SNode maperNode) {
                EditorCell portCell = context.createNodeCell(maperNode);
                if (portCell instanceof OutputPortCell) {
                  addEditorCell(portCell);
                  return ((OutputPortCell) portCell).getMapper();
                }
                return null;
              }
            }));

            configuration.add(Synchronizers.forConstantRole(this, getSource(), getTarget().contentView.children(), new MapperFactory<SNode, View>() {
              public Mapper<? extends SNode, ? extends View> createMapper(SNode block) {
                return new BlockEditor.ContentMapper(block);
              }
            }));
          }
        };
        DiagramNodeView view = mapper.getTarget();
        view.rect.background().set(Color.BLACK);
        view.padding().set(0);
        mapper.getTarget().rect.prop(RootTrait.MOVE_HANDLER).set(new MoveHandler() {
          public void move(final Vector delta) {
            ModelAccess.instance().runWriteActionInCommand(new Runnable() {
              public void run() {
                SPropertyOperations.set(((SNode) mapper.getSource()), "x", "" + (SPropertyOperations.getInteger(((SNode) mapper.getSource()), "x") + delta.x));
                SPropertyOperations.set(((SNode) mapper.getSource()), "y", "" + (SPropertyOperations.getInteger(((SNode) mapper.getSource()), "y") + delta.y));
              }
            }, context.getOperationContext().getProject());
          }
        });

        return mapper;
      }


    };
    blockCell.setBig(true);
    blockCell.getEditor().addCellDependentOnNodeProperty(blockCell, new Pair<SNodeReference, String>(new SNodePointer(node), "name"));
    blockCell.getEditor().addCellDependentOnNodeProperty(blockCell, new Pair<SNodeReference, String>(new SNodePointer(node), "x"));
    blockCell.getEditor().addCellDependentOnNodeProperty(blockCell, new Pair<SNodeReference, String>(new SNodePointer(node), "y"));

    return blockCell;
  }



  private class ContentMapper extends Mapper<SNode, BlockEditor.ContentView> {
    private ContentMapper(SNode block) {
      super(block, new BlockEditor.ContentView());
    }



    @Override
    protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
      super.registerSynchronizers(configuration);

      configuration.add(Synchronizers.forProperty(stringProperty(getSource(), "name"), getTarget().label.text()));
    }
  }



  private class ContentView extends CenterVerticalLayoutView {
    private TextView label = new TextView();
    private RectView rect = new RectView();

    private ContentView() {
      background().set(Color.DARK_BLUE);
      children().add(label);
      children().add(rect);
      rect.background().set(Color.CYAN);
      rect.dimension().set(new Vector(100, 20));
    }
  }
}
