package jetbrains.mps.testHybridEditor.diagram.generated.editor;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.DefaultNodeEditor;
import java.util.Collection;
import java.util.Arrays;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.nodeEditor.cells.jetpad.BlockCell;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.projectional.diagram.view.DiagramNodeView;
import jetbrains.mps.diagram.dataflow.view.BlockView;
import jetbrains.jetpad.mapper.Synchronizers;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.jetpad.mapper.MapperFactory;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.mps.nodeEditor.cells.jetpad.PortCell;
import jetbrains.jetpad.model.property.ReadableProperty;
import jetbrains.mps.nodeEditor.cells.jetpad.JetpadUtils;
import jetbrains.mps.util.Computable;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.jetpad.geometry.Vector;
import jetbrains.jetpad.projectional.diagram.view.RootTrait;
import jetbrains.jetpad.projectional.diagram.view.MoveHandler;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.editor.figures.sandbox.BlockContentView;
import jetbrains.mps.nodeEditor.cells.jetpad.PropertyMapperCell;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.jetpad.values.Color;

public class Block_diagramGenerated_Editor extends DefaultNodeEditor {
  private Collection<String> myContextHints = Arrays.asList(new String[]{"jetbrains.mps.testHybridEditor.editor.HybridHints.diagramGenerated"});

  @Override
  public Collection<String> getContextHints() {
    return myContextHints;
  }

  public EditorCell createEditorCell(EditorContext editorContext, SNode node) {
    return this.createDiagramNode_70mnj_a(editorContext, node);
  }

  private EditorCell createDiagramNode_70mnj_a(final EditorContext editorContext, final SNode node) {
    BlockCell editorCell = new BlockCell(editorContext, node) {
      public Mapper<SNode, DiagramNodeView> getMapper() {
        final Mapper<SNode, DiagramNodeView> mapper = new Mapper<SNode, DiagramNodeView>(node, new BlockView()) {
          @Override
          protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
            super.registerSynchronizers(configuration);
            configuration.add(Synchronizers.forSimpleRole(this, SLinkOperations.getTargets(node, "inputPorts", true), getTarget().inputs.children(), new MapperFactory<SNode, View>() {
              public Mapper<? extends SNode, ? extends View> createMapper(SNode mapperNode) {
                EditorCell portCell = editorContext.createNodeCell(mapperNode);
                if (portCell instanceof PortCell) {
                  addEditorCell(portCell);
                  return ((PortCell) portCell).getMapper();
                }
                return null;
              }
            }));
            configuration.add(Synchronizers.forSimpleRole(this, SLinkOperations.getTargets(node, "outputPorts", true), getTarget().outputs.children(), new MapperFactory<SNode, View>() {
              public Mapper<? extends SNode, ? extends View> createMapper(SNode mapperNode) {
                EditorCell portCell = editorContext.createNodeCell(mapperNode);
                if (portCell instanceof PortCell) {
                  addEditorCell(portCell);
                  return ((PortCell) portCell).getMapper();
                }
                return null;
              }
            }));
            {
              final ReadableProperty<Integer> x = JetpadUtils.modelProperty(new Computable<Integer>() {
                public Integer compute() {
                  return SNodeOperations.getIndexInParent(node) / 2 * 150 + 10;
                }
              });
              final ReadableProperty<Integer> y = JetpadUtils.modelProperty(new Computable<Integer>() {
                public Integer compute() {
                  return SPropertyOperations.getInteger(node, "y");
                }
              });
              final DiagramNodeView view = getTarget();
              getTarget().moveTo(new Vector(x.get(), y.get()));

              view.prop(RootTrait.MOVE_HANDLER).set(new MoveHandler() {
                public void move(final Vector delta) {
                  String groupId = ModelAccess.instance().runReadAction(new Computable<String>() {
                    public String compute() {
                      return getCellId() + "_" + getSNode().getNodeId().toString();
                    }
                  });
                  getContext().flushEvents();

                  ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                    public void run() {
                    }
                  }, null, groupId, false, editorContext.getOperationContext().getProject());
                  ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                    public void run() {
                      SPropertyOperations.set(((SNode) getSource()), "y", "" + (SPropertyOperations.getInteger(((SNode) getSource()), "y") + delta.y));
                    }
                  }, null, groupId, false, editorContext.getOperationContext().getProject());
                  getTarget().moveTo(new Vector(x.get(), y.get()));
                  getTarget().invalidate();
                }
              });

            }

            registerAditionalSynchronizers(configuration, this);
            Block_diagramGenerated_Editor.setDiagramNodeView(getTarget());
          }
        };
        myView = mapper.getTarget();
        return mapper;
      }

      public void registerAditionalSynchronizers(Mapper.SynchronizersConfiguration configuration, final Mapper<SNode, DiagramNodeView> mapper) {
        configuration.add(Synchronizers.forConstantRole(mapper, mapper.getSource(), mapper.getTarget().contentView.children(), new MapperFactory<SNode, BlockContentView>() {
          public Mapper<? extends SNode, ? extends BlockContentView> createMapper(SNode block) {
            return new Mapper<SNode, BlockContentView>(node, new BlockContentView()) {
              @Override
              protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
                super.registerSynchronizers(configuration);
                final PropertyMapperCell cell_70mnj_a0a = new PropertyMapperCell(editorContext, node, getTarget().text(), "name");
                addEditorCell(cell_70mnj_a0a);
                configuration.add(Synchronizers.forProperty(JetpadUtils.stringProperty(getSource(), "name"), getTarget().text()));
                configuration.add(Synchronizers.forProperty(getTarget().text(), new Runnable() {
                  public void run() {
                    cell_70mnj_a0a.updateModel();
                  }
                }));
              }
            };
          }
        }));
      }



      @Override
      public void synchronizeViewWithModel() {
        myView.moveTo(new Vector(SNodeOperations.getIndexInParent(node) / 2 * 150 + 10, SPropertyOperations.getInteger(node, "y")));
        myView.invalidate();
        requestRelayout();
      }
    };
    editorCell.getEditor().addCellDependentOnNodeProperty(editorCell, new Pair<SNodeReference, String>(new SNodePointer(node), "y"));

    editorCell.setCellId("DiagramNode_70mnj_a");
    editorCell.setBig(true);
    return editorCell;

  }

  public static void setDiagramNodeView(DiagramNodeView view) {
    view.rect.background().set(Color.TRANSPARENT);
    view.padding().set(0);
  }
}
