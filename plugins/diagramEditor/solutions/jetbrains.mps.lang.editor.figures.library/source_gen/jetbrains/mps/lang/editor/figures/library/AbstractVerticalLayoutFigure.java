package jetbrains.mps.lang.editor.figures.library;

/*Generated by MPS */

import jetbrains.jetpad.projectional.view.RectView;
import jetbrains.mps.lang.editor.diagram.runtime.jetpad.views.ResizableContentView;
import jetbrains.jetpad.model.property.Property;
import jetbrains.jetpad.model.property.ValueProperty;
import jetbrains.jetpad.values.Color;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.jetpad.geometry.Vector;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.jetpad.geometry.Rectangle;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.mapper.Synchronizers;

public abstract class AbstractVerticalLayoutFigure extends RectView implements ResizableContentView {
  private static int DEFAULT_WIDTH = 80;
  private static int DEFAULT_HEIGHT = 60;

  public Property<Integer> figureWidth = new ValueProperty<Integer>(AbstractVerticalLayoutFigure.DEFAULT_WIDTH);
  public Property<Integer> figureHeight = new ValueProperty<Integer>(AbstractVerticalLayoutFigure.DEFAULT_HEIGHT);


  protected AbstractVerticalLayoutFigure() {
    background().set(Color.WHITE);
  }

  @Override
  protected void doValidate(View.ValidationContext context) {
    super.doValidate(context);
    Vector prefSize = prop(PREFERRED_SIZE).get();
    AbstractVerticalLayoutFigure.Insets insets = getInsets();

    int width = 0;
    int height = insets.top + insets.bottom;
    for (View nextChild : ListSequence.fromList(children())) {
      if (isExcludedFromLayout(nextChild)) {
        continue;
      }
      Rectangle childBounds = nextChild.bounds().get();
      width = Math.max(width, childBounds.dimension.x);
      height += childBounds.dimension.y;
    }
    width += insets.left + insets.right;
    if (width < prefSize.x) {
      width = prefSize.x;
    }
    if (height < prefSize.y) {
      height = prefSize.y;
    }
    int yOffset = bounds().get().origin.y + insets.top;
    int xOrigin = bounds().get().origin.x;
    for (View nextChild : ListSequence.fromList(children())) {
      if (isExcludedFromLayout(nextChild)) {
        continue;
      }
      Rectangle childBounds = nextChild.bounds().get();
      nextChild.moveTo(new Vector(xOrigin + (width - childBounds.dimension.x) / 2, yOffset));
      yOffset += childBounds.dimension.y;
    }
    figureWidth.set(width);
    figureHeight.set(height);
    Vector newDimension = new Vector(width, height);
    if (!(newDimension.equals(dimension().get()))) {
      dimension().set(newDimension);
      super.validate();
    }
  }

  protected boolean isExcludedFromLayout(View childView) {
    return !((childView.visible().get()));
  }

  protected AbstractVerticalLayoutFigure.Insets getInsets() {
    return AbstractVerticalLayoutFigure.Insets.EMPTY_INSETS;
  }

  public static class Insets {
    public static final AbstractVerticalLayoutFigure.Insets EMPTY_INSETS = new AbstractVerticalLayoutFigure.Insets(0, 0, 0, 0);

    public final int top;
    public final int bottom;
    public final int left;
    public final int right;

    public Insets(int top, int bottom, int left, int right) {
      this.top = top;
      this.bottom = bottom;
      this.left = left;
      this.right = right;
    }

    public AbstractVerticalLayoutFigure.Insets join(AbstractVerticalLayoutFigure.Insets insets) {
      return new AbstractVerticalLayoutFigure.Insets(top + insets.top, bottom + insets.bottom, left + insets.left, right + insets.right);
    }
  }

  protected static class AbstractVerticalLayoutFigureMapper<T extends AbstractVerticalLayoutFigure> extends Mapper<T, T> {
    protected AbstractVerticalLayoutFigureMapper(T figure) {
      super(figure, figure);
    }

    @Override
    protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
      super.registerSynchronizers(configuration);
      configuration.add(Synchronizers.forProperty(getSource().figureWidth, new Runnable() {
        public void run() {
          getSource().prop(PREFERRED_SIZE).set(new Vector(getSource().figureWidth.get(), getSource().figureHeight.get()));
        }
      }));
      configuration.add(Synchronizers.forProperty(getSource().figureHeight, new Runnable() {
        public void run() {
          getSource().prop(PREFERRED_SIZE).set(new Vector(getSource().figureWidth.get(), getSource().figureHeight.get()));
        }
      }));
    }
  }
}
