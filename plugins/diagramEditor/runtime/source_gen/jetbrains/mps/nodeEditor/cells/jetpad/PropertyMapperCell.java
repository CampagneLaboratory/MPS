package jetbrains.mps.nodeEditor.cells.jetpad;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.model.property.Property;
import jetbrains.jetpad.mapper.Synchronizers;
import jetbrains.jetpad.model.property.BaseReadableProperty;
import jetbrains.jetpad.model.event.Listeners;
import jetbrains.jetpad.model.event.EventHandler;
import jetbrains.jetpad.model.property.PropertyChangeEvent;
import jetbrains.jetpad.model.event.Registration;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.Computable;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.jetpad.model.event.ListenerCaller;

public abstract class PropertyMapperCell extends EditorCell_Basic {
  protected PropertyMapperCell.WritableModelProperty myModelProperty;
  private String myCommandId;

  public PropertyMapperCell(EditorContext editorContext, SNode node) {
    super(editorContext, node);
    myModelProperty = createModelProperty();
    myCommandId = getCellId() + "_" + getSNode().getNodeId().toString();
  }

  @Override
  public void paintContent(Graphics g, ParentSettings parentSettings) {
  }

  public void registerSynchronizers(Mapper.SynchronizersConfiguration configuration, Property viewProperty) {
    configuration.add(Synchronizers.forProperty(myModelProperty, viewProperty));
    configuration.add(Synchronizers.forProperty(viewProperty, myModelProperty));
  }

  protected abstract PropertyMapperCell.WritableModelProperty createModelProperty();

  @Override
  public void synchronizeViewWithModel() {
    myModelProperty.firePropertyChangedEvent();
    requestRelayout();
  }

  public abstract class WritableModelProperty<T> extends BaseReadableProperty<T> implements Property<T> {
    private Listeners<EventHandler<? super PropertyChangeEvent<T>>> myHandlers;

    public Registration addHandler(EventHandler<? super PropertyChangeEvent<T>> handler) {
      if (myHandlers == null) {
        myHandlers = new Listeners<EventHandler<? super PropertyChangeEvent<T>>>();
      }
      final Registration registration = myHandlers.add(handler);
      return new Registration() {
        public void remove() {
          registration.remove();
          if (myHandlers.isEmpty()) {
            myHandlers = null;
          }
        }
      };
    }

    public T get() {
      return ModelAccess.instance().runReadAction(new Computable<T>() {
        public T compute() {
          return NodeReadAccessCasterInEditor.runCleanPropertyAccessAction(new Computable<T>() {
            public T compute() {
              return getModelPropertyValue();
            }
          });
        }
      });
    }

    public void set(final T t) {
      ModelAccess.instance().tryWrite(new Runnable() {
        public void run() {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              setModelPropertyValue((t == null ? null : t));
            }
          }, null, myCommandId, false, getContext().getOperationContext().getProject());
        }
      });
    }

    protected abstract T getModelPropertyValue();

    protected abstract void setModelPropertyValue(T value);

    private void firePropertyChangedEvent() {
      if (myHandlers != null) {
        T newValue = get();
        final PropertyChangeEvent<T> event = new PropertyChangeEvent(newValue, newValue);
        ListenerCaller<EventHandler<? super PropertyChangeEvent<T>>> caller = new ListenerCaller<EventHandler<? super PropertyChangeEvent<T>>>() {
          public void call(EventHandler<? super PropertyChangeEvent<T>> listener) {
            listener.onEvent(event);
          }
        };
        myHandlers.fire(caller);
      }
    }
  }
}
