package jetbrains.mps.nodeEditor.cells.jetpad;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import java.util.List;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import jetbrains.mps.nodeEditor.cells.CellFinderUtil;
import org.jetbrains.mps.util.Condition;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.nodeEditor.EditorMessage;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Set;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.jetpad.projectional.diagram.view.RootTrait;
import jetbrains.jetpad.projectional.diagram.view.DeleteHandler;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.jetpad.projectional.view.ViewTraitBuilder;
import jetbrains.jetpad.projectional.view.ViewEvents;
import jetbrains.jetpad.projectional.view.ViewEventHandler;
import jetbrains.jetpad.event.KeyEvent;
import jetbrains.mps.ide.tooltips.MPSToolTipManager;
import jetbrains.jetpad.event.Key;
import jetbrains.jetpad.event.ModifierKey;

public class AbstractJetpadCell extends EditorCell_Collection {
  private List<WritableModelProperty> myModelProperties;

  public AbstractJetpadCell(EditorContext editorContext, SNode node) {
    super(editorContext, node, new CellLayout_Horizontal(), null);
  }

  @Override
  public boolean isTransparentCollection() {
    return false;
  }

  protected DiagramCell getDiagramCell() {
    return (DiagramCell) CellFinderUtil.findParent(this, new Condition<jetbrains.mps.openapi.editor.cells.EditorCell_Collection>() {
      public boolean met(jetbrains.mps.openapi.editor.cells.EditorCell_Collection parent) {
        return parent instanceof DiagramCell;
      }
    });
  }

  @Override
  public void paint(Graphics graphics, ParentSettings settings) {
    for (EditorCell child : Sequence.fromIterable(this)) {
      ((jetbrains.mps.nodeEditor.cells.EditorCell) child).paint(graphics, settings);
    }
    List<EditorMessage> messages = getMessages(EditorMessage.class);
    for (EditorMessage message : messages) {
      if (message != null && !(message.isBackground())) {
        message.paint(graphics, getEditor(), this);
      }
    }

  }

  protected void addModelProperty(WritableModelProperty modelProperty) {
    if (myModelProperties == null) {
      myModelProperties = new LinkedList<WritableModelProperty>();
    }
    myModelProperties.add(modelProperty);
    modelProperty.get();
  }

  @Override
  public int getAscent() {
    return getHeight();
  }

  @Override
  public void synchronizeViewWithModel() {
    if (myModelProperties != null) {
      for (WritableModelProperty nextModelProperty : myModelProperties) {
        nextModelProperty.firePropertyChangedEvent();
      }
      requestRelayout();
    }
  }

  protected EditorCell getDirectChildCell(SNode node) {
    // TODO: use more effitient way of getting port cell (by ID) 
    for (EditorCell nextCell : Sequence.fromIterable(getContentCells())) {
      if (nextCell.getSNode() == node) {
        return nextCell;
      }
    }
    return null;
  }

  protected void syncToNextObject(ListIterator listIterator, Set elementsSet, Object next) {
    while (listIterator.hasNext()) {
      Object nextFromList = listIterator.next();
      if (nextFromList == next) {
        return;
      }
      listIterator.remove();
      elementsSet.remove(nextFromList);
    }
    assert false : "Next element was not found in passed listIterator";
  }

  protected void syncToNextNode(ListIterator<SNode> listIterator, Set<SNode> elementsSet, SNode nextNode) {
    while (listIterator.hasNext()) {
      SNode nextFromList = listIterator.next();
      if (nextFromList == nextNode) {
        return;
      }
      listIterator.remove();
      elementsSet.remove(nextFromList);
      removeCell(((jetbrains.mps.nodeEditor.cells.EditorCell) getDirectChildCell(nextFromList)));
    }
    assert false : "Next element was not found in passed listIterator";
  }

  protected void purgeTailNodes(ListIterator<SNode> listIterator) {
    while (listIterator.hasNext()) {
      SNode nextFromList = listIterator.next();
      listIterator.remove();
      removeCell(((jetbrains.mps.nodeEditor.cells.EditorCell) getDirectChildCell(nextFromList)));
    }
  }

  protected void purgeTailObject(ListIterator listIterator) {
    while (listIterator.hasNext()) {
      listIterator.next();
      listIterator.remove();
    }
  }

  protected static void configureView(final View view, final AbstractJetpadCell editorCell, final _FunctionTypes._return_P0_E0<? extends Boolean> canDelete) {
    view.focusable().set(true);
    view.prop(RootTrait.DELETE_HANDLER).set(new DeleteHandler() {
      public boolean canDelete() {
        return canDelete.invoke();
      }

      public void delete() {
        editorCell.getEditorComponent().getSelectionManager().getSelection().executeAction(CellActionType.DELETE);
      }
    });
    view.addTrait(new ViewTraitBuilder().on(ViewEvents.KEY_PRESSED, new ViewEventHandler<KeyEvent>() {
      @Override
      public void handle(View view, KeyEvent e) {
        if (!(view.focused().get())) {
          return;
        }
        MPSToolTipManager.getInstance().hideToolTip();
        if (e.is(Key.F1, ModifierKey.CONTROL)) {
          editorCell.getEditorComponent().getSelectionManager().getSelection().executeAction(CellActionType.SHOW_MESSAGE);
        }
      }
    }).build());

  }
}
