package jetbrains.mps.nodeEditor.cells.jetpad;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.nodeEditor.cells.SynchronizedEditorCell;
import java.util.List;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import jetbrains.mps.nodeEditor.cells.CellFinderUtil;
import org.jetbrains.mps.util.Condition;
import java.util.LinkedList;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.ListIterator;
import java.util.Set;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.jetpad.projectional.diagram.view.RootTrait;
import jetbrains.jetpad.projectional.diagram.view.DeleteHandler;
import jetbrains.mps.openapi.editor.cells.CellActionType;

public abstract class AbstractJetpadCell extends EditorCell_Collection implements SynchronizedEditorCell {
  private List<WritableModelProperty> myModelProperties;

  public AbstractJetpadCell(EditorContext editorContext, SNode node) {
    super(editorContext, node, new CellLayout_Horizontal(), null);
  }

  @Override
  public boolean isTransparentCollection() {
    return false;
  }

  protected DiagramCell getDiagramCell() {
    return (DiagramCell) CellFinderUtil.findParent(this, new Condition<jetbrains.mps.openapi.editor.cells.EditorCell_Collection>() {
      public boolean met(jetbrains.mps.openapi.editor.cells.EditorCell_Collection parent) {
        return parent instanceof DiagramCell;
      }
    });
  }

  protected void addModelProperty(WritableModelProperty modelProperty) {
    if (myModelProperties == null) {
      myModelProperties = new LinkedList<WritableModelProperty>();
    }
    myModelProperties.add(modelProperty);
    modelProperty.get();
  }

  @Override
  public int getAscent() {
    return getHeight();
  }

  @Override
  public void synchronizeViewWithModel() {
    if (myModelProperties != null) {
      for (WritableModelProperty nextModelProperty : myModelProperties) {
        nextModelProperty.firePropertyChangedEvent();
      }
      requestRelayout();
    }
  }

  protected AbstractJetpadCell getDirectChildCell(SNode node) {
    // TODO: use more effitient way of getting port cell (by ID) 
    for (EditorCell nextCell : Sequence.fromIterable(getContentCells())) {
      if (nextCell.getSNode() == node) {
        return (AbstractJetpadCell) nextCell;
      }
    }
    return null;
  }

  protected void syncToNextObject(ListIterator listIterator, Set elementsSet, Object next) {
    while (listIterator.hasNext()) {
      Object nextFromList = listIterator.next();
      if (nextFromList == next) {
        return;
      }
      listIterator.remove();
      elementsSet.remove(nextFromList);
    }
    assert false : "Next element was not found in passed listIterator";
  }

  protected void syncToNextNode(ListIterator<SNode> listIterator, Set<SNode> elementsSet, SNode nextNode) {
    while (listIterator.hasNext()) {
      SNode nextFromList = listIterator.next();
      if (nextFromList == nextNode) {
        return;
      }
      listIterator.remove();
      elementsSet.remove(nextFromList);
      removeCell((getDirectChildCell(nextFromList)));
    }
    assert false : "Next element was not found in passed listIterator";
  }

  protected void purgeTailNodes(ListIterator<SNode> listIterator) {
    while (listIterator.hasNext()) {
      SNode nextFromList = listIterator.next();
      listIterator.remove();
      removeCell((getDirectChildCell(nextFromList)));
    }
  }

  protected void purgeTailObject(ListIterator listIterator) {
    while (listIterator.hasNext()) {
      listIterator.next();
      listIterator.remove();
    }
  }

  protected static void configureView(final View view, final EditorCell editorCell, final _FunctionTypes._return_P0_E0<? extends Boolean> canDelete) {
    view.focusable().set(true);
    view.prop(RootTrait.DELETE_HANDLER).set(new DeleteHandler() {
      public boolean canDelete() {
        return canDelete.invoke();
      }

      public void delete() {
        editorCell.getEditorComponent().getSelectionManager().getSelection().executeAction(CellActionType.DELETE);
      }
    });
  }
}
