package jetbrains.mps.nodeEditor.cells.jetpad;

/*Generated by MPS */

import jetbrains.jetpad.projectional.diagram.view.DiagramView;
import jetbrains.mps.nodeEditor.EditorCell_WithComponent;
import jetbrains.mps.nodeEditor.cells.jetpad.mappers.RootMapper;
import jetbrains.jetpad.projectional.view.awt.ViewContainerComponent;
import jetbrains.jetpad.model.collections.list.ObservableSingleItemList;
import jetbrains.jetpad.projectional.diagram.view.PolyLineConnection;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.jetpad.projectional.view.ViewContainer;
import jetbrains.jetpad.projectional.diagram.view.RootTrait;
import javax.swing.JComponent;
import java.awt.Dimension;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.jetpad.model.event.EventHandler;
import jetbrains.jetpad.model.property.PropertyChangeEvent;
import jetbrains.jetpad.projectional.view.ViewTrait;
import jetbrains.jetpad.projectional.view.ViewTraitBuilder;
import jetbrains.jetpad.projectional.view.ViewEvents;
import jetbrains.jetpad.projectional.view.ViewEventHandler;
import jetbrains.jetpad.event.MouseEvent;
import jetbrains.jetpad.event.KeyEvent;
import jetbrains.jetpad.event.Key;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.nodeEditor.cellMenu.SubstituteInfoPartExt;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.nodeEditor.cellMenu.CellContext;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.action.ModelActions;
import jetbrains.mps.smodel.action.DefaultChildNodeSetter;
import jetbrains.mps.smodel.action.NodeSubstituteActionWrapper;
import org.jetbrains.annotations.Nullable;
import java.util.Collections;
import jetbrains.mps.smodel.action.AbstractNodeSubstituteAction;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.nodeEditor.cellMenu.NodeSubstitutePatternEditor;
import java.awt.Window;
import java.awt.Point;
import jetbrains.jetpad.event.ModifierKey;
import jetbrains.jetpad.geometry.Vector;

public abstract class DiagramCell extends GenericMapperCell<DiagramView> implements EditorCell_WithComponent {
  private RootMapper myRootMapper;
  private ViewContainerComponent myComponent;
  private boolean mySubstituteEditorVisible = false;
  private int myPatternEditorX;
  private int myPatternEditorY;
  protected ObservableSingleItemList<PolyLineConnection> myConnectionSingleList = new ObservableSingleItemList<PolyLineConnection>();
  private SNode myCurrentFrom;
  private SNode myCurrentTo;
  private Object myCurrentFromId;
  private Object myCurrentToId;


  public DiagramCell(EditorContext editorContext, SNode node) {
    super(editorContext, node);
    ViewContainer container = new ViewContainer();
    myComponent = new ViewContainerComponent();
    myComponent.container(container);
    setupRootView(myComponent.container().root());
    myComponent.container().root().addTrait(RootTrait.ROOT_TRAIT);
    myComponent.container().root().addTrait(getEventHandlingTrate());
  }

  public JComponent getComponent() {
    return myComponent;
  }

  @Override
  protected void relayoutImpl() {
    super.relayoutImpl();
    getComponent().doLayout();
    Dimension preferredSize = getComponent().getPreferredSize();
    getComponent().setSize(preferredSize);
    setWidth(getComponent().getWidth() + myGapLeft + myGapRight);
    setHeight(getComponent().getHeight());
  }

  @Override
  public void onAdd() {
    super.onAdd();
    getEditor().getCellTracker().addComponentCell(this);
  }

  @Override
  public void onRemove() {
    getEditor().getCellTracker().removeComponentCell(this);
    super.onRemove();
  }

  @Override
  public void setX(int x) {
    getComponent().setLocation(x, myComponent.getY());
    super.setX(x);
  }

  @Override
  public void setY(int y) {
    getComponent().setLocation(myComponent.getX(), y);
    super.setY(y);
  }

  @Override
  public void moveTo(int x, int y) {
    super.moveTo(x, y);
    getComponent().setLocation(myX, myY);
  }

  @Override
  public boolean isDrawBorder() {
    return false;
  }

  private void setupRootView(View root) {
    root.focusable().set(true);
    root.focused().addHandler(new EventHandler<PropertyChangeEvent<Boolean>>() {
      public void onEvent(PropertyChangeEvent<Boolean> focused) {
        if (!(focused.getNewValue())) {
          hidePatternEditor();
        }
      }
    });
  }

  private ViewTrait getEventHandlingTrate() {
    return new ViewTraitBuilder().on(ViewEvents.MOUSE_PRESSED, new ViewEventHandler<MouseEvent>() {
      public void handle(View view, MouseEvent event) {
        if (view.focused().get()) {
          hidePatternEditor();
        } else {
          view.container().focusedView().set(view);
        }
        View viewUnderMouse = view.viewAt(event.location());
        if (viewUnderMouse != myComponent.container().root()) {
          return;
        }
        createNewDiagramElement(event.x(), event.y());
        event.consume();
      }
    }).on(ViewEvents.KEY_PRESSED, new ViewEventHandler<KeyEvent>() {
      public void handle(View view, KeyEvent event) {
        if (mySubstituteEditorVisible) {
          getEditor().processKeyPressed(getAWTKeyEvent(event, false));
          event.consume();
          return;
        }

        if (event.key() == Key.ESCAPE) {
          view.container().focusedView().set(null);
          event.consume();
        }
      }
    }).on(ViewEvents.KEY_TYPED, new ViewEventHandler<KeyEvent>() {
      public void handle(View view, KeyEvent event) {
        if (!(mySubstituteEditorVisible)) {
          return;
        }
        getEditor().processKeyTyped(getAWTKeyEvent(event, false));
        event.consume();
      }
    }).build();
  }

  public void createNewDiagramElement(int x, int y) {
    if (trySubstituteImmediately()) {
      return;
    }
    myPatternEditorX = x;
    myPatternEditorY = y;
    getEditor().activateNodeSubstituteChooser(this, false);
  }

  private boolean trySubstituteImmediately() {
    List<SubstituteAction> matchingActions = getSubstituteInfo().getMatchingActions("", false);
    if (matchingActions.size() != 1) {
      return false;
    }
    final SubstituteAction theAction = matchingActions.get(0);
    final boolean[] result = new boolean[]{false};
    getContext().getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        result[0] = theAction.canSubstitute("");
      }
    });
    if (!(result[0])) {
      return false;
    }
    theAction.substitute(getContext(), "");
    return true;
  }

  private void hidePatternEditor() {
    getEditor().getNodeSubstituteChooser().setVisible(false);
  }

  public SubstituteInfoPartExt createNewDiagramNodeActions(final SNode container, final SNode childNodeConcept, final SNode containingLink, final _FunctionTypes._void_P3_E0<? super SNode, ? super Integer, ? super Integer> setNodePositionCallback) {
    return new SubstituteInfoPartExt() {
      public List<SubstituteAction> createActions(CellContext cellContext, EditorContext editorContext) {
        List<SubstituteAction> result = new ArrayList<SubstituteAction>();
        for (SubstituteAction action : ListSequence.fromList(ModelActions.createChildNodeSubstituteActions(container, null, childNodeConcept, new DefaultChildNodeSetter(containingLink), editorContext.getOperationContext()))) {
          result.add(new NodeSubstituteActionWrapper(action) {
            @Override
            public boolean canSubstitute(String string) {
              return !(hasConnectionDragFeedback()) && super.canSubstitute(string);
            }

            @Override
            public SNode substitute(@Nullable EditorContext context, String string) {
              SNode result = super.substitute(context, string);
              setNodePositionCallback.invoke(result, myPatternEditorX, myPatternEditorY);
              return result;
            }
          });
        }
        return result;
      }
    };
  }

  public SubstituteInfoPartExt createNewDiagramConnectorActions(final SNode container, final SNode childNodeConcept, final SNode containingLink, final _FunctionTypes._return_P4_E0<? extends Boolean, ? super SNode, ? super Object, ? super SNode, ? super Object> canCreateConnector, final _FunctionTypes._void_P5_E0<? super SNode, ? super SNode, ? super Object, ? super SNode, ? super Object> setConnectorCallback) {
    // TMP solution: manually creating instance of connection instead of using 
    // ModelActions.createChildNodeSubstituteActions() because of mbeddr reqirements: 
    // hiding text-specific connection substitute actions from the diagram 
    return new SubstituteInfoPartExt() {
      public List<SubstituteAction> createActions(CellContext cellContext, final EditorContext editorContext) {
        return Collections.<SubstituteAction>singletonList(new AbstractNodeSubstituteAction(childNodeConcept, childNodeConcept, container) {
          @Override
          public boolean canSubstitute(String string) {
            return hasConnectionDragFeedback() && super.canSubstitute(string) && canCreateConnector.invoke(myCurrentFrom, myCurrentFromId, myCurrentTo, myCurrentToId);
          }

          @Override
          protected SNode doSubstitute(@Nullable EditorContext context, String string) {
            SNode result = NodeFactoryManager.createNode(childNodeConcept, null, container, SNodeOperations.getModel(container), editorContext.getOperationContext().getScope());
            ListSequence.fromList(SNodeOperations.getChildren(container, containingLink)).addElement(result);
            setConnectorCallback.invoke(result, myCurrentFrom, myCurrentFromId, myCurrentTo, myCurrentToId);
            return result;
          }
        });
      }
    };
  }

  public void setCurrentConnectorContext(SNode from, Object fromId, SNode to, Object toId) {
    myCurrentFrom = from;
    myCurrentFromId = fromId;
    myCurrentTo = to;
    myCurrentToId = toId;
  }

  @Override
  public NodeSubstitutePatternEditor createSubstitutePatternEditor() {
    return new NodeSubstitutePatternEditor() {
      @Override
      public void activate(Window window, Point point, Dimension dimension) {
        Dimension actualDimension = new Dimension(100, 0);
        point.translate(myPatternEditorX, myPatternEditorY);
        super.activate(window, point, actualDimension);
        mySubstituteEditorVisible = true;
      }

      @Override
      public void done() {
        super.done();
        hideConnectionDragFeedback();
        mySubstituteEditorVisible = false;
      }
    };
  }



  private java.awt.event.KeyEvent getAWTKeyEvent(KeyEvent jetPadKeyEvent, boolean isTyped) {
    // TODO: better integration with MPS substitute editor is required here 
    int id = (isTyped ? java.awt.event.KeyEvent.KEY_TYPED : java.awt.event.KeyEvent.KEY_PRESSED);
    long when = System.currentTimeMillis();
    int modifiers = 0;
    if (jetPadKeyEvent.has(ModifierKey.ALT)) {
      modifiers |= java.awt.event.KeyEvent.ALT_MASK;
    }
    if (jetPadKeyEvent.has(ModifierKey.CONTROL)) {
      modifiers |= java.awt.event.KeyEvent.CTRL_MASK;
    }
    if (jetPadKeyEvent.has(ModifierKey.META)) {
      modifiers |= java.awt.event.KeyEvent.META_MASK;
    }
    if (jetPadKeyEvent.has(ModifierKey.SHIFT)) {
      modifiers |= java.awt.event.KeyEvent.SHIFT_MASK;
    }
    int keyCode;
    switch (jetPadKeyEvent.key()) {
      case ESCAPE:
        keyCode = java.awt.event.KeyEvent.VK_ESCAPE;
        break;
      case SPACE:
        keyCode = java.awt.event.KeyEvent.VK_SPACE;
        break;
      case BACKSPACE:
        keyCode = java.awt.event.KeyEvent.VK_BACK_SPACE;
        break;
      case DELETE:
        keyCode = java.awt.event.KeyEvent.VK_DELETE;
        break;
      case LEFT:
        keyCode = java.awt.event.KeyEvent.VK_LEFT;
        break;
      case RIGHT:
        keyCode = java.awt.event.KeyEvent.VK_RIGHT;
        break;
      case UP:
        keyCode = java.awt.event.KeyEvent.VK_UP;
        break;
      case DOWN:
        keyCode = java.awt.event.KeyEvent.VK_DOWN;
        break;
      case ENTER:
        keyCode = java.awt.event.KeyEvent.VK_ENTER;
        break;
      default:
        keyCode = 0;
    }
    return new java.awt.event.KeyEvent(getComponent(), id, when, modifiers, keyCode, jetPadKeyEvent.keyChar());
  }

  public RootMapper getRootMapper() {
    if (myRootMapper == null) {
      myRootMapper = new RootMapper(getSNode(), getMapper(), myComponent.container());
    }
    return myRootMapper;
  }

  public boolean hasConnectionDragFeedback() {
    return !(myConnectionSingleList.isEmpty());
  }

  public PolyLineConnection showConnectionDragFeedback(View fromView, Vector toLocation) {
    assert myConnectionSingleList.isEmpty();
    PolyLineConnection connection = new PolyLineConnection();
    connection.fromView().set(fromView);
    connection.toLocation().set(toLocation);
    myConnectionSingleList.setItem(connection);
    return connection;
  }

  public void updateConnectionDragFeedback(Vector toLocation) {
    myConnectionSingleList.getItem().toLocation().set(toLocation);
  }

  public void hideConnectionDragFeedback() {
    myConnectionSingleList.setItem(null);
  }
}
