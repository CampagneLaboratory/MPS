package jetbrains.mps.nodeEditor.cells.jetpad;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.EditorCell_WithComponent;
import jetbrains.jetpad.mapper.MapperFactory;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.jetpad.projectional.diagram.view.DiagramView;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.projectional.view.ViewContainer;
import jetbrains.jetpad.projectional.view.awt.ViewContainerComponent;
import jetbrains.jetpad.model.collections.list.ObservableList;
import jetbrains.jetpad.model.collections.list.ObservableArrayList;
import jetbrains.jetpad.model.collections.list.ObservableSingleItemList;
import jetbrains.jetpad.projectional.diagram.view.PolyLineConnection;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.selection.SelectionListener;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.openapi.editor.selection.Selection;
import com.intellij.openapi.project.Project;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.plugins.projectplugins.ProjectPluginManager;
import jetbrains.mps.lang.editor.diagram.runtime.plugin.DiagramEditorTool_Tool;
import javax.swing.JComponent;
import java.awt.Dimension;
import jetbrains.jetpad.projectional.view.ViewTrait;
import jetbrains.jetpad.projectional.view.ViewTraitBuilder;
import jetbrains.jetpad.projectional.view.ViewEvents;
import jetbrains.jetpad.projectional.view.ViewEventHandler;
import jetbrains.jetpad.event.MouseEvent;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.jetpad.event.KeyEvent;
import jetbrains.jetpad.event.Key;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.nodeEditor.cellMenu.SubstituteInfoPartExt;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.nodeEditor.cellMenu.CellContext;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.action.ModelActions;
import jetbrains.mps.smodel.action.DefaultChildNodeSetter;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.action.AbstractNodeSubstituteAction;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Collections;
import jetbrains.mps.nodeEditor.cellMenu.NodeSubstitutePatternEditor;
import java.awt.Window;
import java.awt.Point;
import jetbrains.jetpad.event.ModifierKey;
import jetbrains.jetpad.mapper.Synchronizers;
import jetbrains.jetpad.model.event.EventHandler;
import jetbrains.jetpad.model.property.PropertyChangeEvent;
import jetbrains.jetpad.projectional.diagram.view.RootTrait;
import jetbrains.jetpad.geometry.Vector;
import java.util.ListIterator;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.smodel.action.NodeSubstituteActionWrapper;

public abstract class DiagramCell extends AbstractJetpadCell implements EditorCell_WithComponent, MapperFactory<SNode, DiagramView> {
  private Mapper<SNode, ViewContainer> myRootMapper;
  private Mapper<SNode, ViewContainer> myDecorationRootMapper;
  private ViewContainerComponent myComponent;
  private boolean mySubstituteEditorVisible = false;
  private int myPatternEditorX;
  private int myPatternEditorY;
  protected ObservableList<SNode> myBlocks = new ObservableArrayList<SNode>();
  protected ObservableList<SNode> myConnectors = new ObservableArrayList<SNode>();
  protected ObservableSingleItemList<PolyLineConnection> myConnectionSingleList = new ObservableSingleItemList<PolyLineConnection>();


  public DiagramCell(EditorContext editorContext, SNode node) {
    super(editorContext, node);
    editorContext.getEditorComponent().getSelectionManager().addSelectionListener(new SelectionListener() {
      public void selectionChanged(EditorComponent component, Selection oldSelection, Selection newSelection) {
        openPalette(newSelection, component);
      }
    });
  }

  private void openPalette(Selection newSelection, EditorComponent component) {
    if (newSelection != null && eq_xnhqai_a0a0a11(newSelection.getSelectedCells().get(0), this)) {
      if (getSubstituteInfo() != null) {
        getSubstituteInfo().invalidateActions();
      }
      Project ideaProject = ProjectHelper.toIdeaProject(component.getOperationContext().getProject());
      if (ideaProject == null) {
        return;
      }
      if (ideaProject.getComponent(ProjectPluginManager.class).getTool(DiagramEditorTool_Tool.class) == null) {
        return;
      }
      ideaProject.getComponent(ProjectPluginManager.class).getTool(DiagramEditorTool_Tool.class).setDiagramCell(this);
      ideaProject.getComponent(ProjectPluginManager.class).getTool(DiagramEditorTool_Tool.class).openTool(false);
    }
  }

  public JComponent getComponent() {
    if (myComponent == null) {
      myComponent = new ViewContainerComponent();
      getRootMapper().attachRoot();
      myComponent.container(getRootMapper().getTarget());
      getDecorationRootMapper().attachRoot();
    }
    return myComponent;
  }

  @Override
  protected void relayoutImpl() {
    super.relayoutImpl();
    getComponent().doLayout();
    Dimension preferredSize = getComponent().getPreferredSize();
    getComponent().setSize(preferredSize);
    setWidth(getComponent().getWidth() + myGapLeft + myGapRight);
    setHeight(getComponent().getHeight());
  }

  @Override
  public void onAdd() {
    super.onAdd();
    getEditor().getCellTracker().addComponentCell(this);
  }

  @Override
  public void onRemove() {
    getEditor().getCellTracker().removeComponentCell(this);
    super.onRemove();
  }

  @Override
  public void setX(int x) {
    getComponent().setLocation(x, getComponent().getY());
    super.setX(x);
  }

  @Override
  public void setY(int y) {
    getComponent().setLocation(getComponent().getX(), y);
    super.setY(y);
  }

  @Override
  public void moveTo(int x, int y) {
    super.moveTo(x, y);
    getComponent().setLocation(myX, myY);
  }

  @Override
  public boolean isDrawBorder() {
    return false;
  }



  private ViewTrait getEventHandlingTrate() {
    return new ViewTraitBuilder().on(ViewEvents.MOUSE_PRESSED, new ViewEventHandler<MouseEvent>() {
      public void handle(View view, MouseEvent event) {
        if (view.focused().get()) {
          hidePatternEditor();
        } else {
          view.container().focusedView().set(view);
        }
        View viewUnderMouse = view.viewAt(event.location());
        if (viewUnderMouse != getRootMapper().getTarget().root()) {
          return;
        }
        createNewDiagramElement(event.x(), event.y());
        event.consume();
      }
    }).on(ViewEvents.KEY_PRESSED, new ViewEventHandler<KeyEvent>() {
      public void handle(View view, KeyEvent event) {
        if (mySubstituteEditorVisible) {
          getEditor().processKeyPressed(getAWTKeyEvent(event, false));
          event.consume();
          return;
        }

        if (event.key() == Key.ESCAPE) {
          view.container().focusedView().set(null);
          event.consume();
        }
      }
    }).on(ViewEvents.KEY_TYPED, new ViewEventHandler<KeyEvent>() {
      public void handle(View view, KeyEvent event) {
        if (!(mySubstituteEditorVisible)) {
          return;
        }
        getEditor().processKeyTyped(getAWTKeyEvent(event, false));
        event.consume();
      }
    }).build();
  }

  public void createNewDiagramElement(int x, int y) {
    if (ProjectHelper.toIdeaProject(getOperationContext().getProject()).getComponent(ProjectPluginManager.class).getTool(DiagramEditorTool_Tool.class).getDiagramCell() != this || ProjectHelper.toIdeaProject(getOperationContext().getProject()).getComponent(ProjectPluginManager.class).getTool(DiagramEditorTool_Tool.class).getSelectedSubstituteAction() != null) {
      return;
    }
    myPatternEditorX = x;
    myPatternEditorY = y;
    if (trySubstituteImmediately()) {
      return;
    }
    getEditor().activateNodeSubstituteChooser(this, false);
  }

  private boolean trySubstituteImmediately() {
    List<SubstituteAction> matchingActions = getSubstituteInfo().getMatchingActions("", false);
    if (matchingActions.size() == 0) {
      hideConnectionDragFeedback();
      return true;
    }
    if (matchingActions.size() > 1) {
      return false;
    }
    final SubstituteAction theAction = matchingActions.get(0);
    final boolean[] result = new boolean[]{false};
    getContext().getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        result[0] = theAction.canSubstitute("");
      }
    });
    if (!(result[0])) {
      return false;
    }
    ModelAccess.instance().executeCommand(new Runnable() {
      public void run() {
        theAction.substitute(getContext(), "");
      }
    }, getOperationContext().getProject());
    return true;
  }

  private void hidePatternEditor() {
    getEditor().getNodeSubstituteChooser().setVisible(false);
  }

  public SubstituteInfoPartExt createNewDiagramNodeActions(final SNode container, final SNode childNodeConcept, final SNode containingLink, final _FunctionTypes._void_P3_E0<? super SNode, ? super Integer, ? super Integer> setNodePositionCallback) {
    return new SubstituteInfoPartExt() {
      public List<SubstituteAction> createActions(CellContext cellContext, EditorContext editorContext) {
        List<SubstituteAction> result = new ArrayList<SubstituteAction>();
        for (SubstituteAction action : ListSequence.fromList(ModelActions.createChildNodeSubstituteActions(container, null, childNodeConcept, new DefaultChildNodeSetter(containingLink), editorContext.getOperationContext()))) {
          result.add(new DiagramCell.TunableNodeSubstituteAction(action) {
            @Override
            public SNode substitute(@Nullable EditorContext context, String string) {
              SNode result = super.substitute(context, string);
              setNodePositionCallback.invoke(result, myPatternEditorX, myPatternEditorY);
              return result;
            }
          });
        }
        return result;
      }
    };
  }

  public SubstituteInfoPartExt createNewDiagramConnectorActions(final SNode container, final SNode childNodeConcept, final SNode containingLink, final _FunctionTypes._return_P4_E0<? extends Boolean, ? super SNode, ? super Object, ? super SNode, ? super Object> canCreateConnector, final _FunctionTypes._void_P5_E0<? super SNode, ? super SNode, ? super Object, ? super SNode, ? super Object> setConnectorCallback) {
    // TMP solution: manually creating instance of connection instead of using 
    // ModelActions.createChildNodeSubstituteActions() because of mbeddr reqirements: 
    // hiding text-specific connection substitute actions from the diagram 
    return new SubstituteInfoPartExt() {
      public List<SubstituteAction> createActions(CellContext cellContext, final EditorContext editorContext) {
        AbstractNodeSubstituteAction action = new AbstractNodeSubstituteAction(childNodeConcept, childNodeConcept, container) {
          @Override
          public boolean canSubstitute(String string) {
            if ((super.canSubstitute(string))) {
              return false;
            }

            DiagramCell.ConnectionInfo connectionInfo = new DiagramCell.ConnectionInfo();
            return connectionInfo.isValid() && canCreateConnector.invoke(connectionInfo.getFromNode(), connectionInfo.getFromId(), connectionInfo.getToNode(), connectionInfo.getToId());
          }

          @Override
          protected SNode doSubstitute(@Nullable EditorContext context, String string) {
            SNode result = NodeFactoryManager.createNode(childNodeConcept, null, container, SNodeOperations.getModel(container));
            ListSequence.fromList(SNodeOperations.getChildren(container, containingLink)).addElement(result);
            DiagramCell.ConnectionInfo connectionInfo = new DiagramCell.ConnectionInfo();
            setConnectorCallback.invoke(result, connectionInfo.getFromNode(), connectionInfo.getFromId(), connectionInfo.getToNode(), connectionInfo.getToId());
            return result;
          }
        };
        return Collections.<SubstituteAction>singletonList(new DiagramCell.TunableNodeSubstituteAction(action));
      }
    };
  }

  @Override
  public NodeSubstitutePatternEditor createSubstitutePatternEditor() {
    return new NodeSubstitutePatternEditor() {
      @Override
      public void activate(Window window, Point point, Dimension dimension) {
        Dimension actualDimension = new Dimension(100, 0);
        point.translate(myPatternEditorX, myPatternEditorY);
        super.activate(window, point, actualDimension);
        mySubstituteEditorVisible = true;
      }

      @Override
      public void done() {
        super.done();
        hideConnectionDragFeedback();
        mySubstituteEditorVisible = false;
      }
    };
  }

  private java.awt.event.KeyEvent getAWTKeyEvent(KeyEvent jetPadKeyEvent, boolean isTyped) {
    // TODO: better integration with MPS substitute editor is required here 
    int id = (isTyped ? java.awt.event.KeyEvent.KEY_TYPED : java.awt.event.KeyEvent.KEY_PRESSED);
    long when = System.currentTimeMillis();
    int modifiers = 0;
    if (jetPadKeyEvent.has(ModifierKey.ALT)) {
      modifiers |= java.awt.event.KeyEvent.ALT_MASK;
    }
    if (jetPadKeyEvent.has(ModifierKey.CONTROL)) {
      modifiers |= java.awt.event.KeyEvent.CTRL_MASK;
    }
    if (jetPadKeyEvent.has(ModifierKey.META)) {
      modifiers |= java.awt.event.KeyEvent.META_MASK;
    }
    if (jetPadKeyEvent.has(ModifierKey.SHIFT)) {
      modifiers |= java.awt.event.KeyEvent.SHIFT_MASK;
    }
    int keyCode;
    switch (jetPadKeyEvent.key()) {
      case ESCAPE:
        keyCode = java.awt.event.KeyEvent.VK_ESCAPE;
        break;
      case SPACE:
        keyCode = java.awt.event.KeyEvent.VK_SPACE;
        break;
      case BACKSPACE:
        keyCode = java.awt.event.KeyEvent.VK_BACK_SPACE;
        break;
      case DELETE:
        keyCode = java.awt.event.KeyEvent.VK_DELETE;
        break;
      case LEFT:
        keyCode = java.awt.event.KeyEvent.VK_LEFT;
        break;
      case RIGHT:
        keyCode = java.awt.event.KeyEvent.VK_RIGHT;
        break;
      case UP:
        keyCode = java.awt.event.KeyEvent.VK_UP;
        break;
      case DOWN:
        keyCode = java.awt.event.KeyEvent.VK_DOWN;
        break;
      case ENTER:
        keyCode = java.awt.event.KeyEvent.VK_ENTER;
        break;
      default:
        keyCode = 0;
    }
    return new java.awt.event.KeyEvent(getComponent(), id, when, modifiers, keyCode, jetPadKeyEvent.keyChar());
  }

  public Mapper<SNode, ViewContainer> getRootMapper() {
    if (myRootMapper == null) {
      myRootMapper = new Mapper<SNode, ViewContainer>(getSNode(), createViewContainer()) {
        @Override
        protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
          super.registerSynchronizers(configuration);

          configuration.add(Synchronizers.forConstantRole(this, getSource(), getTarget().contentRoot().children(), DiagramCell.this));
        }
      };
    }
    return myRootMapper;
  }



  public Mapper<SNode, ViewContainer> getDecorationRootMapper() {
    if (myDecorationRootMapper == null) {
      myDecorationRootMapper = new Mapper<SNode, ViewContainer>(getSNode(), getRootMapper().getTarget()) {
        @Override
        protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
          super.registerSynchronizers(configuration);
          configuration.add(Synchronizers.forConstantRole(this, getSource(), getTarget().decorationRoot().children(), new MapperFactory<SNode, View>() {
            public Mapper<? extends SNode, ? extends View> createMapper(SNode source) {
              return createDecorationMapper(source);
            }
          }));
        }
      };
    }
    return myDecorationRootMapper;
  }



  public abstract Mapper<SNode, DiagramDecoratorView> createDecorationMapper(SNode node);



  private ViewContainer createViewContainer() {
    ViewContainer result = new ViewContainer();
    result.root().focusable().set(true);
    result.root().focused().addHandler(new EventHandler<PropertyChangeEvent<Boolean>>() {
      public void onEvent(PropertyChangeEvent<Boolean> focused) {
        if (!(focused.getNewValue())) {
          hidePatternEditor();
        }
      }
    });
    result.root().addTrait(RootTrait.ROOT_TRAIT);
    result.root().addTrait(getEventHandlingTrate());
    return result;
  }

  public boolean hasConnectionDragFeedback() {
    return !(myConnectionSingleList.isEmpty());
  }

  public PolyLineConnection showConnectionDragFeedback(View fromView) {
    assert myConnectionSingleList.isEmpty();
    PolyLineConnection connection = new PolyLineConnection();
    connection.fromView().set(fromView);
    myConnectionSingleList.setItem(connection);
    return connection;
  }

  public void updateConnectionDragFeedback(Vector toLocation) {
    View targetView = getRootMapper().getTarget().contentRoot().viewAt(toLocation);
    while (targetView != null && targetView.prop(JetpadUtils.CONNECTABLE).get() == null) {
      targetView = targetView.parent().get();
    }
    if (targetView != null && targetView.prop(JetpadUtils.CONNECTABLE).get()) {
      myConnectionSingleList.getItem().toView().set(targetView);
    } else {
      myConnectionSingleList.getItem().toView().set(null);
    }
    myConnectionSingleList.getItem().toLocation().set(toLocation);
  }

  private void hideConnectionDragFeedback() {
    myConnectionSingleList.setItem(null);
  }

  protected void syncDiagramElements(Iterable<SNode> elements, ListIterator<SNode> blocksIterator, Set<SNode> existingBlocks, ListIterator<SNode> connectorsIterator, Set<SNode> existingConnectors) {
    for (SNode nextElement : Sequence.fromIterable(elements)) {
      EditorCell cell = getContext().createNodeCell(nextElement);
      if (!(cell instanceof BlockCell) && !(cell instanceof ConnectorCell)) {
        continue;
      }
      syncToNextNode((cell instanceof BlockCell ? blocksIterator : connectorsIterator), (cell instanceof BlockCell ? existingBlocks : existingConnectors), nextElement, cell);
    }
  }

  private class ConnectionInfo {


    private ConnectionInfo() {
      PolyLineConnection connectionDragFeedback = myConnectionSingleList.getItem();
      if (connectionDragFeedback == null) {
        return;
      }

      View fromView = connectionDragFeedback.fromView().get();
      View toView = connectionDragFeedback.toView().get();
      if (fromView == null || toView == null) {
        return;
      }

      setFromNode(fromView.prop(JetpadUtils.SOURCE).get());
      setFromId(fromView.prop(JetpadUtils.ID).get());
      setToNode(toView.prop(JetpadUtils.SOURCE).get());
      setToId(toView.prop(JetpadUtils.ID).get());
    }

    public boolean isValid() {
      return myFromNode != null && myToNode != null;
    }

    private SNode myFromNode;

    public SNode getFromNode() {
      return this.myFromNode;
    }

    private void setFromNode(SNode value) {
      this.myFromNode = value;
    }

    private Object myFromId;

    public Object getFromId() {
      return this.myFromId;
    }

    private void setFromId(Object value) {
      this.myFromId = value;
    }

    private SNode myToNode;

    public SNode getToNode() {
      return this.myToNode;
    }

    private void setToNode(SNode value) {
      this.myToNode = value;
    }

    private Object myToId;

    public Object getToId() {
      return this.myToId;
    }

    private void setToId(Object value) {
      this.myToId = value;
    }
  }

  public static class TunableNodeSubstituteAction extends NodeSubstituteActionWrapper {
    public TunableNodeSubstituteAction(SubstituteAction action) {
      super(action);
    }

    private boolean myCanSubstitute = true;

    @Override
    public boolean canSubstitute(String string) {
      return myCanSubstitute && super.canSubstitute(string);
    }

    public void setSubstitutable(boolean canSubstitute) {
      myCanSubstitute = canSubstitute;
    }
  }

  private static boolean eq_xnhqai_a0a0a11(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
