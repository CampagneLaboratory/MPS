package jetbrains.mps.nodeEditor.cells.jetpad;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.EditorCell_WithComponent;
import jetbrains.jetpad.mapper.MapperFactory;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.jetpad.projectional.diagram.view.DiagramView;
import jetbrains.jetpad.mapper.Mapper;
import jetbrains.jetpad.projectional.view.ViewContainer;
import jetbrains.jetpad.projectional.view.awt.ViewContainerComponent;
import jetbrains.jetpad.model.collections.list.ObservableList;
import jetbrains.jetpad.model.collections.list.ObservableArrayList;
import jetbrains.jetpad.model.collections.list.ObservableSingleItemList;
import jetbrains.jetpad.projectional.diagram.view.PolyLineConnection;
import jetbrains.jetpad.projectional.view.ViewTrait;
import javax.swing.JPanel;
import jetbrains.mps.openapi.editor.EditorContext;
import javax.swing.JComponent;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.uiDesigner.core.GridConstraints;
import java.awt.Dimension;
import jetbrains.jetpad.projectional.view.ViewTraitBuilder;
import jetbrains.jetpad.projectional.view.ViewEvents;
import jetbrains.jetpad.projectional.view.ViewEventHandler;
import jetbrains.jetpad.event.MouseEvent;
import jetbrains.jetpad.projectional.view.View;
import jetbrains.jetpad.event.KeyEvent;
import jetbrains.jetpad.event.Key;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.nodeEditor.cellMenu.SubstituteInfoPartExt;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.nodeEditor.cellMenu.CellContext;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.action.ModelActions;
import jetbrains.mps.smodel.action.DefaultChildNodeSetter;
import jetbrains.mps.smodel.action.NodeSubstituteActionWrapper;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.action.AbstractNodeSubstituteAction;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Collections;
import jetbrains.mps.openapi.editor.cells.SubstituteInfo;
import jetbrains.mps.nodeEditor.cellMenu.NodeSubstitutePatternEditor;
import java.awt.Window;
import java.awt.Point;
import jetbrains.jetpad.event.ModifierKey;
import jetbrains.jetpad.mapper.Synchronizers;
import jetbrains.jetpad.model.event.EventHandler;
import jetbrains.jetpad.model.property.PropertyChangeEvent;
import jetbrains.jetpad.projectional.diagram.view.RootTrait;
import jetbrains.jetpad.geometry.Vector;
import java.util.ListIterator;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import java.util.Map;
import com.intellij.openapi.actionSystem.ToggleAction;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import javax.swing.JLabel;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import javax.swing.SwingConstants;
import com.intellij.openapi.actionSystem.ActionGroup;
import javax.swing.Icon;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.actionSystem.AnAction;

public abstract class DiagramCell extends AbstractJetpadCell implements EditorCell_WithComponent, MapperFactory<SNode, DiagramView> {
  private Mapper<SNode, ViewContainer> myRootMapper;
  private Mapper<SNode, ViewContainer> myDecorationRootMapper;
  private ViewContainerComponent myComponent;
  private boolean mySubstituteEditorVisible = false;
  private int myPatternEditorX;
  private int myPatternEditorY;
  protected ObservableList<SNode> myBlocks = new ObservableArrayList<SNode>();
  protected ObservableList<SNode> myConnectors = new ObservableArrayList<SNode>();
  protected ObservableSingleItemList<PolyLineConnection> myConnectionSingleList = new ObservableSingleItemList<PolyLineConnection>();
  private ViewTrait myHandlingTrait;
  private DiagramCell.DiagramPalette myPalettePanel;
  private JPanel myPanel;


  public DiagramCell(EditorContext editorContext, SNode node) {
    super(editorContext, node);
  }

  public JComponent getComponent() {
    if (myPanel == null) {
      myPanel = new JPanel(new GridLayoutManager(1, 2));
      GridConstraints constraints = new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_NORTHWEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null);
      myPanel.add(getPalette(), constraints);
      constraints.setColumn(1);
      constraints.setVSizePolicy(GridConstraints.SIZEPOLICY_CAN_GROW);
      constraints.setHSizePolicy(GridConstraints.SIZEPOLICY_CAN_GROW);
      myPanel.add(getContainerComponent(), constraints);

    }
    return myPanel;
  }

  private ViewContainerComponent getContainerComponent() {
    if (myComponent == null) {
      myComponent = new ViewContainerComponent();
      getRootMapper().attachRoot();
      myComponent.container(getRootMapper().getTarget());
      getDecorationRootMapper().attachRoot();
    }
    return myComponent;

  }

  @Override
  protected void relayoutImpl() {
    super.relayoutImpl();
    getPalette().doLayout();
    getContainerComponent().doLayout();
    getComponent().doLayout();
    Dimension preferredSize = getComponent().getPreferredSize();
    getComponent().setSize(preferredSize);
    setWidth(getComponent().getWidth() + myGapLeft + myGapRight);
    setHeight(getComponent().getHeight());
  }

  @Override
  public void onAdd() {
    super.onAdd();
    getEditor().getCellTracker().addComponentCell(this);
  }

  @Override
  public void onRemove() {
    getEditor().getCellTracker().removeComponentCell(this);
    super.onRemove();
  }

  @Override
  public void setX(int x) {
    getComponent().setLocation(x, getComponent().getY());
    super.setX(x);
  }

  @Override
  public void setY(int y) {
    getComponent().setLocation(getComponent().getX(), y);
    super.setY(y);
  }

  @Override
  public void moveTo(int x, int y) {
    super.moveTo(x, y);
    getComponent().setLocation(myX, myY);
  }

  @Override
  public boolean isDrawBorder() {
    return false;
  }

  public DiagramCell.DiagramPalette getPalette() {
    if (myPalettePanel == null) {
      myPalettePanel = new DiagramCell.DiagramPalette();
    }
    return myPalettePanel;
  }

  private ViewTrait getEventHandlingTrate() {
    this.myHandlingTrait = new ViewTraitBuilder().on(ViewEvents.MOUSE_PRESSED, new ViewEventHandler<MouseEvent>() {
      public void handle(View view, MouseEvent event) {
        if (view.focused().get()) {
          hidePatternEditor();
        } else {
          view.container().focusedView().set(view);
        }
        View viewUnderMouse = view.viewAt(event.location());
        if (viewUnderMouse != getRootMapper().getTarget().root()) {
          return;
        }
        createNewDiagramElement(event.x(), event.y());
        event.consume();
      }
    }).on(ViewEvents.KEY_PRESSED, new ViewEventHandler<KeyEvent>() {
      public void handle(View view, KeyEvent event) {
        if (mySubstituteEditorVisible) {
          getEditor().processKeyPressed(getAWTKeyEvent(event, false));
          event.consume();
          return;
        }

        if (event.key() == Key.ESCAPE) {
          view.container().focusedView().set(null);
          event.consume();
        }
      }
    }).on(ViewEvents.KEY_TYPED, new ViewEventHandler<KeyEvent>() {
      public void handle(View view, KeyEvent event) {
        if (!(mySubstituteEditorVisible)) {
          return;
        }
        getEditor().processKeyTyped(getAWTKeyEvent(event, false));
        event.consume();
      }
    }).build();
    return this.myHandlingTrait;
  }

  public void createNewDiagramElement(int x, int y) {
    myPatternEditorX = x;
    myPatternEditorY = y;
    if (trySubstituteImmediately()) {
      return;
    }
    getEditor().activateNodeSubstituteChooser(this, false);
  }

  private boolean trySubstituteImmediately() {
    List<SubstituteAction> matchingActions = getSubstituteInfo().getMatchingActions("", false);
    if (matchingActions.size() == 0) {
      hideConnectionDragFeedback();
      return true;
    }
    if (matchingActions.size() > 1) {
      return false;
    }
    final SubstituteAction theAction = matchingActions.get(0);
    final boolean[] result = new boolean[]{false};
    getContext().getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        result[0] = theAction.canSubstitute("");
      }
    });
    if (!(result[0])) {
      return false;
    }
    ModelAccess.instance().executeCommand(new Runnable() {
      public void run() {
        theAction.substitute(getContext(), "");
      }
    }, getOperationContext().getProject());
    hideConnectionDragFeedback();
    return true;
  }

  private void hidePatternEditor() {
    getEditor().getNodeSubstituteChooser().setVisible(false);
  }

  public SubstituteInfoPartExt createNewDiagramNodeActions(final SNode container, final SNode childNodeConcept, final SNode containingLink, final _FunctionTypes._void_P3_E0<? super SNode, ? super Integer, ? super Integer> setNodePositionCallback) {
    return new SubstituteInfoPartExt() {
      public List<SubstituteAction> createActions(CellContext cellContext, EditorContext editorContext) {
        List<SubstituteAction> result = new ArrayList<SubstituteAction>();
        for (SubstituteAction action : ListSequence.fromList(ModelActions.createChildNodeSubstituteActions(container, null, childNodeConcept, new DefaultChildNodeSetter(containingLink), editorContext.getOperationContext()))) {
          result.add(new NodeSubstituteActionWrapper(action) {
            @Override
            public boolean canSubstitute(String string) {
              return !(hasConnectionDragFeedback()) && super.canSubstitute(string);
            }

            @Override
            public SNode substitute(@Nullable EditorContext context, String string) {
              SNode result = super.substitute(context, string);
              setNodePositionCallback.invoke(result, myPatternEditorX, myPatternEditorY);
              return result;
            }
          });
        }
        return result;
      }
    };
  }

  public SubstituteInfoPartExt createNewDiagramConnectorActions(final SNode container, final SNode childNodeConcept, final SNode containingLink, final _FunctionTypes._return_P4_E0<? extends Boolean, ? super SNode, ? super Object, ? super SNode, ? super Object> canCreateConnector, final _FunctionTypes._void_P5_E0<? super SNode, ? super SNode, ? super Object, ? super SNode, ? super Object> setConnectorCallback) {
    // TMP solution: manually creating instance of connection instead of using 
    // ModelActions.createChildNodeSubstituteActions() because of mbeddr reqirements: 
    // hiding text-specific connection substitute actions from the diagram 
    return new SubstituteInfoPartExt() {
      public List<SubstituteAction> createActions(CellContext cellContext, final EditorContext editorContext) {
        AbstractNodeSubstituteAction action = new AbstractNodeSubstituteAction(childNodeConcept, childNodeConcept, container) {
          @Override
          public boolean canSubstitute(String string) {
            if (!(hasConnectionDragFeedback()) || !(super.canSubstitute(string))) {
              return false;
            }

            DiagramCell.ConnectionInfo connectionInfo = new DiagramCell.ConnectionInfo();
            return connectionInfo.isValid() && canCreateConnector.invoke(connectionInfo.getFromNode(), connectionInfo.getFromId(), connectionInfo.getFromNode(), connectionInfo.getFromId());
          }

          @Override
          protected SNode doSubstitute(@Nullable EditorContext context, String string) {
            SNode result = NodeFactoryManager.createNode(childNodeConcept, null, container, SNodeOperations.getModel(container));
            ListSequence.fromList(SNodeOperations.getChildren(container, containingLink)).addElement(result);
            DiagramCell.ConnectionInfo connectionInfo = new DiagramCell.ConnectionInfo();
            setConnectorCallback.invoke(result, connectionInfo.getFromNode(), connectionInfo.getFromId(), connectionInfo.getToNode(), connectionInfo.getToId());
            return result;
          }
        };
        return Collections.<SubstituteAction>singletonList(new DiagramCell.DiagramSubstituteActionWraper(action, DiagramCell.ActionType.CONNECTOR));
      }
    };
  }




  @Override
  public SubstituteInfo getSubstituteInfo() {
    if (myPalettePanel.isActive()) {
      return myPalettePanel.getSubstituteInfo();
    }
    return super.getSubstituteInfo();
  }



  @Override
  public NodeSubstitutePatternEditor createSubstitutePatternEditor() {
    return new NodeSubstitutePatternEditor() {
      @Override
      public void activate(Window window, Point point, Dimension dimension) {
        Dimension actualDimension = new Dimension(100, 0);
        point.translate(myPatternEditorX, myPatternEditorY);
        super.activate(window, point, actualDimension);
        mySubstituteEditorVisible = true;
      }

      @Override
      public void done() {
        super.done();
        hideConnectionDragFeedback();
        mySubstituteEditorVisible = false;
      }
    };
  }

  private java.awt.event.KeyEvent getAWTKeyEvent(KeyEvent jetPadKeyEvent, boolean isTyped) {
    // TODO: better integration with MPS substitute editor is required here 
    int id = (isTyped ? java.awt.event.KeyEvent.KEY_TYPED : java.awt.event.KeyEvent.KEY_PRESSED);
    long when = System.currentTimeMillis();
    int modifiers = 0;
    if (jetPadKeyEvent.has(ModifierKey.ALT)) {
      modifiers |= java.awt.event.KeyEvent.ALT_MASK;
    }
    if (jetPadKeyEvent.has(ModifierKey.CONTROL)) {
      modifiers |= java.awt.event.KeyEvent.CTRL_MASK;
    }
    if (jetPadKeyEvent.has(ModifierKey.META)) {
      modifiers |= java.awt.event.KeyEvent.META_MASK;
    }
    if (jetPadKeyEvent.has(ModifierKey.SHIFT)) {
      modifiers |= java.awt.event.KeyEvent.SHIFT_MASK;
    }
    int keyCode;
    switch (jetPadKeyEvent.key()) {
      case ESCAPE:
        keyCode = java.awt.event.KeyEvent.VK_ESCAPE;
        break;
      case SPACE:
        keyCode = java.awt.event.KeyEvent.VK_SPACE;
        break;
      case BACKSPACE:
        keyCode = java.awt.event.KeyEvent.VK_BACK_SPACE;
        break;
      case DELETE:
        keyCode = java.awt.event.KeyEvent.VK_DELETE;
        break;
      case LEFT:
        keyCode = java.awt.event.KeyEvent.VK_LEFT;
        break;
      case RIGHT:
        keyCode = java.awt.event.KeyEvent.VK_RIGHT;
        break;
      case UP:
        keyCode = java.awt.event.KeyEvent.VK_UP;
        break;
      case DOWN:
        keyCode = java.awt.event.KeyEvent.VK_DOWN;
        break;
      case ENTER:
        keyCode = java.awt.event.KeyEvent.VK_ENTER;
        break;
      default:
        keyCode = 0;
    }
    return new java.awt.event.KeyEvent(getComponent(), id, when, modifiers, keyCode, jetPadKeyEvent.keyChar());
  }

  public Mapper<SNode, ViewContainer> getRootMapper() {
    if (myRootMapper == null) {
      myRootMapper = new Mapper<SNode, ViewContainer>(getSNode(), createViewContainer()) {
        @Override
        protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
          super.registerSynchronizers(configuration);

          configuration.add(Synchronizers.forConstantRole(this, getSource(), getTarget().contentRoot().children(), DiagramCell.this));
        }
      };
    }
    return myRootMapper;
  }



  public Mapper<SNode, ViewContainer> getDecorationRootMapper() {
    if (myDecorationRootMapper == null) {
      myDecorationRootMapper = new Mapper<SNode, ViewContainer>(getSNode(), getRootMapper().getTarget()) {
        @Override
        protected void registerSynchronizers(Mapper.SynchronizersConfiguration configuration) {
          super.registerSynchronizers(configuration);
          configuration.add(Synchronizers.forConstantRole(this, getSource(), getTarget().decorationRoot().children(), new MapperFactory<SNode, View>() {
            public Mapper<? extends SNode, ? extends View> createMapper(SNode source) {
              return createDecorationMapper(source);
            }
          }));
        }
      };
    }
    return myDecorationRootMapper;
  }



  public abstract Mapper<SNode, DiagramDecoratorView> createDecorationMapper(SNode node);



  private ViewContainer createViewContainer() {
    ViewContainer result = new ViewContainer();
    result.root().focusable().set(true);
    result.root().focused().addHandler(new EventHandler<PropertyChangeEvent<Boolean>>() {
      public void onEvent(PropertyChangeEvent<Boolean> focused) {
        if (!(focused.getNewValue())) {
          hidePatternEditor();
        }
      }
    });
    result.root().addTrait(RootTrait.ROOT_TRAIT);
    result.root().addTrait(getEventHandlingTrate());
    return result;
  }

  public boolean hasConnectionDragFeedback() {
    return !(myConnectionSingleList.isEmpty());
  }

  public PolyLineConnection showConnectionDragFeedback(View fromView) {
    assert myConnectionSingleList.isEmpty();
    PolyLineConnection connection = new PolyLineConnection();
    connection.fromView().set(fromView);
    myConnectionSingleList.setItem(connection);
    return connection;
  }

  public void updateConnectionDragFeedback(Vector toLocation) {
    View targetView = getRootMapper().getTarget().contentRoot().viewAt(toLocation);
    while (targetView != null && targetView.prop(JetpadUtils.CONNECTABLE).get() == null) {
      targetView = targetView.parent().get();
    }
    if (targetView != null && targetView.prop(JetpadUtils.CONNECTABLE).get()) {
      myConnectionSingleList.getItem().toView().set(targetView);
    } else {
      myConnectionSingleList.getItem().toView().set(null);
    }
    myConnectionSingleList.getItem().toLocation().set(toLocation);
  }

  private void hideConnectionDragFeedback() {
    myConnectionSingleList.setItem(null);
  }

  protected void syncDiagramElements(Iterable<SNode> elements, ListIterator<SNode> blocksIterator, Set<SNode> existingBlocks, ListIterator<SNode> connectorsIterator, Set<SNode> existingConnectors) {
    for (SNode nextElement : Sequence.fromIterable(elements)) {
      EditorCell cell = getContext().createNodeCell(nextElement);
      if (!(cell instanceof BlockCell) && !(cell instanceof ConnectorCell)) {
        continue;
      }
      syncToNextNode((cell instanceof BlockCell ? blocksIterator : connectorsIterator), (cell instanceof BlockCell ? existingBlocks : existingConnectors), nextElement, cell);
    }
  }

  private class ConnectionInfo {


    public ConnectionInfo() {
      PolyLineConnection connectionDragFeedback = myConnectionSingleList.getItem();
      if (connectionDragFeedback == null) {
        return;
      }

      View fromView = connectionDragFeedback.fromView().get();
      View toView = connectionDragFeedback.toView().get();
      if (fromView == null || toView == null) {
        return;
      }

      setFromNode(fromView.prop(JetpadUtils.SOURCE).get());
      setFromId(fromView.prop(JetpadUtils.ID).get());
      setToNode(toView.prop(JetpadUtils.SOURCE).get());
      setToId(toView.prop(JetpadUtils.ID).get());
    }

    public boolean isValid() {
      return myFromNode != null && myToNode != null;
    }

    private SNode myFromNode;

    public SNode getFromNode() {
      return this.myFromNode;
    }

    private void setFromNode(SNode value) {
      this.myFromNode = value;
    }

    private Object myFromId;

    public Object getFromId() {
      return this.myFromId;
    }

    private void setFromId(Object value) {
      this.myFromId = value;
    }

    private SNode myToNode;

    public SNode getToNode() {
      return this.myToNode;
    }

    private void setToNode(SNode value) {
      this.myToNode = value;
    }

    private Object myToId;

    public Object getToId() {
      return this.myToId;
    }

    private void setToId(Object value) {
      this.myToId = value;
    }
  }

  public class DiagramPalette extends JPanel {
    private JPanel myBlockActionPanel = new JPanel(new GridLayoutManager(1, 1));
    private JPanel myConnectorActionPanel = new JPanel(new GridLayoutManager(1, 1));

    public boolean myIsActive = true;
    private Map<SubstituteAction, ToggleAction> myActionToButtonMap = MapSequence.fromMap(new HashMap<SubstituteAction, ToggleAction>());
    private SubstituteInfo mySubstituteInfo;
    private DefaultActionGroup myBlockActionGroup = new DefaultActionGroup();
    private DefaultActionGroup myConnectorActionGroup = new DefaultActionGroup();

    public DiagramPalette() {
      super(new GridLayoutManager(4, 1));
      GridConstraints constraints = new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_NORTHWEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null);

      add(new JLabel("Blocks"), constraints);
      constraints.setRow(1);
      add(myBlockActionPanel, constraints);

      constraints.setRow(2);
      add(new JLabel("Connectors"), constraints);
      constraints.setRow(3);
      add(myConnectorActionPanel, constraints);
    }



    public void setSubstituteInfo(SubstituteInfo substituteInfo) {
      mySubstituteInfo = substituteInfo;
      update();
    }



    public SubstituteInfo getSubstituteInfo() {
      return mySubstituteInfo;
    }



    public boolean isActive() {
      return myIsActive;
    }




    public SubstituteInfoPartExt createNewDiagramNodeActions(final SNode container, final SNode childNodeConcept, final SNode containingLink, final _FunctionTypes._void_P3_E0<? super SNode, ? super Integer, ? super Integer> setNodePositionCallback) {
      return new SubstituteInfoPartExt() {
        public List<SubstituteAction> createActions(CellContext cellContext, EditorContext editorContext) {
          List<SubstituteAction> result = new ArrayList<SubstituteAction>();
          for (SubstituteAction action : ListSequence.fromList(ModelActions.createChildNodeSubstituteActions(container, null, childNodeConcept, new DefaultChildNodeSetter(containingLink), editorContext.getOperationContext()))) {
            result.add(new DiagramCell.DiagramSubstituteActionWraper(action, DiagramCell.ActionType.BLOCK) {
              @Override
              public boolean canSubstitute(String string) {
                if (!(super.canSubstitute(string))) {
                  return false;
                }
                return isActionEnabled(this) && !(hasConnectionDragFeedback());
              }

              @Override
              public SNode substitute(@Nullable EditorContext context, String string) {
                SNode result = super.substitute(context, string);
                setNodePositionCallback.invoke(result, myPatternEditorX, myPatternEditorY);
                return result;
              }
            });
          }
          return result;
        }
      };
    }

    public SubstituteInfoPartExt createNewDiagramConnectorActions(final SNode container, final SNode childNodeConcept, final SNode containingLink, final _FunctionTypes._return_P4_E0<? extends Boolean, ? super SNode, ? super Object, ? super SNode, ? super Object> canCreateConnector, final _FunctionTypes._void_P5_E0<? super SNode, ? super SNode, ? super Object, ? super SNode, ? super Object> setConnectorCallback) {
      // TMP solution: manually creating instance of connection instead of using 
      // ModelActions.createChildNodeSubstituteActions() because of mbeddr reqirements: 
      // hiding text-specific connection substitute actions from the diagram 
      return new SubstituteInfoPartExt() {
        public List<SubstituteAction> createActions(CellContext cellContext, final EditorContext editorContext) {
          AbstractNodeSubstituteAction action = new AbstractNodeSubstituteAction(childNodeConcept, childNodeConcept, container) {
            @Override
            public boolean canSubstitute(String string) {
              if (!(super.canSubstitute(string))) {
                return false;
              }
              DiagramCell.ConnectionInfo connectionInfo = new DiagramCell.ConnectionInfo();
              return connectionInfo.isValid() && canCreateConnector.invoke(connectionInfo.getFromNode(), connectionInfo.getFromId(), connectionInfo.getToNode(), connectionInfo.getToId()) && hasConnectionDragFeedback();
            }

            @Override
            protected SNode doSubstitute(@Nullable EditorContext context, String string) {
              SNode result = NodeFactoryManager.createNode(childNodeConcept, null, container, SNodeOperations.getModel(container));
              ListSequence.fromList(SNodeOperations.getChildren(container, containingLink)).addElement(result);
              DiagramCell.ConnectionInfo connectionInfo = new DiagramCell.ConnectionInfo();
              setConnectorCallback.invoke(result, connectionInfo.getFromNode(), connectionInfo.getFromId(), connectionInfo.getToNode(), connectionInfo.getToId());
              return result;
            }
          };
          return Collections.<SubstituteAction>singletonList(new DiagramCell.DiagramSubstituteActionWraper(action, DiagramCell.ActionType.CONNECTOR) {
            @Override
            public boolean canSubstitute(String string) {
              return isActionEnabled(this) && super.canSubstitute(string);
            }
          });
        }
      };
    }

    private boolean isActionEnabled(SubstituteAction substituteAction) {
      return check_xnhqai_a0a91xb(MapSequence.fromMap(myActionToButtonMap).get(substituteAction));
    }



    private void updateToggleActions() {
      SubstituteInfo substituteInfo = getSubstituteInfo();
      if (substituteInfo == null) {
        return;
      }
      substituteInfo.invalidateActions();
      for (SubstituteAction action : ListSequence.fromList(((DiagramCompositeSubstituteInfo) mySubstituteInfo).createActions())) {
        ToggleAction substituteButton = null;
        switch (((DiagramCell.DiagramSubstituteActionWraper) action).getType()) {
          case BLOCK:
            substituteButton = new DiagramCell.DiagramPalette.MyToggleAction(action.getMatchingText(""), action.getMatchingText(""), AllIcons.Actions.Refresh, myBlockActionGroup);
            myBlockActionGroup.add(substituteButton);
            break;
          case CONNECTOR:
            substituteButton = new DiagramCell.DiagramPalette.MyToggleAction(action.getMatchingText(""), action.getMatchingText(""), AllIcons.Actions.Refresh, myConnectorActionGroup);
            myConnectorActionGroup.add(substituteButton);
            break;
          default:
        }
        MapSequence.fromMap(myActionToButtonMap).put(action, substituteButton);
      }
    }

    private void update() {
      updateToggleActions();
      GridConstraints gridConstraints = new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null);
      ActionToolbar elementsToolbat = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, myBlockActionGroup, true);
      elementsToolbat.setOrientation(SwingConstants.VERTICAL);
      JComponent blockActionPanel = elementsToolbat.getComponent();
      myBlockActionPanel.removeAll();
      myBlockActionPanel.add(blockActionPanel, gridConstraints);
      ActionToolbar connectorToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, myConnectorActionGroup, true);
      connectorToolbar.setOrientation(SwingConstants.VERTICAL);
      JComponent connectorActionPanel = connectorToolbar.getComponent();
      myConnectorActionPanel.removeAll();
      myConnectorActionPanel.add(connectorActionPanel, gridConstraints);
    }





    private class MyToggleAction extends ToggleAction {
      private boolean myIsSelected;
      private ActionGroup myParentGroup;

      public MyToggleAction(@Nullable String text, @Nullable String description, @Nullable Icon icon, ActionGroup parent) {
        super(text, description, icon);
        myParentGroup = parent;
      }

      public boolean isSelected(AnActionEvent actionEvent) {
        return myIsSelected;
      }

      public void setSelected(AnActionEvent actionEvent, boolean isSelected) {
        myIsSelected = isSelected;
        if (isSelected) {
          for (AnAction action : myParentGroup.getChildren(null)) {
            if (action != this) {
              ((ToggleAction) action).setSelected(null, false);
            }
          }
        }
      }
    }
  }



  private static class DiagramSubstituteActionWraper extends NodeSubstituteActionWrapper {
    private DiagramCell.ActionType myType;

    private DiagramSubstituteActionWraper(SubstituteAction action, DiagramCell.ActionType type) {
      super(action);
      myType = type;
    }

    public DiagramCell.ActionType getType() {
      return myType;
    }
  }

  public static   enum ActionType {
    BLOCK(),
    CONNECTOR();

    ActionType() {
    }
  }



  private static boolean check_xnhqai_a0a91xb(ToggleAction checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isSelected(null);
    }
    return false;
  }
}
