package jetbrains.mps.debugger.java.runtime;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import com.sun.jdi.event.EventSet;
import java.util.Set;
import com.sun.jdi.ObjectReference;
import java.util.HashSet;
import org.jetbrains.annotations.Nullable;
import com.sun.jdi.ThreadReference;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.debugger.java.runtime.execution.DebuggerManagerThread;
import com.sun.jdi.StackFrame;
import java.util.List;
import java.util.Collections;
import com.sun.jdi.IncompatibleThreadStateException;
import com.sun.jdi.request.EventRequest;

public abstract class SuspendContext {
  private static final Logger LOG = Logger.getLogger(SuspendContext.class);

  private final DebugVMEventsProcessor myDebugProcess;
  private final int mySuspendPolicy;
  private final EventSet myEventSet;
  private final Set<ObjectReference> myKeptReferences = new HashSet<ObjectReference>();
  @Nullable
  private ThreadReference myThread;
  /*package*/ boolean myIsVotedForResume = true;
  protected int myVotesToVote;
  private volatile boolean myIsResumed;
  public volatile boolean myInProgress;
  private boolean myIsEvaluating = false;

  /*package*/ SuspendContext(@NotNull DebugVMEventsProcessor debugProcess, int suspendPolicy, int eventVotes, @Nullable EventSet set) {
    myDebugProcess = debugProcess;
    mySuspendPolicy = suspendPolicy;
    myVotesToVote = eventVotes;
    myEventSet = set;
  }

  public void setThread(@Nullable ThreadReference thread) {
    assertNotResumed();
    LOG.assertLog(myThread == null || myThread == thread);
    myThread = thread;
  }

  protected abstract void resumeImpl();

  protected void resume() {
    assertNotResumed();
    DebuggerManagerThread.assertIsManagerThread();
    try {
      resumeImpl();
    } finally {
      myIsResumed = true;
    }
  }

  private void assertNotResumed() {
    if (myIsResumed) {
      if (myDebugProcess.isAttached()) {
        LOG.assertLog(false, "Cannot access SuspendContext. SuspendContext is resumed.");
      }
    }
  }

  @Nullable
  public EventSet getEventSet() {
    assertNotResumed();
    return myEventSet;
  }

  public DebugVMEventsProcessor getDebugProcess() {
    assertNotResumed();
    return myDebugProcess;
  }

  @Nullable
  public StackFrame getFrame() {
    assertNotResumed();
    List<StackFrame> frames = getFrames();
    return (!(frames.isEmpty()) ?
      frames.get(0) :
      null
    );
  }

  @NotNull
  private List<StackFrame> getFrames() {
    assertNotResumed();
    try {
      return (myThread != null ?
        myThread.frames() :
        Collections.<StackFrame>emptyList()
      );
    } catch (IncompatibleThreadStateException e) {
      return Collections.<StackFrame>emptyList();
    }
  }

  @Nullable
  public ThreadReference getThread() {
    return myThread;
  }

  public int getSuspendPolicy() {
    assertNotResumed();
    return mySuspendPolicy;
  }

  public boolean suspends(ThreadReference thread) {
    // if this context suspends a given thread 
    assertNotResumed();
    switch (getSuspendPolicy()) {
      case EventRequest.SUSPEND_ALL:
        return true;
      case EventRequest.SUSPEND_EVENT_THREAD:
        return thread == getThread();
      default:
    }
    return false;
  }

  public boolean isResumed() {
    return myIsResumed;
  }

  public void setIsEvaluating(boolean b) {
    myIsEvaluating = b;
  }

  public boolean isEvaluating() {
    return myIsEvaluating;
  }
}
