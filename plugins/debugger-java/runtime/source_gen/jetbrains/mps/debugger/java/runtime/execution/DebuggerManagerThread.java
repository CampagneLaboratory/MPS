package jetbrains.mps.debugger.java.runtime.execution;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.util.Alarm;
import com.sun.jdi.VMDisconnectedException;

public class DebuggerManagerThread implements IDebuggerManagerThread {
  private static final Logger LOG = Logger.getLogger(DebuggerManagerThread.class);

  private final DebuggerCommandQueue myCommandQueue;
  private volatile DebuggerManagerThread.WorkerThread myWorkerThread;

  public DebuggerManagerThread() {
    myCommandQueue = new DebuggerCommandQueue();
    startNewWorkerThread();
  }

  private void startNewWorkerThread() {
    myWorkerThread = new DebuggerManagerThread.WorkerThread();
    myWorkerThread.start();
  }

  @Override
  public void invokeAndWait(@NotNull IDebuggerCommand command) {
    LOG.assertLog(!(ApplicationManager.getApplication().isDispatchThread()));
    LOG.assertLog(!(DebuggerManagerThread.isManagerThread()), "Should be invoked outside manager thread, use DebuggerManagerThreadImpl.getInstance(..).invoke...");
    invokeAndWaitInternal(command);
  }

  @Override
  public void invoke(@NotNull IDebuggerCommand command) {
    if (DebuggerManagerThread.isManagerThread()) {
      processCommand(command);
    } else {
      schedule(command);
    }
  }

  @Override
  public void invokeTerminalCommand(@NotNull IDebuggerCommand command) {
    final IDebuggerCommand currentCommand = myCommandQueue.getCurrentCommand();

    if (DebuggerManagerThread.isManagerThread()) {
      processCommand(command);
    } else {
      scheduleFirst(command);
    }

    Alarm alarm = new Alarm(Alarm.ThreadToUse.SHARED_THREAD);
    alarm.addRequest(new Runnable() {
      @Override
      public void run() {
        if (myCommandQueue.getCurrentCommand() == currentCommand) {
          //  hanged 
          myWorkerThread.interrupt();
          startNewWorkerThread();

          // this code only works when there is a hanged command already => user can stop debugger 
          // if there is some potentially long command in the queue we cant help it 
        }
      }
    }, IDebuggerManagerThread.COMMAND_TIMEOUT);
    //  in idea they also deal with case in which current command takes to long to execute 
    //  see DebuggerManagerThreadImpl.terminateAndInvoke 
    //  thanks god the comment above exists 
  }

  @Override
  public void scheduleFirst(@NotNull IDebuggerCommand command) {
    if (myCommandQueue.isClosed()) {
      command.notifyCancelled();
    } else {
      scheduleFirstInternal(command);
    }
  }

  @Override
  public void schedule(@NotNull IDebuggerCommand command) {
    if (myCommandQueue.isClosed()) {
      command.notifyCancelled();
    } else {
      scheduleInternal(command);
    }
  }

  private void scheduleFirstInternal(@NotNull IDebuggerCommand command) {
    LOG.debug("scheduleFirst " + command + " in " + this);
    myCommandQueue.pushBack(command, command.getPriority().ordinal());
  }

  private void scheduleInternal(@NotNull IDebuggerCommand command) {
    LOG.debug("schedule " + command + " in " + this);
    myCommandQueue.put(command, command.getPriority().ordinal());
  }

  public void close() {
    myCommandQueue.close();
    LOG.debug("Closing evaluation");
  }

  private void invokeAndWaitInternal(@NotNull IDebuggerCommand command) {
    command.hold();
    schedule(command);
    command.waitFor();
  }

  private void processCommand(@NotNull IDebuggerCommand command) {
    DebuggerManagerThread.assertIsManagerThread();
    try {
      if (myCommandQueue.isClosed()) {
        command.notifyCancelled();
      } else {
        command.run();
      }
    } catch (VMDisconnectedException e) {
      LOG.debug("", e);
    } catch (RuntimeException e) {
      throw e;
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    } catch (Exception e) {
      LOG.error(e);
    }
  }

  public static boolean isManagerThread() {
    return Thread.currentThread() instanceof DebuggerManagerThread.WorkerThread;
  }

  public static void assertIsManagerThread() {
    LOG.assertLog(DebuggerManagerThread.isManagerThread(), "Should be invoked in manager thread, use DebuggerManagerThreadImpl.getInstance(..).invoke...");
  }

  private class WorkerThread extends Thread {
    private WorkerThread() {
      super("Debug Manager Thread");
    }

    @Override
    public void run() {
      DebuggerManagerThread.LOG.debug("Worker thread started.");
      while (true) {
        try {
          processCommand(myCommandQueue.get());
        } catch (VMDisconnectedException e) {
          //  todo if not this exception this code could be in debug-api 
          break;
        } catch (DebuggerCommandQueueClosedException e) {
          break;
        } catch (RuntimeException e) {
          if (e.getCause() instanceof InterruptedException) {
            break;
          }
          DebuggerManagerThread.LOG.error(e);
        }
      }
      DebuggerManagerThread.LOG.debug("Worker thread " + this.toString() + " exited");
    }
  }
}
