package jetbrains.mps.debugger.java.runtime.evaluation.container;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.generator.generationTypes.InMemoryJavaGenerationHandler;
import jetbrains.mps.debugger.java.api.evaluation.EvaluationException;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.messages.IMessageHandler;
import com.intellij.openapi.progress.util.ProgressWindow;
import jetbrains.mps.generator.GenerationFacade;
import java.util.Collections;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.generator.GenerationOptions;
import jetbrains.mps.ide.generator.TransientModelsComponent;
import com.intellij.openapi.util.Disposer;
import java.lang.reflect.InvocationTargetException;
import jetbrains.mps.debugger.java.api.evaluation.InvocationTargetEvaluationException;
import jetbrains.mps.compiler.CompilationResultAdapter;
import org.eclipse.jdt.internal.compiler.CompilationResult;
import org.eclipse.jdt.core.compiler.CategorizedProblem;
import jetbrains.mps.generator.IncrementalGenerationStrategy;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.generator.GenerationCacheContainer;
import jetbrains.mps.generator.impl.dependencies.GenerationDependencies;
import jetbrains.mps.ide.messages.DefaultMessageHandler;
import jetbrains.mps.messages.IMessage;
import jetbrains.mps.messages.MessageKind;

public class GeneratorUtil {
  @Nullable
  public static Class generateAndLoadEvaluatorClass(Project ideaProject, SModelDescriptor modelDescriptor, String className, IOperationContext context, boolean developerMode, InMemoryJavaGenerationHandler handler, ClassLoader parentloader) throws EvaluationException {
    try {

      final String fullClassName = SNodeOperations.getModelLongName(modelDescriptor) + "." + className;
      GeneratorUtil.MyCompilationResultAdapter compilationResult = new GeneratorUtil.MyCompilationResultAdapter();
      handler.setCompilationListener(compilationResult);
      IMessageHandler messageHandler = new GeneratorUtil.MyMessageHandler(ideaProject, developerMode);
      ProgressWindow progressWindow = new ProgressWindow(false, ideaProject);
      boolean successful = GenerationFacade.generateModels(context.getProject(), Collections.singletonList(modelDescriptor), context, handler, new ProgressMonitorAdapter(progressWindow), messageHandler, GenerationOptions.getDefaults().incremental(new GeneratorUtil.MyIncrementalGenerationStrategy()).saveTransientModels(developerMode).rebuildAll(false).reporting(false, false, false, 0).create(), context.getProject().getComponent(TransientModelsComponent.class));

      Disposer.dispose(progressWindow);

      String source = handler.getSources().get(fullClassName);

      if (successful && (source != null && source.length() > 0)) {
        if (developerMode) {
          System.err.println("[Generated text]\n" + source + "\n[Generated text]");
        }
        return Class.forName(fullClassName, true, handler.getCompiler().getClassLoader(parentloader));
      } else if ((source != null && source.length() > 0) && !(successful)) {
        String text = "Errors during compilation";
        if (compilationResult.hasErrors()) {
          text += ":\n" + compilationResult.getMessage();
        } else {
          text += ".";
        }
        throw new EvaluationException(text);
      } else {
        throw new EvaluationException("Errors during generation.");
      }
    } catch (EvaluationException e) {
      throw e;
    } catch (ClassNotFoundException e) {
      throw new EvaluationException(e);
    }
  }

  public static <E> E createInstance(Class clazz, Class[] parameterClasses, Object[] parameters) throws EvaluationException {
    try {
      return (E) clazz.getConstructor(parameterClasses).newInstance(parameters);
    } catch (InvocationTargetException e) {
      throw new InvocationTargetEvaluationException(e.getCause());
    } catch (NoSuchMethodException e) {
      throw new EvaluationException(e);
    } catch (IllegalAccessException e) {
      throw new EvaluationException(e);
    } catch (InstantiationException e) {
      throw new EvaluationException(e);
    }
  }

  private static class MyCompilationResultAdapter extends CompilationResultAdapter {
    private final StringBuffer myBuffer = new StringBuffer();
    private boolean myHasErrors;

    public MyCompilationResultAdapter() {
    }

    @Override
    public void onCompilationResult(CompilationResult result) {
      if (result.hasErrors()) {
        myHasErrors = true;
        for (CategorizedProblem error : result.getErrors()) {
          myBuffer.append(error.getMessage());
          myBuffer.append("\n");
        }
      }
    }

    public boolean hasErrors() {
      return myHasErrors;
    }

    public String getMessage() {
      return myBuffer.toString();
    }
  }

  private static class MyIncrementalGenerationStrategy implements IncrementalGenerationStrategy {
    public MyIncrementalGenerationStrategy() {
    }

    @Override
    public Map<String, String> getModelHashes(SModel p0, IOperationContext p1) {
      return Collections.emptyMap();
    }

    @Override
    public GenerationCacheContainer getContainer() {
      return null;
    }

    @Override
    public GenerationDependencies getDependencies(SModel p0) {
      return null;
    }

    @Override
    public boolean isIncrementalEnabled() {
      return false;
    }
  }

  private static class MyMessageHandler implements IMessageHandler {
    private final DefaultMessageHandler myInternalHandler;
    private final boolean myDeveloperMode;

    private MyMessageHandler(Project project, boolean developerMode) {
      myInternalHandler = new DefaultMessageHandler(project);
      myDeveloperMode = developerMode;
    }

    @Override
    public void handle(IMessage message) {
      if (myDeveloperMode && message.getKind().equals(MessageKind.ERROR)) {
        System.err.println("[Generation error]" + message.getText());
      }
      myInternalHandler.handle(message);
    }

    @Override
    public void clear() {
      myInternalHandler.clear();
    }
  }
}
