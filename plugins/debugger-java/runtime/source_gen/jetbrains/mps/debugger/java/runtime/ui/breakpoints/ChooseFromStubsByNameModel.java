package jetbrains.mps.debugger.java.runtime.ui.breakpoints;

/*Generated by MPS */

import com.intellij.ide.util.gotoByName.ChooseByNameModel;
import java.util.Map;
import java.util.List;
import org.jetbrains.mps.openapi.persistence.indexing.NodeDescriptor;
import java.util.LinkedHashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.workbench.goTo.navigation.GotoNavigationUtil;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.generator.JavaModelUtil_new;
import jetbrains.mps.smodel.SModelReference;
import javax.swing.ListCellRenderer;
import com.intellij.ide.ui.ListCellRendererWrapper;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JList;
import org.jetbrains.annotations.NotNull;

/*package*/ abstract class ChooseFromStubsByNameModel implements ChooseByNameModel {
  private final Map<String, List<NodeDescriptor>> myPossibleNodes = new LinkedHashMap<String, List<NodeDescriptor>>();

  /*package*/ ChooseFromStubsByNameModel(final Project p) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        List<SModelDescriptor> mds = SModelRepository.getInstance().getModelDescriptors();
        Iterable<SModelDescriptor> stubModels = ListSequence.fromList(mds).where(new IWhereFilter<SModelDescriptor>() {
          public boolean accept(SModelDescriptor it) {
            return SModelStereotype.isStubModelStereotype(it.getStereotype());
          }
        });
        Iterable<NodeDescriptor> descr = GotoNavigationUtil.getNodeElements(stubModels, p);

        for (NodeDescriptor descriptor : descr) {
          String name = getName(descriptor);
          List<NodeDescriptor> descriptorList = myPossibleNodes.get(name);
          if (descriptorList == null) {
            descriptorList = new ArrayList<NodeDescriptor>();
            myPossibleNodes.put(name, descriptorList);
          }
          descriptorList.add(descriptor);
        }
      }
    });
  }

  protected abstract boolean isValid(SNode node);

  private boolean isValidClassifier(final NodeDescriptor descriptor) {
    final Wrappers._boolean result = new Wrappers._boolean();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        SNode classifier = JavaModelUtil_new.findClassifier(getNamespace(descriptor), getName(descriptor), true);
        result.value = (classifier != null) && isValid(classifier);
      }
    });
    return result.value;
  }

  private String getName(NodeDescriptor descriptor) {
    return descriptor.getName();
  }

  private String getNamespace(NodeDescriptor descriptor) {
    SModelReference modelReference = ((SModelReference) descriptor.getNodeReference().getModelReference());
    if (modelReference != null) {
      return modelReference.getLongName();
    }
    return null;
  }

  @Override
  public String getPromptText() {
    return null;
  }

  @Override
  public String getNotInMessage() {
    return null;
  }

  @Override
  public String getNotFoundMessage() {
    return null;
  }

  @Override
  public String getCheckBoxName() {
    return null;
  }

  @Override
  public char getCheckBoxMnemonic() {
    return (char) 0;
  }

  @Override
  public boolean loadInitialCheckBoxState() {
    return false;
  }

  @Override
  public void saveInitialCheckBoxState(boolean state) {
  }

  @Override
  public ListCellRenderer getListCellRenderer() {
    ListCellRendererWrapper wrapper = new ListCellRendererWrapper<Object>(new DefaultListCellRenderer()) {
      @Override
      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {
        if (value != null && value instanceof NodeDescriptor) {
          String fullName = getFullName(value);
          if (fullName != null) {
            setText(fullName);
          }
        }
      }
    };
    return wrapper;
  }

  @Override
  public String[] getNames(boolean checkBoxState) {
    return myPossibleNodes.keySet().toArray(new String[myPossibleNodes.size()]);
  }

  @Override
  public Object[] getElementsByName(String name, boolean checkBoxState, String pattern) {
    List<NodeDescriptor> descriptors = new ArrayList<NodeDescriptor>();
    for (NodeDescriptor descriptor : myPossibleNodes.get(name)) {
      String descriptorName = getElementName(descriptor);
      if (descriptorName != null && descriptorName.equals(name) && isValidClassifier(descriptor)) {
        descriptors.add(descriptor);
      }
    }
    return descriptors.toArray(new NodeDescriptor[descriptors.size()]);
  }

  @Override
  public String getElementName(Object element) {
    return getName((NodeDescriptor) element);
  }

  @NotNull
  @Override
  public String[] getSeparators() {
    return new String[]{"."};
  }

  @Override
  public String getFullName(Object element) {
    String name = getName((NodeDescriptor) element);
    String namespace = getNamespace((NodeDescriptor) element);
    if (namespace == null) {
      return name;
    }
    return namespace + "." + name;
  }

  @Override
  public String getHelpId() {
    return null;
  }

  @Override
  public boolean useMiddleMatching() {
    return true;
  }
}
