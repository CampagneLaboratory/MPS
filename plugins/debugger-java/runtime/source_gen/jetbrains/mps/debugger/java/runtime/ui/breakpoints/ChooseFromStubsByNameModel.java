package jetbrains.mps.debugger.java.runtime.ui.breakpoints;

/*Generated by MPS */

import com.intellij.ide.util.gotoByName.ChooseByNameModel;
import java.util.Map;
import java.util.List;
import org.jetbrains.mps.openapi.persistence.NavigationParticipant;
import java.util.LinkedHashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.workbench.goTo.navigation.GotoNavigationUtil;
import jetbrains.mps.ide.findusages.model.scopes.ModelsScope;
import jetbrains.mps.progress.EmptyProgressMonitor;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.generator.JavaModelUtil_new;
import org.jetbrains.mps.openapi.model.SModelReference;
import javax.swing.ListCellRenderer;
import com.intellij.ide.ui.ListCellRendererWrapper;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JList;
import org.jetbrains.annotations.NotNull;

/*package*/ abstract class ChooseFromStubsByNameModel implements ChooseByNameModel {
  private final Map<String, List<NavigationParticipant.NavigationTarget>> myPossibleNodes = new LinkedHashMap<String, List<NavigationParticipant.NavigationTarget>>();

  /*package*/ ChooseFromStubsByNameModel(Project p) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        List<SModel> mds = SModelRepository.getInstance().getModelDescriptors();
        Iterable<SModel> stubModels = ListSequence.fromList(mds).where(new IWhereFilter<SModel>() {
          public boolean accept(SModel it) {
            return SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(it));
          }
        });
        Iterable<NavigationParticipant.NavigationTarget> descr = GotoNavigationUtil.getNavigationTargets(NavigationParticipant.TargetKind.ROOT, new ModelsScope(stubModels), new EmptyProgressMonitor());

        for (NavigationParticipant.NavigationTarget descriptor : descr) {
          String name = getName(descriptor);
          List<NavigationParticipant.NavigationTarget> descriptorList = myPossibleNodes.get(name);
          if (descriptorList == null) {
            descriptorList = new ArrayList<NavigationParticipant.NavigationTarget>();
            myPossibleNodes.put(name, descriptorList);
          }
          descriptorList.add(descriptor);
        }
      }
    });
  }

  protected abstract boolean isValid(SNode node);

  private boolean isValidClassifier(final NavigationParticipant.NavigationTarget descriptor) {
    final Wrappers._boolean result = new Wrappers._boolean();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        SNode classifier = JavaModelUtil_new.findClassifier(getNamespace(descriptor), getName(descriptor), true);
        result.value = (classifier != null) && isValid(classifier);
      }
    });
    return result.value;
  }

  private String getName(NavigationParticipant.NavigationTarget descriptor) {
    return descriptor.getPresentation();
  }

  private String getNamespace(NavigationParticipant.NavigationTarget descriptor) {
    SModelReference modelReference = ((jetbrains.mps.smodel.SModelReference) descriptor.getNodeReference().getModelReference());
    if (modelReference != null) {
      return SModelStereotype.withoutStereotype(modelReference.getModelName());
    }
    return null;
  }

  @Override
  public String getPromptText() {
    return null;
  }

  @Override
  public String getNotInMessage() {
    return null;
  }

  @Override
  public String getNotFoundMessage() {
    return null;
  }

  @Override
  public String getCheckBoxName() {
    return null;
  }

  @Override
  public char getCheckBoxMnemonic() {
    return (char) 0;
  }

  @Override
  public boolean loadInitialCheckBoxState() {
    return false;
  }

  @Override
  public void saveInitialCheckBoxState(boolean state) {
  }

  @Override
  public ListCellRenderer getListCellRenderer() {
    ListCellRendererWrapper wrapper = new ListCellRendererWrapper<Object>(new DefaultListCellRenderer()) {
      @Override
      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {
        if (value != null && value instanceof NavigationParticipant.NavigationTarget) {
          String fullName = getFullName(value);
          if (fullName != null) {
            setText(fullName);
          }
        }
      }
    };
    return wrapper;
  }

  @Override
  public String[] getNames(boolean checkBoxState) {
    return myPossibleNodes.keySet().toArray(new String[myPossibleNodes.size()]);
  }

  @Override
  public Object[] getElementsByName(String name, boolean checkBoxState, String pattern) {
    List<NavigationParticipant.NavigationTarget> descriptors = new ArrayList<NavigationParticipant.NavigationTarget>();
    for (NavigationParticipant.NavigationTarget descriptor : myPossibleNodes.get(name)) {
      String descriptorName = getElementName(descriptor);
      if (descriptorName != null && descriptorName.equals(name) && isValidClassifier(descriptor)) {
        descriptors.add(descriptor);
      }
    }
    return descriptors.toArray(new NavigationParticipant.NavigationTarget[descriptors.size()]);
  }

  @Override
  public String getElementName(Object element) {
    return getName((NavigationParticipant.NavigationTarget) element);
  }

  @NotNull
  @Override
  public String[] getSeparators() {
    return new String[]{"."};
  }

  @Override
  public String getFullName(Object element) {
    NavigationParticipant.NavigationTarget navTarget = (NavigationParticipant.NavigationTarget) element;
    String name = getName(navTarget);
    String namespace = getNamespace(navTarget);
    if (namespace == null) {
      return name;
    }
    return namespace + "." + name;
  }

  @Override
  public String getHelpId() {
    return null;
  }

  @Override
  public boolean useMiddleMatching() {
    return true;
  }
}
