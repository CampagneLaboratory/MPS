package jetbrains.mps.debugger.java.runtime.events;

/*Generated by MPS */

import com.sun.jdi.VirtualMachine;
import java.util.concurrent.atomic.AtomicInteger;
import jetbrains.mps.debugger.java.runtime.RequestManager;
import com.sun.jdi.event.ClassPrepareEvent;
import com.sun.jdi.event.StepEvent;
import com.sun.jdi.request.EventRequest;
import com.sun.jdi.request.StepRequest;
import jetbrains.mps.debugger.java.runtime.requests.StepRequestor;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.event.LocatableEvent;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.sun.jdi.event.EventQueue;
import com.sun.jdi.event.EventSet;
import com.sun.jdi.event.Event;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import com.sun.jdi.event.VMDeathEvent;
import com.sun.jdi.event.VMDisconnectEvent;

public class EventsProcessor {
  protected static final int STATE_INITIAL = 0;
  protected static final int STATE_ATTACHED = 1;
  protected static final int STATE_DETACHING = 2;
  protected static final int STATE_DETACHED = 3;

  private final DebuggerManagerThread myManagerThread = new DebuggerManagerThread();
  private EventsProcessor.EventProcessorRunnable myRunnable = new EventsProcessor.EventProcessorRunnable();
  private VirtualMachine myVirtualMachine;
  protected final AtomicInteger myState = new AtomicInteger(STATE_INITIAL);
  private RequestManager myRequestManager;
  private final ContextManager myContextManager = new ContextManager();

  public EventsProcessor() {
  }

  private void processVmDeathEvent() {
    if (myRunnable != null) {
      myRunnable.stop();
      myRunnable = null;
    }

    if (myState.compareAndSet(STATE_INITIAL, STATE_DETACHING) || myState.compareAndSet(STATE_ATTACHED, STATE_DETACHING)) {
      myVirtualMachine = null;
      myManagerThread.close();
      myState.set(STATE_DETACHED);

      // todo fire detached 
    }
  }

  private void processClassPrepareEvent(EventContext context, ClassPrepareEvent event) {
    myRequestManager.processClassPrepared(event);
    myContextManager.resume(context);
  }

  private void processStepEvent(EventContext context, StepEvent event) {
    myRequestManager.deleteStepRequests();
    EventRequest request = event.request();
    if (request instanceof StepRequest) {
      StepRequest stepRequest = (StepRequest) request;
      StepRequestor requestor = (StepRequestor) myRequestManager.findRequestor(stepRequest);
      int nextStep = requestor.nextStep(event);
      if (nextStep == StepRequestor.STOP) {
        myContextManager.pause(context);
        return;
      } else {
        addNewStepRequest(requestor, nextStep, event.thread(), context.getSuspendPolicy());
      }
    }
    myContextManager.resume(context);
  }

  private void addNewStepRequest(StepRequestor stepRequestor, int stepType, ThreadReference threadReference, int suspendPolicy) {
    StepRequest stepRequest = myRequestManager.createStepRequest(stepRequestor, stepType, threadReference, suspendPolicy);
    //  TODO request filters should be configured by user 
    //  this particular list was taken from idea debugger settings in order to fix MPS-8725 
    stepRequest.addClassExclusionFilter("java.*");
    stepRequest.addClassExclusionFilter("javax.*");
    stepRequest.addClassExclusionFilter("org.omg.*");
    stepRequest.addClassExclusionFilter("sun.*");
    stepRequest.addClassExclusionFilter("junit.*");
    stepRequest.addClassExclusionFilter("com.sun.*");
    // TODO also might wanna let user to exclude constructors, classloaders, getters, 
    // synthetic methods (whatever synthetic methods are). 
    // see idea debugger settings for the full list 
    myRequestManager.enableRequest(stepRequest);
  }

  private void processLocatableEvent(EventContext context, LocatableEvent event) {
    final ThreadReference thread = event.thread();
    if (myContextManager.isEvaluated(thread)) {
      myContextManager.resume(context);
      return;
    }
    myManagerThread.schedule(new _FunctionTypes._void_P0_E0() {
      public void invoke() {
      }
    }, CommandPriority.EVALUATE);
  }

  public class EventProcessorRunnable implements Runnable {
    private volatile boolean myIsStopped = false;

    public EventProcessorRunnable() {
    }

    public void run() {
      try {
        EventQueue eventQueue = myVirtualMachine.eventQueue();
        while (!(myIsStopped)) {
          EventSet events = eventQueue.remove();
          EventContext context = new EventContext(events);
          for (Event event : SetSequence.fromSet(events)) {
            if (event instanceof VMDeathEvent) {
              processVmDeathEvent();
            } else
            if (event instanceof VMDisconnectEvent) {
              processVmDeathEvent();
            } else
            if (event instanceof ClassPrepareEvent) {
              processClassPrepareEvent(context, (ClassPrepareEvent) event);
            } else
            if (event instanceof StepEvent) {
              processStepEvent(context, (StepEvent) event);
            } else
            if (event instanceof LocatableEvent) {
              processLocatableEvent(context, (LocatableEvent) event);
            } else {
              myContextManager.resume(context);
            }
          }
        }
      } catch (InterruptedException e) {
        processVmDeathEvent();
      }
    }

    public void stop() {
      myIsStopped = true;
    }

    public boolean isStopped() {
      return myIsStopped;
    }
  }
}
