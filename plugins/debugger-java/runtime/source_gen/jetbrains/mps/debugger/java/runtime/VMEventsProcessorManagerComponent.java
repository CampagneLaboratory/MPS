package jetbrains.mps.debugger.java.runtime;

/*Generated by MPS */

import com.intellij.openapi.components.ProjectComponent;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.debug.api.DebugSessionManagerComponent;
import org.jetbrains.annotations.NotNull;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.debugger.java.runtime.execution.DebuggerCommand;
import com.intellij.openapi.project.Project;
import jetbrains.mps.debugger.java.runtime.events.EventsProcessor;
import jetbrains.mps.debugger.java.runtime.events.Context;

public class VMEventsProcessorManagerComponent implements ProjectComponent {
  private final Map<DebugVMEventsProcessor, DebugSession> myEventProcessorToSessionMap = new HashMap<DebugVMEventsProcessor, DebugSession>(1);
  private final DebugProcessListener myListener = new VMEventsProcessorManagerComponent.MyDebugProcessesMulticaster();
  private final List<DebugProcessListener> myAllProcessListeners = new ArrayList<DebugProcessListener>();
  private final DebugSessionManagerComponent myDebugManager;

  public VMEventsProcessorManagerComponent(DebugSessionManagerComponent component) {
    myDebugManager = component;
  }

  @Override
  public void projectOpened() {
  }

  @Override
  public void projectClosed() {
  }

  @NotNull
  @Override
  public String getComponentName() {
    return "MPS Debug VM Events Processors Manager";
  }

  @Override
  public void initComponent() {
  }

  @Override
  public void disposeComponent() {
  }

  public DebugVMEventsProcessor getDebugVMEventsProcessor(DebugSession session) {
    synchronized (myEventProcessorToSessionMap) {
      for (DebugVMEventsProcessor p : myEventProcessorToSessionMap.keySet()) {
        if (myEventProcessorToSessionMap.get(p) == session) {
          return p;
        }
      }
      return null;
    }
  }

  private Set<DebugVMEventsProcessor> getDebugProcesses() {
    synchronized (myEventProcessorToSessionMap) {
      return new HashSet<DebugVMEventsProcessor>(myEventProcessorToSessionMap.keySet());
    }
  }

  private void removeDebugProcess(DebugVMEventsProcessor process) {
    synchronized (myEventProcessorToSessionMap) {
      DebugSession debugSession = myEventProcessorToSessionMap.remove(process);
      myDebugManager.removeDebugSession(debugSession);
    }
    process.removeDebugProcessListener(myListener);
  }

  public void performAllDebugProcessesAction(final VMEventsProcessorManagerComponent.AllDebugProcessesAction action) {
    for (final DebugVMEventsProcessor processor : getDebugProcesses()) {
      processor.getManagerThread().invoke(new DebuggerCommand() {
        @Override
        protected void action() throws Exception {
          action.run(processor);
        }
      });
    }
  }

  public void addDebugSession(DebugSession debugSession) {
    DebugVMEventsProcessor process = debugSession.getEventsProcessor();
    synchronized (myEventProcessorToSessionMap) {
      myEventProcessorToSessionMap.put(process, debugSession);
    }
    process.addDebugProcessListener(myListener);
  }

  public void addAllProcessListener(DebugProcessListener listener) {
    synchronized (myAllProcessListeners) {
      myAllProcessListeners.add(listener);
    }
  }

  public void removeAllProcessListener(DebugProcessListener listener) {
    synchronized (myAllProcessListeners) {
      myAllProcessListeners.remove(listener);
    }
  }

  public List<DebugProcessListener> getAllProcessListeners() {
    synchronized (myAllProcessListeners) {
      return new ArrayList<DebugProcessListener>(myAllProcessListeners);
    }
  }

  public static VMEventsProcessorManagerComponent getInstance(Project project) {
    return project.getComponent(VMEventsProcessorManagerComponent.class);
  }

  public static interface AllDebugProcessesAction {
    public void run(DebugVMEventsProcessor processor);
  }

  private class MyDebugProcessesMulticaster implements DebugProcessListener {
    private MyDebugProcessesMulticaster() {
    }

    @Override
    public void connectorIsReady() {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.connectorIsReady();
      }
    }

    @Override
    public void paused(@NotNull SuspendContext suspendContext) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.paused(suspendContext);
      }
    }

    @Override
    public void resumed(@NotNull SuspendContext suspendContext) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.resumed(suspendContext);
      }
    }

    @Override
    public void processDetached(@NotNull DebugVMEventsProcessor process, boolean closedByUser) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.processDetached(process, closedByUser);
      }
      removeDebugProcess(process);
    }

    @Override
    public void processAttached(@NotNull DebugVMEventsProcessor process) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.processAttached(process);
      }
    }

    public void processAttached(@NotNull EventsProcessor process) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.processAttached(process);
      }
    }

    public void processDetached(@NotNull EventsProcessor process, boolean closedByUser) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.processDetached(process, closedByUser);
      }
      // <node> 
    }

    public void resumed(@NotNull Context suspendContext) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.resumed(suspendContext);
      }
    }

    public void paused(@NotNull Context suspendContext) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.paused(suspendContext);
      }
    }
  }
}
