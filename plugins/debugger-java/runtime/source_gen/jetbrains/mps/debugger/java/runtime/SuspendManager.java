package jetbrains.mps.debugger.java.runtime;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.LinkedList;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import com.sun.jdi.event.EventSet;
import com.sun.jdi.request.EventRequest;
import jetbrains.mps.debugger.java.runtime.execution.DebuggerManagerThread;
import java.util.List;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.ObjectCollectedException;
import com.sun.jdi.InternalException;

public class SuspendManager {
  private static final Logger LOG = Logger.getLogger(SuspendManager.class);

  private final DebugVMEventsProcessor myDebugProcess;
  private final LinkedList<SuspendContext> myEventContexts = new LinkedList<SuspendContext>();
  /**
   * Contexts, paused at breakpoint or another debugger event requests.
   * Note that thread, explicitly paused by user is not considered as

   * "paused at breakpoint" and JDI prohibits data queries on its stackframes
   */
  private final LinkedList<SuspendContext> myPausedContexts = new LinkedList<SuspendContext>();
  /**
   * context paused by user
   */
  @Nullable
  private SuspendContext myPausedByUserContext;

  public SuspendManager(DebugVMEventsProcessor debugProcess) {
    myDebugProcess = debugProcess;
    myDebugProcess.addDebugProcessListener(new DebugProcessAdapter() {
      public void processDetached(@NotNull DebugVMEventsProcessor process, boolean closedByUser) {
        myEventContexts.clear();
        myPausedContexts.clear();
        myPausedByUserContext = null;
      }
    });
  }

  public SuspendContext pushSuspendContextWithVotesNumber(int suspendPolicy, int nVotes) {
    SuspendContext suspendContext = new SuspendManager.SuspendContextByItSelf(myDebugProcess, suspendPolicy, nVotes);
    pushContext(suspendContext);
    return suspendContext;
  }

  public SuspendContext pushSuspendContextFromEventSet(EventSet set) {
    SuspendContext suspendContext;
    if (set == null) {
      //  special case 
      suspendContext = new SuspendManager.SuspendContextByItSelf(myDebugProcess, EventRequest.SUSPEND_NONE, 1) {
        @Override
        protected void resumeImpl() {
        }
      };
    } else {
      suspendContext = new SuspendManager.SuspendContextFromSet(myDebugProcess, set);
    }
    pushContext(suspendContext);
    return suspendContext;
  }

  private void pushContext(SuspendContext suspendContext) {
    DebuggerManagerThread.assertIsManagerThread();
    myEventContexts.addFirst(suspendContext);
  }

  public void resume(SuspendContext context) {
    context.resume();
    popContext(context);
  }

  @Nullable
  public SuspendContext getPausedContext() {
    return (!(myPausedContexts.isEmpty()) ?
      myPausedContexts.getFirst() :
      null
    );
  }

  public void popContext(SuspendContext suspendContext) {
    DebuggerManagerThread.assertIsManagerThread();
    myEventContexts.remove(suspendContext);
    myPausedContexts.remove(suspendContext);
    if (myPausedByUserContext == suspendContext) {
      myPausedByUserContext = null;
    }
  }

  private void pushPausedContext(SuspendContext suspendContext) {
    LOG.assertLog(myEventContexts.contains(suspendContext));
    myPausedContexts.addFirst(suspendContext);
  }

  public boolean hasEventContext(SuspendContext suspendContext) {
    DebuggerManagerThread.assertIsManagerThread();
    return myEventContexts.contains(suspendContext);
  }

  public List<SuspendContext> getEventContexts() {
    DebuggerManagerThread.assertIsManagerThread();
    return myEventContexts;
  }

  public boolean isSuspended(ThreadReference thread) throws ObjectCollectedException {
    DebuggerManagerThread.assertIsManagerThread();
    boolean suspended = false;
    for (SuspendContext suspendContext : myEventContexts) {
      if (suspendContext.suspends(thread)) {
        suspended = true;
        break;
      }
    }
    return suspended && (thread == null || thread.isSuspended());
  }

  private void processVote(SuspendContext suspendContext) {
    LOG.assertLog(suspendContext.myVotesToVote > 0);
    suspendContext.myVotesToVote--;
    if (suspendContext.myVotesToVote == 0) {
      if (suspendContext.myIsVotedForResume) {
        resume(suspendContext);
      } else {
        notifyPaused(suspendContext);
      }
    }
  }

  private void notifyPaused(SuspendContext suspendContext) {
    pushPausedContext(suspendContext);
    myDebugProcess.getMulticaster().paused(suspendContext);
  }

  public void voteResume(SuspendContext suspendContext) {
    processVote(suspendContext);
  }

  public void voteSuspend(SuspendContext suspendContext) {
    suspendContext.myIsVotedForResume = false;
    processVote(suspendContext);
  }

  /*package*/ LinkedList<SuspendContext> getPausedContexts() {
    return myPausedContexts;
  }

  @Nullable
  /*package*/ SuspendContext getPausedByUserContext() {
    return myPausedByUserContext;
  }

  public void setPausedByUser(SuspendContext suspendContext) {
    myPausedByUserContext = suspendContext;
  }

  private class SuspendContextFromSet extends SuspendManager.SuspendContextImpl {
    public SuspendContextFromSet(@NotNull DebugVMEventsProcessor debugProcess, @NotNull EventSet set) {
      super(debugProcess, set.suspendPolicy(), set.size(), set);
    }

    @Override
    protected void resumeImpl() {
      ThreadReference thread = getThread();
      if (thread != null) {
        //  check that thread is suspended at the moment 
        try {
          if (!(thread.isSuspended())) {
            SuspendManager.LOG.assertLog(false, "Context thread must be suspended");
          }
        } catch (ObjectCollectedException ignored) {
        }
      }
      tryResume5Times();
    }

    @Override
    protected void tryResume() throws ObjectCollectedException, InternalException {
      getEventSet().resume();
    }
  }

  private class SuspendContextByItSelf extends SuspendManager.SuspendContextImpl {
    public SuspendContextByItSelf(@NotNull DebugVMEventsProcessor debugProcess, int suspendPolicy, int eventVotes) {
      super(debugProcess, suspendPolicy, eventVotes, null);
    }

    @Override
    protected void resumeImpl() {
      SuspendManager.LOG.debug("Start resuming...");
      switch (getSuspendPolicy()) {
        case EventRequest.SUSPEND_ALL:
          tryResume5Times();
          SuspendManager.LOG.debug("VM resumed ");
          break;
        case EventRequest.SUSPEND_EVENT_THREAD:
          //  TODO: well, this call not just MAY produce NPE, it WILL, if we ever get here (but we won't AFAIK) 
          //  TODO why don't we repeat 5 times here? 
          ThreadReference thread = getThread();
          SuspendManager.LOG.assertLog(thread != null);
          thread.resume();
          SuspendManager.LOG.debug("Thread resumed : " + getThread().toString());
          break;
        case EventRequest.SUSPEND_NONE:
          SuspendManager.LOG.debug("None resumed");
          break;
        default:
      }
    }

    @Override
    protected void tryResume() throws ObjectCollectedException, InternalException {
      myDebugProcess.getVirtualMachine().resume();
    }
  }

  private abstract class SuspendContextImpl extends SuspendContext {
    public SuspendContextImpl(@NotNull DebugVMEventsProcessor debugProcess, int suspendPolicy, int eventVotes, @Nullable EventSet set) {
      super(debugProcess, suspendPolicy, eventVotes, set);
    }

    protected abstract void tryResume() throws ObjectCollectedException, InternalException;

    protected void tryResume5Times() {
      int resumeAttempts = 5;
      while (--resumeAttempts > 0) {
        try {
          tryResume();
          break;
        } catch (ObjectCollectedException e) {
          //  according to error reports set.resume() may throw this if one of the threads has been collected 
        } catch (InternalException e) {
          // InternalException 13 means that there are running threads that we are trying to resume 
          // On MacOS it happened that native thread didn't stop while some java thread reached breakpoint 
          if (e.errorCode() == 13 && getSuspendPolicy() == EventRequest.SUSPEND_ALL) {
            // Patches.MAC_RESUME_VM_HACK &&  
            // Its funny, but second resume solves the problem 
          } else {
            SuspendManager.LOG.error(e);
            break;
          }
        }
      }
    }
  }
}
