package jetbrains.mps.debugger.java.runtime;

/*Generated by MPS */

import jetbrains.mps.debug.runtime.JavaUiState;
import jetbrains.mps.logging.Logger;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import jetbrains.mps.debug.runtime.java.programState.proxies.JavaThread;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.debug.api.AbstractUiState;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.debug.api.AbstractDebugSession;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.ObjectReference;
import jetbrains.mps.debug.runtime.java.programState.proxies.JavaStackFrame;
import jetbrains.mps.util.CollectionUtil;
import java.util.Collections;
import jetbrains.mps.debug.api.programState.IThread;
import jetbrains.mps.debug.api.programState.IStackFrame;
import jetbrains.mps.debug.api.programState.IWatchable;
import com.sun.jdi.event.EventSet;
import jetbrains.mps.debugger.java.runtime.watchables.EventWatchablesCreator;
import com.sun.jdi.event.Event;
import com.sun.jdi.StackFrame;

public class JavaUiStateImpl extends JavaUiState {
  private static Logger LOG = Logger.getLogger(JavaUiStateImpl.class);

  @Nullable
  private final SuspendContext myContext;
  private final int myThreadIndex;
  private final int myStackFrameIndex;
  private final DebugSession myDebugSession;
  private final List<JavaThread> myThreads = ListSequence.fromList(new ArrayList<JavaThread>());
  private boolean myInitialized = false;

  /*package*/ JavaUiStateImpl(@Nullable SuspendContext context, DebugSession debugSession) {
    super(debugSession);
    myDebugSession = debugSession;
    myContext = context;
    if (context == null) {
      myThreadIndex = -1;
      myStackFrameIndex = AbstractUiState.NO_FRAME;
    } else {
      myThreadIndex = findThreadIndex();
      LOG.assertLog(myThreadIndex >= 0);
      myStackFrameIndex = findStackFrameIndex();
    }
  }

  /**
   * This constructor is called when user selects some thread from ui
   */
  /*package*/ JavaUiStateImpl(@NotNull JavaUiStateImpl previousState, DebugSession debugSession, int currentThreadIndex) {
    super(debugSession);
    myDebugSession = debugSession;
    myThreadIndex = currentThreadIndex;
    if (currentThreadIndex < 0) {
      myContext = null;
      myStackFrameIndex = AbstractUiState.NO_FRAME;
    } else {
      myContext = findContext(previousState);
      LOG.assertLog(myContext != null);
      //  in case some botva is going on 
      myStackFrameIndex = findStackFrameIndex();
    }
  }

  /**
   * This constructor is called when user selects some frame from ui
   */
  /*package*/ JavaUiStateImpl(@NotNull JavaUiStateImpl previousState, int frameIndex, DebugSession debugSession) {
    super(debugSession);
    myDebugSession = debugSession;
    LOG.assertLog(frameIndex == AbstractUiState.NO_FRAME || (frameIndex >= 0 && frameIndex < previousState.getCurrentThread().getFramesCount()));
    myContext = previousState.myContext;
    myThreadIndex = previousState.myThreadIndex;
    myStackFrameIndex = frameIndex;
  }

  private SuspendContext findContext(@NotNull JavaUiStateImpl previousState) {
    SuspendContext newContext = previousState.myContext;
    if (newContext == null) {
      LOG.errorAssertionFailed();
      return null;
    }
    if (!(newContext.suspends(getThread().getThread()))) {
      newContext = null;
      for (SuspendContext context : getAllPausedContexts()) {
        if (context.suspends(getThread().getThread())) {
          newContext = context;
          break;
        }
      }
    }
    return newContext;
  }

  private synchronized void initializeThreads() {
    if (myInitialized) {
      return;
    }
    myInitialized = true;
    if (getExecutionState().equals(AbstractDebugSession.ExecutionState.Paused)) {
      for (ThreadReference threadReference : getEventsProcessor().getVirtualMachine().allThreads()) {
        if (threadReference.isSuspended()) {
          myThreads.add(new JavaThread(threadReference));
        }
      }
      assert myThreadIndex < ListSequence.fromList(myThreads).count();
    } else {
      assert myThreadIndex < 0;
    }
  }

  @Nullable
  public JavaThread getCurrentThread() {
    if (myThreadIndex < 0) {
      return null;
    }
    initializeThreads();
    return ListSequence.fromList(myThreads).getElement(myThreadIndex);
  }

  private int findThreadIndex() {
    if (myContext == null) {
      return -1;
    }

    List<ThreadReference> threads = getEventsProcessor().getVirtualMachine().allThreads();
    ThreadReference thread = myContext.getThread();

    if (thread != null) {
      return threads.indexOf(thread);
    }

    for (ThreadReference t : threads) {
      //  TODO this is a hack to filter out system threads 
      if (!(t.threadGroup().name().equals("system"))) {
        return threads.indexOf(t);
      }
    }
    return 0;
  }

  protected int findStackFrameIndex() {
    if (myThreadIndex < 0) {
      return AbstractUiState.NO_FRAME;
    }
    return super.findStackFrameIndex();
  }

  @Nullable
  public ObjectReference getThisObject() {
    JavaStackFrame javaStackFrame = getStackFrame();
    if (javaStackFrame != null) {
      return check_vkri5_a0a1a5(javaStackFrame.getStackFrame());
    }
    return null;
  }

  @NotNull
  /*package*/ JavaUiStateImpl paused(SuspendContext context) {
    //  changes state on pause/resume 
    //  we select new context even if we are already on some other context 
    //  user probably wants to know about new paused contexts 
    return new JavaUiStateImpl(context, myDebugSession);
  }

  @NotNull
  /*package*/ JavaUiStateImpl resumed(SuspendContext context) {
    // TODO if some other context is resumed it does not mean that those changes do not concern us. We still want to display correct threads state. 
    if (context != myContext) {
      return this;
    }
    SuspendContext newContext = null;
    List<SuspendContext> allPausedContexts = getAllPausedContexts();
    if (!(allPausedContexts.isEmpty())) {
      newContext = allPausedContexts.get(0);
    }
    return new JavaUiStateImpl(newContext, myDebugSession);
  }

  private List<SuspendContext> getAllPausedContexts() {
    SuspendManager suspendManager = getEventsProcessor().getSuspendManager();
    SuspendContext context = suspendManager.getPausedByUserContext();
    if (context != null) {
      return suspendManager.getPausedContexts();
    }
    return CollectionUtil.union(suspendManager.getPausedContexts(), Collections.singletonList(context));
  }

  protected JavaUiStateImpl selectThreadInternal(@Nullable IThread thread) {
    initializeThreads();
    int index = ListSequence.fromList(myThreads).indexOf(thread);
    //  changes state on user selection 
    return new JavaUiStateImpl(this, myDebugSession, index);
  }

  protected JavaUiStateImpl selectFrameInternal(int frame) {
    if (myStackFrameIndex != frame) {
      return new JavaUiStateImpl(this, frame, myDebugSession);
    }
    return this;
  }

  @Nullable
  public SuspendContext getContext() {
    return myContext;
  }

  @NotNull
  public List<? extends IThread> getThreads() {
    initializeThreads();
    return myThreads;
  }

  public boolean isPausedOnBreakpoint() {
    return myContext != null && getEventsProcessor().getSuspendManager().getPausedContexts().contains(myContext);
  }

  @Nullable
  public JavaThread getThread() {
    initializeThreads();
    return (JavaThread) ListSequence.fromList(myThreads).getElement(myThreadIndex);
  }

  @Nullable
  public JavaStackFrame getStackFrame() {
    initializeThreads();
    if (myStackFrameIndex == AbstractUiState.NO_FRAME) {
      return null;
    }
    assert myThreadIndex >= 0;
    //  if we have a frame then we have a thread 
    return (JavaStackFrame) ListSequence.fromList(myThreads).getElement(myThreadIndex).getFrames().get(myStackFrameIndex);
  }

  @Override
  public IStackFrame getStackFrame(int index) {
    JavaThread thread = getThread();
    if (thread == null) {
      return null;
    }
    return thread.getFrame(index);
  }

  private DebugVMEventsProcessor getEventsProcessor() {
    return myDebugSession.getEventsProcessor();
  }

  private AbstractDebugSession.ExecutionState getExecutionState() {
    return myDebugSession.getExecutionState();
  }

  @NotNull
  private List<IWatchable> getAdditionalWatchables() {
    List<IWatchable> watchables = new ArrayList<IWatchable>();
    if (myContext != null) {
      EventSet eventSet = myContext.getEventSet();
      if (eventSet != null) {
        String classFqName = check_vkri5_a0a0b0b0t(getStackFrame(), this);
        ThreadReference threadReference = check_vkri5_a0b0b0b0t(getThread(), this);
        if (classFqName == null || threadReference == null) {
          return watchables;
        }
        EventWatchablesCreator watchablesCreator = new EventWatchablesCreator();
        for (Event event : eventSet) {
          watchablesCreator.addWatchablesFromEvent(event, watchables, classFqName, threadReference);
        }
      }
    }
    return watchables;
  }

  @NotNull
  public List<IWatchable> getWatchables() {
    List<IWatchable> watchables = new ArrayList<IWatchable>();
    watchables.addAll(super.getWatchables());
    watchables.addAll(getAdditionalWatchables());
    return watchables;
  }

  private static ObjectReference check_vkri5_a0a1a5(StackFrame checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.thisObject();
    }
    return null;
  }

  private static String check_vkri5_a0a0b0b0t(JavaStackFrame checkedDotOperand, JavaUiStateImpl checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getClassFqName();
    }
    return null;
  }

  private static ThreadReference check_vkri5_a0b0b0b0t(JavaThread checkedDotOperand, JavaUiStateImpl checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getThread();
    }
    return null;
  }
}
