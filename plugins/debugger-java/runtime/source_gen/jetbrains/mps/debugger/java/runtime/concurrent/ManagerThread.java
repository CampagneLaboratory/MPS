package jetbrains.mps.debugger.java.runtime.concurrent;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.concurrent.CountDownLatch;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.util.ui.Timer;

public class ManagerThread {
  public static final int COMMANT_TIMEOUT = 10000;
  protected static Log log = LogFactory.getLog(ManagerThread.class);

  private final ICommandQueue myCommandQueue = new CommandQueue();
  private volatile ManagerThread.WorkerThread myThread;
  private final ManagerThread.AngelOfDeath myAngelOfDeath = new ManagerThread.AngelOfDeath();

  public ManagerThread() {
    myAngelOfDeath.start();
    startNewThread();
  }

  public void invoke(ICommand command) {
    if (isManagerThread()) {
      myThread.processCommand(command);
    } else {
      schedule(command);
    }
  }

  public void invokeAndWait(ICommand command) {
    if (isManagerThread()) {
      myThread.processCommand(command);
    } else {
      final CountDownLatch countDown = new CountDownLatch(1);
      schedule(new CommandDecorator(command, new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          countDown.countDown();
        }
      }));
      try {
        countDown.await();
      } catch (InterruptedException ignore) {
      }
    }
  }

  public void schedule(ICommand command) {
    if (myCommandQueue.isClosed()) {
      command.cancelled();
    } else {
      myCommandQueue.put(command);
    }
  }

  public void startNewThread() {
    myThread = new ManagerThread.WorkerThread();
    myThread.start();
  }

  public void close() {
    myCommandQueue.close();
  }

  public static boolean isManagerThread() {
    return Thread.currentThread() instanceof ManagerThread.WorkerThread;
  }

  public static void assertIsMangerThread() {
    assert isManagerThread();
  }

  private class WorkerThread extends Thread {
    public WorkerThread() {
    }

    public void run() {
      while (true) {
        if (isInterrupted()) {
          break;
        }
        try {
          processCommand(myCommandQueue.poll());
        } catch (ICommandQueue.QueueClosedException e) {
          break;
        }
      }
      if (log.isDebugEnabled()) {
        log.debug("Thread " + this + " finished working.");
      }
    }

    private void processCommand(ICommand command) {
      try {
        command.run();
      } catch (Throwable t) {
        if (log.isErrorEnabled()) {
          log.error("Command " + command + " threw an exception.", t);
        }
      }
    }
  }

  private class AngelOfDeath extends Timer {
    private volatile ICommand myCommandOnTrial;

    public AngelOfDeath() {
      super("Angel of death", ManagerThread.COMMANT_TIMEOUT);
    }

    protected void onTimer() throws InterruptedException {
      if (myCommandOnTrial != null && myCommandOnTrial == myCommandQueue.currentCommand()) {
        //  hanged 
        myThread.interrupt();
        startNewThread();
      }

      myCommandOnTrial = myCommandQueue.currentCommand();
    }
  }
}
