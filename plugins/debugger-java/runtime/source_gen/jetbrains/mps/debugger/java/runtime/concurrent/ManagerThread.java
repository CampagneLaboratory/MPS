package jetbrains.mps.debugger.java.runtime.concurrent;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.concurrent.BlockingQueue;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.CountDownLatch;

public class ManagerThread {
  protected static Log log = LogFactory.getLog(ManagerThread.class);

  private final BlockingQueue<_FunctionTypes._void_P0_E0> myCommandQueue = new LinkedBlockingQueue<_FunctionTypes._void_P0_E0>();
  private final ManagerThread.WorkerThread myThread = new ManagerThread.WorkerThread();
  private volatile boolean myClosed = false;

  public ManagerThread() {
    myThread.start();
  }

  public void invoke(_FunctionTypes._void_P0_E0 command) {
    if (isManagerThread()) {
      myThread.processCommand(command);
    } else {
      schedule(command);
    }
  }

  public void invokeAndWait(final _FunctionTypes._void_P0_E0 command) {
    if (isManagerThread()) {
      myThread.processCommand(command);
    } else {
      final CountDownLatch countDown = new CountDownLatch(1);
      schedule(new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          try {
            command.invoke();
          } finally {
            countDown.countDown();
          }
        }
      });
      try {
        countDown.await();
      } catch (InterruptedException ignore) {
      }
    }
  }

  public void schedule(_FunctionTypes._void_P0_E0 command) {
    myCommandQueue.offer(command);
  }

  public void close() {
    myClosed = true;
  }

  public static boolean isManagerThread() {
    return Thread.currentThread() instanceof ManagerThread.WorkerThread;
  }

  public static void assertIsMangerThread() {
    assert isManagerThread();
  }

  private class WorkerThread extends Thread {
    public WorkerThread() {
    }

    public void run() {
      try {
        while (true) {
          if (isInterrupted() || myClosed) {
            break;
          }
          processCommand(myCommandQueue.take());
        }
      } catch (InterruptedException ignore) {
      }
      if (log.isDebugEnabled()) {
        log.debug("Thread " + this + " finished working.");
      }
    }

    private void processCommand(_FunctionTypes._void_P0_E0 command) {
      try {
        command.invoke();
      } catch (Throwable t) {
        if (log.isErrorEnabled()) {
          log.error("Command " + command + " threw an exception.", t);
        }
      }
    }
  }
}
