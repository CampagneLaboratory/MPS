package jetbrains.mps.debugger.java.runtime.evaluation;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.generator.generationTypes.InMemoryJavaGenerationHandler;
import jetbrains.mps.debugger.java.api.evaluation.EvaluationException;
import jetbrains.mps.ide.messages.DefaultMessageHandler;
import com.intellij.openapi.progress.util.ProgressWindow;
import jetbrains.mps.generator.GenerationFacade;
import java.util.Collections;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.generator.GenerationOptions;
import jetbrains.mps.ide.generator.TransientModelsComponent;
import com.intellij.openapi.util.Disposer;
import java.lang.reflect.InvocationTargetException;
import jetbrains.mps.debugger.java.api.evaluation.InvocationTargetEvaluationException;
import jetbrains.mps.compiler.CompilationResultAdapter;
import org.eclipse.jdt.internal.compiler.CompilationResult;
import org.eclipse.jdt.core.compiler.CategorizedProblem;
import jetbrains.mps.generator.IncrementalGenerationStrategy;
import java.util.Map;
import jetbrains.mps.generator.GenerationCacheContainer;
import jetbrains.mps.generator.impl.dependencies.GenerationDependencies;

public class EvaluationGeneratorUtil {
  @Nullable
  public static Class generateAndLoadEvaluatorClass(Project ideaProject, SModelDescriptor modelDescriptor, String className, IOperationContext context, boolean saveTransientModels, InMemoryJavaGenerationHandler handler, ClassLoader parentloader) throws EvaluationException {
    try {

      final String fullClassName = modelDescriptor.getLongName() + "." + className;
      EvaluationGeneratorUtil.MyCompilationResultAdapter compilationResult = new EvaluationGeneratorUtil.MyCompilationResultAdapter();
      handler.setCompilationListener(compilationResult);
      DefaultMessageHandler messageHandler = new DefaultMessageHandler(ideaProject);
      ProgressWindow progressWindow = new ProgressWindow(false, ideaProject);
      boolean successful = GenerationFacade.generateModels(context.getProject(), Collections.singletonList(modelDescriptor), context, handler, new ProgressMonitorAdapter(progressWindow), messageHandler, GenerationOptions.getDefaults().incremental(new EvaluationGeneratorUtil.MyIncrementalGenerationStrategy()).saveTransientModels(saveTransientModels).rebuildAll(false).reporting(false, false, false, 0).create(), context.getProject().getComponent(TransientModelsComponent.class));

      Disposer.dispose(progressWindow);

      String source = handler.getSources().get(fullClassName);

      if (successful && (source != null && source.length() > 0)) {
        return Class.forName(fullClassName, true, handler.getCompiler().getClassLoader(parentloader));
      } else if ((source != null && source.length() > 0) && !(successful)) {
        String text = "Errors during compilation";
        if (compilationResult.hasErrors()) {
          text += ":\n" + compilationResult.getMessage();
        } else {
          text += ".";
        }
        throw new EvaluationException(text);
      } else {
        throw new EvaluationException("Errors during generation.");
      }
    } catch (EvaluationException e) {
      throw e;
    } catch (ClassNotFoundException e) {
      throw new EvaluationException(e);
    }
  }

  public static <E> E createInstance(Class clazz, Class[] parameterClasses, Object[] parameters) throws EvaluationException {
    try {
      return (E) clazz.getConstructor(parameterClasses).newInstance(parameters);
    } catch (InvocationTargetException e) {
      throw new InvocationTargetEvaluationException(e.getCause());
    } catch (NoSuchMethodException e) {
      throw new EvaluationException(e);
    } catch (IllegalAccessException e) {
      throw new EvaluationException(e);
    } catch (InstantiationException e) {
      throw new EvaluationException(e);
    }
  }

  private static class MyCompilationResultAdapter extends CompilationResultAdapter {
    private final StringBuffer myBuffer = new StringBuffer();
    private boolean myHasErrors;

    public MyCompilationResultAdapter() {
    }

    @Override
    public void onCompilationResult(CompilationResult result) {
      if (result.hasErrors()) {
        myHasErrors = true;
        for (CategorizedProblem error : result.getErrors()) {
          myBuffer.append(error.getMessage());
          myBuffer.append("\n");
        }
      }
    }

    public boolean hasErrors() {
      return myHasErrors;
    }

    public String getMessage() {
      return myBuffer.toString();
    }
  }

  private static class MyIncrementalGenerationStrategy implements IncrementalGenerationStrategy {
    public MyIncrementalGenerationStrategy() {
    }

    public Map<String, String> getModelHashes(SModelDescriptor p0, IOperationContext p1) {
      return Collections.emptyMap();
    }

    public GenerationCacheContainer getContainer() {
      return null;
    }

    public GenerationDependencies getDependencies(SModelDescriptor p0) {
      return null;
    }

    public boolean isIncrementalEnabled() {
      return false;
    }
  }
}
