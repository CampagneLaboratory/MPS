package jetbrains.mps.debugger.java.runtime.engine;

/*Generated by MPS */

import com.intellij.openapi.components.ProjectComponent;
import java.util.Map;
import jetbrains.mps.debugger.java.runtime.engine.events.EventsProcessor;
import jetbrains.mps.debugger.java.runtime.state.DebugSession;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.debug.api.DebugSessionManagerComponent;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.openapi.project.Project;
import jetbrains.mps.debugger.java.runtime.engine.events.Context;

public class VMEventsProcessorManagerComponent implements ProjectComponent {
  private final Map<EventsProcessor, DebugSession> myEventProcessorToSessionMap = MapSequence.fromMap(new HashMap<EventsProcessor, DebugSession>());
  private final DebugProcessListener myListener = new VMEventsProcessorManagerComponent.MyDebugProcessesMulticaster();
  private final List<DebugProcessListener> myAllProcessListeners = new ArrayList<DebugProcessListener>();
  private final DebugSessionManagerComponent myDebugManager;

  public VMEventsProcessorManagerComponent(DebugSessionManagerComponent component) {
    myDebugManager = component;
  }

  @Override
  public void projectOpened() {
  }

  @Override
  public void projectClosed() {
  }

  @NotNull
  @Override
  public String getComponentName() {
    return "MPS Debug VM Events Processors Manager";
  }

  @Override
  public void initComponent() {
  }

  @Override
  public void disposeComponent() {
  }

  public EventsProcessor getEventsProcessor(final DebugSession session) {
    synchronized (myEventProcessorToSessionMap) {
      EventsProcessor processor = check_4p75cp_a0a0a0f(MapSequence.fromMap(myEventProcessorToSessionMap).findFirst(new IWhereFilter<IMapping<EventsProcessor, DebugSession>>() {
        public boolean accept(IMapping<EventsProcessor, DebugSession> it) {
          return it.value() == session;
        }
      }));
      return processor;
    }
  }

  private Set<EventsProcessor> getDebugProcesses() {
    synchronized (myEventProcessorToSessionMap) {
      return SetSequence.fromSetWithValues(new HashSet<EventsProcessor>(), MapSequence.fromMap(myEventProcessorToSessionMap).keySet());
    }
  }

  private void removeDebugProcess(EventsProcessor process) {
    synchronized (myEventProcessorToSessionMap) {
      DebugSession debugSession = MapSequence.fromMap(myEventProcessorToSessionMap).removeKey(process);
      myDebugManager.removeDebugSession(debugSession);
    }
    process.removeDebugProcessListener(myListener);
  }

  public void performAllDebugProcessesAction(final _FunctionTypes._void_P1_E0<? super EventsProcessor> action) {
    for (final EventsProcessor processor : getDebugProcesses()) {
      processor.invoke(new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          action.invoke(processor);
        }
      });
    }
  }

  public void addDebugSession(DebugSession debugSession) {
    EventsProcessor process = debugSession.getEventsProcessor();
    synchronized (myEventProcessorToSessionMap) {
      MapSequence.fromMap(myEventProcessorToSessionMap).put(process, debugSession);
    }
    process.addDebugProcessListener(myListener);
  }

  public void addAllProcessListener(DebugProcessListener listener) {
    synchronized (myAllProcessListeners) {
      myAllProcessListeners.add(listener);
    }
  }

  public void removeAllProcessListener(DebugProcessListener listener) {
    synchronized (myAllProcessListeners) {
      myAllProcessListeners.remove(listener);
    }
  }

  public List<DebugProcessListener> getAllProcessListeners() {
    synchronized (myAllProcessListeners) {
      return new ArrayList<DebugProcessListener>(myAllProcessListeners);
    }
  }

  public static VMEventsProcessorManagerComponent getInstance(Project project) {
    return project.getComponent(VMEventsProcessorManagerComponent.class);
  }

  private static EventsProcessor check_4p75cp_a0a0a0f(IMapping<EventsProcessor, DebugSession> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.key();
    }
    return null;
  }

  private class MyDebugProcessesMulticaster implements DebugProcessListener {
    private MyDebugProcessesMulticaster() {
    }

    @Override
    public void connectorIsReady() {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.connectorIsReady();
      }
    }

    public void processAttached(@NotNull EventsProcessor process) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.processAttached(process);
      }
    }

    public void processDetached(@NotNull EventsProcessor process, boolean closedByUser) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.processDetached(process, closedByUser);
      }
      removeDebugProcess(process);
    }

    public void resumed(@NotNull Context suspendContext) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.resumed(suspendContext);
      }
    }

    public void paused(@NotNull Context suspendContext) {
      for (DebugProcessListener listener : getAllProcessListeners()) {
        listener.paused(suspendContext);
      }
    }
  }
}
