package jetbrains.mps.debugger.java.evaluation.model;

/*Generated by MPS */

import jetbrains.mps.generator.generationTypes.InMemoryJavaGenerationHandler;
import java.util.Set;
import jetbrains.mps.reloading.IClassPathItem;
import java.util.List;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.reloading.CompositeClassPathItem;
import jetbrains.mps.project.IModule;
import jetbrains.mps.generator.GenerationStatus;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.progress.ProgressMonitor;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.debug.evaluation.transform.Transformator;

/*package*/ class MyInMemoryJavaGenerationHandler extends InMemoryJavaGenerationHandler {
  private final Set<IClassPathItem> myClasspaths;
  private final List<_FunctionTypes._void_P1_E0<? super SNode>> myGenerationListeners = ListSequence.fromList(new ArrayList<_FunctionTypes._void_P1_E0<? super SNode>>());

  public MyInMemoryJavaGenerationHandler(boolean reloadClasses, boolean keepSources, Set<IClassPathItem> classpaths, Iterable<_FunctionTypes._void_P1_E0<? super SNode>> listeners) {
    super(reloadClasses, keepSources);
    myClasspaths = classpaths;
    ListSequence.fromList(myGenerationListeners).addSequence(Sequence.fromIterable(listeners));
  }

  @Override
  public boolean canHandle(SModelDescriptor inputModel) {
    return inputModel != null;
  }

  @Override
  protected CompositeClassPathItem getClassPath(Set<IModule> contextModules) {
    CompositeClassPathItem result = super.getClassPath(contextModules);
    for (IClassPathItem item : myClasspaths) {
      result.add(item);
    }
    return result;
  }

  @Override
  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext context, ProgressMonitor monitor) {
    SModel model = status.getOutputModel();
    if (model != null) {
      final SNode evaluator = SModelOperations.getRootByName(model, AbstractEvaluationModel.EVALUATOR_NAME);

      if (evaluator != null) {
        try {
          new Transformator(evaluator, true).transformEvaluator();
          if (AbstractEvaluationModel.IS_DEVELOPER_MODE) {
            for (_FunctionTypes._void_P1_E0<? super SNode> listener : ListSequence.fromList(myGenerationListeners)) {
              listener.invoke(evaluator);
            }
          }
        } catch (Throwable t) {
          LOG.error(t);
        }

      }
    }
    return super.handleOutput(module, inputModel, status, context, monitor);
  }
}
