package jetbrains.mps.debug.runtime.java.programState.proxies;

/*Generated by MPS */

import jetbrains.mps.debug.api.programState.IStackFrame;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.debug.api.programState.IWatchable;
import java.util.List;
import jetbrains.mps.debug.runtime.java.programState.watchables.JavaLocalVariable;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.sun.jdi.AbsentInformationException;
import jetbrains.mps.util.Pair;
import com.sun.jdi.StackFrame;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.ModelAccess;
import java.util.Map;
import jetbrains.mps.debug.api.programState.IValue;
import java.util.Collections;
import com.sun.jdi.IncompatibleThreadStateException;
import com.sun.jdi.LocalVariable;
import com.sun.jdi.ObjectReference;
import jetbrains.mps.debug.runtime.java.programState.watchables.JavaThisObject;
import jetbrains.mps.debug.runtime.java.programState.watchables.JavaStaticContext;

public class JavaStackFrame extends ProxyForJava implements IStackFrame {
  private static final Logger LOG = Logger.getLogger(JavaStackFrame.class);

  private final String myClassFqName;
  private final int myIndex;
  private final JavaLocation myLocation;
  private final JavaThread myThread;
  private IWatchable myContextWatchable;
  private final List<JavaLocalVariable> myVariables = ListSequence.fromList(new ArrayList<JavaLocalVariable>());
  private boolean myInitialized;

  public JavaStackFrame(JavaThread threadReference, int i) throws AbsentInformationException {
    super(new Pair<JavaThread, Integer>(threadReference, i));
    myIndex = i;
    myThread = threadReference;
    StackFrame stackFrame = getStackFrame();
    if (stackFrame != null) {
      myLocation = new JavaLocation(stackFrame.location());
      myClassFqName = myLocation.getUnitName();
    } else {
      myLocation = null;
      myClassFqName = null;
    }
  }

  @Override
  @Nullable
  public JavaLocation getLocation() {
    return myLocation;
  }

  @Override
  public JavaThread getThread() {
    return myThread;
  }

  public String getClassFqName() {
    return myClassFqName;
  }

  @Nullable
  public StackFrame getStackFrame() {
    assert !(ModelAccess.instance().isInEDT());
    try {
      return getFrame();
    } catch (Throwable t) {
      LOG.error(t);
      return null;
    }
  }

  @Override
  public Map<IWatchable, IValue> getWatchableValues() {
    assert false : "Deprecated method getWatchableValues is used.";
    return Collections.emptyMap();
  }

  @Override
  public List<IWatchable> getVisibleWatchables() {
    List<IWatchable> watchables = ListSequence.fromList(new ArrayList<IWatchable>());
    ListSequence.fromList(watchables).addSequence(ListSequence.fromList(myVariables));
    if (myContextWatchable != null) {
      ListSequence.fromList(watchables).addElement(myContextWatchable);
    }
    return watchables;
  }

  public List<JavaLocalVariable> getVisibleVariables() {
    return myVariables;
  }

  public IWatchable getContextWatchable() {
    return myContextWatchable;
  }

  public void initializeWatchables() {
    if (myInitialized) {
      return;
    }
    myInitialized = true;
    try {
      ListSequence.fromList(myVariables).addSequence(ListSequence.fromList(fetchVisibleVariables()));
      myContextWatchable = fetchContextWatchable();
    } catch (IncompatibleThreadStateException ignore) {
    } catch (AbsentInformationException ignore) {
    }
  }

  private List<JavaLocalVariable> fetchVisibleVariables() throws IncompatibleThreadStateException, AbsentInformationException {
    assert !(ModelAccess.instance().isInEDT());

    StackFrame stackFrame = getFrame();
    List<JavaLocalVariable> result = new ArrayList<JavaLocalVariable>();
    if (stackFrame != null) {
      for (LocalVariable variable : stackFrame.visibleVariables()) {
        result.add(new JavaLocalVariable(variable, this, myClassFqName, myThread.getThread()));
      }
    }
    return result;
  }

  private IWatchable fetchContextWatchable() throws IncompatibleThreadStateException {
    assert !(ModelAccess.instance().isInEDT());

    StackFrame stackFrame = getFrame();
    if (stackFrame != null) {
      ObjectReference thisObject = stackFrame.thisObject();
      if (thisObject != null) {
        return new JavaThisObject(thisObject, this, myClassFqName, myThread.getThread());
      } else {
        return new JavaStaticContext(stackFrame.location().declaringType(), myClassFqName, myThread.getThread());
      }
    }
    return null;
  }

  private StackFrame getFrame() throws IncompatibleThreadStateException {
    return myThread.getThread().frame(myIndex);
  }

  @Override
  public IValue getValue(IWatchable watchable) {
    assert !(ModelAccess.instance().isInEDT());
    try {
      if (watchable instanceof JavaLocalVariable) {
        JavaLocalVariable localVariable = (JavaLocalVariable) watchable;
        return ValueUtil.getInstance().fromJDI(getFrame().getValue(localVariable.getLocalVariable()), myClassFqName, myThread.getThread());
      }
    } catch (IncompatibleThreadStateException e) {
    }
    return null;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    JavaStackFrame that = (JavaStackFrame) o;
    if (myIndex != that.myIndex) {
      return false;
    }
    if ((myLocation != null ?
      !(myLocation.equals(that.myLocation)) :
      that.myLocation != null
    )) {
      return false;
    }
    if ((myThread != null ?
      !(myThread.equals(that.myThread)) :
      that.myThread != null
    )) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + myIndex;
    result = 31 * result + ((myLocation != null ?
      ((Object) myLocation).hashCode() :
      0
    ));
    result = 31 * result + ((myThread != null ?
      ((Object) myThread).hashCode() :
      0
    ));
    return result;
  }
}
