package jetbrains.mps.lang.test.matcher;

/*Generated by MPS */

import jetbrains.mps.util.IterableUtil;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;
import java.util.HashSet;
import jetbrains.mps.util.SNodeOperations;

public class NodesMatcher {
  public NodesMatcher() {
  }

  public static NodeDifference matchNodes(SNode a, SNode b) {
    ArrayList<SNode> aList = new ArrayList<SNode>();
    aList.add(a);
    ArrayList<SNode> bList = new ArrayList<SNode>();
    bList.add(b);
    ArrayList<NodeDifference> diffs = NodesMatcher.matchNodes(aList, bList);
    if (diffs != null) {
      return diffs.get(0);
    } else {
      return null;
    }
  }

  public static ArrayList<NodeDifference> matchNodes(List<SNode> a, List<SNode> b) {
    HashMap<SNode, SNode> map = new HashMap<SNode, SNode>();
    return NodesMatcher.matchNodes(a, b, map);
  }

  public static ArrayList<NodeDifference> matchNodes(List<SNode> a, List<SNode> b, Map<SNode, SNode> map) {
    Iterator<SNode> iteratorA = a.iterator();
    Iterator<SNode> iteratorB = b.iterator();
    while (iteratorA.hasNext() && iteratorB.hasNext()) {
      NodesMatcher.match(iteratorA.next(), iteratorB.next(), map);
    }
    ArrayList<NodeDifference> ret = null;
    iteratorA = a.iterator();
    iteratorB = b.iterator();
    while (iteratorA.hasNext() && iteratorB.hasNext()) {
      NodeDifference diff = NodesMatcher.matchNodes(iteratorA.next(), iteratorB.next(), map);
      if (diff != null) {
        if (ret == null) {
          ret = new ArrayList<NodeDifference>();
        }
        ret.add(diff);
      }
    }
    return ret;
  }

  private static void match(SNode a, SNode b, Map<SNode, SNode> map) {
    if (!(a.getConcept().getConceptId().equals(b.getConcept().getConceptId()))) {
      return;
    }
    HashSet<String> roles = new HashSet<String>();
    roles.addAll(SNodeOperations.getChildRoles(a));
    roles.addAll(SNodeOperations.getChildRoles(b));
    for (String role : roles) {
      List<? extends SNode> children1 = IterableUtil.asList(a.getChildren(role));
      List<? extends SNode> children2 = IterableUtil.asList(b.getChildren(role));
      if (children1.size() != children2.size()) {
        continue;
      }
      for (int i = 0; i < children1.size(); i++) {
        NodesMatcher.match(children1.get(i), children2.get(i), map);
      }
    }
    map.put(a, b);
  }

  public static NodeDifference matchNodes(SNode a, SNode b, Map<SNode, SNode> map) {
    ArrayList<DifferanceItem> difference = new ArrayList<DifferanceItem>();
    if (NodesMatcher.matchConcepts(a, b, difference)) {
      return new NodeDifference(a.getPresentation(), difference);
    }
    NodesMatcher.matchProperties(a, b, difference);
    NodesMatcher.matchChildren(a, b, map, difference);
    NodesMatcher.matchReferences(a, b, map, difference);
    if (difference.size() != 0) {
      return new NodeDifference(a.getPresentation(), difference);
    }
    return null;
  }

  private static boolean matchConcepts(SNode a, SNode b, ArrayList<DifferanceItem> difference) {
    if (!(a.getConcept().getConceptId().equals(b.getConcept().getConceptId()))) {
      difference.add(new ConceptDifference(a.getConcept().getConceptId(), b.getConcept().getConceptId()));
      return true;
    }
    return false;
  }

  private static void matchReferences(SNode a, SNode b, Map<SNode, SNode> map, ArrayList<DifferanceItem> difference) {
    HashSet<String> roles = new HashSet<String>();
    roles.addAll(SNodeOperations.getReferenceRoles(a));
    roles.addAll(SNodeOperations.getReferenceRoles(b));
    for (String role : roles) {
      SNode reference1 = null;
      if (a.getReference(role) != null) {
        reference1 = a.getReference(role).getTargetNode();
      }
      SNode reference2 = null;
      if (b.getReference(role) != null) {
        reference2 = b.getReference(role).getTargetNode();
      }
      if (map.containsKey(reference1)) {
        if (map.get(reference1) != reference2) {
          difference.add(new ReferenceDifferense(role, true));
        }
      } else {
        if (reference1 != reference2) {
          difference.add(new ReferenceDifferense(role, false));
        }
      }
    }
  }

  private static void matchChildren(SNode a, SNode b, Map<SNode, SNode> map, ArrayList<DifferanceItem> difference) {
    HashSet<String> roles = new HashSet<String>();
    roles.addAll(SNodeOperations.getChildRoles(a));
    roles.addAll(SNodeOperations.getChildRoles(b));
    for (String role : roles) {
      List<? extends SNode> children1 = IterableUtil.asList(a.getChildren(role));
      List<? extends SNode> children2 = IterableUtil.asList(b.getChildren(role));
      if (children1.size() != children2.size()) {
        difference.add(new ChildrenCountDifference(role, children1.size(), children2.size()));
        continue;
      }
      for (int i = 0; i < children1.size(); i++) {
        NodeDifference d = NodesMatcher.matchNodes(children1.get(i), children2.get(i), map);
        if (d != null) {
          difference.add(d);
        }
      }
    }
  }

  private static void matchProperties(SNode a, SNode b, ArrayList<DifferanceItem> difference) {
    HashSet<String> propertes = new HashSet<String>();
    propertes.addAll(SNodeOperations.getProperties(a).keySet());
    propertes.addAll(SNodeOperations.getProperties(b).keySet());
    for (String key : propertes) {
      String p1 = SNodeOperations.getProperties(a).get(key);
      String p2 = SNodeOperations.getProperties(b).get(key);
      if (p1 == null && "false".equals(p2)) {
        continue;
      }
      if (p2 == null && "false".equals(p1)) {
        continue;
      }
      if (p1 == null || p2 == null || !(p1.equals(p2))) {
        difference.add(new PropertyDifferense(key));
      }
    }
  }
}
