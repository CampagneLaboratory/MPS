package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestEventsDispatcher;
import com.intellij.execution.process.ProcessHandler;
import jetbrains.mps.baseLanguage.unitTest.execution.server.TestLightExecutor;
import java.util.concurrent.Future;
import jetbrains.mps.baseLanguage.unitTest.execution.server.TestExecutor;
import com.intellij.openapi.application.ApplicationManager;

public class JUnitLightExecutor implements Executor {

  private final Iterable<ITestNodeWrapper> myNodes;
  private final TestEventsDispatcher myDispatcher;
  private static volatile boolean ourRunInProgress = false;

  public JUnitLightExecutor(Iterable<ITestNodeWrapper> testNodeWrappers, TestEventsDispatcher dispatcher) {
    myNodes = testNodeWrappers;
    myDispatcher = dispatcher;
    ourRunInProgress = true;
  }

  @Override
  public ProcessHandler execute() {
    try {
      TestLightExecutor executor = new TestLightExecutor(myDispatcher, myNodes);
      final Future<?> future = doExecute(executor);
      final FakeProcessHandler process = new FakeProcessHandler(future, executor);
      return process;
    } finally {
      dispose();
    }
  }

  private Future<?> doExecute(final TestExecutor executor) {
    return ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
      @Override
      public void run() {
        try {
          executor.init();
          executor.execute();
        } finally {
          JUnitLightExecutor.this.dispose();
        }
      }
    });
  }

  private void dispose() {
    ourRunInProgress = false;
  }


  public static boolean isLightRunInProgress() {
    return ourRunInProgress;
  }
}
