package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import com.intellij.openapi.project.Project;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunState;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestEventsDispatcher;
import java.util.concurrent.Future;
import com.intellij.openapi.application.ApplicationManager;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class JUnitLightExecutor {
  private final Iterable<ITestNodeWrapper> myNodes;
  private final Project myProject;
  private final Filter<ITestNodeWrapper> myFilter = new JUnitLightExecutor.DefaultFilter();
  private static boolean ourRunInProgress = false;
  private static boolean ourRunTerminating = false;


  public JUnitLightExecutor(Iterable<ITestNodeWrapper> testNodeWrappers, Project project) {
    myNodes = testNodeWrappers;
    myProject = project;
  }



  public synchronized boolean accept() {
    if (ourRunInProgress) {
      return false;
    }
    boolean result = myFilter.accept(myNodes);
    if (result) {
      init();
    }
    return result;
  }



  private void init() {
    ourRunInProgress = true;
    ourRunTerminating = false;
  }



  public static boolean isRunInProgress() {
    return ourRunInProgress;
  }



  public static boolean isRunTerminating() {
    return ourRunTerminating;
  }



  /*package*/ static boolean terminateRun() {
    return ourRunTerminating = true;
  }



  public JUnitProcessPack execute() {
    final Iterable<? extends ITestNodeWrapper> nodes = myFilter.filter(myNodes);
    TestRunState runState = new TestRunState(nodes);
    TestEventsDispatcher eventsDispatcher = new TestEventsDispatcher(runState);

    TestLightExecutor lightExecutor = new TestLightExecutor(eventsDispatcher, nodes);
    lightExecutor.init();
    final Future<?> future = doExecute(lightExecutor);
    final FakeProcessHandler process = new FakeProcessHandler(future, lightExecutor);

    JUnitProcessPack packProcess = new JUnitProcessPacker(myProject, runState, eventsDispatcher).packProcess(process);
    return packProcess;
  }



  private Future<?> doExecute(final TestExecutor executor) {
    return ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
      @Override
      public void run() {
        System.out.println("Taking the execution control...");
        executor.execute();
        System.out.println("I am so done");
        ourRunInProgress = false;
      }
    });
  }



  private static class DefaultFilter implements Filter<ITestNodeWrapper> {
    @Override
    public boolean accept(Iterable<? extends ITestNodeWrapper> ts) {
      return true;
      // TODO REMOVE!!! 
      // <node> 
    }



    @Override
    public Iterable<? extends ITestNodeWrapper> filter(final Iterable<? extends ITestNodeWrapper> ts) {
      final List<ITestNodeWrapper> seq = ListSequence.fromList(new LinkedList<ITestNodeWrapper>());
      ModelAccess.instance().runReadAction(new Runnable() {
        @Override
        public void run() {
          ListSequence.fromList(seq).addSequence(Sequence.fromIterable(ts).where(new IWhereFilter<ITestNodeWrapper>() {
            public boolean accept(ITestNodeWrapper it) {
              SNode root = SNodeOperations.getContainingRoot(it.getNode());
              return SNodeOperations.isInstanceOf(root, "jetbrains.mps.lang.test.structure.NodesTestCase") || SNodeOperations.isInstanceOf(root, "jetbrains.mps.lang.test.structure.EditorTestCase");
            }
          }));
        }
      });
      return seq;
    }
  }


}
