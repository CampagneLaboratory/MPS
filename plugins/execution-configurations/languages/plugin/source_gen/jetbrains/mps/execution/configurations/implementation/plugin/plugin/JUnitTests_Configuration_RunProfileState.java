package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import com.intellij.execution.process.ProcessHandler;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.util.Key;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._void_P0_E0;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestEventsDispatcher;
import jetbrains.mps.debug.api.run.DebuggerRunProfileState;
import com.intellij.execution.configurations.RunProfileState;
import jetbrains.mps.execution.api.configurations.DefaultExecutionConsole;
import jetbrains.mps.execution.api.configurations.DefaultExecutionResult;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.fast.exec.prototype.TestLightExecutor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.annotations.NotNull;
import com.intellij.execution.runners.ExecutionEnvironment;
import com.intellij.execution.Executor;
import com.intellij.execution.configurations.ConfigurationPerRunnerSettings;
import com.intellij.execution.configurations.RunnerSettings;
import org.jetbrains.annotations.Nullable;
import com.intellij.execution.ExecutionResult;
import com.intellij.execution.runners.ProgramRunner;
import com.intellij.execution.ExecutionException;
import com.intellij.openapi.project.Project;

import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Future;

import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.baseLanguage.unitTest.execution.client.Junit_Command;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunState;
import com.intellij.execution.ui.ConsoleView;
import jetbrains.mps.execution.api.configurations.ConsoleCreator;
import jetbrains.mps.ide.actions.StandaloneMPSStackTraceFilter;
import jetbrains.mps.baseLanguage.unitTest.execution.tool.UnitTestViewComponent;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.debug.api.run.IDebuggerConfiguration;
import com.intellij.execution.executors.DefaultRunExecutor;
import com.intellij.execution.executors.DefaultDebugExecutor;

public class JUnitTests_Configuration_RunProfileState extends DebuggerRunProfileState implements RunProfileState {
  @NotNull
  private final JUnitTests_Configuration myRunConfiguration;
  @NotNull
  private final ExecutionEnvironment myEnvironment;

  public JUnitTests_Configuration_RunProfileState(@NotNull JUnitTests_Configuration configuration, @NotNull Executor executor, @NotNull ExecutionEnvironment environment) {
    myRunConfiguration = configuration;
    myEnvironment = environment;
  }

  public ConfigurationPerRunnerSettings getConfigurationSettings() {
    return null;
  }

  public RunnerSettings getRunnerSettings() {
    return null;
  }

  @Nullable
  public ExecutionResult execute(Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {
    Project project = myEnvironment.getProject();
    final List<ITestNodeWrapper> nodeWrappers0 = ListSequence.fromList(myRunConfiguration.getJUnitSettings().getTests(ProjectHelper.toMPSProject(project))).toListSequence();

    final List<ITestNodeWrapper> nodeWrappers = new ArrayList<ITestNodeWrapper>();
    ModelAccess.instance().runReadAction(new Runnable() {
      @Override
      public void run() {
        for (ITestNodeWrapper<?> wrapper : nodeWrappers0) {
          if ((SNodeOperations.isInstanceOf(wrapper.getNode(), "jetbrains.mps.lang.test.structure.EditorTestCase")) ||
              (SNodeOperations.isInstanceOf(wrapper.getNode(), "jetbrains.mps.lang.test.structure.NodesTestCase")))
            nodeWrappers.add(wrapper);
        }
      }
    });

//    final ProcessHandler process = new Junit_Command().setDebuggerSettings_String(myDebuggerSettings.getCommandLine(true)).createProcess(nodeWrappers, myRunConfiguration.getJavaRunParameters().getJavaRunParameters());
    TestRunState runState = new TestRunState(nodeWrappers);
    final TestEventsDispatcher eventsDispatcher = new TestEventsDispatcher(runState);
//    final UnitTestProcessListener unitTestProcessListener = new UnitTestProcessListener(eventsDispatcher);
    ConsoleView console = ConsoleCreator.createConsoleView(project, false);
    console.addMessageFilter(new StandaloneMPSStackTraceFilter(project));
    final ProjectOperationContext context = new ProjectOperationContext(ProjectHelper.toMPSProject(project));

    TestLightExecutor testLightExecutor = new TestLightExecutor(eventsDispatcher);
    final Future<?> future = doExecute(testLightExecutor, nodeWrappers, eventsDispatcher);
    final NullProcessHandler process = new NullProcessHandler(future, testLightExecutor);

    final _void_P0_E0 closeListener = new _void_P0_E0() {
      public void invoke() {
        if (process != null)
          process.destroyProcess();
      }
    };

    final UnitTestViewComponent viewComponent = new UnitTestViewComponent(project, context, console, runState, closeListener);
    final DefaultExecutionConsole executionConsole = new DefaultExecutionConsole(viewComponent, new _void_P0_E0() {
      public void invoke() {
        viewComponent.dispose();
      }
    });


    {
//      ProcessHandler _processHandler = process;
//      _processHandler.addProcessListener(unitTestProcessListener);
      return new DefaultExecutionResult(process, executionConsole);
    }
  }

  private Future<?> doExecute(final TestLightExecutor testLightExecutor, final List<ITestNodeWrapper> nodeWrappers, final TestEventsDispatcher eventsDispatcher) {
    return ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
      @Override
      public void run() {
        System.out.println("Taking the execution control...");
        testLightExecutor.execute(nodeWrappers);
        System.out.println("I am so done!");
      }
    });
  }

  @NotNull
  public IDebuggerConfiguration getDebuggerConfiguration() {
    return Junit_Command.getDebuggerConfiguration();
  }

  public static boolean canExecute(String executorId) {
    if (DefaultRunExecutor.EXECUTOR_ID.equals(executorId)) {
      return true;
    }
    if (DefaultDebugExecutor.EXECUTOR_ID.equals(executorId)) {
      return true;
    }
    return false;
  }

  private static class NullProcessHandler extends ProcessHandler {
    private final Future<?> myFuture;
    private final TestLightExecutor myTestLightExecutor;

    public NullProcessHandler(Future<?> future, TestLightExecutor testLightExecutor) {
      myFuture = future;
      myTestLightExecutor = testLightExecutor;
    }

    @Override
    public void startNotify() {
      super.startNotify();
      myTestLightExecutor.setStarted(true);
    }

    public void terminate() {
      myFuture.cancel(true);
    }

    @Override
    protected void destroyProcessImpl() {
      terminate();
    }

    @Override
    protected void detachProcessImpl() {
      terminate();
    }

    @Override
    public boolean isProcessTerminated() {
      return myFuture.isDone();
    }

    @Override
    public boolean detachIsDefault() {
      return false;
    }

    @Nullable
    @Override
    public OutputStream getProcessInput() {
      return null;
    }
  }
}
