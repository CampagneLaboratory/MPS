package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import jetbrains.mps.execution.api.configurations.BaseMpsBeforeTaskProvider;
import com.intellij.openapi.util.Key;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.io.File;
import com.intellij.openapi.project.Project;
import com.intellij.execution.runners.ExecutionEnvironment;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SModel;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.openapi.application.ModalityState;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.make.IMakeService;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.resources.ModelsToResources;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import com.intellij.execution.ui.ConsoleView;
import jetbrains.mps.execution.api.configurations.ConsoleCreator;
import jetbrains.mps.ide.actions.StandaloneMPSStackTraceFilter;
import com.intellij.execution.process.ProcessHandler;
import jetbrains.mps.execution.api.commands.OutputRedirector;
import jetbrains.mps.ant.execution.Ant_Command;
import jetbrains.mps.execution.api.configurations.ConsoleProcessListener;
import org.apache.log4j.Priority;
import com.intellij.execution.ExecutionManager;
import com.intellij.execution.executors.DefaultRunExecutor;
import com.intellij.execution.ui.RunContentDescriptor;
import jetbrains.mps.execution.api.commands.ProcessHandlerBuilder;
import jetbrains.mps.util.FileUtil;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class DeployPlugins_BeforeTask extends BaseMpsBeforeTaskProvider<DeployPlugins_BeforeTask.DeployPlugins_BeforeTask_RunTask> {
  private static final Key<DeployPlugins_BeforeTask.DeployPlugins_BeforeTask_RunTask> KEY = Key.create("jetbrains.mps.execution.configurations.implementation.plugin.plugin.DeployPlugins_BeforeTask");

  public DeployPlugins_BeforeTask() {
    super("DeployPlugins", "Deploy Plugins");
  }

  protected DeployPlugins_BeforeTask.DeployPlugins_BeforeTask_RunTask createTaskImpl() {
    return new DeployPlugins_BeforeTask.DeployPlugins_BeforeTask_RunTask();
  }

  public Key<DeployPlugins_BeforeTask.DeployPlugins_BeforeTask_RunTask> getId() {
    return KEY;
  }

  public static class DeployPlugins_BeforeTask_RunTask extends BaseMpsBeforeTaskProvider.BaseMpsBeforeRunTask<DeployPlugins_BeforeTask.DeployPlugins_BeforeTask_RunTask> {
    private List<SNodeReference> myPlugins;
    private File myDeployLocation;

    public DeployPlugins_BeforeTask_RunTask() {
      super(KEY);
    }

    public boolean configure(List<SNodeReference> plugins, File deployLocation) {
      myPlugins = plugins;
      myDeployLocation = deployLocation;
      return true;
    }

    public boolean execute(Project project, ExecutionEnvironment environment) {
      if (ListSequence.fromList(myPlugins).isEmpty()) {
        return true;
      }

      final Project projectFinal = project;
      final Wrappers._T<Tuples._2<SModel, File>> deployScript = new Wrappers._T<Tuples._2<SModel, File>>();

      ApplicationManager.getApplication().invokeAndWait(new Runnable() {
        public void run() {
          ModelAccess.instance().executeCommand(new Runnable() {
            public void run() {
              deployScript.value = DeployScriptCreator.createDeployScript(projectFinal, myPlugins);
            }
          }, ProjectHelper.toMPSProject(projectFinal));
        }
      }, ModalityState.NON_MODAL);

      MakeSession session = new MakeSession(new ProjectOperationContext(ProjectHelper.toMPSProject(project)), null, true);
      if (IMakeService.INSTANCE.get().openNewSession(session)) {
        Future<IResult> future = IMakeService.INSTANCE.get().make(session, new ModelsToResources(new ProjectOperationContext(ProjectHelper.toMPSProject(project)), Sequence.<SModel>singleton(deployScript.value._0())).resources(false));
        IResult result = null;
        try {
          result = future.get();
        } catch (CancellationException ignore) {
        } catch (InterruptedException ignore) {
        } catch (ExecutionException ignore) {
        }
        if (result == null || !(result.isSucessful())) {
          return false;
        }
      }

      final ConsoleView console = ConsoleCreator.createConsoleView(project, false);
      console.addMessageFilter(new StandaloneMPSStackTraceFilter(project));

      File deployScriptFile = deployScript.value._1();

      final Wrappers._T<ProcessHandler> process = new Wrappers._T<ProcessHandler>();
      try {
        process.value = OutputRedirector.redirect(new Ant_Command().setTargetName_String("buildDependents assemble").createProcess(deployScriptFile.getAbsolutePath()), new ConsoleProcessListener(console));

      } catch (com.intellij.execution.ExecutionException e) {
        if (LOG.isEnabledFor(Priority.ERROR)) {
          LOG.error("Can not deploy plugins", e);
        }
        return false;
      }

      ApplicationManager.getApplication().invokeAndWait(new Runnable() {
        public void run() {
          ExecutionManager.getInstance(projectFinal).getContentManager().showRunContent(DefaultRunExecutor.getRunExecutorInstance(), new RunContentDescriptor(console, process.value, console.getComponent(), "Deploy plugins"));
        }
      }, ModalityState.NON_MODAL);
      int exitCode = ProcessHandlerBuilder.startAndWait(process.value);
      if (exitCode != 0) {
        return false;
      }

      FileUtil.copyDir(new File(deployScriptFile.getParentFile(), "build" + File.separator + "artifacts" + File.separator + "deploy"), myDeployLocation);

      return true;
    }
  }

  protected static Logger LOG = LogManager.getLogger(DeployPlugins_BeforeTask.class);
}
