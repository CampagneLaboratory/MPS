package jetbrains.mps.baseLanguage.unitTest.execution.settings;

/*Generated by MPS */

import jetbrains.mps.execution.lib.ui.ListPanel;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestNodeWrapperFactory;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConceptRepository;
import jetbrains.mps.util.NameUtil;
import java.util.Set;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import jetbrains.mps.project.GlobalScope;
import java.util.Collections;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import com.intellij.openapi.progress.ProgressManager;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class TestListPanel extends ListPanel<ITestNodeWrapper> {
  private boolean myIsTestMethods;


  @Nullable
  @Override
  protected ITestNodeWrapper wrap(SNode node) {
    return TestNodeWrapperFactory.tryToWrap(node);
  }

  @Override
  protected SNodeReference unwrap(ITestNodeWrapper element) {
    return element.getNodePointer();
  }

  @Override
  protected String getFqName(ITestNodeWrapper element) {
    return element.getCachedFqName();
  }

  public void init(List<ITestNodeWrapper> nodes, final boolean isTestMethods) {
    myIsTestMethods = isTestMethods;
    super.init(nodes);
  }

  @Override
  protected void collectCandidates() {
    final List<SNode> nodesList = new ArrayList<SNode>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        for (SNode concept : Sequence.fromIterable(TestNodeWrapperFactory.getWrappedRootConcepts())) {
          SAbstractConcept c = SConceptRepository.getInstance().getConcept(NameUtil.nodeFQName(concept));
          Set<SNode> usages = FindUsagesFacade.getInstance().findInstances(GlobalScope.getInstance(), Collections.singleton(c), false, new ProgressMonitorAdapter(ProgressManager.getInstance().getProgressIndicator()));
          ListSequence.fromList(nodesList).addSequence(SetSequence.fromSet(usages));
        }
      }
    });

    if (myIsTestMethods) {
      final List<ITestNodeWrapper> methodsList = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          for (SNode testCase : nodesList) {
            ITestNodeWrapper wrapper = TestNodeWrapperFactory.tryToWrap(testCase);
            if (wrapper == null) {
              continue;
            }
            ListSequence.fromList(methodsList).addSequence(Sequence.fromIterable(wrapper.getTestMethods()));
          }
        }
      });
      synchronized (myLock) {
        ListSequence.fromList(myCandidates).clear();
        ListSequence.fromList(myCandidates).addSequence(ListSequence.fromList(methodsList));
      }
    } else {
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          synchronized (myLock) {
            ListSequence.fromList(myCandidates).clear();
            ListSequence.fromList(myCandidates).addSequence(ListSequence.fromList(nodesList).select(new ISelector<SNode, ITestNodeWrapper>() {
              public ITestNodeWrapper select(SNode it) {
                return wrap(it);
              }
            }).where(new IWhereFilter<ITestNodeWrapper>() {
              public boolean accept(ITestNodeWrapper it) {
                return it != null;
              }
            }));
          }
        }
      });
    }
  }



  public TestListPanel() {
    super("Tests");
  }
}
