package jetbrains.mps.baseLanguage.unitTest.execution.settings;

/*Generated by MPS */

import javax.swing.JPanel;
import javax.swing.JList;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.awt.event.ActionListener;
import com.intellij.openapi.project.Project;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.awt.BorderLayout;
import com.intellij.ui.components.JBList;
import com.intellij.openapi.actionSystem.AnAction;
import javax.swing.border.TitledBorder;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import javax.swing.JScrollPane;
import com.intellij.ui.ScrollPaneFactory;
import javax.swing.JLabel;
import com.intellij.openapi.progress.ProgressManager;
import jetbrains.mps.internal.collections.runtime.ISelector;
import javax.swing.AbstractListModel;
import jetbrains.mps.workbench.dialogs.project.components.parts.actions.ListAddAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import jetbrains.mps.ide.platform.dialogs.choosers.NodeChooserDialog;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.workbench.dialogs.project.components.parts.actions.ListRemoveAction;

public abstract class ListPanel<T> extends JPanel {
  private final Object myLock = new Object();
  private JList myListComponent;
  protected final List<T> myValues = ListSequence.fromList(new ArrayList<T>());
  protected final List<T> myCandidates = ListSequence.fromList(new ArrayList<T>());
  private ActionListener myListener;
  private ListPanel.MyAbstractListModel myListModel;
  private Project myProject;

  public ListPanel() {
  }

  protected abstract T wrap(SNode node);

  protected abstract SNodeReference unwrap(T element);

  protected abstract String getFqName(T element);

  protected abstract String getBorderTitle();

  protected abstract String getListTitle();

  protected abstract void collectCandidates();

  public void addItem(T item) {
    ListSequence.fromList(myValues).addElement(item);
    myListComponent.updateUI();
  }

  public void addActionListener(ActionListener listener) {
    myListener = listener;
  }

  public List<T> getItems() {
    return myValues;
  }

  public void clear() {
    ListSequence.fromList(myValues).removeSequence(ListSequence.fromList(myValues));
    myListComponent.updateUI();
  }

  public void init(List<? extends T> nodes) {
    setLayout(new BorderLayout());
    ListSequence.fromList(myValues).clear();
    ListSequence.fromList(myValues).addSequence(ListSequence.fromList(nodes));
    myListModel = new ListPanel.MyAbstractListModel();
    myListComponent = new JBList(myListModel);
    AnAction add = new ListPanel.MyListAddAction(myListComponent);
    AnAction remove = new ListPanel.MyListRemoveAction(this.myListComponent);

    this.setBorder(new TitledBorder(getBorderTitle()));

    DefaultActionGroup group = ActionUtils.groupFromActions(add, remove);
    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, false);
    this.add(toolbar.getComponent(), BorderLayout.WEST);

    JScrollPane comp = ScrollPaneFactory.createScrollPane(myListComponent);
    comp.doLayout();
    this.add(comp, BorderLayout.CENTER);

    this.add(new JLabel(getListTitle()), BorderLayout.PAGE_START);
    myListComponent.updateUI();
  }

  private List<SNodeReference> getCandidates() {
    boolean needsUpdate;
    synchronized (myLock) {
      needsUpdate = ListSequence.fromList(this.myCandidates).isEmpty();
    }

    if (needsUpdate) {
      ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {
        @Override
        public void run() {
          collectCandidates();
        }
      }, "Searching for nodes", false, myProject);
    }

    synchronized (myLock) {
      ListSequence.fromList(this.myCandidates).removeSequence(ListSequence.fromList(this.myValues));
      return ListSequence.fromList(this.myCandidates).select(new ISelector<T, SNodeReference>() {
        public SNodeReference select(T it) {
          return unwrap(it);
        }
      }).toListSequence();
    }
  }



  public void setProject(Project project) {
    myProject = project;
  }

  private class MyAbstractListModel extends AbstractListModel {
    public MyAbstractListModel() {
    }

    @Override
    public Object getElementAt(int p0) {
      return getFqName(ListSequence.fromList(ListPanel.this.myValues).getElement(p0));
    }

    @Override
    public int getSize() {
      return ListSequence.fromList(ListPanel.this.myValues).count();
    }

    public void fireSomethingChanged() {
      fireContentsChanged(this, 0, ListSequence.fromList(myValues).count());
    }
  }

  private class MyListAddAction extends ListAddAction {
    public MyListAddAction(JList list) {
      super(list);
    }

    @Override
    protected int doAdd(AnActionEvent p0) {
      List<SNodeReference> nodesList = getCandidates();

      NodeChooserDialog chooserDialog = new NodeChooserDialog(myProject, nodesList);
      chooserDialog.show();
      final SNodeReference resultNode = chooserDialog.getResult();

      if (resultNode == null) {
        return -1;
      }
      final Wrappers._T<T> wrapper = new Wrappers._T<T>();
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          wrapper.value = wrap(((SNodePointer) resultNode).resolve(MPSModuleRepository.getInstance()));
        }
      });
      if (wrapper.value == null) {
        return -1;
      }
      ListSequence.fromList(ListPanel.this.myValues).addElement(wrapper.value);
      if (ListPanel.this.myListener != null) {
        ListPanel.this.myListener.actionPerformed(null);
      }
      ListPanel.this.myListComponent.updateUI();
      ListPanel.this.myListModel.fireSomethingChanged();
      return ListSequence.fromList(ListPanel.this.myValues).indexOf(wrapper.value);
    }
  }

  private class MyListRemoveAction extends ListRemoveAction {
    public MyListRemoveAction(JList list) {
      super(list);
    }

    @Override
    protected void doRemove(AnActionEvent p0) {
      for (Object value : ListPanel.this.myListComponent.getSelectedValues()) {
        for (final T node : ListPanel.this.myValues) {
          final Wrappers._T<String> fqName = new Wrappers._T<String>();
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              fqName.value = getFqName(node);
            }
          });
          if (fqName.value.equals(value)) {
            ListSequence.fromList(ListPanel.this.myValues).removeElement(node);
            break;
          }
        }
      }
      if (ListPanel.this.myListener != null) {
        ListPanel.this.myListener.actionPerformed(null);
      }
      ListPanel.this.myListComponent.updateUI();
      ListPanel.this.myListModel.fireSomethingChanged();
    }
  }
}
