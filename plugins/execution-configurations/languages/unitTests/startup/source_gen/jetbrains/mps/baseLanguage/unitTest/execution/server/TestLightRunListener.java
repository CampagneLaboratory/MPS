package jetbrains.mps.baseLanguage.unitTest.execution.server;

/*Generated by MPS */

import org.junit.runner.notification.RunListener;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestEventsDispatcher;
import jetbrains.mps.lang.test.util.TestLightRunState;
import org.junit.runner.notification.Failure;
import java.io.StringWriter;
import java.io.PrintWriter;
import org.junit.runner.Result;
import com.intellij.execution.process.ProcessOutputTypes;
import org.junit.runner.Description;
import jetbrains.mps.baseLanguage.unitTest.execution.TestEvent;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class TestLightRunListener extends RunListener {
  private final TestLightExecutor myExecutor;
  private final TestEventsDispatcher myDispatcher;
  private final TestLightRunState myTestRunState;
  private final int myRequestCount;
  private final TestLightRunListener.TestEventFactory myFactory;
  private int currentRequest;

  private boolean isTerminating() {
    return myTestRunState.isTerminating();
  }

  public TestLightRunListener(TestLightExecutor executor, int requestCount) {
    myExecutor = executor;
    myDispatcher = executor.getDispatcher();
    myTestRunState = executor.getRunState();
    myRequestCount = requestCount;
    myFactory = new TestLightRunListener.TestEventFactory();
  }

  private String getStackTrace(Failure failure) {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    failure.getException().printStackTrace(pw);
    return sw.toString();
  }

  @Override
  public void testRunFinished(Result result) throws Exception {
    if (isTerminating()) {
      return;
    }
    if (++currentRequest == myRequestCount) {
      if (LOG.isInfoEnabled()) {
        LOG.info("TESTS WERE SUCCESSFUL " + result.wasSuccessful());
      }
      int code = result.getFailureCount();
      myExecutor.terminateProcess(code);
    } else {
      if (LOG.isInfoEnabled()) {
        LOG.info("Request #" + currentRequest + " is finished -- proceeding to the next request");
      }
    }
  }

  private void onTestErrorEvent(String startToken, String endToken, Failure failure) {
    myDispatcher.onTestEvent(myFactory.create(startToken, failure.getDescription()));
    final String text = getStackTrace(failure);
    myDispatcher.onSimpleTextAvailable(text, ProcessOutputTypes.STDERR);
    myDispatcher.onTestEvent(myFactory.create(endToken, failure.getDescription()));
  }

  private void onTestEvent(String token, Description description) throws Exception {
    myDispatcher.onTestEvent(myFactory.create(token, description));
  }

  @Override
  public void testFailure(Failure failure) throws Exception {
    if (isTerminating()) {
      return;
    }
    if (LOG.isInfoEnabled()) {
      LOG.info(TestEvent.ERROR_TEST_PREFIX + failure.getDescription());
    }
    onTestErrorEvent(TestEvent.ERROR_TEST_PREFIX, TestEvent.ERROR_TEST_SUFFIX, failure);
  }

  @Override
  public void testAssumptionFailure(Failure failure) {
    if (isTerminating()) {
      return;
    }
    if (LOG.isInfoEnabled()) {
      LOG.info(TestEvent.FAILURE_TEST_PREFIX + failure.getDescription());
    }
    onTestErrorEvent(TestEvent.FAILURE_TEST_PREFIX, TestEvent.FAILURE_TEST_SUFFIX, failure);
  }

  @Override
  public void testStarted(Description description) throws Exception {
    if (isTerminating()) {
      return;
    }
    if (LOG.isInfoEnabled()) {
      LOG.info(TestEvent.START_TEST_PREFIX + description.getDisplayName());
    }
    onTestEvent(TestEvent.START_TEST_PREFIX, description);
  }

  @Override
  public void testFinished(Description description) throws Exception {
    if (isTerminating()) {
      return;
    }
    if (LOG.isInfoEnabled()) {
      LOG.info(TestEvent.END_TEST_PREFIX + description.getDisplayName());
    }
    onTestEvent(TestEvent.END_TEST_PREFIX, description);
  }

  private class TestEventFactory {
    public TestEvent create(String token, Description description) {
      String fqName = description.getClassName();
      String methodName = description.getMethodName();
      Runtime runtime = Runtime.getRuntime();
      long memory = runtime.totalMemory() - runtime.freeMemory();
      long time = System.currentTimeMillis();
      return new TestEvent(token, fqName, methodName, memory, time);
    }
  }


  protected static Logger LOG = LogManager.getLogger(TestLightRunListener.class);
}
