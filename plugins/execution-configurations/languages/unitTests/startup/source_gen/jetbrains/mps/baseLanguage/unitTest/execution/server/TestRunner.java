package jetbrains.mps.baseLanguage.unitTest.execution.server;

/*Generated by MPS */

import java.util.List;
import org.junit.runner.Request;
import java.io.FileNotFoundException;
import java.io.IOException;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.io.File;
import java.io.LineNumberReader;
import java.io.FileReader;
import java.util.ArrayList;
import jetbrains.mps.util.annotation.ToRemove;
import org.junit.runner.JUnitCore;
import java.io.PrintStream;
import org.junit.runner.notification.RunListener;
import org.junit.runner.Description;
import org.junit.runner.notification.Failure;

public class TestRunner {
  public TestRunner() {
  }

  private void loadTests(String[] argv, List<Request> requests) throws ClassNotFoundException, FileNotFoundException, IOException {
    for (int i = 0; i < argv.length; i++) {
      if ("-c".equals(argv[i])) {
        i++;
        String className = argv[i];
        ListSequence.fromList(requests).addElement(this.createClassRequest(className));
      } else if ("-m".equals(argv[i])) {
        i++;
        String s = argv[i];
        int index = s.lastIndexOf('.');
        String testCase = s.substring(0, index);
        String method = s.substring(index + 1);
        ListSequence.fromList(requests).addElement(this.createMethodRequest(testCase, method));
      } else if ("-f".equals(argv[i])) {
        i++;
        String filename = argv[i];
        new File(filename).deleteOnExit();
        LineNumberReader reader = new LineNumberReader(new FileReader(filename));
        List<String> fileContents = ListSequence.fromList(new ArrayList<String>());
        while (true) {
          String line = reader.readLine();
          if (line == null) {
            break;
          }
          if ((line == null || line.length() == 0)) {
            continue;
          }
          ListSequence.fromList(fileContents).addElement(line);
        }
        loadTests(ListSequence.fromList(fileContents).toGenericArray(String.class), requests);
      }
    }
  }

  /**
   * Since BaseTransformationTest4 is no longer TestCase we can start tests without hacks
   */
  @Deprecated
  @ToRemove(version = 2.1)
  protected Request createMethodRequest(String testCase, String method) throws ClassNotFoundException {
    // protected just for the sake of symmetry with createClassRequest 
    return Request.method(Class.forName(testCase), method);
  }

  /**
   * Since BaseTransformationTest4 is no longer TestCase we can start tests without hacks
   */
  @Deprecated
  @ToRemove(version = 2.1)
  protected Request createClassRequest(String className) throws ClassNotFoundException {
    return Request.aClass(Class.forName(className));
  }

  protected void executeTestsFromArguments(String[] args) throws IOException, ClassNotFoundException, FileNotFoundException {
    JUnitCore core = new JUnitCore();

    CommandOutputStream out = new CommandOutputStream(System.out);
    CommandOutputStream err = new CommandOutputStream(System.err);
    System.setOut(new PrintStream(out));
    System.setErr(new PrintStream(err));
    core.addListener(new TestRunner.MyRunListener(out, err));

    List<Request> requests = ListSequence.fromList(new ArrayList<Request>());
    loadTests(args, requests);

    for (Request request : ListSequence.fromList(requests)) {
      core.run(request);
    }
  }

  public static void main(String[] args) throws ClassNotFoundException, FileNotFoundException, IOException {
    new TestRunner().executeTestsFromArguments(args);
  }

  private static class MyRunListener extends RunListener {
    private final CommandOutputStream myOutput;
    private final CommandOutputStream myErrorOutput;

    public MyRunListener(CommandOutputStream out, CommandOutputStream err) {
      myOutput = out;
      myErrorOutput = err;
    }

    @Override
    public void testFinished(Description description) throws Exception {
      this.printSyncToken(("<END_TEST>"), description);
      super.testFinished(description);
    }

    @Override
    public void testFailure(Failure failure) throws Exception {
      this.printSyncToken(("<TEST_ERROR_BEGIN>"), failure.getDescription());
      failure.getException().printStackTrace(System.out);
      this.printSyncToken(("<TEST_ERROR_END>"), failure.getDescription());
      super.testFailure(failure);
    }

    @Override
    public void testAssumptionFailure(Failure failure) {
      this.printSyncToken(("<TEST_FAILURE_BEGIN>"), failure.getDescription());
      failure.getException().printStackTrace(System.out);
      this.printSyncToken(("<TEST_FAILURE_END>"), failure.getDescription());
      super.testAssumptionFailure(failure);
    }

    @Override
    public void testStarted(Description description) throws Exception {
      printSyncToken(("<START_TEST>"), description);
      super.testStarted(description);
    }

    private void printSyncToken(String tokenPrefix, Description description) {
      StringBuilder builder = new StringBuilder();
      builder.append(tokenPrefix);
      builder.append(description.getTestClass().getName());
      if (description.getMethodName() != null) {
        builder.append(':').append(description.getMethodName());
      }
      Runtime runtime = Runtime.getRuntime();
      builder.append(":memory=").append(runtime.totalMemory() - runtime.freeMemory());
      builder.append(":time=").append(System.currentTimeMillis());

      synchronized (this.myOutput) {
        this.myOutput.writeCommand(builder.toString());
        myOutput.flushSafe();
      }
    }
  }
}
