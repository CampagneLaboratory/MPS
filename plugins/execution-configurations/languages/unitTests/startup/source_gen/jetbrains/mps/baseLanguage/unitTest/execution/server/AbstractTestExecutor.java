package jetbrains.mps.baseLanguage.unitTest.execution.server;

/*Generated by MPS */

import org.junit.runner.notification.RunListener;
import org.jetbrains.annotations.Nullable;
import org.junit.runner.Request;
import org.junit.runner.JUnitCore;
import org.apache.log4j.Level;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.NotNull;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunNotifier;
import org.junit.runner.Description;
import org.junit.runner.notification.Failure;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public abstract class AbstractTestExecutor implements TestExecutor {
  protected AbstractTestExecutor.StoppableIgnoringRunner myCurrentRunner = null;
  protected Filter myFilter = new EmptyFilter();
  private RunListener myListener;
  private volatile boolean myStopping = false;

  @Nullable
  public AbstractTestExecutor.StoppableIgnoringRunner getCurrentRunner() {
    return myCurrentRunner;
  }

  @Override
  public void execute() {
    try {
      TestsContributor testsContributor = createTestsContributor();
      Iterable<Request> requests = testsContributor.gatherTests();
      JUnitCore jUnitCore = prepareJUnitCore(requests);
      doExecute(jUnitCore, requests);
    } catch (Throwable t) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Exception in the test framework", t);
      }
    }
  }

  protected JUnitCore prepareJUnitCore(Iterable<Request> requests) {
    Iterable<Request> reqSeq = Sequence.fromIterable(requests);
    JUnitCore core = new JUnitCore();
    myListener = createListener(requests);
    core.addListener(myListener);
    if (Sequence.fromIterable(reqSeq).count() > 0) {
      Request firstRequest = Sequence.fromIterable(reqSeq).first();
      updateRunner(firstRequest);
    }
    return core;
  }

  protected void doExecute(JUnitCore core, Iterable<Request> requests) throws Throwable {
    for (Request request : requests) {
      updateRunner(request);
      core.run(myCurrentRunner);
    }
  }

  protected void stopRun() {
    AbstractTestExecutor.StoppableIgnoringRunner currentRunner = this.getCurrentRunner();
    assert currentRunner != null;
    currentRunner.pleaseStop();
    myStopping = true;
  }


  private void updateRunner(Request request) {
    myCurrentRunner = new AbstractTestExecutor.StoppableIgnoringRunner(request, myFilter);
    if (myStopping) {
      myCurrentRunner.pleaseStop();
    }
  }

  @NotNull
  protected abstract TestsContributor createTestsContributor();

  @Nullable
  protected RunListener getListener() {
    return myListener;
  }

  @NotNull
  protected abstract RunListener createListener(Iterable<Request> requests);

  protected static class StoppableIgnoringRunner extends Runner {
    private final Request myRequest;
    private final Filter myIgnoringFilter;
    private volatile RunNotifier myNotifier = null;

    public StoppableIgnoringRunner(Request request, Filter ignoringFilter) {
      myRequest = request;
      myIgnoringFilter = ignoringFilter;
    }

    public Description getDescription() {
      return myRequest.getRunner().getDescription();
    }

    public void run(RunNotifier notifier) {
      myNotifier = notifier;

      if (myIgnoringFilter.accept(myRequest)) {
        myRequest.getRunner().run(notifier);
      } else {
        ignoreRequest(notifier);
      }
    }

    private void ignoreRequest(RunNotifier notifier) {
      notifier.fireTestStarted(getDescription());
      notifier.fireTestAssumptionFailed(new Failure(getDescription(), new Throwable("Ignoring test " + myRequest.getRunner().getDescription().getDisplayName())));
      notifier.fireTestFinished(getDescription());
    }

    public void pleaseStop() {
      assert myNotifier != null;
      myNotifier.pleaseStop();
    }
  }
  protected static Logger LOG = LogManager.getLogger(AbstractTestExecutor.class);
}
