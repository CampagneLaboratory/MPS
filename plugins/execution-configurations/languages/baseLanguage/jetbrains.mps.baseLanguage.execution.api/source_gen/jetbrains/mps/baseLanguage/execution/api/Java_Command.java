package jetbrains.mps.baseLanguage.execution.api;

/*Generated by MPS */

import java.io.File;
import com.intellij.util.SystemProperties;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.execution.api.commands.CommandPart;
import com.intellij.execution.process.ProcessHandler;
import com.intellij.execution.ExecutionException;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.execution.api.commands.ListCommandPart;
import jetbrains.mps.execution.api.commands.ProcessHandlerBuilder;
import jetbrains.mps.execution.api.commands.KeyValueCommandPart;
import java.io.FileNotFoundException;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.debug.api.IDebugger;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.traceInfo.DebugInfo;
import jetbrains.mps.generator.traceInfo.TraceInfoCache;
import jetbrains.mps.generator.traceInfo.TraceDown;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.traceInfo.TraceablePositionInfo;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.util.Computable;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.Set;
import jetbrains.mps.project.facets.JavaModuleOperations;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.project.facets.JavaModuleFacet;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.util.SystemInfo;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.util.FileUtil;
import java.io.PrintWriter;
import jetbrains.mps.debug.api.run.IDebuggerConfiguration;
import jetbrains.mps.debug.api.IDebuggerSettings;
import jetbrains.mps.debugger.java.api.settings.LocalConnectionSettings;
import jetbrains.mps.debug.api.Debuggers;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SNodeId;

public class Java_Command {
  private File myWorkingDirectory_File = new File(SystemProperties.getUserHome());
  private String myJrePath_String = Java_Command.getJdkHome();
  private String myProgramParameter_String;
  private String myVirtualMachineParameter_String;
  private List<String> myClassPath_ListString = ListSequence.fromList(new ArrayList<String>());
  private String myDebuggerSettings_String;
  private CommandPart myVirtualMachineParameter_ProcessBuilderCommandPart;

  public Java_Command() {
  }

  public Java_Command setWorkingDirectory_File(File workingDirectory) {
    if (workingDirectory != null) {
      myWorkingDirectory_File = workingDirectory;
    }
    return this;
  }

  public Java_Command setJrePath_String(String jrePath) {
    if (jrePath != null) {
      myJrePath_String = jrePath;
    }
    return this;
  }

  public Java_Command setProgramParameter_String(String programParameter) {
    if (programParameter != null) {
      myProgramParameter_String = programParameter;
    }
    return this;
  }

  public Java_Command setVirtualMachineParameter_String(String virtualMachineParameter) {
    if (virtualMachineParameter != null) {
      myVirtualMachineParameter_String = virtualMachineParameter;
    }
    return this;
  }

  public Java_Command setClassPath_ListString(List<String> classPath) {
    if (classPath != null) {
      myClassPath_ListString = classPath;
    }
    return this;
  }

  public Java_Command setDebuggerSettings_String(String debuggerSettings) {
    if (debuggerSettings != null) {
      myDebuggerSettings_String = debuggerSettings;
    }
    return this;
  }

  public Java_Command setVirtualMachineParameter_ProcessBuilderCommandPart(CommandPart virtualMachineParameter) {
    if (virtualMachineParameter != null) {
      myVirtualMachineParameter_ProcessBuilderCommandPart = virtualMachineParameter;
    }
    return this;
  }

  public ProcessHandler createProcess(String className) throws ExecutionException {
    return new Java_Command().setWorkingDirectory_File(myWorkingDirectory_File).setJrePath_String(myJrePath_String).setProgramParameter_String(myProgramParameter_String).setVirtualMachineParameter_String(myVirtualMachineParameter_String).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(className, ListSequence.fromList(myClassPath_ListString).select(new ISelector<String, File>() {
      public File select(String it) {
        if (it.startsWith("\"") && it.endsWith("\"")) {
          return new File(it.substring(1, it.length() - 2));
        }
        return new File(it);
      }
    }).toListSequence());
  }

  public ProcessHandler createProcess(String className, List<File> classPath) throws ExecutionException {
    return new Java_Command().setWorkingDirectory_File(myWorkingDirectory_File).setJrePath_String(myJrePath_String).setVirtualMachineParameter_ProcessBuilderCommandPart(new ListCommandPart(ListSequence.fromListAndArray(new ArrayList(), myVirtualMachineParameter_String))).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(new ListCommandPart(ListSequence.fromListAndArray(new ArrayList(), myProgramParameter_String)), className, classPath);
  }

  public ProcessHandler createProcess(CommandPart programParameter, String className, List<File> classPath) throws ExecutionException {
    File java = Java_Command.getJavaCommand(myJrePath_String);
    if ((className == null || className.length() == 0)) {
      throw new ExecutionException("Classname is empty");
    }
    if (check_yvpt_a0c0a2(programParameter) >= Java_Command.getMaxCommandLine()) {
      try {
        File parametersFile = Java_Command.writeToTmpFile(programParameter.getCommandList());
        File classPathFile = Java_Command.writeToTmpFile(ListSequence.fromList(classPath).select(new ISelector<File, String>() {
          public String select(File it) {
            return it.getAbsolutePath();
          }
        }));
        List<File> classRunnerClassPath = ListSequence.fromList(Java_Command.getClassRunnerClassPath()).select(new ISelector<String, File>() {
          public File select(String it) {
            return new File(it);
          }
        }).toListSequence();
        return new ProcessHandlerBuilder().append(java).append(myVirtualMachineParameter_ProcessBuilderCommandPart).append(myDebuggerSettings_String).append(new KeyValueCommandPart("-" + "classpath", new ListCommandPart(classRunnerClassPath, File.pathSeparator))).append("jetbrains.mps.execution.lib.startup.ClassRunner").append(new KeyValueCommandPart("-" + ("c"), className)).append(new KeyValueCommandPart("-" + ("f"), parametersFile)).append(new KeyValueCommandPart("-" + ("p"), classPathFile)).build(myWorkingDirectory_File);
      } catch (FileNotFoundException e) {
        throw new ExecutionException("Could not create temporal file for program parameters.", e);
      }

    } else {
      return new ProcessHandlerBuilder().append(java).append(myVirtualMachineParameter_ProcessBuilderCommandPart).append(myDebuggerSettings_String).append(new KeyValueCommandPart("-" + "classpath", new ListCommandPart(classPath, File.pathSeparator))).append(className).append(programParameter).build(myWorkingDirectory_File);
    }
  }

  public ProcessHandler createProcess(final SNodeReference nodePointer) throws ExecutionException {
    IModule module = check_yvpt_a0a0a3(check_yvpt_a0a0a0d(((SNodePointer) nodePointer)));
    if (module == null) {
      final Wrappers._T<String> text = new Wrappers._T<String>();
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          text.value = "Can't find module for node " + nodePointer;
        }
      });
      throw new ExecutionException(text.value);
    }
    return new Java_Command().setJrePath_String(myJrePath_String).setWorkingDirectory_File(myWorkingDirectory_File).setProgramParameter_String(myProgramParameter_String).setVirtualMachineParameter_String(myVirtualMachineParameter_String).setClassPath_ListString(Java_Command.getClasspath(module)).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(Java_Command.getClassName(nodePointer));
  }

  public ProcessHandler createProcess(JavaRunParameters runParameters, SNodeReference nodePointer) throws ExecutionException {
    return new Java_Command().setJrePath_String(check_yvpt_a0a0a0e(runParameters)).setProgramParameter_String(check_yvpt_a2a0a0e(runParameters)).setVirtualMachineParameter_String(check_yvpt_a3a0a0e(runParameters)).setWorkingDirectory_File((check_yvpt_a0a4a0a0e(runParameters) == null ?
      null :
      new File(check_yvpt_a0a0e0a0a4(runParameters))
    )).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(nodePointer);
  }

  public static IDebugger getDebugger() {
    return getDebuggerConfiguration().getDebugger();
  }

  public static boolean isUnitNode(SNode node) {
    return isNotEmpty_kk96hj_a0a0v(Java_Command.getClassName(node));
  }

  private static String getClassName(final SNode node) {
    final Wrappers._T<String> className = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        SModel model = SNodeOperations.getModel(node);
        DebugInfo debugInfo = TraceInfoCache.getInstance().get(model.getModelDescriptor());
        if (debugInfo == null) {
          LOG.error("No trace.info found for model " + model + ". Check that model is generated.");
          className.value = null;
        } else {
          Iterable<String> unitNames = (Iterable<String>) TraceDown.unitNames(node);
          if (Sequence.fromIterable(unitNames).isEmpty()) {
            LOG.error("No unitName found for " + node + " in trace.info. Check that model is generated.");
            className.value = null;
          } else if ((int) Sequence.fromIterable(unitNames).count() == 1) {
            className.value = Sequence.fromIterable(unitNames).first();
          } else {
            className.value = TraceDown.unitNameWithPosition(node, new _FunctionTypes._return_P1_E0<Boolean, TraceablePositionInfo>() {
              public Boolean invoke(TraceablePositionInfo position) {
                return (eq_kk96hj_a0a0a0a0a1a0a0a1a0c0a0a0a0b0w(position.getConceptFqName(), "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")) && (eq_kk96hj_a0a0a0a0a1a0a0a1a0c0a0a0a0b0w_0(position.getPropertyString(), BehaviorReflection.invokeVirtual(String.class, _quotation_createNode_yvpt_a0a0a0a1a0a0a1a0c0a1a1(), "virtual_getTraceableProperty_5067982036267369901", new Object[]{})));
              }
            });
          }
        }
      }
    });
    return className.value;
  }

  private static String getClassName(final SNodeReference node) {
    final Wrappers._T<String> className = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        className.value = Java_Command.getClassName(((SNodePointer) node).resolve(MPSModuleRepository.getInstance()));
      }
    });
    return className.value;
  }

  private static int getMaxCommandLine() {
    // the command line limit on win is 32767 characters 
    // (see http://blogs.msdn.com/b/oldnewthing/archive/2003/12/10/56028.aspx) 
    // we set the limit to 16384 (half as many) just in case 
    return 16384;
  }

  public static List<String> getClasspath(final SNode node) {
    // todo: node argument -> read action? 
    return ModelAccess.instance().runReadAction(new Computable<List<String>>() {
      public List<String> compute() {
        return Java_Command.getClasspath(SNodeOperations.getModel(node).getModelDescriptor().getModule());
      }
    });
  }

  public static List<String> getClasspath(final SModule module) {
    final Wrappers._T<Set<String>> classpath = new Wrappers._T<Set<String>>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        classpath.value = JavaModuleOperations.collectExecuteClasspath(module);
        classpath.value.removeAll(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("6354ebe7-c22a-4a0f-ac54-50b52ab9b065")).getFacet(JavaModuleFacet.class).getClassPath());
      }
    });
    return new ArrayList<String>(classpath.value);
  }

  public static List<String> getClasspath(IModule module, boolean withDependencies) {
    if (withDependencies) {
      return Java_Command.getClasspath(module);
    } else {
      return new ArrayList<String>(module.getFacet(JavaModuleFacet.class).getClassPath());
    }
  }

  private static List<String> getClassRunnerClassPath() {
    return ModelAccess.instance().runReadAction(new Computable<List<String>>() {
      public List<String> compute() {
        return Java_Command.getClasspath(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("5b247b59-8fd0-4475-a767-9e9ff6a9d01c")));
      }
    });
  }

  public static File getJavaCommand(@Nullable String javaHome) throws ExecutionException {
    if ((javaHome == null || javaHome.length() == 0) || !(new File(javaHome).exists())) {
      javaHome = Java_Command.getJdkHome();
    }
    if ((javaHome == null || javaHome.length() == 0)) {
      throw new ExecutionException("Could not find valid java home.");
    }
    return new File(Java_Command.getJavaCommandPath(javaHome));
  }

  public static String getJavaCommandPath(String javaHome) {
    String result = javaHome + File.separator + "bin" + File.separator;
    String java = "java";
    if (SystemInfo.isMac) {
      result += java;
    } else
    if (SystemInfo.isWindows) {
      result += java + ".exe";
    } else {
      result += java;
    }
    return result;
  }

  public static List<String> getJavaHomes() {
    String systemJavaHome = SystemProperties.getJavaHome();
    List<String> homes = ListSequence.fromList(new LinkedList<String>());
    String systemJdkHome = systemJavaHome.substring(0, systemJavaHome.length() - "/jre".length());
    if (systemJavaHome.endsWith("jre") && new File(systemJdkHome + File.separator + "bin").exists()) {
      ListSequence.fromList(homes).addElement(systemJdkHome);
    }
    if (isNotEmpty_kk96hj_a0e0fb(System.getenv("JAVA_HOME"))) {
      ListSequence.fromList(homes).addElement(System.getenv("JAVA_HOME"));
    }
    ListSequence.fromList(homes).addElement(systemJavaHome);
    return homes;
  }

  public static String getJdkHome() {
    List<String> homes = Java_Command.getJavaHomes();
    for (String javaHome : ListSequence.fromList(homes)) {
      if (new File(Java_Command.getJavaCommandPath(javaHome)).exists()) {
        return javaHome;
      }
    }
    return null;
  }

  public static String protect(String result) {
    if (result.contains(" ")) {
      return "\"" + result + "\"";
    }
    return result;
  }

  private static File writeToTmpFile(Iterable<String> text) throws FileNotFoundException {
    File tmpFile = FileUtil.createTmpFile();
    tmpFile.deleteOnExit();
    PrintWriter writer = new PrintWriter(tmpFile);
    for (String line : Sequence.fromIterable(text)) {
      writer.println(line);
    }
    writer.flush();
    writer.close();
    return tmpFile;
  }

  public static IDebuggerConfiguration getDebuggerConfiguration() {
    return new IDebuggerConfiguration() {
      @Nullable
      public IDebuggerSettings createDebuggerSettings() {
        return new LocalConnectionSettings(true);
      }

      public IDebugger getDebugger() {
        return Debuggers.getInstance().getDebuggerByName("Java");
      }
    };
  }

  private static Logger LOG = Logger.getLogger(Java_Command.class);

  private static int check_yvpt_a0c0a2(CommandPart checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getLength();
    }
    return 0;
  }

  private static IModule check_yvpt_a0a0a3(SModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }

  private static SModelDescriptor check_yvpt_a0a0a0d(SNodePointer checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModel();
    }
    return null;
  }

  private static String check_yvpt_a0a0a0e(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getAlternativeJre();
    }
    return null;
  }

  private static String check_yvpt_a2a0a0e(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.programParameters();
    }
    return null;
  }

  private static String check_yvpt_a3a0a0e(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.vmOptions();
    }
    return null;
  }

  private static String check_yvpt_a0a0e0a0a4(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.workingDirectory();
    }
    return null;
  }

  private static String check_yvpt_a0a4a0a0e(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.workingDirectory();
    }
    return null;
  }

  private static SNode _quotation_createNode_yvpt_a0a0a0a1a0a0a1a0c0a1a1() {
    SNode quotedNode_1 = null;
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    SNode quotedNode_4 = null;
    SNode quotedNode_5 = null;
    SNode quotedNode_6 = null;
    SNode quotedNode_7 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration", null, null, GlobalScope.getInstance(), false);
    SNodeAccessUtil.setProperty(quotedNode_1, "name", "main");
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.VoidType", null, null, GlobalScope.getInstance(), false);
    quotedNode_1.addChild("returnType", quotedNode_2);
    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.PublicVisibility", null, null, GlobalScope.getInstance(), false);
    quotedNode_1.addChild("visibility", quotedNode_3);
    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.StatementList", null, null, GlobalScope.getInstance(), false);
    quotedNode_1.addChild("body", quotedNode_4);
    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ParameterDeclaration", null, null, GlobalScope.getInstance(), false);
    SNodeAccessUtil.setProperty(quotedNode_5, "name", "args");
    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ArrayType", null, null, GlobalScope.getInstance(), false);
    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.baseLanguage.structure.ClassifierType", null, null, GlobalScope.getInstance(), false);
    quotedNode_7.setReference("classifier", SReference.create("classifier", quotedNode_7, SModelReference.fromString("f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)"), SNodeId.fromString("~String")));
    quotedNode_6.addChild("componentType", quotedNode_7);
    quotedNode_5.addChild("type", quotedNode_6);
    quotedNode_1.addChild("parameter", quotedNode_5);
    return quotedNode_1;
  }

  public static boolean isNotEmpty_kk96hj_a0a0v(String str) {
    return str != null && str.length() > 0;
  }

  private static boolean eq_kk96hj_a0a0a0a0a1a0a0a1a0c0a0a0a0b0w(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  private static boolean eq_kk96hj_a0a0a0a0a1a0a0a1a0c0a0a0a0b0w_0(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  public static boolean isNotEmpty_kk96hj_a0e0fb(String str) {
    return str != null && str.length() > 0;
  }
}
