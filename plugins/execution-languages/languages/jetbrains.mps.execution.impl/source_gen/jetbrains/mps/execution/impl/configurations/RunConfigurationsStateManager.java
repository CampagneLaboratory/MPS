package jetbrains.mps.execution.impl.configurations;

/*Generated by MPS */

import com.intellij.openapi.components.ProjectComponent;
import jetbrains.mps.plugins.PluginReloadingListener;
import com.intellij.openapi.project.Project;
import jetbrains.mps.plugins.PluginReloader;
import jetbrains.mps.ide.IdeMain;
import java.util.List;
import com.intellij.execution.ui.RunContentDescriptor;
import com.intellij.openapi.application.ApplicationManager;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.apache.log4j.Level;
import com.intellij.openapi.application.ModalityState;
import com.intellij.execution.ExecutionManager;
import com.intellij.execution.ui.RunContentManagerImpl;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.intellij.execution.configurations.RunConfiguration;
import jetbrains.mps.classloading.ModuleClassLoader;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.ArrayList;
import com.intellij.execution.impl.RunManagerImpl;
import com.intellij.execution.RunManagerEx;
import com.intellij.execution.impl.ProjectRunConfigurationManager;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import com.intellij.execution.configurations.ConfigurationType;
import com.intellij.openapi.extensions.Extensions;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jdom.Element;
import com.intellij.execution.RunManagerAdapter;
import com.intellij.execution.RunnerAndConfigurationSettings;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.WriteExternalException;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class RunConfigurationsStateManager implements ProjectComponent, PluginReloadingListener {
  private final Project myProject;
  private final PluginReloader myPluginReloader;
  private RunConfigurationsStateManager.RunConfigurationsState myState = null;


  public RunConfigurationsStateManager(Project project, PluginReloader pluginReloader) {
    myProject = project;
    myPluginReloader = pluginReloader;
  }



  @Override
  public void afterPluginsLoaded() {
    if (IdeMain.getTestMode() != IdeMain.TestMode.NO_TEST) {
      return;
    }
    initRunConfigurations();
  }



  @Override
  public void beforePluginsDisposed() {
    if (IdeMain.getTestMode() != IdeMain.TestMode.NO_TEST) {
      return;
    }
    disposeRunConfigurations();
  }



  @Override
  public void projectOpened() {
  }



  @Override
  public void projectClosed() {
  }



  public void initRunConfigurations() {
    if (myProject.isDisposed()) {
      return;
    }

    myState.restoreState();
  }



  /**
   * not saving state at dispose, because we do not have the valid classes at this time
   * see @PluginReloader#schedulePluginsReload()
   * instead of that we have to saveState ocassionally using RunManagerListener (see below)
   */
  public void disposeRunConfigurations() {
    assert !(myProject.isDisposed());
    disposeRunContentDescriptors();
    clearAllRunConfigurations();
  }



  private void disposeRunContentDescriptors() {
    final List<RunContentDescriptor> descriptors = collectDescriptorsToDispose();

    ApplicationManager.getApplication().invokeLater(new Runnable() {
      @Override
      public void run() {
        {
          Iterator<RunContentDescriptor> d_it = ListSequence.fromList(descriptors).iterator();
          RunContentDescriptor d_var;
          while (d_it.hasNext()) {
            d_var = d_it.next();
            if (d_var.getAttachedContent() == null) {
              if (LOG.isEnabledFor(Level.WARN)) {
                LOG.warn("Attached content of descriptor " + d_var.getDisplayName() + " is null.");
              }
            } else
            if (d_var.getAttachedContent().getManager() == null) {
              if (LOG.isEnabledFor(Level.WARN)) {
                LOG.warn("Manager of attached content of descriptor " + d_var.getDisplayName() + " is null.");
              }
            } else {
              d_var.getAttachedContent().getManager().removeAllContents(true);
            }
          }
        }
      }
    }, ModalityState.NON_MODAL);
  }



  private void clearAllRunConfigurations() {
    getRunManager().clearAll();
  }



  private List<RunContentDescriptor> collectDescriptorsToDispose() {
    ExecutionManager executionManager = myProject.getComponent(ExecutionManager.class);
    final RunContentManagerImpl contentManager = (RunContentManagerImpl) executionManager.getContentManager();

    final List<String> reloadableConfigurationNames = Sequence.fromIterable(Sequence.fromArray(getRunManager().getAllConfigurations())).where(new IWhereFilter<RunConfiguration>() {
      public boolean accept(RunConfiguration it) {
        return it.getClass().getClassLoader() instanceof ModuleClassLoader;
      }
    }).select(new ISelector<RunConfiguration, String>() {
      public String select(RunConfiguration it) {
        return it.getName();
      }
    }).toListSequence();
    final List<RunContentDescriptor> descriptors = ListSequence.fromList(new ArrayList<RunContentDescriptor>());
    {
      Iterator<RunContentDescriptor> d_it = ListSequence.fromList(contentManager.getAllDescriptors()).iterator();
      RunContentDescriptor d_var;
      while (d_it.hasNext()) {
        d_var = d_it.next();
        if (ListSequence.fromList(reloadableConfigurationNames).contains(d_var.getDisplayName())) {
          ListSequence.fromList(descriptors).addElement(d_var);
        }
      }
    }
    return descriptors;
  }



  private RunManagerImpl getRunManager() {
    return (RunManagerImpl) RunManagerEx.getInstanceEx(myProject);
  }



  private ProjectRunConfigurationManager getSharedConfigurationManager() {
    return myProject.getComponent(ProjectRunConfigurationManager.class);
  }



  @NonNls
  @NotNull
  @Override
  public String getComponentName() {
    return "MPS Run Configs Manager";
  }



  @Override
  public void initComponent() {
    myState = new RunConfigurationsStateManager.RunConfigurationsState(getRunManager());
    myState.saveState();
    myPluginReloader.addReloadingListener(this);
  }



  @Override
  public void disposeComponent() {
    myPluginReloader.removeReloadingListener(this);
  }



  public static ConfigurationType[] getConfigurationTypes() {
    ConfigurationType[] configurationTypes = Extensions.getExtensions(ConfigurationType.CONFIGURATION_TYPE_EP);
    List<ConfigurationType> result = ListSequence.fromList(new ArrayList<ConfigurationType>());
    Set<String> uniqTypes = SetSequence.fromSet(new HashSet<String>());

    for (ConfigurationType type : configurationTypes) {
      String typeId = type.getClass().getName();
      if (!(SetSequence.fromSet(uniqTypes).contains(typeId))) {
        ListSequence.fromList(result).addElement(type);
        SetSequence.fromSet(uniqTypes).addElement(typeId);
      }
    }

    return ListSequence.fromList(result).toGenericArray(ConfigurationType.class);
  }



  public static RunConfigurationsStateManager getInstance(Project project) {
    return project.getComponent(RunConfigurationsStateManager.class);
  }



  private class RunConfigurationsState {
    private Element myState;
    private Element mySharedState;


    public RunConfigurationsState(RunManagerEx runManager) {
      runManager.addRunManagerListener(new RunManagerAdapter() {
        @Override
        public void runConfigurationSelected() {
          saveState();
        }



        @Override
        public void beforeRunTasksChanged() {
          saveState();
        }



        @Override
        public void runConfigurationChanged(@NotNull RunnerAndConfigurationSettings p0) {
          saveState();
        }
      });
    }



    public void restoreState() {
      assert myState != null && mySharedState != null;
      getRunManager().initializeConfigurationTypes(RunConfigurationsStateManager.getConfigurationTypes());
      try {
        getRunManager().readExternal(myState);
        getSharedConfigurationManager().readExternal(mySharedState);
      } catch (InvalidDataException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Can't read execution configurations state", e);
        }
      }
    }



    public void saveState() {
      try {
        Element newState = new Element("root");
        getRunManager().writeExternal(newState);
        myState = newState;

        Element newSharedState = new Element("root");
        getSharedConfigurationManager().writeExternal(newSharedState);
        mySharedState = newSharedState;
      } catch (WriteExternalException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Can't save run configurations state", e);
        }
      }
    }
  }

  protected static Logger LOG = LogManager.getLogger(RunConfigurationsStateManager.class);
}
