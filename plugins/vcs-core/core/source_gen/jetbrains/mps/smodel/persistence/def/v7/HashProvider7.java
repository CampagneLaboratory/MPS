package jetbrains.mps.smodel.persistence.def.v7;

/*Generated by MPS */

import jetbrains.mps.smodel.persistence.def.IHashProvider;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.generator.ModelDigestUtil;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.persistence.def.XmlFastScanner;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import jetbrains.mps.extapi.model.GeneratableSModel;

public class HashProvider7 extends IHashProvider {
  private static final Logger LOG = LogManager.getLogger(HashProvider7.class);
  @Override
  public String getHash(String content) {
    return ModelDigestUtil.hashText(content);
  }
  @Override
  public Map<String, String> getRootHashes(String content) {
    Map<String, String> result = new HashMap<String, String>();
    extractRootHashes(content, result);
    return result;
  }
  private static void extractRootHashes(String content, Map<String, String> rootHashes) {
    XmlFastScanner scanner = new XmlFastScanner(content.toCharArray());
    int depth = 0;
    int token;
    int rootStart = -1;
    String rootId = null;
    Map<String, String> shortContent = new HashMap<String, String>();
    boolean insideRoots = false;
    while ((token = scanner.next()) != XmlFastScanner.EOI) {
      switch (token) {
        case XmlFastScanner.SIMPLE_TAG:
          boolean rootShortPart = insideRoots && ModelPersistence.NODE.equals(scanner.getName());
          boolean rootLongPart = depth == 1 && ModelPersistence.ROOT_CONTENT.equals(scanner.getName());
          if (rootShortPart || rootLongPart) {
            rootId = IHashProvider.extractId(scanner.token());
            if (rootId != null) {
              String s = scanner.getText(scanner.getTokenOffset(), scanner.getOffset());
              if (rootShortPart) {
                shortContent.put(rootId, s);
              } else {
                addMultiHash(rootHashes, rootId, shortContent.get(rootId), s);
              }
            }
            rootId = null;
          }
          break;
        case XmlFastScanner.OPEN_TAG:
          depth++;
          if (depth == 2 && ModelPersistence.ROOTS.equals(scanner.getName())) {
            insideRoots = true;
            rootHashes.put(GeneratableSModel.HEADER, ModelDigestUtil.hashText(scanner.getText(0, scanner.getTokenOffset())));
          }
          if (insideRoots && ModelPersistence.NODE.equals(scanner.getName())) {
            rootStart = scanner.getTokenOffset();
            rootId = IHashProvider.extractId(scanner.token());
          }
          if (depth == 2 && ModelPersistence.ROOT_CONTENT.equals(scanner.getName())) {
            rootStart = scanner.getTokenOffset();
            rootId = IHashProvider.extractId(scanner.token());
          }
          break;
        case XmlFastScanner.CLOSE_TAG:
          if (depth == 2 && ModelPersistence.ROOTS.equals(scanner.getName())) {
            insideRoots = false;
          }
          if (insideRoots && rootId != null && ModelPersistence.NODE.equals(scanner.getName())) {
            String s = scanner.getText(rootStart, scanner.getOffset());
            shortContent.put(rootId, s);
            rootStart = -1;
            rootId = null;
          }
          if (depth == 2 && rootId != null && ModelPersistence.ROOT_CONTENT.equals(scanner.getName())) {
            String s = scanner.getText(rootStart, scanner.getOffset());
            addMultiHash(rootHashes, rootId, shortContent.get(rootId), s);
            rootStart = -1;
            rootId = null;
          }
          depth--;
          break;
        default:
      }
    }
    if (depth != 0) {
      LOG.error("xml: bad data");
    }
  }
  private static void addMultiHash(Map<String, String> rootHashes, String rootId, String... cont) {
    StringBuilder sb = new StringBuilder();
    for (String s : cont) {
      assert s != null;
      sb.append(s);
    }
    String hash = ModelDigestUtil.hashText(sb.toString());
    rootHashes.put(rootId, hash);
  }
}
