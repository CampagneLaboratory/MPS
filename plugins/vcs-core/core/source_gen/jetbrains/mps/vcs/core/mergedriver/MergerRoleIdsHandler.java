package jetbrains.mps.vcs.core.mergedriver;

/*Generated by MPS */

import jetbrains.mps.smodel.persistence.RoleIdsComponent;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class MergerRoleIdsHandler implements RoleIdsComponent.RoleIdsHandler {
  private boolean myConsistent = true;
  private Map<String, SNodeReference> myConceptsToPointers = MapSequence.fromMap(new HashMap<String, SNodeReference>());
  private Map<Tuples._2<String, String>, SNodeReference> myNodeRolesToPointers = MapSequence.fromMap(new HashMap<Tuples._2<String, String>, SNodeReference>());
  private Map<Tuples._2<String, String>, SNodeReference> myReferenceRolesToPointers = MapSequence.fromMap(new HashMap<Tuples._2<String, String>, SNodeReference>());
  private Map<Tuples._2<String, String>, SNodeReference> myPropertyNamesToPointers = MapSequence.fromMap(new HashMap<Tuples._2<String, String>, SNodeReference>());
  private Map<SModelReference, Integer> myModelVersions = MapSequence.fromMap(new HashMap<SModelReference, Integer>());

  public MergerRoleIdsHandler() {
  }

  private <K, V> void storeAndCheckConsistency(Map<K, V> theMap, K key, V value) {
    if (MapSequence.fromMap(theMap).containsKey(key)) {
      myConsistent = myConsistent && eq_clnjnl_a0a0a0a0h(MapSequence.fromMap(theMap).get(key), value);
    } else {
      MapSequence.fromMap(theMap).put(key, value);
    }
  }

  @Override
  public void conceptRead(String conceptFqName, SNodeReference conceptPointer) {
    storeAndCheckConsistency(myConceptsToPointers, conceptFqName, conceptPointer);
  }

  @Override
  public void nodeRoleRead(String conceptFqName, String linkRole, SNodeReference linkPointer) {
    storeAndCheckConsistency(myNodeRolesToPointers, MultiTuple.<String,String>from(conceptFqName, linkRole), linkPointer);
  }

  @Override
  public void referenceRoleRead(String conceptFqName, String referenceLinkRole, SNodeReference linkPointer) {
    storeAndCheckConsistency(myReferenceRolesToPointers, MultiTuple.<String,String>from(conceptFqName, referenceLinkRole), linkPointer);
  }

  @Override
  public void propertyNameRead(String conceptFqName, String propertyName, SNodeReference namePointer) {
    storeAndCheckConsistency(myPropertyNamesToPointers, MultiTuple.<String,String>from(conceptFqName, propertyName), namePointer);
  }

  @Override
  public void modelVersionRead(SModelReference reference, int i) {
    storeAndCheckConsistency(myModelVersions, reference, i);
  }

  @Override
  public SNodeReference getConceptPointer(String conceptFqName) {
    return MapSequence.fromMap(myConceptsToPointers).get(conceptFqName);
  }

  @Override
  public SNodeReference getNodeRolePointer(String conceptFqName, String linkRole) {
    return MapSequence.fromMap(myNodeRolesToPointers).get(MultiTuple.<String,String>from(conceptFqName, linkRole));
  }

  @Override
  public SNodeReference getReferenceRolePointer(String conceptFqName, String referenceLinkRole) {
    return MapSequence.fromMap(myReferenceRolesToPointers).get(MultiTuple.<String,String>from(conceptFqName, referenceLinkRole));
  }

  @Override
  public SNodeReference getPropertyNamePointer(String conceptFqName, String propertyName) {
    return MapSequence.fromMap(myPropertyNamesToPointers).get(MultiTuple.<String,String>from(conceptFqName, propertyName));
  }

  @Override
  public int getModelVersion(SModelReference reference) {
    return MapSequence.fromMap(myModelVersions).get(reference);
  }

  /*package*/ boolean isConsistent() {
    return myConsistent;
  }

  private static boolean eq_clnjnl_a0a0a0a0h(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }
}
