package jetbrains.mps.vcs.core.mergedriver;

/*Generated by MPS */

import jetbrains.mps.persistence.LightModelEnvironmentInfo;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.SModel;

public class MergerModelEnvironmentInfoImpl implements LightModelEnvironmentInfo {
  private boolean myConsistent = true;
  private Map<String, SNodeReference> myConceptsToPointers = MapSequence.fromMap(new HashMap<String, SNodeReference>());
  private Map<Tuples._2<String, String>, SNodeReference> myNodeRolesToPointers = MapSequence.fromMap(new HashMap<Tuples._2<String, String>, SNodeReference>());
  private Map<Tuples._2<String, String>, SNodeReference> myReferenceRolesToPointers = MapSequence.fromMap(new HashMap<Tuples._2<String, String>, SNodeReference>());
  private Map<Tuples._2<String, String>, SNodeReference> myPropertyNamesToPointers = MapSequence.fromMap(new HashMap<Tuples._2<String, String>, SNodeReference>());
  private Map<SModelReference, Integer> myModelVersions = MapSequence.fromMap(new HashMap<SModelReference, Integer>());

  public MergerModelEnvironmentInfoImpl() {
  }

  private <K, V> void storeAndCheckConsistency(Map<K, V> theMap, K key, V value) {
    if (MapSequence.fromMap(theMap).containsKey(key)) {
      myConsistent = myConsistent && eq_uiv2ah_a0a0a0a0h(MapSequence.fromMap(theMap).get(key), value);
    } else {
      MapSequence.fromMap(theMap).put(key, value);
    }
  }



  @Override
  public void conceptRead(SNode node, SNodeReference conceptPointer) {
    storeAndCheckConsistency(myConceptsToPointers, node.getConcept().getId(), conceptPointer);
  }

  @Override
  public void nodeRoleRead(SNode node, SNodeReference linkPointer) {
    storeAndCheckConsistency(myNodeRolesToPointers, MultiTuple.<String,String>from(node.getConcept().getId(), node.getRoleInParent()), linkPointer);
  }

  @Override
  public void referenceRoleRead(SReference reference, SNodeReference linkPointer) {
    storeAndCheckConsistency(myReferenceRolesToPointers, MultiTuple.<String,String>from(reference.getSourceNode().getConcept().getId(), reference.getRole()), linkPointer);
  }

  @Override
  public void propertyNameRead(SNode node, String propertyName, SNodeReference propertyPointer) {
    storeAndCheckConsistency(myPropertyNamesToPointers, MultiTuple.<String,String>from(node.getConcept().getId(), propertyName), propertyPointer);
  }

  @Override
  public void modelVersionRead(SModel.ImportElement element) {
    storeAndCheckConsistency(myModelVersions, element.getModelReference(), element.getUsedVersion());
  }

  @Override
  public SNodeReference getConceptId(SNode node) {
    return MapSequence.fromMap(myConceptsToPointers).get(node.getConcept().getId());
  }

  @Override
  public SNodeReference getNodeRoleId(SNode node) {
    String roleInParent = node.getRoleInParent();
    if (roleInParent == null) {
      return null;
    }
    return MapSequence.fromMap(myNodeRolesToPointers).get(MultiTuple.<String,String>from(node.getConcept().getId(), roleInParent));
  }

  @Override
  public SNodeReference getReferenceRoleId(SReference reference) {
    return MapSequence.fromMap(myReferenceRolesToPointers).get(MultiTuple.<String,String>from(reference.getSourceNode().getConcept().getId(), reference.getRole()));
  }

  @Override
  public SNodeReference getPropertyId(SNode node, String propertyName) {
    return MapSequence.fromMap(myPropertyNamesToPointers).get(MultiTuple.<String,String>from(node.getConcept().getId(), propertyName));
  }

  @Override
  public int getModelVersion(SModelReference reference) {
    return MapSequence.fromMap(myModelVersions).get(reference);
  }

  /*package*/ boolean isConsistent() {
    return myConsistent;
  }

  private static boolean eq_uiv2ah_a0a0a0a0h(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }
}
