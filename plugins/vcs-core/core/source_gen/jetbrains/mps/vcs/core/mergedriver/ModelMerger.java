package jetbrains.mps.vcs.core.mergedriver;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.MPSCore;
import jetbrains.mps.persistence.LightModelEnvironmentInfoImpl;
import jetbrains.mps.persistence.PersistenceRegistry;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.persistence.FilePerRootDataSource;
import jetbrains.mps.project.MPSExtentions;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.persistence.PersistenceUtil;
import org.apache.log4j.Priority;
import jetbrains.mps.vcs.diff.merge.MergeSession;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.io.File;
import jetbrains.mps.vcs.util.MergeDriverBackupUtil;
import java.io.IOException;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.smodel.DefaultSModel;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

/*package*/ class ModelMerger extends SimpleMerger {
  private String myModelName;

  /*package*/ ModelMerger() {
  }

  @Override
  @Nullable
  public Tuples._2<Integer, byte[]> mergeContents(FileContent baseContent, FileContent localContent, FileContent latestContent) {
    System.setProperty("mps.playRefactorings", "false");
    MPSCore.getInstance().setMergeDriverMode(true);
    LightModelEnvironmentInfoImpl persistenceEnv = new LightModelEnvironmentInfoImpl();
    PersistenceRegistry.getInstance().setModelEnvironmentInfo(persistenceEnv);

    IFile file = FileSystem.getInstance().getFileByPath(baseContent.getFile().getPath());
    String fileExt = FileUtil.getExtension(file.getPath());
    boolean isPerRoot = FilePerRootDataSource.isPerRootPersistenceFile(file);
    String ext = (isPerRoot ?
      MPSExtentions.MODEL :
      fileExt
    );

    if (LOG.isInfoEnabled()) {
      LOG.info("Reading models...");
    }
    SModel baseModel = PersistenceUtil.loadModel(new String(baseContent.getData(), FileUtil.DEFAULT_CHARSET), ext);
    SModel localModel = PersistenceUtil.loadModel(new String(localContent.getData(), FileUtil.DEFAULT_CHARSET), ext);
    SModel latestModel = PersistenceUtil.loadModel(new String(latestContent.getData(), FileUtil.DEFAULT_CHARSET), ext);
    if (baseModel == null || localModel == null || latestModel == null) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error("Error while reading models");
      }
      return backup(baseContent, localContent, latestContent);
    }
    myModelName = baseModel.getModelName();

    int baseP = getPersistenceVersion(baseModel);
    int localP = getPersistenceVersion(localModel);
    int latestP = getPersistenceVersion(latestModel);
    if (baseP >= 7 && localP >= 7 && latestP >= 7 || baseP < 7 && localP < 7 && latestP < 7) {
      // ok, can merge 
    } else {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error(String.format("%s: Conflicting model persistence versions", myModelName));
      }
      return backup(baseContent, localContent, latestContent);
    }
    if (!(persistenceEnv.isConsistent())) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error(String.format("%s: Inconsistent structure ids or import versions", myModelName));
      }
      return backup(baseContent, localContent, latestContent);
    }

    try {
      if (LOG.isInfoEnabled()) {
        LOG.info("Merging " + baseModel.getReference() + "...");
      }
      final MergeSession mergeSession = MergeSession.createMergeSession(baseModel, localModel, latestModel);
      int conflictingChangesCount = Sequence.fromIterable(mergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange c) {
          return Sequence.fromIterable(mergeSession.getConflictedWith(c)).isNotEmpty();
        }
      }).count();
      if (conflictingChangesCount == 0) {
        if (LOG.isInfoEnabled()) {
          LOG.info(String.format("%s: %d changes detected: %d local and %d latest.", myModelName, Sequence.fromIterable(mergeSession.getAllChanges()).count(), ListSequence.fromList(mergeSession.getMyChangeSet().getModelChanges()).count(), ListSequence.fromList(mergeSession.getRepositoryChangeSet().getModelChanges()).count()));
        }
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            mergeSession.applyChanges(mergeSession.getAllChanges());
          }
        });
        if (mergeSession.hasIdsToRestore()) {
          if (LOG.isInfoEnabled()) {
            LOG.info(String.format("%s: node id duplication detected, should merge in UI.", myModelName));
          }
        } else {
          String resultString;
          if (isPerRoot) {
            resultString = PersistenceUtil.savePerRootModel(mergeSession.getResultModel(), fileExt.equals(MPSExtentions.MODEL_HEADER));
          } else {
            resultString = PersistenceUtil.saveModel(mergeSession.getResultModel(), ext);
          }
          if (resultString == null) {
            if (LOG.isEnabledFor(Priority.ERROR)) {
              LOG.error("Error while saving result model");
            }
            return backup(baseContent, localContent, latestContent);
          }
          if (LOG.isInfoEnabled()) {
            LOG.info(String.format("%s: merged successfully.", myModelName));
          }
          backup(baseContent, localContent, latestContent);
          return MultiTuple.<Integer,byte[]>from(MERGED, resultString.getBytes(FileUtil.DEFAULT_CHARSET));
        }
      } else {
        if (LOG.isInfoEnabled()) {
          LOG.info(String.format("%s: %d changes detected, %d of them are conflicting", myModelName, Sequence.fromIterable(mergeSession.getAllChanges()).count(), conflictingChangesCount));
        }
      }
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error("Exception while merging", e);
      }
      return backup(baseContent, localContent, latestContent);
    }

    return backup(baseContent, localContent, latestContent);
  }

  private Tuples._2<Integer, byte[]> backup(FileContent baseContent, FileContent localContent, FileContent latestContent) {
    try {
      File zipModel = MergeDriverBackupUtil.zipModel(new byte[][]{baseContent.getData(), localContent.getData(), latestContent.getData()}, myModelName);
      if (zipModel != null) {
        if (LOG.isInfoEnabled()) {
          LOG.info("Saved merge backup to " + zipModel);
        }
      }
    } catch (IOException e) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error(String.format("%s: exception while backuping", myModelName), e);
      }
    }
    return null;
  }

  private static int getPersistenceVersion(SModel model) {
    jetbrains.mps.smodel.SModel m = ((SModelBase) model).getSModelInternal();
    if (m instanceof DefaultSModel) {
      return ((DefaultSModel) m).getPersistenceVersion();
    }
    return -1;
  }

  protected static Logger LOG = LogManager.getLogger(ModelMerger.class);
}
