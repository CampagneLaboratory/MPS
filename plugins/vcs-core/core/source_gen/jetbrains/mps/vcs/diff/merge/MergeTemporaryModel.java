package jetbrains.mps.vcs.diff.merge;

/*Generated by MPS */

import jetbrains.mps.extapi.model.EditableSModelBase;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.persistence.NullDataSource;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import java.io.IOException;
import org.jetbrains.mps.openapi.persistence.ModelSaveException;

public class MergeTemporaryModel extends EditableSModelBase {
  protected volatile SModel mySModel;
  private boolean myReadOnly;

  public MergeTemporaryModel(SModelReference modelRef, boolean readonly) {
    super(modelRef, new NullDataSource());
    myReadOnly = readonly;
    updateTimestamp();
  }

  public MergeTemporaryModel(SModel model, boolean readonly) {
    this(model.getSModelReference(), readonly);
    mySModel = model;
    model.setModelDescriptor(this);
  }

  @Override
  public final SModel getSModelInternal() {
    if (mySModel != null) {
      return mySModel;
    }
    synchronized (this) {
      if (mySModel == null) {
        mySModel = new SModel(getReference());
        mySModel.setModelDescriptor(this);
        fireModelStateChanged(ModelLoadingState.FULLY_LOADED);
      }
    }
    return mySModel;
  }

  @Override
  public boolean isLoaded() {
    return mySModel != null;
  }

  @Override
  protected SModel getCurrentModelInternal() {
    return mySModel;
  }

  @Override
  public boolean isChanged() {
    // false prevents model from saving 
    return false;
  }

  @Override
  protected boolean saveModel() throws IOException, ModelSaveException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void rename(String newModelName, boolean changeFile) {
    throw new UnsupportedOperationException();
  }

  protected void doUnload() {
    throw new UnsupportedOperationException();
  }

  @Override
  public boolean isReadOnly() {
    return myReadOnly;
  }

  @Override
  protected void reloadContents() {
    throw new UnsupportedOperationException();
  }
}
