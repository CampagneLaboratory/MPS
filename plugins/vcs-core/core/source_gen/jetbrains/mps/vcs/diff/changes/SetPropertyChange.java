package jetbrains.mps.vcs.diff.changes;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import jetbrains.mps.vcs.diff.ChangeSet;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.search.SModelSearchUtil;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.UUID;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.smodel.SNodePointer;
import org.jetbrains.mps.openapi.model.SModel;

public class SetPropertyChange extends NodeChange {
  private String myPropertyName;
  private String myNewValue;
  public SetPropertyChange(@NotNull ChangeSet changeSet, @NotNull SNodeId nodeId, String propertyName, String newValue) {
    super(changeSet, nodeId);
    myPropertyName = propertyName;
    myNewValue = newValue;
  }
  @NotNull
  public String getPropertyName() {
    return myPropertyName;
  }
  private SNodeReference myMergeHint = null;
  private boolean myMergeHintLoaded = false;
  @Nullable
  @Override
  public SNodeReference getMergeHint() {
    // get "nonconflicting" attribute in metamodel  
    if (!(myMergeHintLoaded)) {
      myMergeHintLoaded = true;
      SNode n = getChangeSet().getOldModel().getNode(getAffectedNodeId());
      SNode c = SNodeOperations.getConceptDeclaration(n);
      SNode propDecl = SNodeOperations.as(SModelSearchUtil.findPropertyDeclaration(c, myPropertyName), MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489288299l, "jetbrains.mps.lang.structure.structure.PropertyDeclaration"));
      SNode hint = AttributeOperations.getAttribute(propDecl, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.vcs.mergehints.structure.MergeHint"));
      if ((hint == null)) {
        hint = AttributeOperations.getAttribute(c, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.vcs.mergehints.structure.MergeHint"));
      }
      if ((hint != null)) {
        myMergeHint = new SNodePointer(hint);
      }
    }
    return myMergeHint;
  }
  public String getNewValue() {
    return myNewValue;
  }
  @Override
  public void apply(@NotNull SModel model, @NotNull NodeCopier nodeCopier) {
    SNode node = model.getNode(getAffectedNodeId());
    assert node != null;
    node.setProperty(myPropertyName, myNewValue);
  }
  @NotNull
  @Override
  protected ModelChange createOppositeChange() {
    SNode node = getChangeSet().getOldModel().getNode(getAffectedNodeId());
    assert node != null;
    return new SetPropertyChange(getChangeSet().getOppositeChangeSet(), getAffectedNodeId(), myPropertyName, node.getProperty(myPropertyName));
  }
  @Override
  public String toString() {
    return String.format("Set property %s to %s in node %s", myPropertyName, myNewValue, getAffectedNodeId());
  }
  @Override
  public String getDescription() {
    return String.format("Changed %s of #%s from '%s' to '%s'", myPropertyName, getAffectedNodeId(), getChangeSet().getOldModel().getNode(getAffectedNodeId()).getProperty(myPropertyName), getChangeSet().getNewModel().getNode(getAffectedNodeId()).getProperty(myPropertyName));
  }
}
