package jetbrains.mps.vcs.diff.changes;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.vcs.diff.ChangeSet;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.UUID;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.smodel.SNodePointer;
import org.jetbrains.mps.openapi.model.SModel;

public class SetPropertyChange extends NodeChange {
  private SProperty myProperty;
  private String myNewValue;
  private SNodeReference myMergeHint = null;
  private boolean myMergeHintLoaded = false;

  public SetPropertyChange(@NotNull ChangeSet changeSet, @NotNull SNodeId nodeId, SProperty property, String newValue) {
    super(changeSet, nodeId);
    myProperty = property;
    myNewValue = newValue;
  }
  @NotNull
  public String getPropertyName() {
    return myProperty.getName();
  }
  public boolean isAbout(SProperty property) {
    return myProperty.equals(property);
  }
  @Nullable
  @Override
  public SNodeReference getMergeHint() {
    // get "nonconflicting" attribute in metamodel  
    if (!(myMergeHintLoaded)) {
      myMergeHintLoaded = true;
      SNode n = getChangeSet().getOldModel().getNode(getAffectedNodeId());
      SNode c = SNodeOperations.getConceptDeclaration(n);
      SNode propDecl = SNodeOperations.as(myProperty.getDeclarationNode(), MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489288299l, "jetbrains.mps.lang.structure.structure.PropertyDeclaration"));
      SNode hint = AttributeOperations.getAttribute(propDecl, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.vcs.mergehints.structure.MergeHint"));
      if ((hint == null)) {
        hint = AttributeOperations.getAttribute(c, new IAttributeDescriptor.NodeAttribute("jetbrains.mps.vcs.mergehints.structure.MergeHint"));
      }
      if ((hint != null)) {
        myMergeHint = new SNodePointer(hint);
      }
    }
    return myMergeHint;
  }
  public String getNewValue() {
    return myNewValue;
  }
  @Override
  public void apply(@NotNull SModel model, @NotNull NodeCopier nodeCopier) {
    SNode node = model.getNode(getAffectedNodeId());
    assert node != null;
    node.setProperty(myProperty, myNewValue);
  }
  @NotNull
  @Override
  protected ModelChange createOppositeChange() {
    SNode node = getChangeSet().getOldModel().getNode(getAffectedNodeId());
    assert node != null;
    return new SetPropertyChange(getChangeSet().getOppositeChangeSet(), getAffectedNodeId(), myProperty, node.getProperty(myProperty));
  }
  @Override
  public String toString() {
    return String.format("Set property %s to %s in node %s", myProperty, myNewValue, getAffectedNodeId());
  }
  @Override
  public String getDescription() {
    return String.format("Changed %s of #%s from '%s' to '%s'", myProperty, getAffectedNodeId(), getChangeSet().getOldModel().getNode(getAffectedNodeId()).getProperty(myProperty), getChangeSet().getNewModel().getNode(getAffectedNodeId()).getProperty(myProperty));
  }
}
