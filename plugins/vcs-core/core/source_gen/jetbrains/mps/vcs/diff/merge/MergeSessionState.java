package jetbrains.mps.vcs.diff.merge;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import java.util.Set;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;

public class MergeSessionState {
  /*package*/ SModel myResultModel;
  /*package*/ Set<ModelChange> myResolvedChanges;
  /*package*/ Map<SNodeId, SNodeId> myIdReplacementCache;

  /*package*/ MergeSessionState(SModel resultModel, Set<ModelChange> resolvedChanges, Map<SNodeId, SNodeId> idReplacementCache) {
    myResultModel = CopyUtil.copyModel(as_4dd3vt_a0a0a0a0d(resultModel, SModelBase.class).getSModelInternal()).getModelDescriptor();
    myResolvedChanges = SetSequence.fromSetWithValues(new HashSet<ModelChange>(), resolvedChanges);
    myIdReplacementCache = MapSequence.fromMap(new HashMap<SNodeId, SNodeId>(MapSequence.fromMap(idReplacementCache).count()));
    MapSequence.fromMap(idReplacementCache).visitAll(new IVisitor<IMapping<SNodeId, SNodeId>>() {
      public void visit(IMapping<SNodeId, SNodeId> m) {
        MapSequence.fromMap(myIdReplacementCache).put(m.key(), m.value());
      }
    });
  }

  /*package*/ MergeSessionState(MergeSessionState copy) {
    this(copy.myResultModel, copy.myResolvedChanges, copy.myIdReplacementCache);
  }

  private static <T> T as_4dd3vt_a0a0a0a0d(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
