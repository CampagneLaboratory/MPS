package jetbrains.mps.ide.modelchecker.actions;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.ide.findusages.model.SearchResult;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.progress.ProgressMonitor;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.smodel.LanguageAspect;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.project.GlobalScope;

public class ReferenceableConceptsChecker extends SpecificChecker {
  public ReferenceableConceptsChecker() {
  }

  @Override
  public List<SearchResult<ModelCheckerIssue>> checkModel(final SModel model, final ProgressMonitor monitor, IOperationContext operationContext) {
    final List<SearchResult<ModelCheckerIssue>> results = ListSequence.fromList(new ArrayList<SearchResult<ModelCheckerIssue>>());
    if (model == null || model.getModelDescriptor() == null || model.getModelDescriptor().getModule() == null) {
      return results;
    }

    String title = "Checking " + SModelOperations.getModelName(model) + " for bad references...";
    if (monitor.isCanceled()) {
      return results;
    }
    monitor.start(title, 1);

    if (LanguageAspect.STRUCTURE.is(model.getModelDescriptor())) {
      for (SNode concept : ListSequence.fromList(SModelOperations.getRoots(model, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"))) {
        for (SNode ref : ListSequence.fromList(SLinkOperations.getTargets(concept, "linkDeclaration", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SPropertyOperations.hasValue(it, "metaClass", "reference", "reference");
          }
        })) {
          SNode target = SLinkOperations.getTarget(ref, "target", false);
          if (SNodeOperations.isInstanceOf(target, "jetbrains.mps.lang.structure.structure.ConceptDeclaration")) {
            SNode decl = SNodeOperations.cast(target, "jetbrains.mps.lang.structure.structure.ConceptDeclaration");
            if (SPropertyOperations.hasValue(decl, "incomingRefs", "forbidden", null)) {
              addIssue(results, ref, "Reference to a non-referenceable concept found: " + SPropertyOperations.getString(target, "name"), ModelChecker.SEVERITY_ERROR, "reference to a non-referenceable concept", null);
            }
          }
        }
      }
    }

    for (SNode node : ListSequence.fromList(SModelOperations.getNodes(model, null))) {
      if (monitor.isCanceled()) {
        break;
      }
      // Check for unresolved references 
      for (SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(node))) {
        if ((AttributeOperations.getAttribute(node, new IAttributeDescriptor.LinkAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.generator.structure.ReferenceMacro"), SLinkOperations.getRole(ref))) != null)) {
          continue;
        }
        SNode target = jetbrains.mps.util.SNodeOperations.getTargetNodeSilently(ref);
        if (target == null) {
          addIssue(results, node, "Unresolved reference: " + SLinkOperations.getResolveInfo(ref), ModelChecker.SEVERITY_ERROR, "unresolved reference", null);
          continue;
        }
        boolean sameRoot = SNodeOperations.getContainingRoot(target) == SNodeOperations.getContainingRoot(node);
        checkNode(results, target, sameRoot, false, target);
        SNode curr = target;
        while (!(SNodeOperations.isAttribute(curr))) {
          curr = SNodeOperations.getParent(curr);
          if (curr == null) {
            break;
          }
          checkNode(results, curr, sameRoot, true, target);
        }
      }
    }
    return results;
  }



  private void checkNode(List<SearchResult<ModelCheckerIssue>> results, SNode node, boolean sameRoot, boolean isAncestor, SNode anchor) {
    SNode conceptDecl = SModelUtil.findConceptDeclaration(node.getConcept().getQualifiedName(), GlobalScope.getInstance());
    if (conceptDecl == null) {
      addIssue(results, node, "No concept found for " + node.toString(), ModelChecker.SEVERITY_ERROR, "no concept", null);
    }
    if (SNodeOperations.isInstanceOf(conceptDecl, "jetbrains.mps.lang.structure.structure.ConceptDeclaration")) {
      SNode decl = SNodeOperations.cast(conceptDecl, "jetbrains.mps.lang.structure.structure.ConceptDeclaration");

      if (isAncestor) {
        if (SPropertyOperations.hasValue(decl, "childrenRefs", "forbidden", null)) {
          addIssue(results, anchor, "Reference to a node under `enforce forbidden' references node: ancestor concept=" + SPropertyOperations.getString(decl, "name"), ModelChecker.SEVERITY_ERROR, "reference to a non-referenceable node", null);
        } else if (SPropertyOperations.hasValue(decl, "childrenRefs", "local", null) && !(sameRoot)) {
          addIssue(results, anchor, "Cross-root reference to a locally referenceable concept found: ancestor concept=" + SPropertyOperations.getString(decl, "name"), ModelChecker.SEVERITY_ERROR, "reference to a locally referenceable node", null);
        }

      } else {
        if (SPropertyOperations.hasValue(decl, "incomingRefs", "forbidden", null)) {
          addIssue(results, anchor, "Reference to a non-referenceable node found: " + SPropertyOperations.getString(decl, "name"), ModelChecker.SEVERITY_ERROR, "reference to a non-referenceable node", null);
        } else if (SPropertyOperations.hasValue(decl, "incomingRefs", "local", null) && !(sameRoot)) {
          addIssue(results, anchor, "Cross-root reference to a locally referenceable node found: " + SPropertyOperations.getString(decl, "name"), ModelChecker.SEVERITY_ERROR, "reference to a locally referenceable node", null);
        }
      }
    } else {
      addIssue(results, node, "Interface instance found! " + node.toString(), ModelChecker.SEVERITY_ERROR, "no concept", null);
    }
  }


}
