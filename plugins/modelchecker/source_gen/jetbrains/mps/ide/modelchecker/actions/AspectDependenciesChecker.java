package jetbrains.mps.ide.modelchecker.actions;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.util.PathManager;
import java.util.List;
import jetbrains.mps.ide.findusages.model.SearchResult;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.progress.ProgressMonitor;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.resolve.ResolverComponent;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.persistence.DataSource;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.extapi.persistence.FileDataSource;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.project.Solution;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class AspectDependenciesChecker extends SpecificChecker {
  private static int CORE = 1;
  private static int EDITOR = 2;
  private static int WORKBENCH = 3;
  private static int OTHER = 4;
  private SModule coreModule;
  private SModule editorModule;
  private String languagesUtilPath;

  public AspectDependenciesChecker() {
    this.coreModule = MPSModuleRepository.getInstance().getModuleByFqName("MPS.Core");
    this.editorModule = MPSModuleRepository.getInstance().getModuleByFqName("MPS.Editor");
    this.languagesUtilPath = PathManager.getHomePath() + "/languages/util/";
  }

  @Override
  public List<SearchResult<ModelCheckerIssue>> checkModel(SModel model, ProgressMonitor monitor, final IOperationContext operationContext) {
    List<SearchResult<ModelCheckerIssue>> results = ListSequence.fromList(new ArrayList<SearchResult<ModelCheckerIssue>>());
    String title = "Checking " + SModelOperations.getModelName(model) + " for wrong aspect dependencies...";
    monitor.start(title, 1);

    int modelKind = getModelKind(model, null);
    if (modelKind == OTHER) {
      monitor.done();
      return results;
    }

    for (SNode node : ListSequence.fromList(SModelOperations.getNodes(model, null))) {
      if (monitor.isCanceled()) {
        break;
      }
      // Check for unresolved references 
      for (final SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(node))) {
        if ((AttributeOperations.getAttribute(node, new IAttributeDescriptor.LinkAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.generator.structure.ReferenceMacro"), SLinkOperations.getRole(ref))) != null)) {
          continue;
        }
        SNode targetNode = jetbrains.mps.util.SNodeOperations.getTargetNodeSilently(ref);
        if (targetNode == null) {
          addIssue(results, node, "Unresolved reference: " + SLinkOperations.getResolveInfo(ref), ModelChecker.SEVERITY_ERROR, "unresolved reference", new IModelCheckerFix() {
            public boolean doFix() {
              return ResolverComponent.getInstance().resolve(ref, operationContext);
            }
          });
          continue;
        }

        SModel targetModel = SNodeOperations.getModel(targetNode);
        int targetKind = getModelKind(targetModel, ref);
        if (targetKind > modelKind) {
          addIssue(results, node, "Wrong reference: " + SLinkOperations.getResolveInfo(ref) + ", reference from " + kindToString(modelKind) + " to " + kindToString(targetKind), ModelChecker.SEVERITY_ERROR, "wrong aspect dependency (" + kindToString(modelKind) + ")", null);
        }
      }
    }
    monitor.done();
    return results;
  }

  public int getModelKind(SModel model, @Nullable SReference reference) {
    DataSource source = (model != null ?
      model.getSource() :
      null
    );
    IFile modelFile = (source instanceof FileDataSource ?
      ((FileDataSource) source).getFile() :
      null
    );
    if (modelFile != null) {
      String filePath = modelFile.getAbsolutePath().replace('\\', '/');
      if (filePath.startsWith(languagesUtilPath)) {
        return OTHER;
      }
    }

    SModule module = model.getModule();
    if (module instanceof Language) {
      LanguageAspect aspect = Language.getModelAspect(model);
      if (aspect != null) {
        switch (aspect) {
          case ACTIONS:
            return EDITOR;
          case BEHAVIOR:
            return CORE;
          case CONSTRAINTS:
            return CORE;
          case DATA_FLOW:
            return CORE;
          case EDITOR:
            return EDITOR;
          case FIND_USAGES:
            return CORE;
          case INTENTIONS:
            return EDITOR;
          case PLUGIN:
            return WORKBENCH;
          case REFACTORINGS:
            return CORE;
          case SCRIPTS:
            return CORE;
          case STRUCTURE:
            return CORE;
          case STUBS:
            return CORE;
          case TEST:
            return EDITOR;
          case TEXT_GEN:
            return CORE;
          case TYPESYSTEM:
            return CORE;
          default:
        }
      }
      return CORE;

    } else if (module instanceof Solution) {

      String moduleFqName = module.getModuleName();
      if (moduleFqName.equals("JDK")) {
        return CORE;
      }
      if (moduleFqName.equals("MPS.Core")) {
        return CORE;
      }
      if (moduleFqName.equals("MPS.Editor")) {
        return EDITOR;
      }
      if (moduleFqName.equals("MPS.Workbench")) {
        return WORKBENCH;
      }
      if (moduleFqName.equals("MPS.Classpath")) {
        SNode refTargetRoot = reference.getTargetNode().getContainingRoot();
        if (SNodeOperations.isInstanceOf(refTargetRoot, "jetbrains.mps.baseLanguage.structure.Classifier")) {
          String cName = SPropertyOperations.getString(SNodeOperations.cast(refTargetRoot, "jetbrains.mps.baseLanguage.structure.Classifier"), "name");
          String modelName = model.getModelName();
          if (findInModule(coreModule, modelName, cName)) {
            return CORE;
          }
          if (findInModule(editorModule, modelName, cName)) {
            return EDITOR;
          }
          return WORKBENCH;
        }
        return OTHER;
      }

      Solution sol = ((Solution) module);
      switch (sol.getModuleDescriptor().getKind()) {
        case NONE:
          return OTHER;
        case PLUGIN_CORE:
          return CORE;
        case PLUGIN_EDITOR:
          return EDITOR;
        case PLUGIN_OTHER:
          return WORKBENCH;
        default:
      }
    }
    return OTHER;
  }

  public static boolean findInModule(SModule module, String modelName, String rootName) {
    for (SModel d : module.getModels()) {
      if (d.getModelName().equals(modelName)) {
        for (SNode _n : d.getRootNodes()) {
          SNode n = (SNode) _n;
          if (SNodeOperations.isInstanceOf(n, "jetbrains.mps.baseLanguage.structure.Classifier") && SPropertyOperations.getString(SNodeOperations.cast(n, "jetbrains.mps.baseLanguage.structure.Classifier"), "name").equals(rootName)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  public static String kindToString(int kind) {
    switch (kind) {
      case 1:
        return "core";
      case 2:
        return "editor";
      case 3:
        return "workbench";
      default:
    }
    return "unknown";
  }
}
