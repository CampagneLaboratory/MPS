package jetbrains.mps.ide.modelchecker.actions;

/*Generated by MPS */

import org.jetbrains.mps.openapi.util.ProgressMonitor;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.util.concurrent.CountDownLatch;
import java.util.Iterator;

public abstract class ModelCheckerController {
  public ModelCheckerController() {
  }

  public void process(final ProgressMonitor promon, final Collection<ModelCheckerIssue> issues) {
    promon.start("", CollectionSequence.fromCollection(issues).count());

    final List<ModelCheckerIssue> issuesCopy = ListSequence.fromListWithValues(new LinkedList<ModelCheckerIssue>(), issues);
    // run attempts in cycle until no more results produced 
    int issuesSize = 0;
    while (issuesSize != ListSequence.fromList(issuesCopy).count()) {
      issuesSize = ListSequence.fromList(issuesCopy).count();
      final CountDownLatch latch = new CountDownLatch(1);
      runCommand(new Runnable() {
        @Override
        public void run() {
          try {
            for (Iterator<ModelCheckerIssue> lit = ListSequence.fromList(issuesCopy).iterator(); lit.hasNext();) {
              ModelCheckerIssue issue = lit.next();
              if (issue.fix()) {
                lit.remove();
                promon.advance(1);
              }
            }
          } finally {
            latch.countDown();
          }
        }
      });
      try {
        latch.await();
      } catch (InterruptedException ignore) {
      }
    }
  }

  public abstract void runCommand(Runnable cmd);
}
