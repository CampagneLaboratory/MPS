package jetbrains.mps.lang.editor.table.runtime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.util.ArrayList;

public class ChildrenTableRow extends AbstractTableRow {
  private SContainmentLink myChildLinkDeclaration;
  private SNode myParentNode;
  private List<SNode> myChildNodes;
  public ChildrenTableRow(@NotNull SNode parentNode, @NotNull SContainmentLink childLinkDeclaration, int rowNumber) {
    super(rowNumber);
    myParentNode = parentNode;
    myChildLinkDeclaration = childLinkDeclaration;
  }
  @Override
  public void removeCell(int index) {
    SNodeOperations.deleteNode(ListSequence.fromList(getChildren()).getElement(index));
  }
  @Override
  public void createNewCell(int index) {
    assert index <= ListSequence.fromList(getChildren()).count();
    SAbstractConcept targetConcept = myChildLinkDeclaration.getTargetConcept();
    SNode newCellNode = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(targetConcept));
    insertNewCell(newCellNode, index);
  }
  protected void insertNewCell(SNode newCellNode, int index) {
    // subclasses may implement this method in a different way 
    if (index == ListSequence.fromList(getChildren()).count()) {
      myParentNode.addChild(myChildLinkDeclaration, newCellNode);
    } else {
      SNodeOperations.insertPrevSiblingChild(ListSequence.fromList(getChildren()).getElement(index), newCellNode);
    }
  }
  @Override
  public int getColumnCount() {
    return ListSequence.fromList(getChildren()).count();
  }
  @Override
  public SNode getCell(int index) {
    return ListSequence.fromList(getChildren()).getElement(index);
  }
  protected List<SNode> filterChildren(List<SNode> children) {
    // Dummy filter subclasses may implement some filtering here. 
    // Returned list can contain nulls representing not existing cells. 
    List<SNode> result = new ArrayList<SNode>();
    return ListSequence.fromList(result).addSequence(ListSequence.fromList(children));
  }
  private List<SNode> getChildren() {
    if (myChildNodes == null) {
      myChildNodes = filterChildren(SNodeOperations.getChildren(myParentNode, myChildLinkDeclaration));
    }
    return myChildNodes;
  }
}
