package jetbrains.mps.ide.mpsmigration.migration32.migrations;

/*Generated by MPS */

import jetbrains.mps.migration.global.BaseProjectMigration;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.project.Project;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.vfs.newvfs.persistent.FSRecords;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.migration.runtime.util.MigrationsUtil;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.generator.fileGenerator.FileGenerationUtil;
import jetbrains.mps.project.facets.JavaModuleFacet;

public class CleanSourcesMigration extends BaseProjectMigration implements ProjectMigrationWithOptions {
  public static final String OPTION_REMOVE_SOURCES = "jetbrains.mps.removeSources";
  public static final String ID = "jetbrains.mps.cleanSrc";


  private boolean mySources = false;

  public CleanSourcesMigration() {
    super(CleanSourcesMigration.ID);
  }

  @Override
  public String getDescription() {
    return "Clean Generated " + ((mySources ? "Sources" : "Classes"));
  }

  @Override
  public boolean doExecute(Project p) {
    removeGeneratedFiles(mySources, p);
    return true;
  }

  @Override
  public Collection<String> getOptionIds() {
    return Collections.singleton(CleanSourcesMigration.OPTION_REMOVE_SOURCES);
  }

  @Override
  public void setOptionValues(Map<String, Object> values) {
    Object b = values.get(CleanSourcesMigration.OPTION_REMOVE_SOURCES);
    assert b instanceof Boolean;
    mySources = ((Boolean) b);
  }

  public static void removeGeneratedFiles(final boolean sources, final Project p) {
    ApplicationManager.getApplication().runWriteAction(new Runnable() {
      public void run() {
        if (sources) {
          removeGenSources(p);
        }

        // clean genclasses 
        removeClassesGen(p);
        // invalidate FS caches (see InvalidateCachesAction) 
        FSRecords.invalidateCaches();
      }
    });
  }

  /**
   * todo. Was originally copied from IdeCommandUtil, then changed. Check whether they could 
   * be combined into one piece of universal code
   */
  private static void removeGenSources(Project p) {
    Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(p)).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        IFile outputDir = it.getOutputPath();
        IFile testDir = check_jwqyzj_a0b0a0a0a81(it.getFacet(TestsFacet.class));
        if (outputDir != null) {
          IFile cacheDir = FileGenerationUtil.getCachesDir(outputDir);
          outputDir.delete();
          cacheDir.delete();
        }
        if (testDir != null) {
          IFile testCacheDir = FileGenerationUtil.getCachesDir(testDir);
          testDir.delete();
          testCacheDir.delete();
        }
      }
    });
  }

  private static void removeClassesGen(Project p) {
    Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(p)).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        IFile outputDir = it.getOutputPath();
        IFile classesGen = check_jwqyzj_a0b0a0a0a02(it.getFacet(JavaModuleFacet.class));
        if (classesGen != null) {
          classesGen.delete();
        }
      }
    });
  }
  private static IFile check_jwqyzj_a0b0a0a0a81(TestsFacet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTestsOutputPath();
    }
    return null;
  }
  private static IFile check_jwqyzj_a0b0a0a0a02(JavaModuleFacet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getClassesGen();
    }
    return null;
  }
}
