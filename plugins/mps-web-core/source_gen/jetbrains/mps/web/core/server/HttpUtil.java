package jetbrains.mps.web.core.server;

/*Generated by MPS */

import com.sun.net.httpserver.HttpExchange;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.sun.net.httpserver.Headers;
import java.io.IOException;
import org.apache.log4j.Priority;
import java.io.OutputStream;
import org.jetbrains.annotations.NotNull;
import java.io.File;
import java.io.FileInputStream;
import com.intellij.openapi.util.io.FileUtilRt;
import java.util.Map;
import java.util.HashMap;
import java.net.URI;
import java.net.URLDecoder;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class HttpUtil {
  public static void doResponse(String content, String contentType, int responseCode, HttpExchange exchange) {
    doResponse(content.getBytes(), contentType, responseCode, exchange);
  }

  public static void doResponse(byte[] content, String contentType, int responseCode, HttpExchange exchange) {
    doResponse(content, contentType, responseCode, null, exchange);
  }

  public static void doResponse(byte[] content, String contentType, int responseCode, _FunctionTypes._void_P1_E0<? super Headers> callbackOnResponseHeaders, HttpExchange exchange) {
    Headers responseHeaders = exchange.getResponseHeaders();
    responseHeaders.set("Content-Type", contentType);
    if (callbackOnResponseHeaders != null) {
      callbackOnResponseHeaders.invoke(responseHeaders);
    }
    try {
      exchange.sendResponseHeaders(responseCode, content.length);
    } catch (IOException e) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error("Could not send response headers", e);
      }
    }

    OutputStream responseBody = exchange.getResponseBody();
    try {
      responseBody.write(content);
    } catch (IOException e) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error("Could not write response", e);
      }
    } finally {
      try {
        responseBody.close();
      } catch (IOException e) {
        if (LOG.isEnabledFor(Priority.ERROR)) {
          LOG.error("Could not close response", e);
        }
      }
    }
  }

  public static void doResponse(@NotNull File file, HttpExchange exchange) throws IOException {
    if (!(file.exists())) {
      doResponse("file not found: " + file.getAbsolutePath(), "text/plain", 404, exchange);
      return;
    }
    FileInputStream inputStream = new FileInputStream(file);
    try {
      byte[] content = FileUtilRt.loadBytes(inputStream);
      HttpUtil.doResponse(content, getContentType(file), 200, exchange);
    } finally {
      inputStream.close();
    }
  }

  public static void doJsonResponse(String json, HttpExchange exchange) {
    doResponse(json, "application/json", 200, exchange);
  }

  public static String getContentType(File file) {
    if (file.getPath().endsWith(".js")) {
      return "application/javascript";
    }
    if (file.getPath().endsWith(".json")) {
      return "application/json";
    }
    if (file.getPath().endsWith(".css")) {
      return "text/css";
    }
    if (file.getPath().endsWith(".html")) {
      return "text/html";
    }
    if (file.getPath().endsWith(".png")) {
      return "image/png";
    }
    return "application/octet-stream";
  }



  public static Map<String, String> getQueryParameters(HttpExchange exchange) {
    Map<String, String> parameters = new HashMap<String, String>();
    URI requestedUri = exchange.getRequestURI();
    String query = requestedUri.getRawQuery();

    if (query != null) {
      String[] pairs = query.split("[&]");
      for (String pair : pairs) {
        String[] param = pair.split("[=]");
        String key = null;
        String value = null;
        if (param.length > 0) {
          key = URLDecoder.decode(param[0]);
        }
        if (param.length > 1) {
          value = URLDecoder.decode(param[1]);
        }
        parameters.put(key, value);
      }
    }

    return parameters;
  }

  protected static Logger LOG = LogManager.getLogger(HttpUtil.class);
}
