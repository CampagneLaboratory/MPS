package jetbrains.mps.core.gen.plugin;

/*Generated by MPS */

import jetbrains.mps.smodel.Language;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.messages.IMessageHandler;
import java.util.List;
import jetbrains.mps.core.util.merge.MergeSession;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.messages.Message;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.EditableSModel;

public class LanguageModelsMerger {
  private Language lang;
  private SModel sourceModel;
  private IMessageHandler messageHandler;
  private List<SModel> generated;
  private MergeSession session;

  public LanguageModelsMerger(Language lang, SModel sourceModel, IMessageHandler messageHandler) {
    this.lang = lang;
    this.sourceModel = sourceModel;
    this.messageHandler = messageHandler;
    this.generated = ListSequence.fromList(new ArrayList<SModel>());
  }

  public void convert() {
    ModelAccess.assertLegalRead();
    session = new MergeSession(messageHandler) {
      @Override
      protected SNode merge(SNode existing, SNode node, SModel newmodel) {
        SNode merged = super.merge(existing, node, newmodel);
        if (isNotEmptyString(SPropertyOperations.getString(SNodeOperations.cast(existing, "jetbrains.mps.lang.core.structure.BaseConcept"), "virtualPackage"))) {
          SPropertyOperations.set(SNodeOperations.cast(merged, "jetbrains.mps.lang.core.structure.BaseConcept"), "virtualPackage", SPropertyOperations.getString(SNodeOperations.cast(existing, "jetbrains.mps.lang.core.structure.BaseConcept"), "virtualPackage"));
        }
        return merged;
      }
    };

    if (ListSequence.fromList(SModelOperations.getRoots(sourceModel, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration")).isEmpty()) {
      messageHandler.handle(new Message(MessageKind.ERROR, "No concepts in generated model"));
      return;
    }


    merge(LanguageAspect.STRUCTURE, ListSequence.fromList(SModelOperations.getRoots(sourceModel, null)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return it.getConcept().getQualifiedName().startsWith("jetbrains.mps.lang.structure");
      }
    }));
    merge(LanguageAspect.BEHAVIOR, ListSequence.fromList(SModelOperations.getRoots(sourceModel, null)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return it.getConcept().getQualifiedName().startsWith("jetbrains.mps.lang.behavior");
      }
    }));

    Iterable<SNode> notMerged = ListSequence.fromList(SModelOperations.getRoots(sourceModel, null)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(session.isMapped(it));
      }
    });
    if (Sequence.fromIterable(notMerged).isNotEmpty()) {
      messageHandler.handle(new Message(MessageKind.ERROR, "Not merged: " + jetbrains.mps.util.SNodeOperations.getDebugText(Sequence.fromIterable(notMerged).first())));
      return;
    }

    session.restoreRefs();
  }

  private void merge(LanguageAspect aspect, Iterable<SNode> roots) {
    EditableSModel modelDesc = aspect.get(lang);
    if (modelDesc == null) {
      messageHandler.handle(new Message(MessageKind.ERROR, "no " + aspect.getName() + " model"));
      return;
    }
    session.replace(modelDesc, roots);
    ListSequence.fromList(this.generated).addElement(modelDesc);
  }

  public Language getLanguage() {
    return lang;
  }

  public Iterable<SModel> getGenerated() {
    return this.generated;
  }

  public void apply() {
    session.apply();
  }

  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }
}
