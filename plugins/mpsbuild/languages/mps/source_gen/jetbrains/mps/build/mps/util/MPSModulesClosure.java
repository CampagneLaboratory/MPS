package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import java.util.LinkedHashSet;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.build.util.DependenciesHelper;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.util.iterable.RecursiveIterator;
import java.util.Iterator;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;

public class MPSModulesClosure {
  private LinkedHashSet<SNode> modules = new LinkedHashSet<SNode>();
  private LinkedHashSet<SNode> languagesWithRuntime = new LinkedHashSet<SNode>();
  private TemplateQueryContext genContext;
  private SNode initial;

  public MPSModulesClosure(TemplateQueryContext genContext, SNode initialModule) {
    this.genContext = genContext;
    this.initial = initialModule;
  }

  private SNode toOriginal(SNode node) {
    if (node == null) {
      return null;
    }
    if (SNodeOperations.getContainingRoot(node) == SNodeOperations.getContainingRoot(initial)) {
      return node;
    }
    return SNodeOperations.as(DependenciesHelper.getOriginalNode(node, genContext), "jetbrains.mps.build.mps.structure.BuildMps_Module");
  }

  private Iterable<SNode> toOriginal(Iterable<SNode> modules) {
    return Sequence.fromIterable(modules).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return toOriginal(it);
      }
    }).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return it != null;
      }
    });
  }

  private Iterable<SNode> toOriginalLangs(Iterable<SNode> langs) {
    return Sequence.fromIterable(langs).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.as(toOriginal(it), "jetbrains.mps.build.mps.structure.BuildMps_Language");
      }
    }).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return it != null;
      }
    });
  }

  private Iterable<SNode> dependencies(SNode module) {
    return ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return (SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency") ?
          SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency"), "dependency", true) :
          it
        );
      }
    });
  }

  private Iterable<SNode> getDependencies(SNode module, final boolean reexport) {
    Iterable<SNode> dependencies = Sequence.fromIterable(dependencies(module)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule") && SPropertyOperations.getBoolean(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule"), "reexport") == reexport;
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule"), "module", false);
      }
    });

    if (reexport) {
      // add extended langs 
      dependencies = Sequence.fromIterable(dependencies).concat(Sequence.fromIterable(dependencies(module)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage");
        }
      }).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage"), "language", false);
        }
      }));
    }

    if (reexport) {
      return toOriginal(dependencies);
    }

    Iterable<SNode> solutionsFromDevkits = Sequence.fromIterable(includingExtended(usedDevkits(module))).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return ListSequence.fromList(SLinkOperations.getTargets(it, "exports", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode iit) {
            return SNodeOperations.isInstanceOf(iit, "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution");
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode iit) {
            return SLinkOperations.getTarget(SNodeOperations.cast(iit, "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution"), "solution", false);
          }
        });
      }
    });
    // "core" language is added in loadModules pre-script 
    return toOriginal(IterableUtil.distinct(IterableUtil.merge(dependencies, solutionsFromDevkits)));
  }

  private Iterable<SNode> getUsedLanguages(SNode module) {
    Iterable<SNode> usedLangs = Sequence.fromIterable(dependencies(module)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage"), "language", false);
      }
    });

    Iterable<SNode> languagesFromDevkits = Sequence.fromIterable(includingExtended(usedDevkits(module))).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return ListSequence.fromList(SLinkOperations.getTargets(it, "exports", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode iit) {
            return SNodeOperations.isInstanceOf(iit, "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage");
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode iit) {
            return SLinkOperations.getTarget(SNodeOperations.cast(iit, "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage"), "language", false);
          }
        });
      }
    });

    // use "core" language is added in loadModules pre-script 
    return toOriginalLangs(includingExtendedLanguages(IterableUtil.merge(usedLangs, languagesFromDevkits)));
  }

  private Iterable<SNode> usedDevkits(SNode module) {
    return Sequence.fromIterable(dependencies(module)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit"), "devkit", false);
      }
    });
  }

  private Iterable<SNode> includingExtended(Iterable<SNode> devkits) {
    return new RecursiveIterator<SNode>(Sequence.fromIterable(devkits).iterator(), false) {
      protected Iterator<SNode> children(SNode node) {
        return ListSequence.fromList(SLinkOperations.getTargets(node, "extends", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SLinkOperations.getTarget(it, "devkit", false) != null);
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, "devkit", false);
          }
        }).iterator();
      }
    };
  }

  private Iterable<SNode> includingExtendedLanguages(Iterable<SNode> langs) {
    return new RecursiveIterator<SNode>(Sequence.fromIterable(langs).iterator(), false) {
      protected Iterator<SNode> children(SNode node) {
        return Sequence.fromIterable(dependencies(node)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage");
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage"), "language", false);
          }
        }).iterator();
      }
    };
  }

  private void collectAllCompileTimeDependencies(SNode module, boolean reexportOnly, Set<SNode> nonreexportDeps) {
    // copy of ModuleDependenciesManager.collectAllCompileTimeDependencies (ignoring "core" language) 
    modules.add(module);
    for (SNode m : getDependencies(module, true)) {
      if (!(modules.contains(m))) {
        collectAllCompileTimeDependencies(m, true, nonreexportDeps);
      }
    }

    if (reexportOnly) {
      return;
    }
    for (SNode m : getDependencies(module, false)) {
      nonreexportDeps.add(m);
    }

    // NOTE: generator dependencies are imported into language in ModuleLoader.collectDependencies() 

    for (SNode language : getUsedLanguages(module)) {
      boolean hasRuntime = false;
      for (SNode rdep : SLinkOperations.getTargets(language, "runtime", true)) {
        if (!(SNodeOperations.isInstanceOf(rdep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime"))) {
          hasRuntime = true;
          continue;
        }
        SNode runtimeSolution = SNodeOperations.as(toOriginal(SLinkOperations.getTarget(SNodeOperations.cast(rdep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime"), "solution", false)), "jetbrains.mps.build.mps.structure.BuildMps_Solution");
        if (!(modules.contains(runtimeSolution))) {
          collectAllCompileTimeDependencies(runtimeSolution, true, nonreexportDeps);
        }

      }
      if (hasRuntime) {
        languagesWithRuntime.add(language);
      }
    }
  }

  public MPSModulesClosure closure() {
    Set<SNode> nonreexportDeps = new LinkedHashSet<SNode>();
    collectAllCompileTimeDependencies(initial, false, nonreexportDeps);
    modules.addAll(nonreexportDeps);
    modules.remove(initial);
    return this;
  }

  public MPSModulesClosure runtimeDependencies() {
    Set<SNode> nonreexportDeps = new LinkedHashSet<SNode>();
    modules.add(initial);
    for (SNode language : getUsedLanguages(initial)) {
      boolean hasRuntime = false;
      for (SNode rdep : SLinkOperations.getTargets(language, "runtime", true)) {
        if (!(SNodeOperations.isInstanceOf(rdep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime"))) {
          hasRuntime = true;
          continue;
        }
        SNode runtimeSolution = SNodeOperations.as(toOriginal(SLinkOperations.getTarget(SNodeOperations.cast(rdep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime"), "solution", false)), "jetbrains.mps.build.mps.structure.BuildMps_Solution");
        modules.add(runtimeSolution);

      }
      if (hasRuntime) {
        languagesWithRuntime.add(language);
      }
    }

    modules.addAll(nonreexportDeps);
    modules.remove(initial);
    return this;
  }

  public MPSModulesClosure.RequiredJavaModules getRequiredJava() {
    Iterable<SNode> reexportedFromModuleDependencies = Sequence.fromIterable(getModules()).concat(Sequence.fromIterable(Sequence.<SNode>singleton(initial))).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode mod) {
        return ListSequence.fromList(SLinkOperations.getTargets(mod, "dependencies", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule") && SPropertyOperations.getBoolean(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule"), "reexport");
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule"), "module", false);
          }
        });
      }
    });
    Set<SNode> reexportMods = SetSequence.fromSet(new HashSet<SNode>());
    for (SNode mod : reexportedFromModuleDependencies) {
      SetSequence.fromSet(reexportMods).addElement(mod);
    }

    Iterable<SNode> directDeps = ListSequence.fromList(SLinkOperations.getTargets(initial, "dependencies", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule"), "module", false);
      }
    });
    return new MPSModulesClosure.RequiredJavaModules(Sequence.fromIterable(reexportedFromModuleDependencies).concat(Sequence.fromIterable(directDeps)), reexportMods);
  }

  public Iterable<SNode> getModules() {
    return modules;
  }

  public Iterable<SNode> getLanguagesWithRuntime() {
    return languagesWithRuntime;
  }

  public SNode getInitial() {
    return initial;
  }

  public static class RequiredJavaModules {
    private Iterable<SNode> modules;
    private Set<SNode> reexported;

    public RequiredJavaModules(Iterable<SNode> modules, Set<SNode> reexported) {
      this.modules = modules;
      this.reexported = reexported;
    }

    public Iterable<SNode> getModules() {
      return modules;
    }

    public boolean isReexported(SNode mod) {
      return SetSequence.fromSet(reexported).contains(mod);
    }
  }
}
