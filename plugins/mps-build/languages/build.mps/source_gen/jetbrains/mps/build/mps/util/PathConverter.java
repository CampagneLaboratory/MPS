package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.build.behavior.BuildProject_BehaviorDescriptor;
import jetbrains.mps.build.util.Context;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.build.behavior.BuildFolderMacro_BehaviorDescriptor;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.io.File;
import java.io.IOException;

public class PathConverter {
  private String workingDirectory;
  private final Iterable<Tuples._2<String, SNode>> macros;
  private final Iterable<SNode> macrosWithoutPath;
  public PathConverter(SNode project) {
    String workingDir = BuildProject_BehaviorDescriptor.getBasePath_id4jjtc7WZOyG.invoke(project, Context.defaultContext());
    this.workingDirectory = normalizePath(workingDir, true);

    final List<Tuples._2<String, SNode>> result = ListSequence.fromList(new ArrayList<Tuples._2<String, SNode>>());
    final List<SNode> withoutPath = ListSequence.fromList(new ArrayList<SNode>());
    ListSequence.fromList(SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x4df58c6f18f84a22L, "macros"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, "jetbrains.mps.build.structure.BuildFolderMacro"));
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        String path = normalizePath(BuildFolderMacro_BehaviorDescriptor.evaluate_id4jjtc7WZOzA.invoke(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, "jetbrains.mps.build.structure.BuildFolderMacro")), Context.defaultContext()), true);
        if (path != null && path.length() > 1) {
          ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(path, SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, "jetbrains.mps.build.structure.BuildFolderMacro"))));
        } else {
          ListSequence.fromList(withoutPath).addElement(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafadd002L, "jetbrains.mps.build.structure.BuildFolderMacro")));
        }
      }
    });
    if (workingDirectory != null) {
      ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(this.workingDirectory, (SNode) null));
    }
    macros = ListSequence.fromList(result).sort(new ISelector<Tuples._2<String, SNode>, Integer>() {
      public Integer select(Tuples._2<String, SNode> it) {
        return it._0().length() * 2 - ((it._1() == null ? 1 : 0));
      }
    }, false);
    macrosWithoutPath = withoutPath;
  }
  public List<SNode> convertPath(String path, SModel model) throws PathConverter.PathConvertException {
    path = normalizePath(path, false);
    String withSlash = normalizePath(path, true);
    List<SNode> result = new ArrayList<SNode>();
    for (Tuples._2<String, SNode> m : Sequence.fromIterable(macros)) {
      String mdir = (path.startsWith("$") && m._1() != null ? "${" + SPropertyOperations.getString(m._1(), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")) + "}/" : m._0());
      mdir = (mdir == null ? "" : mdir);
      String currPath = (path.length() < mdir.length() ? withSlash : path);

      if (currPath.startsWith(mdir)) {
        currPath = currPath.substring(mdir.length());
      } else {
        continue;
      }
      ListSequence.fromList(result).addElement(buildRelative(currPath, m._1(), model));
    }
    for (SNode m : Sequence.fromIterable(macrosWithoutPath)) {
      String mdir = "${" + SPropertyOperations.getString(m, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")) + "}/";
      String currPath = (path.length() < mdir.length() ? withSlash : path);
      if (currPath.startsWith(mdir)) {
        currPath = currPath.substring(mdir.length());
      } else {
        continue;
      }
      ListSequence.fromList(result).addElement(buildRelative(currPath, m, model));
    }
    if (ListSequence.fromList(result).isEmpty()) {
      throw new PathConverter.PathConvertException("source path (" + path + ") should be under working directory (" + workingDirectory + "), or any macros default directory");

    }
    return result;
  }

  public static SNode createRelative(String baseDir, String fullPath, SModel model) throws PathConverter.PathConvertException {
    baseDir = normalizePath(baseDir, true);
    fullPath = normalizePath(fullPath, false);
    if (!(fullPath.startsWith(baseDir))) {
      throw new PathConverter.PathConvertException(String.format("specified path '%s' does not start with base dir '%s'", fullPath, baseDir));
    }
    return buildRelative(fullPath.substring(baseDir.length(), fullPath.length()), null, model);
  }

  private static SNode buildRelative(String currPath, SNode macro, SModel model) {
    SNode relPath;
    if (macro == null) {
      relPath = SModelOperations.createNewNode(model, null, SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4c12642949048fb2L, "jetbrains.mps.build.structure.BuildSourceProjectRelativePath")));
    } else {
      relPath = SModelOperations.createNewNode(model, null, SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafae121dL, "jetbrains.mps.build.structure.BuildSourceMacroRelativePath")));
      SLinkOperations.setTarget(SNodeOperations.cast(relPath, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafae121dL, "jetbrains.mps.build.structure.BuildSourceMacroRelativePath")), MetaAdapterFactory.getReferenceLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafae121dL, 0x668c6cfbafae122aL, "macro"), macro);
    }
    buildCompositePath(relPath, currPath, model);
    return relPath;
  }

  private static void buildCompositePath(SNode result, String path, SModel model) {
    SNode last = null;
    for (String fname : path.split("/")) {
      if ((fname != null && fname.length() > 0)) {
        SNode npath = SModelOperations.createNewNode(model, null, SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x779c6e65c01467f1L, "jetbrains.mps.build.structure.BuildCompositePath")));
        SPropertyOperations.set(npath, MetaAdapterFactory.getProperty(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x779c6e65c01467f1L, 0x779c6e65c01467f3L, "head"), fname);
        if (last == null) {
          SLinkOperations.setTarget(result, MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x65997a657729f6fbL, 0x65997a65772aebcbL, "compositePart"), npath);
        } else {
          SLinkOperations.setTarget(last, MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x779c6e65c01467f1L, 0x779c6e65c01467f2L, "tail"), npath);
        }
        last = npath;
      }
    }
  }

  private static String normalizePath(String path, boolean addSlash) {
    if (path == null || (path == null || path.length() == 0)) {
      return null;
    }
    try {
      path = (path.startsWith("${") ? path : new File(path).getCanonicalPath());
      path = path.replace("\\", "/");
    } catch (IOException ignore) {
      // ignore 
    }
    if (addSlash && !(path.endsWith("/"))) {
      path = path + "/";
    }
    return path;
  }

  public static class PathConvertException extends Exception {
    public PathConvertException(String message) {
      super(message);
    }
  }
}
