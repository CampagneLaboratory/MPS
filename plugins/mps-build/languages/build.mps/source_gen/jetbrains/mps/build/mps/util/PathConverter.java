package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.build.behavior.BuildProject_Behavior;
import jetbrains.mps.build.util.Context;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.build.behavior.BuildFolderMacro_Behavior;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.io.File;
import java.io.IOException;

public class PathConverter {
  private String workingDirectory;
  private final Iterable<Tuples._2<String, SNode>> macros;

  public PathConverter(SNode project) {
    String workingDir = BuildProject_Behavior.call_getBasePath_4959435991187146924(project, Context.defaultContext());
    this.workingDirectory = normalizePath(workingDir, true);

    final List<Tuples._2<String, SNode>> result = ListSequence.fromList(new ArrayList<Tuples._2<String, SNode>>());
    ListSequence.fromList(SLinkOperations.getTargets(project, "macros", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.structure.BuildFolderMacro");
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        String path = normalizePath(BuildFolderMacro_Behavior.call_evaluate_4959435991187146982(SNodeOperations.cast(it, "jetbrains.mps.build.structure.BuildFolderMacro"), Context.defaultContext()), true);
        if (path != null && path.length() > 1) {
          ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(path, SNodeOperations.cast(it, "jetbrains.mps.build.structure.BuildFolderMacro")));
        }
      }
    });
    ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(this.workingDirectory, (SNode) null));
    macros = ListSequence.fromList(result).sort(new ISelector<Tuples._2<String, SNode>, Comparable<?>>() {
      public Comparable<?> select(Tuples._2<String, SNode> it) {
        return it._0().length() * 2 - ((it._1() == null ?
          1 :
          0
        ));
      }
    }, false);
  }

  public List<SNode> convertPath(String path, SModel model) throws PathConverter.PathConvertException {
    path = normalizePath(path, false);
    String withSlash = normalizePath(path, true);
    List<SNode> result = new ArrayList<SNode>();
    for (Tuples._2<String, SNode> m : Sequence.fromIterable(macros)) {
      String mdir = m._0();
      String currPath = (path.length() < mdir.length() ?
        withSlash :
        path
      );
      if (!(currPath.startsWith(mdir))) {
        continue;
      }
      currPath = currPath.substring(mdir.length());
      SNode relPath;
      if (m._1() == null) {
        relPath = SModelOperations.createNewNode(model, "jetbrains.mps.build.structure.BuildSourceProjectRelativePath", null);
      } else {
        relPath = SModelOperations.createNewNode(model, "jetbrains.mps.build.structure.BuildSourceMacroRelativePath", null);
        SLinkOperations.setTarget(SNodeOperations.cast(relPath, "jetbrains.mps.build.structure.BuildSourceMacroRelativePath"), "macro", m._1(), false);
      }
      buildCompositePath(relPath, currPath, model);
      ListSequence.fromList(result).addElement(relPath);

    }
    if ((int) ListSequence.fromList(result).count() == 0) {
      throw new PathConverter.PathConvertException("source path (" + path + ") should be under working directory (" + workingDirectory + "), or any macros default directory");

    }
    return result;
  }

  private void buildCompositePath(SNode result, String path, SModel model) {
    SNode last = null;
    for (String fname : path.split("/")) {
      if (StringUtils.isNotEmpty(fname)) {
        SNode npath = SModelOperations.createNewNode(model, "jetbrains.mps.build.structure.BuildCompositePath", null);
        SPropertyOperations.set(npath, "head", fname);
        if (last == null) {
          SLinkOperations.setTarget(result, "compositePart", npath, true);
        } else {
          SLinkOperations.setTarget(last, "tail", npath, true);
        }
        last = npath;
      }
    }
  }

  private static String normalizePath(String path, boolean addSlash) {
    if (path == null || StringUtils.isEmpty(path)) {
      return null;
    }
    try {
      path = new File(path).getCanonicalPath();
      path = path.replace("\\", "/");
    } catch (IOException ignore) {
      // ignore 
    }
    if (addSlash && !(path.endsWith("/"))) {
      path = path + "/";
    }
    return path;
  }

  public class PathConvertException extends Exception {
    public PathConvertException(String message) {
      super(message);
    }
  }
}
