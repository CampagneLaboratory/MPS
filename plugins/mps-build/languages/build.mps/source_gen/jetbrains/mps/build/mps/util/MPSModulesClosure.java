package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import java.util.LinkedHashSet;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.build.mps.behavior.BuildMps_Generator_Behavior;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.util.iterable.RecursiveIterator;
import java.util.Iterator;
import java.util.HashSet;
import java.util.List;

public class MPSModulesClosure {
  private LinkedHashSet<SNode> modules = new LinkedHashSet<SNode>();
  private Set<SNode> devkits = new LinkedHashSet<SNode>();
  private LinkedHashSet<SNode> languagesWithRuntime = new LinkedHashSet<SNode>();
  private Iterable<SNode> initialModules;
  private boolean skipExternalModules = false;
  private boolean trackDevkits = false;

  public MPSModulesClosure(SNode initialModule) {
    this.initialModules = Sequence.<SNode>singleton(initialModule);
  }

  public MPSModulesClosure(Iterable<SNode> initialModules) {
    this.initialModules = SNodeOperations.ofConcept(initialModules, "jetbrains.mps.build.mps.structure.BuildMps_Module");
    SNode containingRoot = SNodeOperations.getContainingRoot(Sequence.fromIterable(initialModules).first());
    for (SNode m : Sequence.fromIterable(initialModules)) {
      if (containingRoot != SNodeOperations.getContainingRoot(m)) {
        throw new IllegalArgumentException("all modules should be from the same root");
      }
    }
  }

  private SNode toOriginal(SNode node) {
    if (node == null) {
      return null;
    }
    if (SNodeOperations.getContainingRoot(node) == SNodeOperations.getContainingRoot(Sequence.fromIterable(initialModules).first())) {
      return node;
    }
    if (skipExternalModules) {
      return null;
    }
    return node;
  }

  private Iterable<SNode> toOriginal(Iterable<SNode> modules) {
    return Sequence.fromIterable(modules).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return toOriginal(it);
      }
    }).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return it != null;
      }
    });
  }

  private Iterable<SNode> toOriginalLangs(Iterable<SNode> langs) {
    return Sequence.fromIterable(langs).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.as(toOriginal(it), "jetbrains.mps.build.mps.structure.BuildMps_Language");
      }
    }).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return it != null;
      }
    });
  }

  private Iterable<SNode> dependencies(SNode module) {
    return ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return (SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency") ? SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency"), "dependency", true) : it);
      }
    });
  }

  private Iterable<SNode> getDependencies(SNode module, final boolean reexportOnly) {
    Iterable<SNode> dependencies = Sequence.fromIterable(SNodeOperations.ofConcept(dependencies(module), "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule")).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (!(reexportOnly) || SPropertyOperations.getBoolean(it, "reexport"));
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "module", false), "jetbrains.mps.build.mps.structure.BuildMps_Generator") ? BuildMps_Generator_Behavior.call_getSourceLanguage_9200313594510517119(SNodeOperations.cast(SLinkOperations.getTarget(it, "module", false), "jetbrains.mps.build.mps.structure.BuildMps_Generator")) : SLinkOperations.getTarget(it, "module", false));
      }
    });

    // add extended langs 
    dependencies = Sequence.fromIterable(dependencies).concat(Sequence.fromIterable(SNodeOperations.ofConcept(dependencies(module), "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage")).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(it, "language", false);
      }
    }));

    if (reexportOnly) {
      return toOriginal(dependencies);
    }

    Iterable<SNode> usedDevkits = Sequence.fromIterable(includingExtended(usedDevkits(module))).toListSequence();
    if (trackDevkits) {
      SetSequence.fromSet(devkits).addSequence(Sequence.fromIterable(usedDevkits));
    }
    Iterable<SNode> solutionsFromDevkits = Sequence.fromIterable(usedDevkits).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getTargets(it, "exports", true), "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution")).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode iit) {
            return SLinkOperations.getTarget(iit, "solution", false);
          }
        });
      }
    });
    // "core" language is added in loadModules pre-script 
    return toOriginal(IterableUtil.distinct(IterableUtil.merge(dependencies, solutionsFromDevkits)));
  }

  private Iterable<SNode> getUsedLanguages(SNode module) {
    Iterable<SNode> usedLangs = Sequence.fromIterable(SNodeOperations.ofConcept(dependencies(module), "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage")).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(it, "language", false);
      }
    });

    Iterable<SNode> usedDevkits = Sequence.fromIterable(includingExtended(usedDevkits(module))).toListSequence();
    if (trackDevkits) {
      SetSequence.fromSet(devkits).addSequence(Sequence.fromIterable(usedDevkits));
    }
    Iterable<SNode> languagesFromDevkits = Sequence.fromIterable(usedDevkits).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getTargets(it, "exports", true), "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage")).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode iit) {
            return SLinkOperations.getTarget(iit, "language", false);
          }
        });
      }
    });

    // use "core" language is added in loadModules pre-script 
    return toOriginalLangs(includingExtendedLanguages(IterableUtil.merge(usedLangs, languagesFromDevkits)));
  }

  private Iterable<SNode> usedDevkits(SNode module) {
    return Sequence.fromIterable(SNodeOperations.ofConcept(dependencies(module), "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit")).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(it, "devkit", false);
      }
    });
  }

  private Iterable<SNode> includingExtended(Iterable<SNode> devkits) {
    return new RecursiveIterator<SNode>(devkits, false) {
      @Override
      protected Iterator<SNode> children(SNode node) {
        return ListSequence.fromList(SLinkOperations.getTargets(node, "extends", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SLinkOperations.getTarget(it, "devkit", false) != null);
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, "devkit", false);
          }
        }).iterator();
      }
    };
  }

  private Iterable<SNode> includingExtendedLanguages(Iterable<SNode> langs) {
    return new RecursiveIterator<SNode>(langs, false) {
      @Override
      protected Iterator<SNode> children(SNode node) {
        return Sequence.fromIterable(SNodeOperations.ofConcept(dependencies(node), "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage")).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, "language", false);
          }
        }).iterator();
      }
    };
  }

  private Iterable<SNode> usedGenerators(Iterable<SNode> generators) {
    return new RecursiveIterator<SNode>(generators, false) {
      protected Iterator<SNode> children(SNode generator) {
        return Sequence.fromIterable(SNodeOperations.ofConcept(Sequence.fromIterable(SNodeOperations.ofConcept(dependencies(generator), "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule")).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SLinkOperations.getTarget(it, "module", false) != null);
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, "module", false);
          }
        }), "jetbrains.mps.build.mps.structure.BuildMps_Generator")).iterator();
      }
    };
  }

  private void collectDependencies(Iterable<SNode> sequence, boolean reexportOnly) {
    if (Sequence.fromIterable(sequence).isEmpty()) {
      return;
    }
    Set<SNode> dependencies = SetSequence.fromSet(new HashSet<SNode>());
    for (SNode module : Sequence.fromIterable(sequence)) {
      SetSequence.fromSet(dependencies).addSequence(Sequence.fromIterable(getDependencies(module, reexportOnly)));
    }
    SetSequence.fromSet(dependencies).removeSequence(SetSequence.fromSet(modules));
    modules.addAll(dependencies);
    collectDependencies(dependencies, reexportOnly);
  }

  private void collectAllUsedLanguageRuntimesAndTheirDeps(Iterable<SNode> sequence) {
    if (Sequence.fromIterable(sequence).isEmpty()) {
      return;
    }
    Set<SNode> langs = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> solutions = SetSequence.fromSet(new HashSet<SNode>());
    for (SNode module : Sequence.fromIterable(sequence)) {
      fillUsedLanguageRuntimes(module, langs, solutions);
    }
    SetSequence.fromSet(solutions).removeSequence(SetSequence.fromSet(modules));
    modules.addAll(solutions);
    languagesWithRuntime.addAll(langs);
    collectDependencies(((Iterable<SNode>) solutions), false);
    collectAllUsedLanguageRuntimesAndTheirDeps(((Iterable<SNode>) solutions));
  }

  private void collectGeneratorsDependendencies(Iterable<SNode> languages) {
    if (Sequence.fromIterable(languages).isEmpty()) {
      return;
    }
    Set<SNode> extraLangs = SetSequence.fromSet(new HashSet<SNode>());
    for (SNode g : Sequence.fromIterable(languages).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (SLinkOperations.getTarget(it, "generator", true) != null);
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(it, "generator", true);
      }
    })) {
      if (g == null) {
        continue;
      }
      Iterable<SNode> deps = Sequence.fromIterable(SNodeOperations.ofConcept(dependencies(g), "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule")).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return (SLinkOperations.getTarget(it, "module", false) != null);
        }
      }).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return SLinkOperations.getTarget(it, "module", false);
        }
      });
      // I'm not quite sure it's possible to depend directly from generator module. Instead, introduce a dependency from generator's source language 
      SetSequence.fromSet(extraLangs).addSequence(Sequence.fromIterable(SNodeOperations.ofConcept(deps, "jetbrains.mps.build.mps.structure.BuildMps_Generator")).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return BuildMps_Generator_Behavior.call_getSourceLanguage_9200313594510517119(it);
        }
      }).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return it != null;
        }
      }));
      // any language generator depends from are better to be there, too. 
      SetSequence.fromSet(extraLangs).addSequence(Sequence.fromIterable(SNodeOperations.ofConcept(deps, "jetbrains.mps.build.mps.structure.BuildMps_Language")));
    }
    SetSequence.fromSet(extraLangs).removeSequence(SetSequence.fromSet(modules));
    modules.addAll(extraLangs);
    collectGeneratorsDependendencies(extraLangs);
  }

  public MPSModulesClosure reset() {
    modules.clear();
    languagesWithRuntime.clear();
    SetSequence.fromSet(devkits).clear();
    skipExternalModules = false;
    trackDevkits = false;
    return this;
  }

  public MPSModulesClosure closure() {
    // get all direct dependencies abd runtimes, plus re-exported dependencies thereof. 
    Set<SNode> langs = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> solutions = SetSequence.fromSet(new HashSet<SNode>());

    for (SNode module : Sequence.fromIterable(initialModules)) {
      List<SNode> firstLevelDeps = Sequence.fromIterable(getDependencies(module, false)).toListSequence();
      collectDependencies(firstLevelDeps, true);
      fillUsedLanguageRuntimes(module, langs, solutions);
      modules.addAll(firstLevelDeps);
    }
    modules.addAll(solutions);
    languagesWithRuntime.addAll(langs);
    collectDependencies(((Iterable<SNode>) solutions), true);
    modules.removeAll(Sequence.fromIterable(initialModules).toListSequence());
    return this;
  }

  public MPSModulesClosure runtimeClosure() {
    collectDependencies(initialModules, false);
    collectAllUsedLanguageRuntimesAndTheirDeps(initialModules);
    modules.removeAll(Sequence.fromIterable(initialModules).toListSequence());
    return this;
  }

  public MPSModulesClosure designtimeClosure() {
    // direct and indirect dependencies of the modules, languages used and their runtimes 
    collectDependencies(initialModules, false);
    collectAllUsedLanguageRuntimesAndTheirDeps(initialModules);
    for (SNode m : Sequence.fromIterable(initialModules)) {
      Iterable<SNode> usedLanguages = getUsedLanguages(m);
      collectDependencies(usedLanguages, false);
      collectAllUsedLanguageRuntimesAndTheirDeps(usedLanguages);
    }
    modules.removeAll(Sequence.fromIterable(initialModules).toListSequence());
    return this;
  }

  public MPSModulesClosure generationDependenciesClosure() {
    // direct and indirect dependencies of used languages and their runtimes; source languages of generators involved 
    for (SNode m : Sequence.fromIterable(initialModules)) {
      Iterable<SNode> usedLanguages = getUsedLanguages(m);
      collectDependencies(usedLanguages, false);
      collectAllUsedLanguageRuntimesAndTheirDeps(usedLanguages);
      modules.addAll(Sequence.fromIterable(usedLanguages).toListSequence());
      collectGeneratorsDependendencies(usedLanguages);
    }
    return this;
  }

  public MPSModulesClosure runtimeDependencies() {
    // direct dependencies of used languages' runtime solutions 
    if (Sequence.fromIterable(initialModules).count() != 1) {
      throw new IllegalStateException("cannot build runtime dependencies for several modules");
    }

    SNode initial = Sequence.fromIterable(initialModules).first();
    Set<SNode> langs = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> solutions = SetSequence.fromSet(new HashSet<SNode>());
    fillUsedLanguageRuntimes(initial, langs, solutions);
    modules.addAll(solutions);
    languagesWithRuntime.addAll(langs);
    return this;
  }

  private void fillUsedLanguageRuntimes(SNode m, Set<SNode> runtimeLanguages, Set<SNode> runtimeSolutions) {
    for (SNode language : getUsedLanguages(m)) {
      boolean hasRuntime = false;
      for (SNode rdep : SLinkOperations.getTargets(language, "runtime", true)) {
        if (!(SNodeOperations.isInstanceOf(rdep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime"))) {
          hasRuntime = true;
          continue;
        }
        SNode runtimeSolution = SNodeOperations.as(toOriginal(SLinkOperations.getTarget(SNodeOperations.cast(rdep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime"), "solution", false)), "jetbrains.mps.build.mps.structure.BuildMps_Solution");
        if (runtimeSolution != null) {
          SetSequence.fromSet(runtimeSolutions).addElement(runtimeSolution);
        }
      }
      if (hasRuntime) {
        SetSequence.fromSet(runtimeLanguages).addElement(language);
      }
    }
  }

  public MPSModulesClosure.RequiredJavaModules getRequiredJava() {
    Iterable<SNode> reexportedFromModuleDependencies = Sequence.fromIterable(getModules()).concat(Sequence.fromIterable(initialModules)).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode mod) {
        return ListSequence.fromList(SLinkOperations.getTargets(mod, "dependencies", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule") && SPropertyOperations.getBoolean(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule"), "reexport");
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule"), "module", false);
          }
        });
      }
    });
    Set<SNode> reexportMods = SetSequence.fromSet(new HashSet<SNode>());
    for (SNode mod : reexportedFromModuleDependencies) {
      SetSequence.fromSet(reexportMods).addElement(mod);
    }

    Iterable<SNode> directDeps = Sequence.fromIterable(SNodeOperations.ofConcept(Sequence.fromIterable(initialModules).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return SLinkOperations.getTargets(it, "dependencies", true);
      }
    }), "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule")).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SLinkOperations.getTarget(it, "module", false);
      }
    });
    return new MPSModulesClosure.RequiredJavaModules(Sequence.fromIterable(reexportedFromModuleDependencies).concat(Sequence.fromIterable(directDeps)), reexportMods);
  }

  public Iterable<SNode> getModules() {
    return modules;
  }

  public Iterable<SNode> getLanguagesWithRuntime() {
    return languagesWithRuntime;
  }

  public Iterable<SNode> getAllModules() {
    return Sequence.fromIterable(((Iterable<SNode>) modules)).concat(Sequence.fromIterable((Iterable<SNode>) languagesWithRuntime)).concat(Sequence.fromIterable((Iterable<SNode>) devkits));
  }

  public SNode getInitial() {
    return Sequence.fromIterable(initialModules).first();
  }

  public MPSModulesClosure skipExternalModules() {
    this.skipExternalModules = true;
    return this;
  }

  public MPSModulesClosure trackDevkits() {
    this.trackDevkits = true;
    return this;
  }

  public static class RequiredJavaModules {
    private Iterable<SNode> modules;
    private Set<SNode> reexported;

    public RequiredJavaModules(Iterable<SNode> modules, Set<SNode> reexported) {
      this.modules = modules;
      this.reexported = reexported;
    }

    public Iterable<SNode> getModules() {
      return modules;
    }

    public boolean isReexported(SNode mod) {
      return SetSequence.fromSet(reexported).contains(mod);
    }
  }
}
