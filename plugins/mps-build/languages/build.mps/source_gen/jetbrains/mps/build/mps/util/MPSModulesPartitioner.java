package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.UUID;
import jetbrains.mps.make.dependencies.graph.Graph;
import java.util.Map;
import java.util.LinkedHashMap;
import jetbrains.mps.make.dependencies.graph.IVertex;
import jetbrains.mps.make.dependencies.graph.Graphs;
import jetbrains.mps.util.GraphUtil;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.LinkedHashSet;
import jetbrains.mps.build.mps.behavior.BuildMps_DevKit_Behavior;

public class MPSModulesPartitioner {
  private final SNode project;
  private final List<SNode> modules;
  private List<MPSModulesPartitioner.Chunk> chunks;
  private boolean useMeta;
  private Iterable<SNode> external;
  public MPSModulesPartitioner(SNode project) {
    this(project, ListSequence.fromList(Sequence.fromIterable(getModules(project)).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name"));
      }
    }, true).toListSequence()).asUnmodifiable());
  }
  public MPSModulesPartitioner(SNode project, List<SNode> modules) {
    this.project = project;
    this.modules = modules;
  }
  public void buildChunks() {
    Graph<MPSModulesPartitioner.Node> graph = new Graph<MPSModulesPartitioner.Node>();
    final Map<SNode, MPSModulesPartitioner.Node> map = new LinkedHashMap<SNode, MPSModulesPartitioner.Node>();
    for (SNode module : modules) {
      MPSModulesPartitioner.Node decorator = new MPSModulesPartitioner.Node(module);
      map.put(module, decorator);
      graph.add(decorator);
    }
    for (MPSModulesPartitioner.Node node : graph.getData()) {
      node.fill(map);
    }
    IVertex[] vertices = graph.getData().toArray(new IVertex[graph.getNVertexes()]);
    useMeta = false;
    int[][] greater_or_eq = Graphs.graphToIntInt(vertices, false, true);
    useMeta = true;
    int[][] strictly_greater = Graphs.graphToIntInt(vertices, true, true);
    int[] partition = GraphUtil.partition(greater_or_eq, strictly_greater);

    this.chunks = ListSequence.fromList(new ArrayList<MPSModulesPartitioner.Chunk>());
    for (int i = 0; i < vertices.length; i++) {
      SNode m = ((MPSModulesPartitioner.Node) vertices[i]).module;
      int pindex = partition[i];
      boolean conflicting = pindex < 0;
      if (conflicting) {
        pindex = -1 - pindex;
      }
      while (ListSequence.fromList(chunks).count() <= pindex) {
        ListSequence.fromList(chunks).addElement(new MPSModulesPartitioner.Chunk());
      }
      SetSequence.fromSet(ListSequence.fromList(chunks).getElement(pindex).getModules()).addElement(m);
      if (conflicting) {
        ListSequence.fromList(chunks).getElement(pindex).setBootstrap(m, true);
      }
    }
    for (MPSModulesPartitioner.Chunk c : chunks) {
      Set<MPSModulesPartitioner.Node> chunkNodes = SetSequence.fromSetWithValues(new HashSet<MPSModulesPartitioner.Node>(), SetSequence.fromSet(c.getModules()).select(new ISelector<SNode, MPSModulesPartitioner.Node>() {
        public MPSModulesPartitioner.Node select(SNode it) {
          return map.get(it);
        }
      }));
      for (SNode confl : ListSequence.fromListWithValues(new ArrayList<SNode>(), c.getConflicting())) {
        if (SetSequence.fromSet(map.get(confl).metaDependencies).intersect(SetSequence.fromSet(chunkNodes)).isEmpty()) {
          c.setBootstrap(confl, false);
        }
      }
    }
  }
  public void buildExternalDependencies() {
    this.external = Sequence.fromIterable(new MPSModulesClosure(modules).trackDevkits().generationDependenciesClosure().runtimeClosure().getAllModules()).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.getContainingRoot(it) != SNodeOperations.getContainingRoot(MPSModulesPartitioner.this.project);
      }
    });
  }
  public List<MPSModulesPartitioner.Chunk> getChunks() {
    return chunks;
  }
  public Iterable<SNode> getExternal() {
    return external;
  }
  public static Iterable<SNode> getModules(SNode project) {
    return Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(new UUID(8755280088213897754l, -5075149991798053422l), 5617550519002745363l, 7389400916848080626l, "parts")), "jetbrains.mps.build.mps.structure.BuildMps_Group")).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(new UUID(934837630734519964l, -6831122735637083229l), 1500819558095907805l, 1500819558095907806l, "modules"));
      }
    }).concat(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(new UUID(8755280088213897754l, -5075149991798053422l), 5617550519002745363l, 7389400916848080626l, "parts")), "jetbrains.mps.build.mps.structure.BuildMps_AbstractModule")));
  }
  private class Node implements IVertex {
    private SNode module;
    private Set<MPSModulesPartitioner.Node> dependencyNodes = SetSequence.fromSet(new LinkedHashSet<MPSModulesPartitioner.Node>());
    private Set<MPSModulesPartitioner.Node> metaDependencies = SetSequence.fromSet(new LinkedHashSet<MPSModulesPartitioner.Node>());
    public Node(SNode module) {
      this.module = module;
    }
    @Override
    public Set<? extends IVertex> getNexts() {
      return (useMeta ? metaDependencies : dependencyNodes);
    }
    public void fill(Map<SNode, MPSModulesPartitioner.Node> map) {
      if (SNodeOperations.isInstanceOf(module, "jetbrains.mps.build.mps.structure.BuildMps_Module")) {
        MPSModulesClosure closure = new MPSModulesClosure(SNodeOperations.cast(module, "jetbrains.mps.build.mps.structure.BuildMps_Module")).skipExternalModules().generationDependenciesClosure();
        for (SNode q : Sequence.fromIterable(closure.getAllModules())) {
          MPSModulesPartitioner.Node node = map.get(q);
          if (node != null) {
            SetSequence.fromSet(metaDependencies).addElement(node);
          }
        }
        closure.reset().trackDevkits().closure();
        for (SNode q : Sequence.fromIterable(closure.getAllModules())) {
          MPSModulesPartitioner.Node node = map.get(q);
          if (node != null) {
            SetSequence.fromSet(dependencyNodes).addElement(node);
          }
        }
      } else if (SNodeOperations.isInstanceOf(module, "jetbrains.mps.build.mps.structure.BuildMps_DevKit")) {
        SNode devkit = SNodeOperations.cast(module, "jetbrains.mps.build.mps.structure.BuildMps_DevKit");
        Iterable<SNode> extended = ListSequence.fromList(SLinkOperations.getChildren(devkit, MetaAdapterFactory.getContainmentLink(new UUID(934837630734519964l, -6831122735637083229l), 322010710375794190l, 322010710375805250l, "extends"))).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(new UUID(934837630734519964l, -6831122735637083229l), 322010710375805242l, 322010710375805243l, "devkit")) != null);
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(new UUID(934837630734519964l, -6831122735637083229l), 322010710375805242l, 322010710375805243l, "devkit"));
          }
        });
        for (SNode q : Sequence.fromIterable(BuildMps_DevKit_Behavior.call_getExportedModules_7391870795496918763(devkit)).concat(Sequence.fromIterable(extended))) {
          MPSModulesPartitioner.Node node = map.get(q);
          if (node != null) {
            SetSequence.fromSet(dependencyNodes).addElement(node);
          }
        }
      }
    }
  }
  public static class Chunk {
    private final Set<SNode> modules;
    private final Set<SNode> conflicting;
    public Chunk() {
      this.modules = SetSequence.fromSet(new LinkedHashSet<SNode>());
      this.conflicting = SetSequence.fromSet(new HashSet<SNode>());
    }
    public Set<SNode> getModules() {
      return modules;
    }
    public Set<SNode> getConflicting() {
      return conflicting;
    }
    public boolean isConflicting(SNode mod) {
      return SetSequence.fromSet(conflicting).contains(mod);
    }
    public boolean isBootstrap() {
      return SetSequence.fromSet(conflicting).isNotEmpty();
    }
    public void setBootstrap(SNode module, boolean flag) {
      if (flag) {
        SetSequence.fromSet(conflicting).addElement(module);
      } else {
        SetSequence.fromSet(conflicting).removeElement(module);
      }
    }
  }
}
