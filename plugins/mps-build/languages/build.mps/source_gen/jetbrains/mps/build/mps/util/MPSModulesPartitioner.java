package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.make.dependencies.graph.Graph;
import java.util.Map;
import java.util.LinkedHashMap;
import jetbrains.mps.make.dependencies.graph.IVertex;
import jetbrains.mps.make.dependencies.graph.Graphs;
import jetbrains.mps.util.GraphUtil;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.LinkedHashSet;
import jetbrains.mps.build.mps.behavior.BuildMps_DevKit_Behavior;

public class MPSModulesPartitioner {
  private final TemplateQueryContext genContext;
  private final SNode project;
  private final List<SNode> modules;
  private List<MPSModulesPartitioner.Chunk> chunks;
  private boolean useMeta;
  private Iterable<SNode> external;

  public MPSModulesPartitioner(TemplateQueryContext genContext, SNode project) {
    this.genContext = genContext;
    this.project = project;
    this.modules = ListSequence.fromList(Sequence.fromIterable(getModules(project)).sort(new ISelector<SNode, Comparable<?>>() {
      public Comparable<?> select(SNode it) {
        return SPropertyOperations.getString(it, "name");
      }
    }, true).toListSequence()).asUnmodifiable();
  }

  public void buildChunks() {
    Graph<MPSModulesPartitioner.Node> graph = new Graph<MPSModulesPartitioner.Node>();
    final Map<SNode, MPSModulesPartitioner.Node> map = new LinkedHashMap<SNode, MPSModulesPartitioner.Node>();
    for (SNode module : modules) {
      MPSModulesPartitioner.Node decorator = new MPSModulesPartitioner.Node(module);
      map.put(module, decorator);
      graph.add(decorator);
    }
    for (MPSModulesPartitioner.Node node : graph.getData()) {
      node.fill(map);
    }
    IVertex[] vertices = graph.getData().toArray(new IVertex[graph.getNVertexes()]);
    useMeta = false;
    int[][] greater_or_eq = Graphs.graphToIntInt(vertices, false, true);
    useMeta = true;
    int[][] strictly_greater = Graphs.graphToIntInt(vertices, true, true);
    int[] partition = GraphUtil.partition(greater_or_eq, strictly_greater);

    this.chunks = ListSequence.fromList(new ArrayList<MPSModulesPartitioner.Chunk>());
    for (int i = 0; i < vertices.length; i++) {
      SNode m = ((MPSModulesPartitioner.Node) vertices[i]).module;
      int pindex = partition[i];
      boolean conflicting = pindex < 0;
      if (conflicting) {
        pindex = -1 - pindex;
      }
      while (ListSequence.fromList(chunks).count() <= pindex) {
        ListSequence.fromList(chunks).addElement(new MPSModulesPartitioner.Chunk());
      }
      SetSequence.fromSet(ListSequence.fromList(chunks).getElement(pindex).getModules()).addElement(m);
      if (conflicting) {
        ListSequence.fromList(chunks).getElement(pindex).setBootstrap(m, true);
      }
    }
    for (MPSModulesPartitioner.Chunk c : chunks) {
      Set<MPSModulesPartitioner.Node> chunkNodes = SetSequence.fromSetWithValues(new HashSet<MPSModulesPartitioner.Node>(), SetSequence.fromSet(c.getModules()).select(new ISelector<SNode, MPSModulesPartitioner.Node>() {
        public MPSModulesPartitioner.Node select(SNode it) {
          return map.get(it);
        }
      }));
      for (SNode confl : ListSequence.fromListWithValues(new ArrayList<SNode>(), c.getConflicting())) {
        if (SetSequence.fromSet(map.get(confl).metaDependencies).intersect(SetSequence.fromSet(chunkNodes)).isEmpty()) {
          c.setBootstrap(confl, false);
        }
      }
    }
  }

  public void buildExternalDependencies() {
    this.external = Sequence.fromIterable(new MPSModulesClosure(genContext, modules).trackDevkits().generationDependenciesClosure().runtimeClosure().getAllModules()).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.getContainingRoot(it) != SNodeOperations.getContainingRoot(MPSModulesPartitioner.this.project);
      }
    });
  }

  public List<MPSModulesPartitioner.Chunk> getChunks() {
    return chunks;
  }

  public Iterable<SNode> getExternal() {
    return external;
  }

  public static Iterable<SNode> getModules(SNode project) {
    return ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_Group");
      }
    }).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return SLinkOperations.getTargets(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_Group"), "modules", true);
      }
    }).concat(ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_AbstractModule");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_AbstractModule");
      }
    });
  }

  private class Node implements IVertex {
    private SNode module;
    private Set<MPSModulesPartitioner.Node> dependencyNodes = SetSequence.fromSet(new LinkedHashSet<MPSModulesPartitioner.Node>());
    private Set<MPSModulesPartitioner.Node> metaDependencies = SetSequence.fromSet(new LinkedHashSet<MPSModulesPartitioner.Node>());

    public Node(SNode module) {
      this.module = module;
    }

    public Set<? extends IVertex> getNexts() {
      return (useMeta ?
        metaDependencies :
        dependencyNodes
      );
    }

    public void fill(Map<SNode, MPSModulesPartitioner.Node> map) {
      if (SNodeOperations.isInstanceOf(module, "jetbrains.mps.build.mps.structure.BuildMps_Module")) {
        MPSModulesClosure closure = new MPSModulesClosure(genContext, SNodeOperations.cast(module, "jetbrains.mps.build.mps.structure.BuildMps_Module")).skipExternalModules().generationDependenciesClosure();
        for (SNode q : Sequence.fromIterable(closure.getAllModules())) {
          MPSModulesPartitioner.Node node = map.get(q);
          if (node != null) {
            SetSequence.fromSet(metaDependencies).addElement(node);
          }
        }
        closure.reset().trackDevkits().closure();
        for (SNode q : Sequence.fromIterable(closure.getAllModules())) {
          MPSModulesPartitioner.Node node = map.get(q);
          if (node != null) {
            SetSequence.fromSet(dependencyNodes).addElement(node);
          }
        }
      } else if (SNodeOperations.isInstanceOf(module, "jetbrains.mps.build.mps.structure.BuildMps_DevKit")) {
        SNode devkit = SNodeOperations.cast(module, "jetbrains.mps.build.mps.structure.BuildMps_DevKit");
        for (SNode q : Sequence.fromIterable(BuildMps_DevKit_Behavior.call_getExportedModules_7391870795496918763(devkit)).concat(ListSequence.fromList(SLinkOperations.getTargets(devkit, "extends", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SLinkOperations.getTarget(it, "devkit", false) != null);
          }
        }).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, "devkit", false);
          }
        }))) {
          MPSModulesPartitioner.Node node = map.get(q);
          if (node != null) {
            SetSequence.fromSet(dependencyNodes).addElement(node);
          }
        }
      }
    }
  }

  public static class Chunk {
    private final Set<SNode> modules;
    private final Set<SNode> conflicting;

    public Chunk() {
      this.modules = SetSequence.fromSet(new LinkedHashSet<SNode>());
      this.conflicting = SetSequence.fromSet(new HashSet<SNode>());
    }

    public Set<SNode> getModules() {
      return modules;
    }

    public Set<SNode> getConflicting() {
      return conflicting;
    }

    public boolean isConflicting(SNode mod) {
      return SetSequence.fromSet(conflicting).contains(mod);
    }

    public boolean isBootstrap() {
      return SetSequence.fromSet(conflicting).isNotEmpty();
    }

    public void setBootstrap(SNode module, boolean flag) {
      if (flag) {
        SetSequence.fromSet(conflicting).addElement(module);
      } else {
        SetSequence.fromSet(conflicting).removeElement(module);
      }
    }
  }
}
