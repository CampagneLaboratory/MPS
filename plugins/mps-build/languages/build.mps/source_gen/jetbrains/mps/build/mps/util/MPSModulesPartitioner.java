package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.make.dependencies.graph.Graph;
import java.util.Map;
import java.util.LinkedHashMap;
import jetbrains.mps.make.dependencies.graph.IVertex;
import jetbrains.mps.make.dependencies.graph.Graphs;
import jetbrains.mps.util.GraphUtil;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Set;
import java.util.LinkedHashSet;
import java.util.HashSet;

public class MPSModulesPartitioner {
  private final TemplateQueryContext genContext;
  private final SNode project;
  private final List<SNode> modules;
  private List<MPSModulesPartitioner.Chunk> chunks;
  private boolean useMeta;
  private Iterable<SNode> external;

  public MPSModulesPartitioner(TemplateQueryContext genContext, SNode project) {
    this.genContext = genContext;
    this.project = project;
    this.modules = ListSequence.fromList(Sequence.fromIterable(getModules(project)).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(it, "name");
      }
    }, true).toListSequence()).asUnmodifiable();
  }

  public void buildChunks() {
    Graph<MPSModulesPartitioner.Node> graph = new Graph<MPSModulesPartitioner.Node>();
    Map<SNode, MPSModulesPartitioner.Node> map = new LinkedHashMap<SNode, MPSModulesPartitioner.Node>();
    for (SNode module : modules) {
      MPSModulesPartitioner.Node decorator = new MPSModulesPartitioner.Node(module);
      map.put(module, decorator);
      graph.add(decorator);
    }
    for (MPSModulesPartitioner.Node node : graph.getData()) {
      node.fill(map);
    }
    IVertex[] vertices = graph.getData().toArray(new IVertex[graph.getNVertexes()]);
    useMeta = false;
    int[][] greater_or_eq = Graphs.graphToIntInt(vertices);
    useMeta = true;
    int[][] strictly_greater = Graphs.graphToIntInt(vertices);
    int[] partition = GraphUtil.partition(greater_or_eq, strictly_greater);

    this.chunks = ListSequence.fromList(new ArrayList<MPSModulesPartitioner.Chunk>());
    for (int i = 0; i < vertices.length; i++) {
      SNode m = ((MPSModulesPartitioner.Node) vertices[i]).module;
      int pindex = partition[i];
      boolean conflicting = pindex < 0;
      if (conflicting) {
        pindex = -1 - pindex;
      }
      while (ListSequence.fromList(chunks).count() <= pindex) {
        ListSequence.fromList(chunks).addElement(new MPSModulesPartitioner.Chunk());
      }
      SetSequence.fromSet(ListSequence.fromList(chunks).getElement(pindex).getModules()).addElement(m);
      if (conflicting) {
        ListSequence.fromList(chunks).getElement(pindex).setBootstrapFor(m);
      }
    }
  }

  public void buildExternalDependencies() {
    this.external = Sequence.fromIterable(new MPSModulesClosure(genContext, modules).generationDependenciesClosure().runtimeClosure().getModulesIncludingLanguagesWithRuntime()).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.getContainingRoot(it) != SNodeOperations.getContainingRoot(MPSModulesPartitioner.this.project);
      }
    });
  }

  public List<MPSModulesPartitioner.Chunk> getChunks() {
    return chunks;
  }

  public Iterable<SNode> getExternal() {
    return external;
  }

  public static Iterable<SNode> getModules(SNode project) {
    return ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_Group");
      }
    }).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return SLinkOperations.getTargets(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_Group"), "modules", true);
      }
    }).concat(ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_Module");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_Module");
      }
    });
  }

  private class Node implements IVertex {
    private SNode module;
    private Set<MPSModulesPartitioner.Node> dependencyNodes = SetSequence.fromSet(new LinkedHashSet<MPSModulesPartitioner.Node>());
    private Set<MPSModulesPartitioner.Node> metaDependencies = SetSequence.fromSet(new LinkedHashSet<MPSModulesPartitioner.Node>());

    public Node(SNode module) {
      this.module = module;
    }

    public Set<? extends IVertex> getNexts() {
      return (useMeta ?
        metaDependencies :
        dependencyNodes
      );
    }

    public void fill(Map<SNode, MPSModulesPartitioner.Node> map) {
      MPSModulesClosure closure = new MPSModulesClosure(genContext, module).skipExternalModules().generationDependenciesClosure();
      for (SNode q : Sequence.fromIterable(closure.getModulesIncludingLanguagesWithRuntime())) {
        MPSModulesPartitioner.Node node = map.get(q);
        if (node != null) {
          SetSequence.fromSet(metaDependencies).addElement(node);
        }
      }
      closure.closure();
      for (SNode q : Sequence.fromIterable(closure.getModulesIncludingLanguagesWithRuntime())) {
        MPSModulesPartitioner.Node node = map.get(q);
        if (node != null) {
          SetSequence.fromSet(dependencyNodes).addElement(node);
        }
      }
    }
  }

  public static class Chunk {
    private final Set<SNode> modules;
    private final Set<SNode> conflicting;
    private boolean bootstrap;

    public Chunk() {
      this.modules = SetSequence.fromSet(new LinkedHashSet<SNode>());
      this.conflicting = SetSequence.fromSet(new HashSet<SNode>());
      this.bootstrap = false;
    }

    public Set<SNode> getModules() {
      return modules;
    }

    public Set<SNode> getConflicting() {
      return modules;
    }

    public boolean isConflicting(SNode mod) {
      return SetSequence.fromSet(conflicting).contains(mod);
    }

    public boolean isBootstrap() {
      return bootstrap;
    }

    public void setBootstrapFor(SNode module) {
      bootstrap = true;
      SetSequence.fromSet(conflicting).addElement(module);
    }
  }
}
