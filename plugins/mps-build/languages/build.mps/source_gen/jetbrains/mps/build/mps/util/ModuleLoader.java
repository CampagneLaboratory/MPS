package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.build.util.DependenciesHelper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.structure.modules.LanguageDescriptor;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.build.util.Context;
import java.io.File;
import java.io.IOException;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.util.MacroHelper;
import jetbrains.mps.project.MPSExtentions;
import jetbrains.mps.project.persistence.LanguageDescriptorPersistence;
import jetbrains.mps.project.persistence.SolutionDescriptorPersistence;
import jetbrains.mps.project.persistence.DevkitDescriptorPersistence;
import jetbrains.mps.project.structure.modules.SolutionDescriptor;
import jetbrains.mps.project.structure.modules.DevkitDescriptor;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.project.structure.modules.GeneratorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.project.structure.modules.Dependency;
import java.util.LinkedHashMap;
import jetbrains.mps.project.structure.model.ModelRoot;
import jetbrains.mps.project.ProjectPathUtil;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.util.MacrosFactory;
import jetbrains.mps.vfs.IFileUtils;

public class ModuleLoader {
  private final TemplateQueryContext genContext;
  private final SNode myModule;
  private SNode myOriginalModule;
  private ModuleDescriptor myModuleDescriptor;
  private IFile myModuleFile;
  private VisibleModules visible;
  private PathConverter pathConverter;

  public ModuleLoader(SNode module, VisibleModules visible, PathConverter pathConverter, TemplateQueryContext genContext) {
    this.genContext = genContext;
    this.myModule = module;
    this.myOriginalModule = SNodeOperations.as(DependenciesHelper.getOriginalNode(module, genContext), "jetbrains.mps.build.mps.structure.BuildMps_Module");
    if (this.myOriginalModule == null) {
      this.myOriginalModule = module;
    }
    this.visible = visible;
    this.pathConverter = pathConverter;
  }

  public void importRequired() {
    loadFile();
    if (myModuleDescriptor != null) {
      SPropertyOperations.set(myModule, "uuid", myModuleDescriptor.getModuleReference().getModuleId().toString());
      SPropertyOperations.set(myModule, "name", myModuleDescriptor.getModuleReference().getModuleFqName());

      if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module")) {
        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module"), "dependencies", true)).removeWhere(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency");
          }
        });

        importDependencies();
        collectSources(true, true);
        if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Language") && myModuleDescriptor instanceof LanguageDescriptor) {
          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Language"), "runtime", true)).clear();
          importRuntime();
          importLanguageDeps();
        }
      }

      if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_DevKit")) {
        importDevkit();
      }
    }
  }

  public void checkModule() {
    loadFile();
    if (myModuleDescriptor != null) {
      if (!(checkModuleReference(myModuleDescriptor))) {
        return;
      }

      if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module")) {
        collectDependencies(true);
        collectSources(true, false);
        if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Language") && myModuleDescriptor instanceof LanguageDescriptor) {
          checkRuntime();
          loadLanguageDeps(true);
        }
      }

      if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_DevKit")) {
        checkDevkit();
      }
    }
  }

  public void loadAndCheck() {
    loadFile();
    if (myModuleDescriptor != null) {
      loadModule();
    }
    SPropertyOperations.set(myModule, "compact", "" + (false));
  }

  private void loadFile() {
    String moduleFilePath = BehaviorReflection.invokeVirtual(String.class, SLinkOperations.getTarget(myModule, "path", true), "virtual_getLocalPath_5481553824944787364", new Object[]{(genContext != null ?
      Context.defaultContext(genContext) :
      Context.defaultContext()
    )});
    try {
      moduleFilePath = new File(moduleFilePath).getCanonicalPath();
    } catch (IOException ex) {
      // ignore 
    }
    IFile file = FileSystem.getInstance().getFileByPath(moduleFilePath);
    if (!(file.exists()) || file.isDirectory()) {
      report("cannot import module file for " + SPropertyOperations.getString(myModule, "name") + ": file doesn't exist (" + moduleFilePath + ")", myOriginalModule);
      return;
    }

    try {
      ModuleDescriptor md = load(file);
      if (md.getLoadException() != null) {
        report("cannot import module file for " + SPropertyOperations.getString(myModule, "name") + ": exception: " + md.getLoadException().getMessage(), myOriginalModule);
        return;
      }

      myModuleDescriptor = md;
      myModuleFile = file;
    } catch (Exception ex) {
      report("cannot import module file for " + SPropertyOperations.getString(myModule, "name") + ": exception: " + ex.getMessage(), myOriginalModule, ex);
      ex.printStackTrace(System.err);
    }
  }

  private ModuleDescriptor load(IFile file) {
    MacroHelper helper = new ModuleLoader.ModuleMacroHelper(file);
    String path = file.getPath();
    if (path.endsWith(MPSExtentions.DOT_LANGUAGE)) {
      return LanguageDescriptorPersistence.loadLanguageDescriptor(file, helper);
    } else if (path.endsWith(MPSExtentions.DOT_SOLUTION)) {
      return SolutionDescriptorPersistence.loadSolutionDescriptor(file, helper);
    } else if (path.endsWith(MPSExtentions.DOT_DEVKIT)) {
      return DevkitDescriptorPersistence.loadDevKitDescriptor(file);
    }
    throw new RuntimeException("unknown file type: " + file.getName());
  }

  private void loadModule() {
    if (!(checkModuleReference(myModuleDescriptor))) {
      return;
    }

    if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Language")) {
      if (!(myModuleDescriptor instanceof LanguageDescriptor)) {
        report("imported file is not a language file " + SPropertyOperations.getString(myModule, "name"), myOriginalModule);
        return;
      }

      checkRuntime();
      loadLanguageDeps(false);
    } else if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Solution")) {
      if (!(myModuleDescriptor instanceof SolutionDescriptor)) {
        report("imported file is not a solution file " + SPropertyOperations.getString(myModule, "name"), myOriginalModule);
        return;
      }
    } else if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_DevKit")) {
      if (!(myModuleDescriptor instanceof DevkitDescriptor)) {
        report("imported file is not a devkit file " + SPropertyOperations.getString(myModule, "name"), myOriginalModule);
        return;
      }

      checkDevkit();
    }

    if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module")) {
      collectDependencies(false);
      collectLocalDependencies();
      collectSources(false, false);
      optimizeDeps();
    }
  }

  private void optimizeDeps() {
    SNode module = SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module");
    List<SNode> deps = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(module, "dependencies", true));
    Map<String, SNode> ndeps = MapSequence.fromMap(new HashMap<String, SNode>());
    Set<String> extendedLanguages = SetSequence.fromSet(new HashSet<String>());
    Set<String> usedLanguages = SetSequence.fromSet(new HashSet<String>());
    for (SNode originalDep : deps) {
      SNode dep = (SNodeOperations.isInstanceOf(originalDep, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency") ?
        SLinkOperations.getTarget(SNodeOperations.cast(originalDep, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency"), "dependency", true) :
        originalDep
      );
      if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule")) {
        SNode depOnModule = SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule");
        String uuid = SPropertyOperations.getString(SLinkOperations.getTarget(depOnModule, "module", false), "uuid");
        if (MapSequence.fromMap(ndeps).containsKey(uuid)) {
          SPropertyOperations.set(MapSequence.fromMap(ndeps).get(uuid), "reexport", "" + (SPropertyOperations.getBoolean(MapSequence.fromMap(ndeps).get(uuid), "reexport") || SPropertyOperations.getBoolean(depOnModule, "reexport")));
          SNodeOperations.deleteNode(originalDep);
          continue;
        }
        MapSequence.fromMap(ndeps).put(uuid, depOnModule);
      } else if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage")) {
        SNode extLang = SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage");
        String uuid = SPropertyOperations.getString(SLinkOperations.getTarget(extLang, "language", false), "uuid");
        if (SetSequence.fromSet(extendedLanguages).contains(uuid)) {
          SNodeOperations.deleteNode(originalDep);
          continue;
        }
        SetSequence.fromSet(extendedLanguages).addElement(uuid);
      } else if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage")) {
        SNode extLang = SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage");
        String uuid = SPropertyOperations.getString(SLinkOperations.getTarget(extLang, "language", false), "uuid");
        if (SetSequence.fromSet(usedLanguages).contains(uuid)) {
          SNodeOperations.deleteNode(originalDep);
          continue;
        }
        SetSequence.fromSet(usedLanguages).addElement(uuid);
      }
    }
    for (SNode dep : ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(module, "dependencies", true))) {
      if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency")) {
        SNodeOperations.replaceWithAnother(dep, SLinkOperations.getTarget(SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency"), "dependency", true));
      }
    }
  }

  private boolean checkModuleReference(ModuleDescriptor md) {
    boolean success = true;
    ModuleReference moduleReference = md.getModuleReference();
    if (neq_a6ewnz_a0c0h(SPropertyOperations.getString(myModule, "name"), moduleReference.getModuleFqName())) {
      report("name in import doesn't match file content " + SPropertyOperations.getString(myModule, "name") + ", should be: " + moduleReference.getModuleFqName(), myOriginalModule);
      success = false;
    }
    if (neq_a6ewnz_a0d0h(SPropertyOperations.getString(myModule, "uuid"), moduleReference.getModuleId().toString())) {
      report("module id in import doesn't match file content " + SPropertyOperations.getString(myModule, "name") + ", should be: " + moduleReference.getModuleId().toString(), myOriginalModule);
      success = false;
    }
    return success;
  }

  private void checkDevkit() {
    DevkitDescriptor descriptor = ((DevkitDescriptor) myModuleDescriptor);
    SNode devkit = SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_DevKit");

    for (ModuleReference module : descriptor.getExtendedDevkits()) {
      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_DevKit");
      if (resolved == null) {
        report("cannot find devkit in dependencies: " + module.getModuleFqName(), myModule);
        continue;
      }
      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_DevKit"), "extends", true)).any(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return asOriginal(SLinkOperations.getTarget(it, "devkit", false)) == resolved;
        }
      }))) {

        report("extends devkit dependency should be extracted into build script: " + module.toString(), myOriginalModule);
      }

    }
    for (ModuleReference module : descriptor.getExportedLanguages()) {
      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Language");
      if (resolved == null) {
        report("cannot find exported languages in dependencies: " + module.getModuleFqName(), myModule);
        continue;
      }
      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_DevKit"), "exports", true)).any(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage"), "language", false)) == resolved;
        }
      }))) {

        report("export language dependency should be extracted into build script: " + module.toString(), myOriginalModule);
      }

    }
    for (ModuleReference module : descriptor.getExportedSolutions()) {
      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Solution");
      if (resolved == null) {
        report("cannot find exported solution in dependencies: " + module.getModuleFqName(), myModule);
        continue;
      }
      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_DevKit"), "exports", true)).any(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution"), "solution", false)) == resolved;
        }
      }))) {

        report("export solution dependency should be extracted into build script: " + module.toString(), myOriginalModule);
      }
    }
  }

  private void importDevkit() {
    DevkitDescriptor descriptor = ((DevkitDescriptor) myModuleDescriptor);
    SNode devkit = SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_DevKit");
    ListSequence.fromList(SLinkOperations.getTargets(devkit, "extends", true)).clear();
    ListSequence.fromList(SLinkOperations.getTargets(devkit, "exports", true)).clear();

    for (ModuleReference module : descriptor.getExtendedDevkits()) {
      SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_DevKit");
      if (resolved == null) {
        report("cannot find devkit in dependencies: " + module.getModuleFqName(), myModule);
        continue;
      }
      SNode ul = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_DevKitRef", null);
      SLinkOperations.setTarget(ul, "devkit", resolved, false);
      ListSequence.fromList(SLinkOperations.getTargets(devkit, "extends", true)).addElement(ul);
    }
    for (ModuleReference module : descriptor.getExportedLanguages()) {
      SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Language");
      if (resolved == null) {
        report("cannot find exported languages in dependencies: " + module.getModuleFqName(), myModule);
        continue;
      }
      SNode ul = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage", null);
      SLinkOperations.setTarget(ul, "language", resolved, false);
      ListSequence.fromList(SLinkOperations.getTargets(devkit, "exports", true)).addElement(ul);
    }
    for (ModuleReference module : descriptor.getExportedSolutions()) {
      SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Solution");
      if (resolved == null) {
        report("cannot find exported solution in dependencies: " + module.getModuleFqName(), myModule);
        continue;
      }
      SNode ul = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution", null);
      SLinkOperations.setTarget(ul, "solution", resolved, false);
      ListSequence.fromList(SLinkOperations.getTargets(devkit, "exports", true)).addElement(ul);
    }
  }

  private void importLanguageDeps() {
    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);
    for (ModuleReference lang : descriptor.getExtendedLanguages()) {
      SNode resolved = SNodeOperations.as(visible.resolve(lang.getModuleFqName(), lang.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Language");
      if (resolved == null) {
        report("cannot find extended language in dependencies: " + lang.getModuleFqName(), myModule);
        continue;
      }
      SNode ul = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage", null);
      SLinkOperations.setTarget(ul, "language", resolved, false);
      SNode res = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency", null);
      SLinkOperations.setTarget(res, "dependency", ul, true);
      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module"), "dependencies", true)).addElement(res);
    }
  }

  private void loadLanguageDeps(boolean checkOnly) {
    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);
    boolean importsCore = false;
    for (ModuleReference lang : descriptor.getExtendedLanguages()) {
      if (!(importsCore) && "ceab5195-25ea-4f22-9b92-103b95ca8c0c".equals(lang.getModuleId())) {
        importsCore = true;
      }
      final SNode resolved = SNodeOperations.as(visible.resolve(lang.getModuleFqName(), lang.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Language");
      if (resolved == null) {
        report("cannot find extended language in dependencies: " + lang.getModuleFqName(), myModule);
        continue;
      }
      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Language"), "dependencies", true)).any(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          SNode em = SNodeOperations.as(it, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency");
          return em != null && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(em, "dependency", true), "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(em, "dependency", true), "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage"), "language", false)) == resolved;
        }
      }))) {

        report("extends language dependency should be extracted into build script: " + lang.toString(), myOriginalModule);
      }
    }
    if (!(importsCore) && !(checkOnly)) {
      SNode resolved = SNodeOperations.as(visible.resolve("jetbrains.mps.lang.core", "ceab5195-25ea-4f22-9b92-103b95ca8c0c"), "jetbrains.mps.build.mps.structure.BuildMps_Language");
      if (resolved == null) {
        report("cannot find jetbrains.mps.lang.core language in dependencies for " + SPropertyOperations.getString(myModule, "name"), myModule);
      } else {
        SNode ul = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage", null);
        SLinkOperations.setTarget(ul, "language", resolved, false);
        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module"), "dependencies", true)).addElement(ul);
      }
    }
    String langName = myModuleDescriptor.getModuleReference().getModuleFqName();
    for (GeneratorDescriptor generator : descriptor.getGenerators()) {
      String generatorName = generator.getGeneratorUID();
      if (generatorName != null && !(generatorName.startsWith(langName + "#"))) {
        report("wrong generator name `" + generatorName + "', should start with `" + langName + "#'", myOriginalModule);
      }
    }
  }

  private SNode asOriginal(SNode node) {
    if (SNodeOperations.getContainingRoot(node) == SNodeOperations.getContainingRoot(myModule)) {
      return node;
    }
    return (genContext != null ?
      genContext.getOriginalCopiedInputNode(node) :
      node
    );
  }

  private void importRuntime() {
    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);
    for (ModuleReference module : descriptor.getRuntimeModules()) {
      SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Solution");
      if (resolved == null) {
        report("cannot find runtime solution in dependencies: " + module.getModuleFqName(), myModule);
        continue;
      }
      SNode ul = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime", null);
      SLinkOperations.setTarget(ul, "solution", resolved, false);
      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Language"), "runtime", true)).addElement(ul);
    }
  }

  private void checkRuntime() {
    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);
    for (ModuleReference module : descriptor.getRuntimeModules()) {
      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Solution");
      if (resolved == null) {
        report("cannot find runtime solution in dependencies: " + module.getModuleFqName(), myModule);
        continue;
      }
      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Language"), "runtime", true)).any(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime"), "solution", false)) == resolved;
        }
      }))) {

        report("runtime solution should be extracted into build script: " + module.toString(), myOriginalModule);
      }
    }
  }

  private void collectLocalDependencies() {
    SNode module = SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module");
    Iterable<ModuleReference> usedLanguages = myModuleDescriptor.getUsedLanguages();
    Iterable<ModuleReference> usedDevkits = myModuleDescriptor.getUsedDevkits();
    if (myModuleDescriptor instanceof LanguageDescriptor) {
      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies 
      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();
      usedLanguages = Sequence.fromIterable(usedLanguages).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, ModuleReference>() {
        public Iterable<ModuleReference> translate(GeneratorDescriptor it) {
          return it.getUsedLanguages();
        }
      }));
      usedDevkits = Sequence.fromIterable(usedDevkits).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, ModuleReference>() {
        public Iterable<ModuleReference> translate(GeneratorDescriptor it) {
          return it.getUsedDevkits();
        }
      }));
    }

    for (ModuleReference lang : usedLanguages) {
      SNode resolved = SNodeOperations.as(visible.resolve(lang.getModuleFqName(), lang.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Language");
      if (resolved == null) {
        report("cannot find used language in dependencies: " + lang.getModuleFqName(), myModule);
        continue;
      }
      SNode ul = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage", null);
      SLinkOperations.setTarget(ul, "language", resolved, false);
      ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).addElement(ul);
    }
    for (ModuleReference devkit : usedDevkits) {
      SNode resolved = SNodeOperations.as(visible.resolve(devkit.getModuleFqName(), devkit.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_DevKit");
      if (resolved == null) {
        report("cannot find used devkit in dependencies: " + devkit.getModuleFqName(), myModule);
        continue;
      }
      SNode ud = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit", null);
      SLinkOperations.setTarget(ud, "devkit", resolved, false);
      ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).addElement(ud);
    }
  }

  private void collectDependencies(boolean checkOnly) {
    SNode module = SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module");
    Map<String, Boolean> usedModuleIds = new HashMap<String, Boolean>();
    Set<String> extractedModules = new HashSet<String>();
    for (SNode dep : SLinkOperations.getTargets(module, "dependencies", true)) {
      boolean extracted = false;
      if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency")) {
        dep = SLinkOperations.getTarget(SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency"), "dependency", true);
        extracted = true;
      }
      if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule")) {
        SNode onModule = SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule");
        boolean existing = (usedModuleIds.containsKey(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, "module", false), "uuid")) ?
          usedModuleIds.get(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, "module", false), "uuid")) :
          false
        );
        usedModuleIds.put(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, "module", false), "uuid"), SPropertyOperations.getBoolean(onModule, "reexport") || existing);
        if (extracted) {
          extractedModules.add(SPropertyOperations.getString(SLinkOperations.getTarget(onModule, "module", false), "uuid"));
        }
      }
    }

    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();
    for (Dependency dependency : dependencies) {
      ModuleReference moduleRef = dependency.getModuleRef();
      if (moduleRef.getModuleFqName().contains("#")) {
        report("module cannot depend on generator: `" + moduleRef.getModuleFqName() + "'", myOriginalModule);
      }
    }
    if (myModuleDescriptor instanceof LanguageDescriptor) {
      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies 
      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();
      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {
        public Iterable<Dependency> translate(GeneratorDescriptor it) {
          return it.getDependencies();
        }
      }));
    }

    // resolve all dependencies 
    Map<SNode, Boolean> depsToReexport = new LinkedHashMap<SNode, Boolean>();
    for (Dependency dep : dependencies) {
      boolean reexport = dep.isReexport();
      ModuleReference moduleRef = dep.getModuleRef();
      SNode resolved;
      String targetName = moduleRef.getModuleFqName();
      int sharpIndex = targetName.indexOf("#");
      if (sharpIndex >= 0) {
        resolved = SNodeOperations.as(visible.resolve(targetName.substring(0, sharpIndex), null), "jetbrains.mps.build.mps.structure.BuildMps_Module");
        if (resolved == null) {
          report("cannot resolve reference on generator's containing language by module name: " + targetName, myOriginalModule);
          continue;
        }
      } else {
        resolved = SNodeOperations.as(visible.resolve(targetName, moduleRef.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Module");
        if (resolved == null) {
          report("unsatisfied dependency: " + dep.getModuleRef().toString(), myOriginalModule);
          continue;
        }
      }

      Boolean alreadyReexport = depsToReexport.get(resolved);
      if (alreadyReexport != null && alreadyReexport.booleanValue()) {
        continue;
      }
      depsToReexport.put(resolved, reexport);
    }

    // check & create 
    for (Map.Entry<SNode, Boolean> entry : depsToReexport.entrySet()) {
      SNode resolved = entry.getKey();
      boolean reexport = entry.getValue().booleanValue();

      boolean found = false;
      if (usedModuleIds.containsKey(SPropertyOperations.getString(resolved, "uuid"))) {
        found = true;
        boolean foundReexport = usedModuleIds.get(SPropertyOperations.getString(resolved, "uuid"));
        if (foundReexport != reexport && extractedModules.contains(SPropertyOperations.getString(resolved, "uuid"))) {
          report("wrong reexport status for dependency in build script for: " + SPropertyOperations.getString(resolved, "name"), myOriginalModule);
        }
      }

      if (reexport && !(extractedModules.contains(SPropertyOperations.getString(resolved, "uuid")))) {
        report("reexport dependency should be extracted into build script: " + SPropertyOperations.getString(resolved, "name"), myOriginalModule);
      }
      if (!(found)) {
        if (checkOnly) {
          continue;
        }

        SNode res = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule", null);
        SLinkOperations.setTarget(res, "module", resolved, false);
        SPropertyOperations.set(res, "reexport", "" + (reexport));
        ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).addElement(res);
      }
    }

    // java stubs: jars 
    for (String path : myModuleDescriptor.getAdditionalJavaStubPaths()) {
      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();
      if (p == null) {
        continue;
      }

      if (path.endsWith(".jar")) {
        final String relPath = BehaviorReflection.invokeVirtual(String.class, p, "virtual_getRelativePath_5481553824944787371", new Object[]{});
        if (!(ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            SNode dep = (SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency") ?
              SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency"), "dependency", true) :
              it
            );
            return SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar") && eq_a6ewnz_a0a1a0a0a0a0b0d0r0q(BehaviorReflection.invokeVirtual(String.class, SLinkOperations.getTarget(SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar"), "path", true), "virtual_getRelativePath_5481553824944787371", new Object[]{}), relPath);
          }
        }))) {
          report("jar stub library should be extracted into build script: " + relPath, myOriginalModule);
        }
      } else {
        report("only jar stub libraries are supported, found: " + path, myOriginalModule);
      }
    }

  }

  private void importDependencies() {
    SNode module = SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module");

    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();
    if (myModuleDescriptor instanceof LanguageDescriptor) {
      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies 
      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();
      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {
        public Iterable<Dependency> translate(GeneratorDescriptor it) {
          return it.getDependencies();
        }
      }));
    }

    Set<SNode> seen = new HashSet<SNode>();
    for (Dependency dep : dependencies) {
      boolean reexport = dep.isReexport();
      if (!(reexport)) {
        continue;
      }

      ModuleReference moduleRef = dep.getModuleRef();
      SNode resolved;
      String targetName = moduleRef.getModuleFqName();
      int sharpIndex = targetName.indexOf("#");
      if (sharpIndex >= 0) {
        resolved = SNodeOperations.as(visible.resolve(targetName.substring(0, sharpIndex), null), "jetbrains.mps.build.mps.structure.BuildMps_Module");
        if (resolved == null) {
          report("cannot resolve reference on generator's containing language by module name: " + targetName, myOriginalModule);
          continue;
        }
      } else {
        resolved = SNodeOperations.as(visible.resolve(targetName, moduleRef.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Module");
        if (resolved == null) {
          report("unsatisfied dependency: " + dep.getModuleRef().toString(), myOriginalModule);
          continue;
        }
      }

      if (!(seen.add(resolved))) {
        continue;
      }

      SNode res = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule", null);
      SLinkOperations.setTarget(res, "module", resolved, false);
      SPropertyOperations.set(res, "reexport", "" + (reexport));
      SNode extr = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency", null);
      SLinkOperations.setTarget(extr, "dependency", res, true);
      ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).addElement(extr);
    }

    // java stubs: jars 
    for (String path : myModuleDescriptor.getAdditionalJavaStubPaths()) {
      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();
      if (p == null) {
        continue;
      }

      if (path.endsWith(".jar")) {
        SNode jar = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar", null);
        SLinkOperations.setTarget(jar, "path", p, true);
        SNode extr = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency", null);
        SLinkOperations.setTarget(extr, "dependency", jar, true);
        ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).addElement(extr);
      } else {
        report("only jar stub libraries are supported, found: " + path, myOriginalModule);
      }
    }
  }

  private void collectSources(boolean checkOnly, boolean importOnly) {
    SNode module = SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module");
    Iterable<ModelRoot> modelRoots = myModuleDescriptor.getModelRoots();
    boolean hasModels = false;
    if (myModuleDescriptor instanceof LanguageDescriptor) {
      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();
      modelRoots = Sequence.fromIterable(modelRoots).concat(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, ModelRoot>() {
        public Iterable<ModelRoot> translate(GeneratorDescriptor it) {
          return it.getModelRoots();
        }
      }));
    }
    for (ModelRoot modelRoot : modelRoots) {
      if (modelRoot.getManager() != null) {
        continue;
      }

      String path = modelRoot.getPath();
      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();
      if (p == null) {
        continue;
      }

      if (!(checkOnly)) {
        SNode mroot = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleModelRoot", null);
        SLinkOperations.setTarget(mroot, "folder", p, true);
        ListSequence.fromList(SLinkOperations.getTargets(module, "sources", true)).addElement(mroot);
      }
      hasModels = true;
    }
    List<String> res = new ArrayList<String>();
    for (String sp : myModuleDescriptor.getSourcePaths()) {
      res.add(sp);
    }
    if (!(SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Solution")) || !(SPropertyOperations.getBoolean(SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Solution"), "doNotCompile")) && hasModels) {
      IFile genPath = ProjectPathUtil.getGeneratorOutputPath(myModuleFile, myModuleDescriptor);
      if (genPath != null) {
        res.add(genPath.getPath());
      }
    }

    boolean doNotCompile = myModuleDescriptor instanceof SolutionDescriptor && (!(((SolutionDescriptor) myModuleDescriptor).getCompileInMPS()) || res.isEmpty());
    if (checkOnly && importOnly) {
      SPropertyOperations.set(module, "doNotCompile", "" + (doNotCompile));

    } else if (SPropertyOperations.getBoolean(module, "doNotCompile") != doNotCompile) {
      report("compile in MPS flag doesn't match file content " + SPropertyOperations.getString(myModule, "name") + ", should be: " + doNotCompile, myOriginalModule);
    }


    if (checkOnly) {
      return;
    }

    for (String path : res) {
      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();
      if (p == null) {
        continue;
      }
      SNode javaSource = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleJavaSource", null);
      SLinkOperations.setTarget(javaSource, "folder", SConceptOperations.createNewNode("jetbrains.mps.build.structure.BuildInputSingleFolder", null), true);
      SLinkOperations.setTarget(SNodeOperations.cast(SLinkOperations.getTarget(javaSource, "folder", true), "jetbrains.mps.build.structure.BuildInputSingleFolder"), "path", p, true);
      ListSequence.fromList(SLinkOperations.getTargets(module, "sources", true)).addElement(javaSource);
    }
  }

  private List<SNode> convertPath(String path, SNode anchor) {
    try {
      return pathConverter.convertPath(path, SNodeOperations.getModel(myModule));
    } catch (PathConverter.PathConvertException ex) {
      report(ex.getMessage(), anchor, ex);
      return null;
    }
  }

  protected void report(String message, SNode node) {
    report(message, node, null);
  }

  protected void report(String message, SNode node, Exception cause) {
    if (genContext == null) {
      throw new ModuleLoader.ModuleLoaderException(message, node, cause);
    }

    genContext.showErrorMessage(node, message);
  }

  private static boolean neq_a6ewnz_a0c0h(Object a, Object b) {
    return !((a != null ?
      a.equals(b) :
      a == b
    ));
  }

  private static boolean neq_a6ewnz_a0d0h(Object a, Object b) {
    return !((a != null ?
      a.equals(b) :
      a == b
    ));
  }

  private static boolean eq_a6ewnz_a0a1a0a0a0a0b0d0r0q(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  private static boolean eq_a6ewnz_a0c0f0d0a1(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  public static class ModuleLoaderException extends RuntimeException {
    private SNode node;

    public ModuleLoaderException(String message, SNode node, Throwable cause) {
      super(message, cause);
      this.node = node;
    }

    public SNode getNode() {
      return node;
    }
  }

  public class ModuleMacroHelper implements MacroHelper {
    private IFile moduleFile;

    public ModuleMacroHelper(IFile moduleFile) {
      this.moduleFile = moduleFile;
    }

    public String expandPath(@Nullable String path) {
      if (path == null) {
        return null;
      }

      if (moduleFile != null) {
        for (String macro : MacrosFactory.descriptors) {
          if (path.startsWith(macro)) {
            String relPath = path.substring(path.indexOf('}') + 1);
            return IFileUtils.getCanonicalPath(moduleFile.getParent().getDescendant(relPath));
          }
        }
      }
      if (path.startsWith("${")) {
        int index = path.indexOf("}");
        if (index == -1) {
          report("invalid macro in `" + path + "'", null);
          return path;
        }

        String macroName = path.substring(2, index);
        SNode found = null;
        for (SNode macro : SLinkOperations.getTargets(SNodeOperations.getAncestor(myOriginalModule, "jetbrains.mps.build.structure.BuildProject", false, false), "macros", true)) {
          if (!(SNodeOperations.isInstanceOf(macro, "jetbrains.mps.build.structure.BuildFolderMacro"))) {
            continue;
          }

          if (eq_a6ewnz_a0c0f0d0a1(SPropertyOperations.getString(macro, "name"), macroName)) {
            found = SNodeOperations.cast(macro, "jetbrains.mps.build.structure.BuildFolderMacro");
            break;
          }
        }
        if (found == null) {
          report("macro is not declared in build script: " + path, null);
          return path;
        }

        String localPath = BehaviorReflection.invokeVirtual(String.class, SLinkOperations.getTarget(found, "defaultPath", true), "virtual_getLocalPath_5481553824944787364", new Object[]{(genContext != null ?
          Context.defaultContext(genContext) :
          Context.defaultContext()
        )});
        if (localPath == null) {
          if (genContext != null) {
            genContext.showWarningMessage(found, "cannot resolve local path: " + path + ", macro has no default value");
          }
          return path;
        }

        String relPath = path.substring(index + 1);
        return IFileUtils.getCanonicalPath(FileSystem.getInstance().getFileByPath(localPath).getDescendant(relPath));
      }
      return path;
    }

    public String shrinkPath(@Nullable String string) {
      throw new UnsupportedOperationException("cannot shrink");
    }
  }
}
