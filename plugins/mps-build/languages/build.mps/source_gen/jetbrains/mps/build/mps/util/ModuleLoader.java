package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import jetbrains.mps.generator.template.TemplateQueryContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.build.util.Context;
import java.io.File;
import java.io.IOException;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.project.structure.modules.LanguageDescriptor;
import jetbrains.mps.project.structure.modules.SolutionDescriptor;
import jetbrains.mps.project.structure.modules.DevkitDescriptor;
import jetbrains.mps.project.structure.modules.GeneratorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.module.SModuleReference;

public class ModuleLoader {
  private final TemplateQueryContext myGenContext;
  private final SNode myModule;
  private final SNode myOriginalModule;
  private final ModuleDescriptor myModuleDescriptor;
  private final IFile myModuleSourceDir;
  private final VisibleModules myVisibleModules;
  private final PathConverter myPathConverter;
  private final ModuleLoader.Reporter myReporter;
  private final ModuleChecker myChecker;


  public ModuleLoader(SNode module, SNode originalModule, VisibleModules visible, PathConverter pathConverter, TemplateQueryContext genContext, IFile moduleSourceDir, ModuleDescriptor moduleDescriptor, ModuleLoader.Reporter reporter) {
    myGenContext = genContext;
    myModule = module;
    myOriginalModule = originalModule;
    myVisibleModules = visible;
    myPathConverter = pathConverter;
    myModuleSourceDir = moduleSourceDir;
    myModuleDescriptor = moduleDescriptor;
    myReporter = reporter;

    myChecker = new ModuleChecker(module, originalModule, visible, pathConverter, genContext, moduleSourceDir, moduleDescriptor, reporter);
  }



  public static ModuleLoader createModuleLoader(SNode module, VisibleModules visible, PathConverter pathConverter, TemplateQueryContext genContext, ModuleLoader.Reporter reporter) {
    SNode originalModule = ModuleLoaderUtils.getOriginalModule(module, genContext);

    String moduleFilePath = BehaviorReflection.invokeVirtual(String.class, SLinkOperations.getTarget(module, "path", true), "virtual_getLocalPath_5481553824944787364", new Object[]{(genContext != null ?
      Context.defaultContext(genContext) :
      Context.defaultContext()
    )});
    try {
      moduleFilePath = new File(moduleFilePath).getCanonicalPath();
    } catch (IOException ex) {
      // ignore 
    }

    IFile file = FileSystem.getInstance().getFileByPath(moduleFilePath);
    if (!(file.exists())) {
      reporter.report("cannot import module file for " + SPropertyOperations.getString(module, "name") + ": file doesn't exist (" + moduleFilePath + ")", originalModule, null);
      return new ModuleLoader(module, originalModule, visible, pathConverter, genContext, null, null, reporter);
    }
    if (file.isDirectory()) {
      reporter.report("cannot import module file for " + SPropertyOperations.getString(module, "name") + ": file is a directory (" + moduleFilePath + ")", originalModule, null);
      return new ModuleLoader(module, originalModule, visible, pathConverter, genContext, null, null, reporter);
    }

    ModuleDescriptor md = null;
    try {
      md = ModuleLoaderUtils.loadModuleDescriptor(file, genContext, originalModule, reporter);
      if (md.getLoadException() != null) {
        reporter.report("cannot import module file for " + SPropertyOperations.getString(module, "name") + ": exception: " + md.getLoadException().getMessage(), originalModule, null);
      }
    } catch (Exception ex) {
      reporter.report("cannot import module file for " + SPropertyOperations.getString(module, "name") + ": exception: " + ex.getMessage(), originalModule, ex);
      ex.printStackTrace(System.err);
    }

    return new ModuleLoader(module, originalModule, visible, pathConverter, genContext, file.getParent(), md, reporter);
  }

  public static ModuleLoader createModuleLoader(SNode module, VisibleModules visible, PathConverter pathConverter) {
    return createModuleLoader(module, visible, pathConverter, null, new ModuleLoader.Reporter(null));
  }



  public void importRequired() {
    myChecker.check(ModuleChecker.CheckType.LOAD_IMPORTANT_PART);
  }

  public void checkModule() {
    myChecker.check(ModuleChecker.CheckType.CHECK);
  }

  public void loadAndCheck() {
    SPropertyOperations.set(myModule, "compact", "" + (false));
    if (myModuleDescriptor == null) {
      return;
    }

    if (!(myChecker.checkModuleReference(ModuleChecker.CheckType.LOAD_ALL))) {
      return;
    }

    if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Language")) {
      if (!(myModuleDescriptor instanceof LanguageDescriptor)) {
        report("imported file is not a language file " + SPropertyOperations.getString(myModule, "name"), myOriginalModule);
        return;
      }

      myChecker.checkLanguage(ModuleChecker.CheckType.LOAD_ALL, null);
      loadGenerators();
    } else if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Solution")) {
      if (!(myModuleDescriptor instanceof SolutionDescriptor)) {
        report("imported file is not a solution file " + SPropertyOperations.getString(myModule, "name"), myOriginalModule);
        return;
      }
    } else if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_DevKit")) {
      if (!(myModuleDescriptor instanceof DevkitDescriptor)) {
        report("imported file is not a devkit file " + SPropertyOperations.getString(myModule, "name"), myOriginalModule);
        return;
      }

      myChecker.checkDevkit(ModuleChecker.CheckType.LOAD_ALL);
    }

    if (SNodeOperations.isInstanceOf(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module")) {
      myChecker.collectDependencies(ModuleChecker.CheckType.LOAD_ALL, null);
      collectLocalDependencies();
      myChecker.collectSources(ModuleChecker.CheckType.LOAD_ALL);
      optimizeDeps();
    }
  }

  private void loadGenerators() {
    LanguageDescriptor languageDescriptor = ((LanguageDescriptor) myModuleDescriptor);
    String langName = languageDescriptor.getModuleReference().getModuleName();

    if (languageDescriptor.getGenerators().size() > 1) {
      report("more than one generator for language `" + langName + "'", myOriginalModule);
    }
    if (languageDescriptor.getGenerators().isEmpty()) {
      return;
    }

    GeneratorDescriptor generatorDescriptor = languageDescriptor.getGenerators().get(0);
    String generatorName = generatorDescriptor.getGeneratorUID();
    if (generatorName != null && !(generatorName.startsWith(langName + "#"))) {
      report("wrong generator name `" + generatorName + "', should start with `" + langName + "#'", myOriginalModule);
    }

    SNode generator = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_Generator", null);
    SPropertyOperations.set(generator, "name", generatorDescriptor.getNamespace());
    SPropertyOperations.set(generator, "uuid", generatorDescriptor.getId().toString());
    SLinkOperations.setTarget(generator, "sourceLanguage", SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Language"), false);

    // <node> 

    // <node> 
    // <node> 
    // <node> 
  }

  private void optimizeDeps() {
    SNode module = SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module");
    List<SNode> deps = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(module, "dependencies", true));
    Map<String, SNode> ndeps = MapSequence.fromMap(new HashMap<String, SNode>());
    Set<String> extendedLanguages = SetSequence.fromSet(new HashSet<String>());
    Set<String> usedLanguages = SetSequence.fromSet(new HashSet<String>());
    for (SNode originalDep : deps) {
      SNode dep = (SNodeOperations.isInstanceOf(originalDep, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency") ?
        SLinkOperations.getTarget(SNodeOperations.cast(originalDep, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency"), "dependency", true) :
        originalDep
      );
      if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule")) {
        SNode depOnModule = SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule");
        String uuid = SPropertyOperations.getString(SLinkOperations.getTarget(depOnModule, "module", false), "uuid");
        if (MapSequence.fromMap(ndeps).containsKey(uuid)) {
          SPropertyOperations.set(MapSequence.fromMap(ndeps).get(uuid), "reexport", "" + (SPropertyOperations.getBoolean(MapSequence.fromMap(ndeps).get(uuid), "reexport") || SPropertyOperations.getBoolean(depOnModule, "reexport")));
          SNodeOperations.deleteNode(originalDep);
          continue;
        }
        MapSequence.fromMap(ndeps).put(uuid, depOnModule);
      } else if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage")) {
        SNode extLang = SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage");
        String uuid = SPropertyOperations.getString(SLinkOperations.getTarget(extLang, "language", false), "uuid");
        if (SetSequence.fromSet(extendedLanguages).contains(uuid)) {
          SNodeOperations.deleteNode(originalDep);
          continue;
        }
        SetSequence.fromSet(extendedLanguages).addElement(uuid);
      } else if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage")) {
        SNode extLang = SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage");
        String uuid = SPropertyOperations.getString(SLinkOperations.getTarget(extLang, "language", false), "uuid");
        if (SetSequence.fromSet(usedLanguages).contains(uuid)) {
          SNodeOperations.deleteNode(originalDep);
          continue;
        }
        SetSequence.fromSet(usedLanguages).addElement(uuid);
      }
    }
    for (SNode dep : ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(module, "dependencies", true))) {
      if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency")) {
        SNodeOperations.replaceWithAnother(dep, SLinkOperations.getTarget(SNodeOperations.cast(dep, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency"), "dependency", true));
      }
    }
  }

  private void collectLocalDependencies() {
    SNode module = SNodeOperations.cast(myModule, "jetbrains.mps.build.mps.structure.BuildMps_Module");
    Iterable<SModuleReference> usedLanguages = myModuleDescriptor.getUsedLanguages();
    Iterable<SModuleReference> usedDevkits = myModuleDescriptor.getUsedDevkits();

    for (SModuleReference lang : usedLanguages) {
      SNode resolved = SNodeOperations.as(myVisibleModules.resolve(lang.getModuleName(), lang.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_Language");
      if (resolved == null) {
        report("cannot find used language in dependencies: " + lang.getModuleName(), myModule);
        continue;
      }
      SNode ul = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage", null);
      SLinkOperations.setTarget(ul, "language", resolved, false);
      ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).addElement(ul);
    }
    for (SModuleReference devkit : usedDevkits) {
      SNode resolved = SNodeOperations.as(myVisibleModules.resolve(devkit.getModuleName(), devkit.getModuleId().toString()), "jetbrains.mps.build.mps.structure.BuildMps_DevKit");
      if (resolved == null) {
        report("cannot find used devkit in dependencies: " + devkit.getModuleName(), myModule);
        continue;
      }
      SNode ud = SConceptOperations.createNewNode("jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit", null);
      SLinkOperations.setTarget(ud, "devkit", resolved, false);
      ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).addElement(ud);
    }
  }



  private void report(String message, SNode node) {
    myReporter.report(message, node, null);
  }



  public static class Reporter {
    private final TemplateQueryContext myGenContext;

    public Reporter(TemplateQueryContext genContext) {
      myGenContext = genContext;
    }

    public void report(String message, SNode node, Exception cause) {
      if (myGenContext == null) {
        throw new ModuleLoaderException(message, node, cause);
      }

      myGenContext.showErrorMessage(node, message);
    }
  }
}
