package jetbrains.mps.build.mps.runtime.anttask;

/*Generated by MPS */

import org.apache.tools.ant.Task;
import java.io.File;
import org.apache.tools.ant.types.Path;
import java.util.List;
import jetbrains.mps.build.ant.MpsLoadTask;
import org.apache.tools.ant.BuildException;
import jetbrains.mps.build.ant.JvmArgs;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Set;
import java.util.LinkedHashSet;
import java.util.HashSet;
import org.apache.tools.ant.util.JavaEnvUtils;
import jetbrains.mps.build.ant.AntBootstrap;
import java.io.FileNotFoundException;
import java.io.IOException;
import org.apache.tools.ant.taskdefs.Execute;
import java.net.URL;
import java.net.MalformedURLException;
import java.net.URLClassLoader;
import org.apache.tools.ant.ProjectComponent;
import jetbrains.mps.build.ant.WhatToDo;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

public class MPSTask extends Task {
  public static final String CONFIGURATION_NAME = "configuration.name";
  public static final String BUILD_NUMBER = "build.number";
  public static final String MPS_HOME = "mps.home";
  private File myMpsHome = null;
  private boolean myFork = true;
  private boolean myUsePropertiesAsMacro = false;
  private Path myClasspath = null;
  private List<String> myJvmArgs = null;

  public MPSTask() {
  }

  public void setMpsHome(File mpsHome) {
    myMpsHome = mpsHome;
  }

  public File getMpsHome() {
    return myMpsHome;
  }

  public void setFork(boolean fork) {
    myFork = fork;
  }

  public void setFailOnError(boolean failOnError) {
  }

  public void setLogLevel(MpsLoadTask.LogLevelAttribute logLevel) {
  }

  public void setUsePropertiesAsMacro(boolean usePropertiesAsMacro) {
    myUsePropertiesAsMacro = usePropertiesAsMacro;
  }

  public boolean getUsePropertiesAsMacro() {
    return myUsePropertiesAsMacro;
  }

  private void checkMpsHome() {
    // use mps.home if was not set in task attribute 
    if (myMpsHome == null) {
      String mpsHomePath = getProject().getProperty(MPS_HOME);
      if (mpsHomePath == null || !(getProject().resolveFile(mpsHomePath).exists())) {
        throw new BuildException("Path to MPS home not set or invalid. Specify mps.home property or mpshome attribute.");
      }
      myMpsHome = getProject().resolveFile(mpsHomePath);
    }
  }

  public void addConfiguredJvmArgs(JvmArgs jvmArgs) {
    if (!(myFork)) {
      throw new BuildException("Nested <jvmargs> is only allowed in fork mode.");
    }
    if (myJvmArgs == null) {
      myJvmArgs = new ArrayList<String>();
    }
    myJvmArgs.addAll(jvmArgs.getArgs());
  }

  public void addPropertiesAsMacro() {
    Hashtable properties = getProject().getProperties();
    for (Object name : properties.keySet()) {
      Object value = properties.get(name);
      // <node> 
    }
  }

  private File absolutePath(String path) {
    return new File(myMpsHome.getAbsolutePath() + File.separator + path.replace('/', File.separatorChar));
  }

  public void addConfiguredClassPath(Path path) {
    myClasspath = path;
  }

  protected boolean isFromSources() {
    return absolutePath("classes").exists();
  }

  protected Set<File> defaultMPSClassPath() {
    File[] pathsToLook;
    if (isFromSources()) {
      pathsToLook = new File[]{absolutePath("core"), absolutePath("lib"), absolutePath("plugins/mps-build/languages/solutions/jetbrains.mps.build.mps.runtime"), absolutePath("languages/baseLanguage/closures/runtime"), absolutePath("languages/baseLanguage/collections/runtime"), absolutePath("languages/baseLanguage/baseLanguage/solutions/jetbrains.mps.baseLanguage.search"), absolutePath("workbench/typesystemUi/classes"), absolutePath("MPSPlugin/apiclasses")};
    } else {
      pathsToLook = new File[]{absolutePath("lib"), absolutePath("plugin"), absolutePath("plugins")};
    }
    Set<File> classPaths = new LinkedHashSet<File>();
    for (File path : pathsToLook) {
      if (!(path.exists() && (path.isDirectory() || path.getAbsolutePath().endsWith(".jar")))) {
        throw new BuildException(myMpsHome + " is invalid MPS classpath: " + path + " does not exist or is not a directory or a jar file.");
      }

      if (path.isDirectory()) {
        gatherAllClassesAndJarsUnder(path, classPaths);
      } else {
        classPaths.add(path.getAbsoluteFile());
      }
    }
    File mpsClasses = absolutePath("classes");
    if (mpsClasses.exists()) {
      classPaths.add(mpsClasses);
    }
    return classPaths;
  }

  private void gatherAllClassesAndJarsUnder(File dir, Set<File> result) {
    if (dir.getName().equals("classes") || dir.getName().equals("classes_gen") || dir.getName().equals("apiclasses")) {
      result.add(dir);
      return;
    }
    File[] children = dir.listFiles();
    //  we do not want trove different from ours in $mps.home$/lib 
    String troveJar = "trove" + File.separator + "lib" + File.separator + "trove";
    //  to provide right order of class loading, 
    //  files go first 
    for (File f : children) {
      if (!(f.isDirectory())) {
        if (f.getName().endsWith(".jar") && !(f.getName().contains("ant.jar")) && !(f.getPath().contains(troveJar))) {
          result.add(f);
        }
      }
    }
    for (File f : children) {
      if (f.isDirectory()) {
        gatherAllClassesAndJarsUnder(f, result);
      }
    }
  }

  public Set<File> getClasspath() {
    if (myClasspath == null) {
      return defaultMPSClassPath();
    }
    Set<File> path = new HashSet<File>();
    for (String pathelem : myClasspath.list()) {
      path.add(new File(pathelem));
    }
    return path;
  }

  private void startOutOfProcess() {
    /*
      final String pathSeparator = System.getProperty("path.separator");

      StringBuilder pathBuilder = new StringBuilder(System.getProperty("java.class.path"));
      for (File path : getClasspath()) {
        pathBuilder.append(pathSeparator).append(path.getAbsolutePath());
      }

      List<String> commandLine = new ArrayList<String>();
      commandLine.add(JavaEnvUtils.getJreExecutable("java"));
      commandLine.addAll((myJvmArgs == null ?
        new JvmArgs().getArgs() :
        myJvmArgs
      ));
      commandLine.add("-classpath");
      commandLine.add(pathBuilder.toString());
      commandLine.add(AntBootstrap.class.getCanonicalName());
      commandLine.add(getWorkerClass().getCanonicalName());
      dumpPropertiesToWhatToDo();
      try {
        commandLine.add(myWhatToDo.dumpToTmpFile().getAbsolutePath());
      } catch (FileNotFoundException e) {
        throw new BuildException(e);
      } catch (IOException e) {
        throw new BuildException(e);
      }
      // working directory == getProject().getBaseDir() ? 
      Execute.runCommand(this, commandLine.toArray(new String[commandLine.size()]));
    */
  }

  private void startInProcess() {
    /*
      List<URL> classPathUrls = new ArrayList<URL>();
      for (File path : getClasspath()) {
        try {
          classPathUrls.add(new URL("file:///" + path + ((path.isDirectory() ?
            "/" :
            ""
          ))));
        } catch (MalformedURLException e) {
          throw new BuildException(e);
        }
      }
      URLClassLoader classLoader = new URLClassLoader(classPathUrls.toArray(new URL[classPathUrls.size()]), ProjectComponent.class.getClassLoader());
      try {
        Class<?> whatToGenerateClass = classLoader.loadClass(WhatToDo.class.getCanonicalName());
        Object whatToGenerate = whatToGenerateClass.newInstance();
        myWhatToDo.cloneTo(whatToGenerate);
        Class<?> generatorClass = classLoader.loadClass(getWorkerClass().getCanonicalName());
        Constructor<?> constructor = generatorClass.getConstructor(whatToGenerateClass, ProjectComponent.class);
        Object generator = constructor.newInstance(whatToGenerate, this);
        Method method = generatorClass.getMethod("work");
        method.invoke(generator);
      } catch (Throwable t) {
        throw new BuildException(t.getMessage() + "\n" + "Used class path: " + classPathUrls.toString());
      }
    */
  }

  @Override
  public void execute() throws BuildException {
    if (myUsePropertiesAsMacro) {
      addPropertiesAsMacro();
    }
    if (myFork) {
      startOutOfProcess();
    } else {
      startInProcess();
    }

  }
}
