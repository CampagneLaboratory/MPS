package jetbrains.mps.build.mps.runner.runtime;

/*Generated by MPS */

import jetbrains.mps.tool.builder.make.GeneratorWorker;
import jetbrains.mps.tool.common.Script;
import jetbrains.mps.tool.builder.MpsWorker;
import org.apache.log4j.Logger;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.project.Project;
import jetbrains.mps.tool.common.MpsRunnerProperties;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.module.ReloadableModule;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import jetbrains.mps.tool.environment.IdeaEnvironment;
import org.jetbrains.annotations.NotNull;

public class MpsRunnerWorker extends GeneratorWorker {
  public MpsRunnerWorker(Script whatToDo, MpsWorker.AntLogger logger) {
    super(whatToDo, logger);
  }

  @Override
  public void work() {
    Logger.getRootLogger().setLevel(myWhatToDo.getLogLevel());

    EnvironmentConfig config = EnvironmentConfig.emptyEnvironment();

    for (String jar : myWhatToDo.getLibraryJars()) {
      File jarFile = new File(jar);
      if (!(jarFile.exists())) {
        warning("Library " + jar + " does not exist.");
      }
      config = config.addLib(jar);
    }
    for (IMapping<String, String> macro : MapSequence.fromMap(myWhatToDo.getMacro())) {
      config = config.addMacro(macro.key(), new File(macro.value()));
    }

    Environment environment = new MpsRunnerWorker.MyEnvironment(config);
    environment.init();
    setupEnvironment();

    final Project project = createDummyProject();

    MpsRunnerProperties properties = new MpsRunnerProperties(myWhatToDo);
    String className = properties.getStartClass();
    String methodName = properties.getStartMethod();
    final SModuleReference solutionRef = ModuleReference.parseReference(properties.getSolution());
    final Wrappers._T<SModule> module = new Wrappers._T<SModule>();
    project.getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        module.value = solutionRef.resolve(project.getRepository());
      }
    });

    boolean isClassFound = runClass(module.value, className, methodName);
    if (!(isClassFound)) {
      error("cannot find class " + className + " in solution " + solutionRef);
    }

    dispose();
  }

  private static boolean runClass(SModule module, String className, String methodName) {
    Class cls = null;
    if (!(module instanceof ReloadableModule)) {
      return false;
    }
    try {
      cls = ((ReloadableModule) (module)).getClass(className);
    } catch (ClassNotFoundException e) {
    }
    if (cls == null) {
      return false;
    }
    try {
      // invoke public static method 
      Method method = cls.getMethod(methodName);
      method.invoke(null);
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
    } catch (InvocationTargetException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    }
    return true;
  }

  protected class MyEnvironment extends IdeaEnvironment {
    public MyEnvironment(@NotNull EnvironmentConfig config) {
      super(config);
    }

    @Override
    protected ClassLoader rootClassLoader() {
      return getClassLoader();
    }
  }

  public static void main(String[] args) {
    MpsRunnerWorker runner = new MpsRunnerWorker(Script.fromDumpInFile(new File(args[0])), new MpsWorker.SystemOutLogger());
    runner.workFromMain();
  }

  protected void executeTask(Project project, MpsWorker.ObjectsToProcess go) {
  }
  protected void showStatistic() {
  }
}
