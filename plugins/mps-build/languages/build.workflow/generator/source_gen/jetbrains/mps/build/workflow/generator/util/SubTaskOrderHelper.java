package jetbrains.mps.build.workflow.generator.util;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.UUID;
import jetbrains.mps.util.GraphUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;

public class SubTaskOrderHelper {
  private final List<SNode> list;
  private final Map<SNode, SubTaskOrderHelper.SubTask> map = new HashMap<SNode, SubTaskOrderHelper.SubTask>();
  private final TemplateQueryContext genContext;
  public SubTaskOrderHelper(List<SNode> list, TemplateQueryContext genContext) {
    this.list = list;
    this.genContext = genContext;
  }
  public void sort() {
    int count = 0;
    SubTaskOrderHelper.SubTask[] subtasks = new SubTaskOrderHelper.SubTask[ListSequence.fromList(list).count()];
    for (SNode st : list) {
      SubTaskOrderHelper.SubTask wrapper = new SubTaskOrderHelper.SubTask(st, count);
      map.put(st, wrapper);
      subtasks[count++] = wrapper;
    }
    for (SubTaskOrderHelper.SubTask st : subtasks) {
      for (SNode dep : SLinkOperations.getChildren(st.getTask(), MetaAdapterFactory.getContainmentLink(new UUID(7605046100638320544l, -5004325039833383149l), 2769948622284546677l, 2769948622284605953l, "after"))) {
        SubTaskOrderHelper.SubTask afterTask = map.get(SLinkOperations.getTarget(dep, MetaAdapterFactory.getReferenceLink(new UUID(7605046100638320544l, -5004325039833383149l), 2769948622284605880l, 2769948622284605881l, "target")));
        if (afterTask == null) {
          genContext.showErrorMessage(dep, "dependency on non-existing subtask");
          continue;
        }
        st.targets.add(afterTask.getIndex());
      }
      for (SNode dep : SLinkOperations.getChildren(st.getTask(), MetaAdapterFactory.getContainmentLink(new UUID(7605046100638320544l, -5004325039833383149l), 2769948622284546677l, 3961775458390293275l, "before"))) {
        SubTaskOrderHelper.SubTask beforeTask = map.get(SLinkOperations.getTarget(dep, MetaAdapterFactory.getReferenceLink(new UUID(7605046100638320544l, -5004325039833383149l), 2769948622284605880l, 2769948622284605881l, "target")));
        if (beforeTask == null) {
          genContext.showErrorMessage(dep, "dependency on non-existing subtask");
          continue;
        }
        beforeTask.targets.add(st.getIndex());
      }
    }
    int[][] graph = new int[count][];
    for (SubTaskOrderHelper.SubTask st : subtasks) {
      graph[st.getIndex()] = st.getTargets();
    }
    int[][] partitions = GraphUtil.tarjan(graph);

    ListSequence.fromList(list).clear();
    for (int[] cycle : partitions) {
      if (cycle.length > 1) {
        StringBuilder sb = new StringBuilder();
        sb.append("subtasks cycle detected: ");
        for (int i = 0; i < 5 && i < cycle.length; i++) {
          if (i > 0) {
            sb.append(", ");
          }
          sb.append(SPropertyOperations.getString(subtasks[cycle[i]].getTask(), MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name")));
        }
        if (cycle.length > 5) {
          sb.append(" ...");
        }
        genContext.showErrorMessage(subtasks[cycle[0]].getTask(), sb.toString());
        continue;
      }
      ListSequence.fromList(list).addElement(subtasks[cycle[0]].getTask());
    }
  }
  private class SubTask {
    private final int index;
    private final SNode task;
    public final Set<Integer> targets = new HashSet<Integer>();
    public SubTask(SNode task, int index) {
      this.task = task;
      this.index = index;
    }
    public int[] getTargets() {
      targets.remove(index);
      int[] arr = new int[targets.size()];
      if (targets.isEmpty()) {
        return arr;
      }
      int i = 0;
      for (Integer val : targets) {
        arr[i++] = val;
      }
      assert i == targets.size();
      if (arr.length > 1) {
        Arrays.sort(arr);
      }
      return arr;
    }
    public SNode getTask() {
      return task;
    }
    public int getIndex() {
      return index;
    }
  }
}
