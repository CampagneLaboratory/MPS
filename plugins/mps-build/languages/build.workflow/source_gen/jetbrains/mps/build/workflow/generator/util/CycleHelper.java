package jetbrains.mps.build.workflow.generator.util;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.generator.template.TemplateQueryContext;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.build.workflow.util.XmlSignature;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.make.dependencies.graph.Graph;
import jetbrains.mps.make.dependencies.graph.Graphs;
import java.util.Collections;
import java.util.Comparator;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.make.dependencies.graph.IVertex;

public class CycleHelper {
  private final SNode project;
  private final Map<SNode, CycleHelper.Module> map = new HashMap<SNode, CycleHelper.Module>();
  private final TemplateQueryContext genContext;

  public CycleHelper(SNode project, TemplateQueryContext genContext) {
    this.project = project;
    this.genContext = genContext;
  }

  public void optimizeDependencies(SNode m) {
    final Set<String> seenDependencies = new HashSet<String>();
    ListSequence.fromList(SLinkOperations.getTargets(m, "dependencies", true)).removeWhere(new IWhereFilter<SNode>() {
      public boolean accept(SNode dep) {
        if (!(SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.workflow.structure.BwfJavaClassPath"))) {
          return false;
        }
        SNode cp = SLinkOperations.getTarget(SNodeOperations.cast(dep, "jetbrains.mps.build.workflow.structure.BwfJavaClassPath"), "classpath", true);
        XmlSignature s = new XmlSignature().add(cp);
        String id = (s.hasErrors() ?
          "dep." + cp.getSNodeId().toString() :
          s.getResult()
        );
        return !(seenDependencies.add(id));
      }
    });
  }

  public void processCycles() {
    List<SNode> modules = new ArrayList<SNode>();
    ListSequence.fromList(modules).addSequence(ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.workflow.structure.BwfJavaModule");
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.build.workflow.structure.BwfJavaModule");
      }
    }));
    for (SNode m : ListSequence.fromList(modules)) {
      optimizeDependencies(m);
    }
    for (SNode jm : modules) {
      CycleHelper.Module module = new CycleHelper.Module(jm);
      map.put(jm, module);
      if (isEmpty_yc0kju_a0c0d0f(SPropertyOperations.getString(jm, "outputFolder"))) {
        genContext.showErrorMessage(jm, "empty output path");
      } else if (SPropertyOperations.getString(jm, "outputFolder").endsWith("/") || SPropertyOperations.getString(jm, "outputFolder").endsWith("\\")) {
        genContext.showErrorMessage(jm, "output path shouldn't end with slash");
      }
    }
    Graph<CycleHelper.Module> graph = new Graph();
    for (CycleHelper.Module module : map.values()) {
      graph.add(module);
    }
    List<List<CycleHelper.Module>> cycles = Graphs.findStronglyConnectedComponents(graph);
    Collections.reverse(cycles);
    List<SNode> cyclesToName = new ArrayList<SNode>();
    for (List<CycleHelper.Module> cycle : cycles) {
      if (cycle.size() < 2) {
        continue;
      }
      final Set<SNode> cycleModules = new HashSet<SNode>();
      for (CycleHelper.Module m : cycle) {
        cycleModules.add(m.getModule());
      }

      Collections.sort(cycle, new Comparator<CycleHelper.Module>() {
        public int compare(CycleHelper.Module m1, CycleHelper.Module m2) {
          return new Integer(SNodeOperations.getIndexInParent(m1.getModule())).compareTo(SNodeOperations.getIndexInParent(m2.getModule()));
        }
      });
      SNode first = cycle.get(0).getModule();
      SModel model = SNodeOperations.getModel(first);
      SNode cycleX = SModelOperations.createNewNode(model, null, "jetbrains.mps.build.workflow.structure.BwfJavaModule");
      cyclesToName.add(cycleX);
      SNodeOperations.insertPrevSiblingChild(first, cycleX);
      SPropertyOperations.set(cycleX, "noWarnings", "" + (true));

      // build cycle sources & dependencies; trying to avoid duplication (which is not critical) 
      Set<String> seenSources = new HashSet<String>();
      List<SNode> sources = new ArrayList<SNode>();
      Set<String> seenDependencies = new HashSet<String>();
      List<SNode> deps = new ArrayList<SNode>();
      Set<SNode> seenModules = new LinkedHashSet<SNode>();
      Set<SNode> seenLibraries = new LinkedHashSet<SNode>();
      Set<SNode> taskDependency = new LinkedHashSet<SNode>();

      int heapSize = 0;
      for (CycleHelper.Module m : cycle) {
        SNode module = m.getModule();
        heapSize = Math.max(heapSize, SPropertyOperations.getInteger(module, "heapSize"));
        ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).removeWhere(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference") && cycleModules.contains(SLinkOperations.getTarget(SNodeOperations.cast(it, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference"), "target", false));
          }
        });
        for (SNode dep : SLinkOperations.getTargets(module, "dependencies", true)) {
          if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference")) {
            seenModules.add(SLinkOperations.getTarget(SNodeOperations.cast(dep, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference"), "target", false));
          } else if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.workflow.structure.BwfJavaLibraryReference")) {
            seenLibraries.add(SLinkOperations.getTarget(SNodeOperations.cast(dep, "jetbrains.mps.build.workflow.structure.BwfJavaLibraryReference"), "target", false));
          } else if (SNodeOperations.isInstanceOf(dep, "jetbrains.mps.build.workflow.structure.BwfJavaClassPath")) {
            SNode cp = SLinkOperations.getTarget(SNodeOperations.cast(dep, "jetbrains.mps.build.workflow.structure.BwfJavaClassPath"), "classpath", true);
            XmlSignature s = new XmlSignature().add(cp);
            String id = (s.hasErrors() ?
              "dep." + cp.getSNodeId().toString() :
              s.getResult()
            );
            if (seenDependencies.add(id)) {
              deps.add(cp);
            }
          } else {
            genContext.showErrorMessage(dep, "unexpected dependency type");
          }

        }

        for (SNode task : ListSequence.fromList(SLinkOperations.getTargets(module, "taskDeps", true)).select(new ISelector<SNode, SNode>() {
          public SNode select(SNode it) {
            return SLinkOperations.getTarget(it, "target", false);
          }
        })) {
          if ((task != null)) {
            taskDependency.add(task);
          }
        }

        SNode mref = SModelOperations.createNewNode(model, null, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference");
        SLinkOperations.setTarget(mref, "target", cycleX, false);
        ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).addElement(mref);

        for (SNode n : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(module, "sources", true), "elements", true))) {
          XmlSignature s = new XmlSignature().add(n);
          String id = (s.hasErrors() ?
            "path." + n.getSNodeId().toString() :
            s.getResult()
          );
          if (seenSources.add(id)) {
            sources.add(n);
          }
        }
      }
      SPropertyOperations.set(cycleX, "heapSize", "" + (heapSize));
      SLinkOperations.setNewChild(cycleX, "sources", "jetbrains.mps.build.workflow.structure.BwfFileSet");
      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(cycleX, "sources", true), "elements", true)).addSequence(Sequence.fromIterable(((Iterable<SNode>) sources)).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return CopyUtil.copy(it);
        }
      }));
      for (SNode dep : deps) {
        SNode cp = SModelOperations.createNewNode(model, null, "jetbrains.mps.build.workflow.structure.BwfJavaClassPath");
        SLinkOperations.setTarget(cp, "classpath", CopyUtil.copy(dep), true);
        ListSequence.fromList(SLinkOperations.getTargets(cycleX, "dependencies", true)).addElement(cp);
      }
      for (SNode jl : seenLibraries) {
        SNode mref = SModelOperations.createNewNode(model, null, "jetbrains.mps.build.workflow.structure.BwfJavaLibraryReference");
        SLinkOperations.setTarget(mref, "target", jl, false);
        ListSequence.fromList(SLinkOperations.getTargets(cycleX, "dependencies", true)).addElement(mref);
      }
      for (SNode jm : seenModules) {
        SNode mref = SModelOperations.createNewNode(model, null, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference");
        SLinkOperations.setTarget(mref, "target", jm, false);
        ListSequence.fromList(SLinkOperations.getTargets(cycleX, "dependencies", true)).addElement(mref);
      }
      for (SNode task : taskDependency) {
        SNode dependency = SModelOperations.createNewNode(model, null, "jetbrains.mps.build.workflow.structure.BwfTaskDependency");
        SLinkOperations.setTarget(dependency, "target", task, false);
        ListSequence.fromList(SLinkOperations.getTargets(cycleX, "taskDeps", true)).addElement(dependency);
      }
    }
    int cycleCounter = 0;
    Collections.sort(cyclesToName, new Comparator<SNode>() {
      public int compare(SNode n1, SNode n2) {
        return new Integer(SNodeOperations.getIndexInParent(n1)).compareTo(SNodeOperations.getIndexInParent(n2));
      }
    });
    for (SNode cycleX : cyclesToName) {
      SPropertyOperations.set(cycleX, "name", "java.modules.cycle." + ++cycleCounter);
      SPropertyOperations.set(cycleX, "outputFolder", SPropertyOperations.getString(project, "temporaryFolder") + "/" + SPropertyOperations.getString(cycleX, "name"));
    }
  }

  public class Module implements IVertex {
    private final SNode module;
    private Set<CycleHelper.Module> targets;

    public Module(SNode module) {
      this.module = module;
    }

    public Set<? extends IVertex> getNexts() {
      if (targets == null) {
        if (ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).isEmpty()) {
          targets = Collections.emptySet();
        } else {
          targets = new HashSet<CycleHelper.Module>();
          for (SNode ref : ListSequence.fromList(SLinkOperations.getTargets(module, "dependencies", true)).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference");
            }
          })) {
            CycleHelper.Module tm = map.get(SLinkOperations.getTarget(SNodeOperations.cast(ref, "jetbrains.mps.build.workflow.structure.BwfJavaModuleReference"), "target", false));
            if (tm == null) {
              genContext.showErrorMessage(ref, "internal problem: unsatisfied local dependency");
            } else {
              targets.add(tm);
            }
          }
        }
      }
      return targets;
    }

    public SNode getModule() {
      return module;
    }
  }

  public static boolean isEmpty_yc0kju_a0c0d0f(String str) {
    return str == null || str.length() == 0;
  }
}
