package jetbrains.mps.build.workflow.constraints;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.generator.template.TemplateQueryContext;
import java.util.Set;
import java.util.LinkedHashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.UUID;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.CopyUtil;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class TaskLibrariesHelper {
  private SNode project;
  private TemplateQueryContext genContext;
  public TaskLibrariesHelper(SNode project, TemplateQueryContext genContext) {
    this.project = project;
    this.genContext = genContext;
  }
  public void importLibs() {
    Set<SNode> libsSet = new LinkedHashSet<SNode>();
    for (SNode tldep : SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(new UUID(7605046100638320544l, -5004325039833383149l), 2769948622284546673l, 7306485738221455031l, "imports"))) {
      libsSet.add(SLinkOperations.getTarget(tldep, MetaAdapterFactory.getReferenceLink(new UUID(7605046100638320544l, -5004325039833383149l), 7306485738221471031l, 7306485738221471032l, "target")));
    }
    closure(libsSet);
    List<SNode> libs = new ArrayList<SNode>(libsSet);
    for (SNode lib : libs) {
      for (SNode n : SNodeUtil.getDescendants(lib)) {
        for (SReference ref : SNodeOperations.getReferences(n)) {
          SNode targetNode = SNodeOperations.getTargetNodeSilently(ref);
          if (targetNode == null) {
            genContext.showErrorMessage(n, "cannot import library `" + SPropertyOperations.getString(lib, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name")) + "': unresolved reference");
          } else if (!(libsSet.contains(targetNode.getContainingRoot()))) {
            genContext.showErrorMessage(n, "cannot import library `" + SPropertyOperations.getString(lib, MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l, -7236703803128771572l), 1169194658468l, 1169194664001l, "name")) + "': broken reference, target is not imported");
          }
        }
      }
    }
    List<SNode> parts = ListSequence.fromList(libs).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(new UUID(7605046100638320544l, -5004325039833383149l), 7306485738221391506l, 7306485738221391508l, "parts"));
      }
    }).toListSequence();
    Map<SNode, SNode> map = new HashMap<SNode, SNode>();
    parts = (List<SNode>) CopyUtil.copy((List<SNode>) parts, map);
    ListSequence.fromList(SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(new UUID(7605046100638320544l, -5004325039833383149l), 2769948622284546673l, 7306485738221455031l, "imports"))).clear();
    for (SNode n : SNodeUtil.getDescendants(project)) {
      for (SReference ref : n.getReferences()) {
        SNode targetNode = SNodeOperations.getTargetNodeSilently(ref);
        if (map.containsKey(targetNode)) {
          SNodeAccessUtil.setReferenceTarget(n, ref.getRole(), map.get(targetNode));
        } else {
          SNode containingRoot = targetNode.getContainingRoot();
          if (jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.isInstanceOf(containingRoot, "jetbrains.mps.build.workflow.structure.BwfTaskLibrary")) {
            genContext.showErrorMessage(n, "task library is not imported");
          }
        }
      }
    }
    // we add everything in the beginning 
    for (int i = parts.size() - 1; i >= 0; i--) {
      ListSequence.fromList(SLinkOperations.getChildren(project, MetaAdapterFactory.getContainmentLink(new UUID(7605046100638320544l, -5004325039833383149l), 2769948622284546673l, 2769948622284574304l, "parts"))).insertElement(0, parts.get(i));
    }
  }
  public static void closure(Set<SNode> libs) {
    Queue<SNode> queue = QueueSequence.fromQueue(new LinkedList<SNode>());
    QueueSequence.fromQueue(queue).addSequence(SetSequence.fromSet(libs));
    while (!(QueueSequence.fromQueue(queue).isEmpty())) {
      SNode lib = QueueSequence.fromQueue(queue).removeFirstElement();
      for (SNode dep : SLinkOperations.getChildren(lib, MetaAdapterFactory.getContainmentLink(new UUID(7605046100638320544l, -5004325039833383149l), 7306485738221391506l, 7306485738221455030l, "imports"))) {
        if (!(libs.contains(SLinkOperations.getTarget(dep, MetaAdapterFactory.getReferenceLink(new UUID(7605046100638320544l, -5004325039833383149l), 7306485738221471031l, 7306485738221471032l, "target"))))) {
          libs.add(SLinkOperations.getTarget(dep, MetaAdapterFactory.getReferenceLink(new UUID(7605046100638320544l, -5004325039833383149l), 7306485738221471031l, 7306485738221471032l, "target")));
          QueueSequence.fromQueue(queue).addLastElement(SLinkOperations.getTarget(dep, MetaAdapterFactory.getReferenceLink(new UUID(7605046100638320544l, -5004325039833383149l), 7306485738221471031l, 7306485738221471032l, "target")));
        }
      }
    }
  }
}
