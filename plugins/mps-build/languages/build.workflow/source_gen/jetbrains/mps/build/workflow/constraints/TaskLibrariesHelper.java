package jetbrains.mps.build.workflow.constraints;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.generator.template.TemplateQueryContext;
import java.util.Set;
import java.util.LinkedHashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.CopyUtil;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;

public class TaskLibrariesHelper {
  private SNode project;
  private TemplateQueryContext genContext;

  public TaskLibrariesHelper(SNode project, TemplateQueryContext genContext) {
    this.project = project;
    this.genContext = genContext;
  }

  public void importLibs() {
    Set<SNode> libsSet = new LinkedHashSet<SNode>();
    for (SNode tldep : SLinkOperations.getTargets(project, "imports", true)) {
      libsSet.add(SLinkOperations.getTarget(tldep, "target", false));
    }
    closure(libsSet);
    List<SNode> libs = new ArrayList<SNode>(libsSet);
    for (SNode lib : libs) {
      for (SNode n : SNodeOperations.getDescendants(lib, null, true)) {
        for (SReference ref : SNodeOperations.getReferences(n)) {
          SNode targetNode = ref.getTargetNodeSilently();
          if (targetNode == null) {
            genContext.showErrorMessage(n, "cannot import library `" + SPropertyOperations.getString(lib, "name") + "': unresolved reference");
          } else if (!(libsSet.contains(targetNode.getTopmostAncestor()))) {
            genContext.showErrorMessage(n, "cannot import library `" + SPropertyOperations.getString(lib, "name") + "': broken reference, target is not imported");
          }
        }
      }
    }
    List<SNode> parts = ListSequence.fromList(libs).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return SLinkOperations.getTargets(it, "parts", true);
      }
    }).toListSequence();
    Map<SNode, SNode> map = new HashMap<SNode, SNode>();
    parts = (List<SNode>) CopyUtil.copy((List<SNode>) parts, map);
    ListSequence.fromList(SLinkOperations.getTargets(project, "imports", true)).clear();
    for (SNode n : SNodeOperations.getDescendants(project, null, true)) {
      for (SReference ref : n.getReferences()) {
        SNode targetNode = ref.getTargetNodeSilently();
        if (map.containsKey(targetNode)) {
          SNodeAccessUtil.setReferenceTarget(n, ref.getRole(), map.get(targetNode));
        } else {
          SNode containingRoot = targetNode.getTopmostAncestor();
          if (jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.isInstanceOf(containingRoot, "jetbrains.mps.build.workflow.structure.BwfTaskLibrary")) {
            genContext.showErrorMessage(n, "task library is not imported");
          }
        }
      }
    }
    // we add everything in the beginning 
    for (int i = parts.size() - 1; i >= 0; i--) {
      ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true)).insertElement(0, parts.get(i));
    }

    // cleanup => remove empty taskss 
    Set<SNode> emptyTasks = new HashSet<SNode>(ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.workflow.structure.BwfTask") && ListSequence.fromList(SLinkOperations.getTargets(jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.cast(it, "jetbrains.mps.build.workflow.structure.BwfTask"), "dependencies", true)).isEmpty() && ListSequence.fromList(SLinkOperations.getTargets(jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.cast(it, "jetbrains.mps.build.workflow.structure.BwfTask"), "subTasks", true)).isEmpty();
      }
    }).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.cast(it, "jetbrains.mps.build.workflow.structure.BwfTask");
      }
    }).toListSequence());
    if (!(emptyTasks.isEmpty())) {
      for (SNode n : SNodeOperations.getDescendants(project, null, true)) {
        for (SReference ref : n.getReferences()) {
          SNode targetNode = ref.getTargetNodeSilently();
          emptyTasks.remove(targetNode);
        }
        if (emptyTasks.isEmpty()) {
          break;
        }
      }
    }
    ListSequence.fromList(SLinkOperations.getTargets(project, "parts", true)).removeSequence(SetSequence.fromSet(emptyTasks));
  }

  public static void closure(Set<SNode> libs) {
    Queue<SNode> queue = QueueSequence.fromQueue(new LinkedList<SNode>());
    QueueSequence.fromQueue(queue).addSequence(SetSequence.fromSet(libs));
    while (!(QueueSequence.fromQueue(queue).isEmpty())) {
      SNode lib = QueueSequence.fromQueue(queue).removeFirstElement();
      for (SNode dep : SLinkOperations.getTargets(lib, "imports", true)) {
        if (!(libs.contains(SLinkOperations.getTarget(dep, "target", false)))) {
          libs.add(SLinkOperations.getTarget(dep, "target", false));
          QueueSequence.fromQueue(queue).addLastElement(SLinkOperations.getTarget(dep, "target", false));
        }
      }
    }
  }
}
