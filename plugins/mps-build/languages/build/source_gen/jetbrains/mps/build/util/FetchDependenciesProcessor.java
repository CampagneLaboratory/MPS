package jetbrains.mps.build.util;

/*Generated by MPS */

import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SNodeId;

public class FetchDependenciesProcessor {
  private TemplateQueryContext genContext;
  private SNode project;

  public FetchDependenciesProcessor(SNode project, TemplateQueryContext genContext) {
    this.genContext = genContext;
    this.project = project;
  }

  public void process() {
    VisibleArtifacts artifacts = new VisibleArtifacts(project, genContext);
    artifacts.collect();
    UnpackHelper helper = new UnpackHelper(artifacts, genContext);
    for (SNode dep : SNodeOperations.getDescendants(project, "jetbrains.mps.build.structure.BuildExternalDependency", false, new String[]{})) {
      BehaviorReflection.invokeVirtual(Void.class, dep, "virtual_fetchDependencies_5908258303322131137", new Object[]{artifacts, new FetchDependenciesProcessor.RequiredDependenciesBuilderImpl(artifacts, dep, helper)});
    }
    helper.eval();

    List<SNode> statements = helper.getStatements();
    if (!(ListSequence.fromList(statements).isEmpty())) {
      SNode wf = SModelOperations.createNewNode(SNodeOperations.getModel(project), null, "jetbrains.mps.build.structure.BuildCustomWorkflow");
      SNode taskpart = SModelOperations.createNewNode(SNodeOperations.getModel(project), null, "jetbrains.mps.build.workflow.structure.BwfTaskPart");
      SLinkOperations.setTarget(taskpart, "task", SLinkOperations.getTarget(_quotation_createNode_t02zqv_a0a2a7a0(), "target", false), false);
      ListSequence.fromList(SLinkOperations.getTargets(wf, "parts", true)).addElement(taskpart);
      SNode stask = SModelOperations.createNewNode(SNodeOperations.getModel(project), null, "jetbrains.mps.build.workflow.structure.BwfSubTask");
      SPropertyOperations.set(stask, "name", "fetch");
      ListSequence.fromList(SLinkOperations.getTargets(taskpart, "subTasks", true)).addElement(stask);
      ListSequence.fromList(SLinkOperations.getTargets(stask, "statements", true)).addSequence(ListSequence.fromList(statements));
      ListSequence.fromList(SLinkOperations.getTargets(project, "aspects", true)).addElement(wf);
    }
  }

  private static SNode _quotation_createNode_t02zqv_a0a2a7a0() {
    SNode quotedNode_1 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration("jetbrains.mps.build.workflow.structure.BwfTaskDependency", null, null, GlobalScope.getInstance(), false);
    quotedNode_1.setReference("target", SReference.create("target", quotedNode_1, SModelReference.fromString("r:14f06230-41df-42af-9a25-81de46539bf1(jetbrains.mps.build.workflow.accessories)"), SNodeId.fromString("7128123785277844790")));
    return quotedNode_1;
  }

  private class RequiredDependenciesBuilderImpl implements RequiredDependenciesBuilder {
    private final VisibleArtifacts artifacts;
    private final SNode dep;
    private final UnpackHelper helper;

    public RequiredDependenciesBuilderImpl(VisibleArtifacts artifacts, SNode dep, UnpackHelper helper) {
      this.artifacts = artifacts;
      this.dep = dep;
      this.helper = helper;
    }

    @Override
    public void add(SNode node) {
      if (!(check(node))) {
        return;
      }
      helper.add(node, false, null);
    }

    @Override
    public void add(SNode node, Object artifactId) {
      if (!(check(node)) || !(checkArtifactId(artifactId))) {
        return;
      }
      helper.add(node, false, artifactId);
    }

    @Override
    public void addWithContent(SNode node) {
      if (!(check(node))) {
        return;
      }
      helper.add(node, true, null);
    }

    private boolean check(SNode node) {
      if (SNodeOperations.getModel(node).isTransient()) {
        genContext.showErrorMessage(dep, "returned dependency in transient model: " + jetbrains.mps.util.SNodeOperations.getDebugText(node));
        return false;
      }
      if (!(artifacts.contains(node))) {
        genContext.showErrorMessage(dep, "returned node which is not available in dependencies: " + jetbrains.mps.util.SNodeOperations.getDebugText(node));
        return false;
      }
      return true;
    }

    private boolean checkArtifactId(Object artifactId) {
      if (artifactId instanceof SNode && ((SNode) artifactId).getModel().isTransient()) {
        genContext.showErrorMessage(dep, "cannot register artifact in transient model " + jetbrains.mps.util.SNodeOperations.getDebugText(((SNode) artifactId)));
        return false;
      }
      return true;
    }
  }
}
