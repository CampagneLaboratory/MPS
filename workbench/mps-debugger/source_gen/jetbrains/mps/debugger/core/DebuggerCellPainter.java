package jetbrains.mps.debugger.core;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.AbstractAdditionalPainter;
import org.jetbrains.annotations.Nullable;
import java.awt.Color;
import org.jetbrains.mps.openapi.model.SNode;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import jetbrains.mps.openapi.editor.cells.CellFinderUtil;
import jetbrains.mps.nodeEditor.cells.GeometryUtil;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import jetbrains.mps.util.Condition;

public abstract class DebuggerCellPainter<E> extends AbstractAdditionalPainter<E> {
  private static final int LEFT_MARGIN = 4;

  public DebuggerCellPainter() {
  }

  @Nullable
  protected abstract Color getCellBackgroundColor();

  @Nullable
  protected abstract Color getStripeBackgroundColor();

  @Nullable
  protected abstract Color getFrameColor();

  @Nullable
  protected abstract SNode getSNode();

  @Override
  public boolean paintsAbove() {
    return true;
  }

  @Override
  public void paint(Graphics graphics, EditorComponent editorComponent) {
    EditorCell nodeCell = getNodeCell(editorComponent);
    if (nodeCell == null) {
      return;
    }

    Color frameColor = getFrameColor();
    if (frameColor == null) {
      return;
    }

    graphics.setColor(frameColor);
    graphics.drawRect(nodeCell.getX(), nodeCell.getY(), nodeCell.getWidth() - 1, nodeCell.getHeight() - 1);
  }

  @Override
  public boolean paintsBackground() {
    return true;
  }

  @Override
  public void paintBackground(Graphics graphics, EditorComponent component) {
    paintStripeBackground(graphics, component);
    paintCellBackground(graphics, component);
  }

  private void paintCellBackground(Graphics graphics, EditorComponent editorComponent) {
    if (isInCellMode(editorComponent)) {
      Color cellBackgroundColor = getCellBackgroundColor();
      if (cellBackgroundColor == null) {
        return;
      }

      graphics.setColor(cellBackgroundColor);
      Rectangle cellCoverage = getCellCoverage(editorComponent);
      if (cellCoverage == null) {
        return;
      }

      graphics.fillRect(cellCoverage.x, cellCoverage.y, cellCoverage.width, cellCoverage.height);
    }
  }

  private void paintStripeBackground(Graphics graphics, EditorComponent editorComponent) {
    if (isInCellMode(editorComponent)) {
      return;
    }

    Color stripeBackgroundColor = getStripeBackgroundColor();
    if (stripeBackgroundColor == null) {
      return;
    }

    graphics.setColor(stripeBackgroundColor);
    Rectangle stripeCoverage = getStripeCoverage(editorComponent);
    if (stripeCoverage == null) {
      return;
    }

    graphics.fillRect(stripeCoverage.x, stripeCoverage.y, stripeCoverage.width, stripeCoverage.height);
  }

  @Nullable
  private EditorCell getNodeCell(EditorComponent editorComponent) {
    SNode node = getSNode();
    if (node != null) {
      return editorComponent.getBigValidCellForNode(node);
    }
    return null;
  }

  @Nullable
  private EditorCell_Label getStripeCell(EditorComponent editorComponent) {
    EditorCell nodeCell = getNodeCell(editorComponent);
    if (nodeCell == null) {
      return null;
    }
    if (nodeCell instanceof EditorCell_Label) {
      return (EditorCell_Label) nodeCell;
    }
    return CellFinderUtil.findChildByClass(nodeCell, EditorCell_Label.class, true);
  }

  @Nullable
  protected Rectangle calculateCoverageArea(EditorComponent editorComponent) {
    if (isInCellMode(editorComponent)) {
      return getCellCoverage(editorComponent);
    }
    return getStripeCoverage(editorComponent);
  }

  @Nullable
  private Rectangle getCellCoverage(EditorComponent editorComponent) {
    EditorCell nodeCell = getNodeCell(editorComponent);
    if (nodeCell == null) {
      return null;
    }
    return GeometryUtil.getBounds(nodeCell);
  }

  @Nullable
  private Rectangle getStripeCoverage(EditorComponent editorComponent) {
    EditorCell_Label stripeCell = getStripeCell(editorComponent);
    if (stripeCell == null) {
      return null;
    }
    return new Rectangle(LEFT_MARGIN, stripeCell.getY(), editorComponent.getWidth() - LEFT_MARGIN, stripeCell.getHeight() - stripeCell.getTopInset() - stripeCell.getBottomInset());
  }

  private boolean isInCellMode(EditorComponent editorComponent) {
    EditorCell nodeCell = getNodeCell(editorComponent);
    if (nodeCell == null) {
      // whatever 
      return false;
    }
    EditorCell_Collection parent = nodeCell.getParent();
    if (parent == null) {
      return false;
    }
    if (parent.getCellLayout() instanceof CellLayout_Horizontal) {
      // if immediate parent is a horisontal collection 
      return true;
    }
    return CellFinderUtil.findParent(nodeCell, new Condition<EditorCell_Collection>() {
      @Override
      public boolean met(EditorCell_Collection cellCollection) {
        // do not want an explicit dependency on table.runtime 
        return eq_mgy25g_a0b0a0a1a0f0r(cellCollection.getClass().getSimpleName(), "EditorCell_Table");
      }
    }) != null;
  }

  private static boolean eq_mgy25g_a0b0a0a1a0f0r(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }
}
