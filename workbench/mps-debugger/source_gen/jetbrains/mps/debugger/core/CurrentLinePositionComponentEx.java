package jetbrains.mps.debugger.core;

/*Generated by MPS */

import com.intellij.openapi.fileEditor.FileEditorManager;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.openapi.project.Project;
import jetbrains.mps.nodeEditor.highlighter.EditorComponentCreateListener;
import com.intellij.util.messages.MessageBusConnection;
import org.jetbrains.mps.openapi.module.SRepositoryListener;
import jetbrains.mps.smodel.MPSModuleRepository;
import java.util.Collection;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.EditorComponent;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.editor.util.EditorComponentUtil;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.util.Computable;
import jetbrains.mps.ide.editor.MPSEditorOpener;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.nodeEditor.AdditionalPainter;
import org.jetbrains.mps.openapi.module.SRepositoryAdapter;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;

public abstract class CurrentLinePositionComponentEx<S> {
  private FileEditorManager myFileEditorManager;
  private final Map<S, CurrentLinePainter> mySessionToContextPainterMap = MapSequence.fromMap(new HashMap<S, CurrentLinePainter>());
  protected final Project myProject;
  private final EditorComponentCreateListener myEditorComponentCreationHandler = new CurrentLinePositionComponentEx.MyEditorComponentCreateListener();
  private MessageBusConnection myMessageBusConnection;
  private final SRepositoryListener myRepositoryListener = new CurrentLinePositionComponentEx.MyRepositoryListener();

  public CurrentLinePositionComponentEx(Project project, FileEditorManager fileEditorManager) {
    myProject = project;
    myFileEditorManager = fileEditorManager;
  }

  protected void init() {
    myMessageBusConnection = myProject.getMessageBus().connect();
    myMessageBusConnection.subscribe(EditorComponentCreateListener.EDITOR_COMPONENT_CREATION, myEditorComponentCreationHandler);
    MPSModuleRepository.getInstance().addRepositoryListener(myRepositoryListener);
  }

  protected void dispose() {
    MPSModuleRepository.getInstance().removeRepositoryListener(myRepositoryListener);
    myMessageBusConnection.disconnect();
  }

  protected abstract S getCurrentSession();

  protected abstract Collection<? extends S> getAllSessions();

  private List<CurrentLinePainter> getAllPainters() {
    synchronized (mySessionToContextPainterMap) {
      List<CurrentLinePainter> painters = ListSequence.fromList(new ArrayList<CurrentLinePainter>());
      ListSequence.fromList(painters).addSequence(Sequence.fromIterable(MapSequence.fromMap(mySessionToContextPainterMap).values()));
      return painters;
    }
  }

  protected void attach(@NotNull final CurrentLinePainter painter, @NotNull final EditorComponent editorComponent) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    ModelAccess.instance().runReadAction(new Runnable() {
      @Override
      public void run() {
        SNode node = painter.getSNode();
        if (node != null && EditorComponentUtil.isNodeShownInTheComponent(editorComponent, node)) {
          editorComponent.addAdditionalPainter(painter);
          editorComponent.repaint();
        }
      }
    });
  }

  protected void detach(@NotNull final CurrentLinePainter painter, @NotNull final EditorComponent editorComponent) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    ModelAccess.instance().runReadAction(new Runnable() {
      @Override
      public void run() {
        SNode node = painter.getSNode();
        if (node == null || EditorComponentUtil.isNodeShownInTheComponent(editorComponent, node)) {
          editorComponent.removeAdditionalPainter(painter);
          editorComponent.repaint();
        }
      }
    });
  }

  @Nullable
  protected Runnable attachPainterRunnable(final S debugSession, final boolean focus) {
    final CurrentLinePainter newPainter = ModelAccess.instance().runReadAction(new Computable<CurrentLinePainter>() {
      @Override
      public CurrentLinePainter compute() {
        SNode node = getNode(debugSession);
        if (node != null) {
          return new CurrentLinePainter(node);
        }
        return null;
      }
    });
    if (newPainter != null) {
      final boolean visible = getCurrentSession() == null || getCurrentSession() == debugSession;
      newPainter.setVisible(visible);
      //  we lock here, since we do not want to acquire read lock inside while having mySessionToContextPainterMap  
      synchronized (mySessionToContextPainterMap) {
        MapSequence.fromMap(mySessionToContextPainterMap).put(debugSession, newPainter);
        return new Runnable() {
          @Override
          public void run() {
            ModelAccess.assertLegalWrite();
            SNode node = newPainter.getSNode();
            if (node != null) {
              if (visible && focus) {
                EditorComponent currentEditorComponent = (EditorComponent) new MPSEditorOpener(myProject).openNode(node, new ProjectOperationContext(ProjectHelper.toMPSProject(myProject)), true, false, true).getCurrentEditorComponent();
                currentEditorComponent = EditorComponentUtil.scrollToNode(node, currentEditorComponent, myFileEditorManager);
                if (currentEditorComponent != null) {
                  attach(newPainter, currentEditorComponent);
                }
              }

              List<EditorComponent> components = EditorComponentUtil.findComponentForNode(node, myFileEditorManager);
              for (EditorComponent component : ListSequence.fromList(components)) {
                attach(newPainter, component);
              }
            }
          }
        };
      }
    }
    return null;
  }

  protected abstract SNode getNode(S session);

  @Nullable
  protected Runnable detachPainterRunnable(S session) {
    final CurrentLinePainter painter;
    synchronized (mySessionToContextPainterMap) {
      painter = MapSequence.fromMap(mySessionToContextPainterMap).get(session);
      MapSequence.fromMap(mySessionToContextPainterMap).removeKey(session);
    }
    if (painter != null) {
      return new Runnable() {
        @Override
        public void run() {
          for (EditorComponent editor : EditorComponentUtil.getAllEditorComponents(myFileEditorManager, true)) {
            detach(painter, editor);
          }
        }
      };
    }
    return null;
  }

  protected void detachPainter(S session) {
    Runnable detachPainterRunnable = detachPainterRunnable(session);
    if (detachPainterRunnable == null) {
      return;
    }
    ApplicationManager.getApplication().invokeLater(detachPainterRunnable);
  }

  protected void reAttachPainter(S session, boolean focus) {
    final Runnable detachSession = detachPainterRunnable(session);
    final Runnable attachSession = attachPainterRunnable(session, focus);
    if (detachSession != null || attachSession != null) {
      ModelAccess.instance().runWriteInEDT(new Runnable() {
        @Override
        public void run() {
          if (detachSession != null) {
            detachSession.run();
          }
          if (attachSession != null) {
            attachSession.run();
          }
        }
      });
    }
  }

  protected void currentSessionChanged(S newSession) {
    synchronized (mySessionToContextPainterMap) {
      for (S session : SetSequence.fromSet(MapSequence.fromMap(mySessionToContextPainterMap).keySet())) {
        CurrentLinePainter painter = MapSequence.fromMap(mySessionToContextPainterMap).get(session);
        if (painter != null) {
          painter.setVisible(newSession != null && newSession == session);
        }
      }
    }
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      @Override
      public void run() {
        for (EditorComponent editorComponent : EditorComponentUtil.getAllEditorComponents(myFileEditorManager, true)) {
          editorComponent.repaint();
        }
      }
    });
  }

  private class MyEditorComponentCreateListener implements EditorComponentCreateListener {
    private MyEditorComponentCreateListener() {
    }

    @Override
    public void editorComponentCreated(@NotNull EditorComponent editorComponent) {
      for (CurrentLinePainter p : ListSequence.fromList(getAllPainters())) {
        attach(p, editorComponent);
      }
    }

    @Override
    public void editorComponentDisposed(@NotNull EditorComponent editorComponent) {
      List<AdditionalPainter> additionalPainters = editorComponent.getAdditionalPainters();
      for (AdditionalPainter painter : ListSequence.fromList(additionalPainters)) {
        if (painter instanceof CurrentLinePainter) {
          editorComponent.removeAdditionalPainter(painter);
        }
      }
    }
  }

  private class MyRepositoryListener extends SRepositoryAdapter {
    @Override
    public void commandFinished(SRepository repository) {
      for (S session : CollectionSequence.fromCollection(getAllSessions())) {
        reAttachPainter(session, false);
      }
    }
  }
}
