package jetbrains.mps.debugger.core;

/*Generated by MPS */

import com.intellij.openapi.fileEditor.FileEditorManager;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.openapi.project.Project;
import jetbrains.mps.nodeEditor.highlighter.EditorComponentCreateListener;
import com.intellij.util.messages.MessageBusConnection;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.EditorComponent;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.ide.editor.util.EditorComponentUtil;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.editor.MPSEditorOpener;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public abstract class CurrentLinePositionComponentEx<S> {
  private FileEditorManager myFileEditorManager;
  private final Map<S, CurrentLinePainter> mySessionToContextPainterMap = MapSequence.fromMap(new HashMap<S, CurrentLinePainter>());
  protected final Project myProject;
  private final EditorComponentCreateListener myEditorComponentCreationHandler = new CurrentLinePositionComponentEx.MyEditorComponentCreateListener();
  private MessageBusConnection myMessageBusConnection;

  public CurrentLinePositionComponentEx(Project project, FileEditorManager fileEditorManager) {
    myProject = project;
    myFileEditorManager = fileEditorManager;
  }

  protected void init() {
    myMessageBusConnection = myProject.getMessageBus().connect();
    myMessageBusConnection.subscribe(EditorComponentCreateListener.EDITOR_COMPONENT_CREATION, myEditorComponentCreationHandler);
  }

  protected void dispose() {
    myMessageBusConnection.disconnect();
  }

  protected abstract S getCurrentSession();

  private List<CurrentLinePainter> getAllPainters() {
    synchronized (mySessionToContextPainterMap) {
      List<CurrentLinePainter> painters = ListSequence.fromList(new ArrayList<CurrentLinePainter>());
      ListSequence.fromList(painters).addSequence(Sequence.fromIterable(MapSequence.fromMap(mySessionToContextPainterMap).values()));
      return painters;
    }
  }

  protected void attach(@NotNull final CurrentLinePainter painter, @NotNull final EditorComponent editorComponent) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    ModelAccess.instance().runReadAction(new Runnable() {
      @Override
      public void run() {
        if (EditorComponentUtil.isNodeShownInTheComponent(editorComponent, painter.getItem())) {
          if (!(editorComponent.getAdditionalPainters().contains(painter))) {
            editorComponent.addAdditionalPainter(painter);
          }
          editorComponent.repaint();
        }
      }
    });
  }

  protected void detach(@NotNull final CurrentLinePainter painter, @NotNull final EditorComponent editorComponent) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    ModelAccess.instance().runReadAction(new Runnable() {
      @Override
      public void run() {
        if (EditorComponentUtil.isNodeShownInTheComponent(editorComponent, painter.getItem())) {
          editorComponent.removeAdditionalPainter(painter);
          editorComponent.repaint();
        }
      }
    });
  }

  @Nullable
  protected Runnable attachPainterRunnable(S debugSession) {
    SNode node = getNode(debugSession);
    if (node != null) {
      final CurrentLinePainter newPainter = new CurrentLinePainter(node);
      boolean visible = getCurrentSession() == null || getCurrentSession() == debugSession;
      newPainter.setVisible(visible);
      //  we lock here, since we do not want to acquire read lock inside while having mySessionToContextPainterMap  
      synchronized (mySessionToContextPainterMap) {
        MapSequence.fromMap(mySessionToContextPainterMap).put(debugSession, newPainter);
        return new Runnable() {
          @Override
          public void run() {
            attachPainterAndOpenEditor(newPainter);
          }
        };
      }
    }
    return null;
  }

  private void attachPainterAndOpenEditor(@NotNull final CurrentLinePainter painter) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        EditorComponent currentEditorComponent = (EditorComponent) new MPSEditorOpener(myProject).openNode(painter.getItem(), new ProjectOperationContext(ProjectHelper.toMPSProject(myProject)), true, false).getCurrentEditorComponent();
        currentEditorComponent = EditorComponentUtil.scrollToNode(painter.getItem(), currentEditorComponent, myFileEditorManager);
        if (currentEditorComponent != null) {
          attach(painter, currentEditorComponent);
        }
      }
    });
  }

  protected abstract SNode getNode(S session);

  @Nullable
  protected Runnable detachPainterRunnable(S session) {
    final CurrentLinePainter painter;
    synchronized (mySessionToContextPainterMap) {
      painter = MapSequence.fromMap(mySessionToContextPainterMap).get(session);
      MapSequence.fromMap(mySessionToContextPainterMap).removeKey(session);
    }
    if (painter != null) {
      return new Runnable() {
        @Override
        public void run() {
          detachPainter(painter);
        }
      };
    }
    return null;
  }

  private void detachPainter(@NotNull CurrentLinePainter painter) {
    for (EditorComponent editor : EditorComponentUtil.getAllEditorComponents(myFileEditorManager, true)) {
      detach(painter, editor);
    }
  }

  protected void detachPainter(S session) {
    Runnable detachPainterRunnable = detachPainterRunnable(session);
    if (detachPainterRunnable == null) {
      return;
    }
    ApplicationManager.getApplication().invokeLater(detachPainterRunnable);
  }

  protected void reAttachPainter(S session) {
    final Runnable detachSession = detachPainterRunnable(session);
    final Runnable attachSession = attachPainterRunnable(session);
    if (detachSession != null || attachSession != null) {
      ApplicationManager.getApplication().invokeLater(new Runnable() {
        public void run() {
          if (detachSession != null) {
            detachSession.run();
          }
          if (attachSession != null) {
            attachSession.run();
          }
        }
      });
    }
  }

  protected void currentSessionChanged(S newSession) {
    synchronized (mySessionToContextPainterMap) {
      for (S session : SetSequence.fromSet(MapSequence.fromMap(mySessionToContextPainterMap).keySet())) {
        CurrentLinePainter painter = MapSequence.fromMap(mySessionToContextPainterMap).get(session);
        if (painter != null) {
          painter.setVisible(newSession != null && newSession == session);
        }
      }
    }
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      @Override
      public void run() {
        for (EditorComponent editorComponent : EditorComponentUtil.getAllEditorComponents(myFileEditorManager, true)) {
          editorComponent.repaint();
        }
      }
    });
  }

  private class MyEditorComponentCreateListener implements EditorComponentCreateListener {
    private MyEditorComponentCreateListener() {
    }

    @Override
    public void editorComponentCreated(@NotNull EditorComponent editorComponent) {
      for (CurrentLinePainter p : ListSequence.fromList(getAllPainters())) {
        attach(p, editorComponent);
      }
    }

    @Override
    public void editorComponentDisposed(@NotNull EditorComponent editorComponent) {
      for (CurrentLinePainter p : ListSequence.fromList(getAllPainters())) {
        detach(p, editorComponent);
      }
    }
  }
}
