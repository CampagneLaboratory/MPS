package jetbrains.mps.ide.datatransfer;

/*Generated by MPS */

import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.DataFlavor;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.module.SModuleReference;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SModelReference;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import java.util.Map;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import java.io.StringReader;
import jetbrains.mps.datatransfer.PasteNodeData;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.MPSModuleRepository;

public class SNodeTransferable implements Transferable {
  private static final int NODE = 0;
  private static final int NODE_REFERENCE = 1;
  private static final int STRING = 2;
  private static final int PLAIN_TEXT = 3;

  private static final DataFlavor[] flavors = {SModelDataFlavor.sNode, SModelDataFlavor.sNodeReference, DataFlavor.stringFlavor, DataFlavor.plainTextFlavor};

  private List<SNode> mySNodes = new ArrayList<SNode>();
  @Nullable
  private SNodeReference mySNodeReference;
  @Nullable
  private SModuleReference mySourceModule;
  private Set<SModelReference> myNecessaryModels = new HashSet<SModelReference>();
  private Set<SModuleReference> myNecessaryLanguages = new HashSet<SModuleReference>();
  private String myText = "";

  public SNodeTransferable(List<SNode> nodes, String text) {
    if (nodes.size() == 1) {
      saveNodeReference(nodes.get(0));
    }
    saveNodes(nodes, null);
    myText = text;
  }

  public SNodeTransferable(List<SNode> nodes) {
    if (nodes.size() == 1) {
      saveNodeReference(nodes.get(0));
    }
    saveNodes(nodes, null);
  }

  public SNodeTransferable(@NotNull List<SNode> nodes, String text, Map<SNode, Set<SNode>> nodesAndAttributes) {
    if (nodes.size() == 1) {
      saveNodeReference(nodes.get(0));
    }
    saveNodes(nodes, nodesAndAttributes);
    myText = text;
  }

  public SNodeTransferable(SNode node) {
    saveNodeReference(node);
    List<SNode> list = new ArrayList<SNode>();
    list.add(node);
    saveNodes(list, null);
  }

  @Override
  public DataFlavor[] getTransferDataFlavors() {
    if (supportsNodeReference()) {
      return flavors;
    } else {
      DataFlavor[] reducedFlavors = {flavors[NODE], flavors[STRING], flavors[PLAIN_TEXT]};
      return reducedFlavors;
    }
  }

  @Override
  public boolean isDataFlavorSupported(DataFlavor flavor) {
    for (DataFlavor flavor1 : getTransferDataFlavors()) {
      if (flavor.equals(flavor1)) {
        return true;
      }
    }
    return false;
  }

  @Override
  public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {
    if (flavor.equals(flavors[NODE])) {
      return this;
    } else if (flavor.equals(flavors[NODE_REFERENCE])) {
      if (supportsNodeReference()) {
        return mySNodeReference;
      }
    } else
    if (flavor.equals(flavors[STRING])) {
      return getAsString();
    } else
    if (flavor.equals(flavors[PLAIN_TEXT])) {
      return new StringReader(getAsString());

    }
    throw new UnsupportedFlavorException(flavor);
  }

  private boolean supportsNodeReference() {
    return mySNodeReference != null;
  }

  private String getAsString() {
    return myText;
  }

  private void saveNodes(@NotNull List<SNode> nodes, @Nullable Map<SNode, Set<SNode>> nodesAndAttributes) {
    for (SNode node : nodes) {
      assert node.getParent() == nodes.get(0).getParent();
    }
    mySNodes.clear();
    PasteNodeData pasteNodeData = CopyPasteUtil.createNodeDataIn(nodes, nodesAndAttributes);
    mySNodes.addAll(pasteNodeData.getNodes());
    SModule module = pasteNodeData.getSourceModule();
    mySourceModule = (module == null ?
      null :
      module.getModuleReference()
    );
    myNecessaryModels = pasteNodeData.getNecessaryModels();
    myNecessaryLanguages = pasteNodeData.getNecessaryLanguages();
  }

  private void saveNodeReference(@NotNull SNode node) {
    mySNodeReference = node.getReference();
  }

  public PasteNodeData createNodeData() {
    Set<SModuleReference> necessaryLanguages = myNecessaryLanguages;
    Set<SModelReference> necessaryImports = myNecessaryModels;
    if (necessaryImports == null) {
      necessaryImports = new HashSet<SModelReference>();
    }
    if (necessaryLanguages == null) {
      necessaryLanguages = new HashSet<SModuleReference>();
    }
    SModule module = (mySourceModule == null ?
      null :
      MPSModuleRepository.getInstance().getModule(mySourceModule)
    );
    return CopyPasteUtil.createNodeDataOut(mySNodes, module, new HashSet<SModuleReference>(necessaryLanguages), new HashSet<SModelReference>(necessaryImports));
  }

  public boolean containsNodes() {
    return (!(mySNodes.isEmpty()));
  }
}
