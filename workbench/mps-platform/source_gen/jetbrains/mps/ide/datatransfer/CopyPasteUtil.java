package jetbrains.mps.ide.datatransfer;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.project.structure.modules.ModuleReference;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.datatransfer.PasteNodeData;
import java.util.List;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.project.IModule;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import jetbrains.mps.datatransfer.CopyPasteManager;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.util.InternUtil;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.SModelId;
import jetbrains.mps.smodel.SModelOperations;
import com.intellij.ide.CopyPasteManagerEx;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import java.awt.datatransfer.DataFlavor;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.project.Project;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.logging.Logger;

public class CopyPasteUtil {
  private static CopyPasteUtil.IDataConverter myDataConverter = null;

  public CopyPasteUtil() {
  }

  private static void processImportsAndLanguages(Set<SModelReference> necessaryImports, Set<ModuleReference> necessaryLanguages, Map<SNode, SNode> sourceNodesToNewNodes, Set<SReference> allReferences) {
    necessaryImports.clear();
    necessaryLanguages.clear();
    Set<SNode> sourceNodes = sourceNodesToNewNodes.keySet();
    for (SNode node : sourceNodes) {
      necessaryLanguages.add(new ModuleReference(node.getLanguageNamespace()).update());
    }
    for (SReference ref : allReferences) {
      if (sourceNodesToNewNodes.get(ref.getTargetNode()) == null) {
        SModelReference targetModelReference = ref.getTargetSModelReference();
        if (targetModelReference != null) {
          necessaryImports.add(targetModelReference.update());
        }
      }
    }
  }

  public static PasteNodeData createNodeDataIn(List<SNode> sourceNodes, Map<SNode, Set<SNode>> sourceNodesAndAttributes) {
    if (sourceNodes.isEmpty()) {
      return PasteNodeData.emptyPasteNodeData(null);
    }
    SModel model = sourceNodes.get(0).getModel();
    IModule module = model.getModelDescriptor().getModule();
    List<SNode> result = new ArrayList<SNode>();
    Map<SNode, SNode> sourceNodesToNewNodes = new HashMap<SNode, SNode>();
    Set<SReference> allReferences = new HashSet<SReference>();
    for (SNode sourceNode : sourceNodes) {
      assert sourceNode.getModel() == model;
      SNode targetNode = CopyPasteUtil.copyNode_internal(sourceNode, sourceNodesAndAttributes, sourceNodesToNewNodes, allReferences);
      result.add(targetNode);
    }
    HashSet<SModelReference> necessaryModels = new HashSet<SModelReference>();
    HashSet<ModuleReference> necessaryLanguages = new HashSet<ModuleReference>();
    CopyPasteUtil.processImportsAndLanguages(necessaryModels, necessaryLanguages, sourceNodesToNewNodes, allReferences);
    CopyPasteUtil.processReferencesIn(sourceNodesToNewNodes, allReferences);
    Map<SNode, SNode> newNodesToSourceNodes = new HashMap<SNode, SNode>();
    for (Map.Entry<SNode, SNode> entry : sourceNodesToNewNodes.entrySet()) {
      newNodesToSourceNodes.put(entry.getValue(), entry.getKey());
    }
    for (SNode newNode : result) {
      CopyPasteManager.getInstance().preProcessNode(newNode, newNodesToSourceNodes);
    }
    return new PasteNodeData(result, null, module, necessaryLanguages, necessaryModels);
  }

  public static PasteNodeData createNodeDataOut(List<SNode> sourceNodes, IModule sourceModule, Set<ModuleReference> necessaryLanguages, Set<SModelReference> necessaryModels) {
    if (sourceNodes.isEmpty()) {
      return PasteNodeData.emptyPasteNodeData(null);
    }
    List<SNode> result = new ArrayList<SNode>();
    Set<SReference> referencesRequireResolve = new HashSet<SReference>();
    Map<SNode, SNode> sourceNodesToNewNodes = new HashMap<SNode, SNode>();
    Set<SReference> allReferences = new HashSet<SReference>();
    SModel originalModel = sourceNodes.get(0).getModel();
    for (SNode sourceNode : sourceNodes) {
      assert sourceNode.getModel() == originalModel;
      SNode nodeToPaste = CopyPasteUtil.copyNode_internal(sourceNode, null, sourceNodesToNewNodes, allReferences);
      result.add(nodeToPaste);
    }
    CopyPasteUtil.processReferencesOut(sourceNodesToNewNodes, allReferences, referencesRequireResolve);
    return new PasteNodeData(result, referencesRequireResolve, sourceModule, necessaryLanguages, necessaryModels);
  }

  private static SNode copyNode_internal(SNode sourceNode, @Nullable Map<SNode, Set<SNode>> nodesAndAttributes, Map<SNode, SNode> sourceNodesToNewNodes, Set<SReference> allReferences) {
    SNode targetNode = new SNode(InternUtil.intern(sourceNode.getConcept().getId()));
    targetNode.setId(SNodeId.fromString(sourceNode.getSNodeId().toString()));
    for (String name : SetSequence.fromSet(sourceNode.getPropertyNames())) {
      targetNode.setProperty(name, sourceNode.getProperty(name));
    }
    sourceNodesToNewNodes.put(sourceNode, targetNode);
    List<SReference> references = sourceNode.getReferences();
    for (SReference reference : references) {
      allReferences.add(reference);
    }
    List<SNode> children = SNodeOperations.getChildren(sourceNode);
    for (SNode sourceChild : children) {
      if (nodesAndAttributes != null) {
        if (AttributeOperations.isAttribute(sourceChild)) {
          Set<SNode> nodes = nodesAndAttributes.get(sourceNode);
          if (nodes != null && !(nodes.contains(sourceChild))) {
            continue;
          }
        }
      }
      SNode targetChild = CopyPasteUtil.copyNode_internal(sourceChild, nodesAndAttributes, sourceNodesToNewNodes, allReferences);
      String role = sourceChild.getRoleInParent();
      assert role != null;
      targetNode.addChild(role, targetChild);
    }
    return targetNode;
  }

  private static void processReferencesIn(Map<SNode, SNode> sourceNodesToNewNodes, Set<SReference> allReferences) {
    for (SReference sourceReference : allReferences) {
      SNode oldSourceNode = sourceReference.getSourceNode();
      SNode newSourceNode = sourceNodesToNewNodes.get(oldSourceNode);
      SNode oldTargetNode = sourceReference.getTargetNode();
      SNode newTargetNode = sourceNodesToNewNodes.get(oldTargetNode);
      SReference newReference;
      if (newTargetNode != null) {
        newReference = SReference.create(sourceReference.getRole(), newSourceNode, newTargetNode);
      } else {
        if (oldTargetNode != null) {
          newReference = SReference.create(sourceReference.getRole(), newSourceNode, oldTargetNode.getModel().getSModelReference(), oldTargetNode.getSNodeId());
        } else
        if (sourceReference.getResolveInfo() != null) {
          newReference = new StaticReference(sourceReference.getRole(), newSourceNode, null, null, sourceReference.getResolveInfo());
        } else {
          continue;
        }
      }
      newSourceNode.setReference(newReference.getRole(), newReference);
    }
  }

  private static void processReferencesOut(Map<SNode, SNode> sourceNodesToNewNodes, Set<SReference> allReferences, Set<SReference> referencesRequireResolve) {
    for (SReference sourceReference : allReferences) {
      SNode oldSourceNode = sourceReference.getSourceNode();
      SNode newSourceNode = sourceNodesToNewNodes.get(oldSourceNode);
      SNode oldTargetNode = sourceReference.getTargetNode();
      SNode newTargetNode = sourceNodesToNewNodes.get(oldTargetNode);
      SReference newReference;
      if (newTargetNode != null) {
        newReference = SReference.create(sourceReference.getRole(), newSourceNode, newTargetNode);
      } else {
        if (jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.isInstanceOf(newSourceNode, "jetbrains.mps.baseLanguage.structure.IMethodCall") && oldTargetNode != null) {
          newReference = SReference.create(sourceReference.getRole(), newSourceNode, oldTargetNode);
        } else {
          String resolveInfo = (oldTargetNode == null ?
            sourceReference.getResolveInfo() :
            oldTargetNode.getName()
          );
          if (resolveInfo != null) {
            if (oldTargetNode != null && !(SNodeOperations.isDisposed(oldTargetNode)) && oldTargetNode.getModel() != null) {
              newReference = new StaticReference(sourceReference.getRole(), newSourceNode, oldTargetNode.getModel().getSModelReference(), oldTargetNode.getSNodeId(), resolveInfo);
            } else {
              newReference = new StaticReference(sourceReference.getRole(), newSourceNode, null, null, resolveInfo);
            }
            referencesRequireResolve.add(newReference);
          } else
          if (oldTargetNode != null) {
            newReference = SReference.create(sourceReference.getRole(), newSourceNode, oldTargetNode);
          } else {
            continue;
          }
        }
      }
      newSourceNode.setReference(newReference.getRole(), newReference);
    }
  }

  private static SModel copyModelProperties(SModel model) {
    SModelReference modelReference = model.getSModelReference();
    SModelFqName fqName = new SModelFqName(modelReference.getLongName(), SModelStereotype.INTERNAL_COPY);
    SModel newModel = new SModel(new SModelReference(fqName, SModelId.generate()));
    for (ModuleReference language : model.importedLanguages()) {
      newModel.addLanguage(language);
    }
    for (SModelReference importedModel : SModelOperations.getImportedModelUIDs(model)) {
      newModel.addModelImport(importedModel, false);
    }
    for (ModuleReference devKit : model.importedDevkits()) {
      newModel.addDevKit(devKit);
    }
    return newModel;
  }

  public static void copyTextToClipboard(String text) {
    CopyPasteManagerEx.getInstanceEx().setContents(new StringSelection(text));
  }

  public static void copyNodesAndTextToClipboard(List<SNode> nodes, String text) {
    setClipboardContents(new SNodeTransferable(nodes, text));
  }

  public static void copyNodesAndTextToClipboard(List<SNode> nodes, Map<SNode, Set<SNode>> nodesAndAttributes, String text) {
    setClipboardContents(new SNodeTransferable(nodes, text, nodesAndAttributes));
  }

  /**
   * A workaround for the following problem with CopyPasteManagerEx:
   * 
   *          if stringContent of one of existing Transferable instances stored inside CopyPasteManagerEx.myDatas
   * collection is equals to the stringContent of Transferable we are trying to "push" there (used as a parameter
   * of this method) then existing element will "float up" inside CopyPasteManagerEx.myDatas collection and will
   * be used next on next paste operation instead of passed Transferable.
   * 
   * In case of MPS precondition that string equality of clipboard ontent meant actual equality of passed Trabsferables
   * (SNodeTransferables) is generally wrong, so we have to work around this logic by deleting all exiting Transferables
   * to avoid possible collisions between copied elements preventing user from copying actual node under mouse in editor.
   */
  private static void setClipboardContents(Transferable content) {
    try {
      String stringContent = getStringContent(content);
      if (stringContent != null) {
        for (Transferable existingContent : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
          if (stringContent.equals(getStringContent(existingContent))) {
            CopyPasteManagerEx.getInstanceEx().removeContent(existingContent);
          }
        }
      }
    } catch (UnsupportedFlavorException e) {
    } catch (IOException ex) {
    }
    CopyPasteManagerEx.getInstanceEx().setContents(content);
  }

  private static String getStringContent(Transferable content) throws UnsupportedFlavorException, IOException {
    return (String) content.getTransferData(DataFlavor.stringFlavor);
  }

  public static void copyNodesToClipboard(List<SNode> nodes) {
    StringBuilder stringBuilder = new StringBuilder();
    int i = 1;
    int size = nodes.size();
    for (SNode node : nodes) {
      stringBuilder.append(SNodeOperations.getDebugText(node));
      if (i < size) {
        stringBuilder.append("\n");
      }
      i++;
    }
    CopyPasteUtil.copyNodesAndTextToClipboard(nodes, stringBuilder.toString());
  }

  public static void copyNodeToClipboard(SNode node) {
    List<SNode> list = new ArrayList<SNode>();
    list.add(node);
    CopyPasteUtil.copyNodesToClipboard(list);
  }

  public static List<SNode> getNodesFromClipboard(SModel model) {
    return CopyPasteUtil.getPasteNodeDataFromClipboard(model).getNodes();
  }

  public static PasteNodeData getPasteNodeDataFromClipboard(SModel model) {
    IModule module = model.getModelDescriptor().getModule();
    Transferable content = null;
    for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
      if (trf != null && trf.isDataFlavorSupported(SModelDataFlavor.sNode)) {
        content = trf;
      }
      break;
    }
    if (content == null) {
      return PasteNodeData.emptyPasteNodeData(module);
    }
    if (content.isDataFlavorSupported(SModelDataFlavor.sNode)) {
      SNodeTransferable nodeTransferable;
      try {
        nodeTransferable = (SNodeTransferable) content.getTransferData(SModelDataFlavor.sNode);
        return nodeTransferable.createNodeData();
      } catch (UnsupportedFlavorException e) {
        LOG.error("Exception", e);
      } catch (IOException e) {
        LOG.error("Exception", e);
      }
    }
    return PasteNodeData.emptyPasteNodeData(module);
  }

  public static SNode getNodeFromClipboard(SModel model) {
    return CopyPasteUtil.getNodesFromClipboard(model).get(0);
  }

  @Nullable
  public static Runnable addImportsWithDialog(final IModule sourceModule, final SModel targetModel, final Set<ModuleReference> necessaryLanguages, final Set<SModelReference> necessaryImports, final IOperationContext context) {
    if (targetModel.getModelDescriptor().getModule() == null) {
      return null;
    }
    final List<ModuleReference> additionalLanguages = new ArrayList<ModuleReference>();
    final List<SModelReference> additionalModels = new ArrayList<SModelReference>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        List<SModelReference> allImportedModels = new ArrayList<SModelReference>();
        for (SModelDescriptor sm : SModelOperations.allImportedModels(targetModel, context.getScope())) {
          allImportedModels.add(sm.getSModelReference());
        }
        for (SModelReference modelReference : necessaryImports) {
          if (modelReference != null && !((allImportedModels.contains(modelReference))) && !((targetModel.getSModelReference().equals(modelReference)))) {
            additionalModels.add(modelReference);
          }
        }
        necessaryImports.retainAll(additionalModels);
        for (ModuleReference moduleReference : necessaryLanguages) {
          if (!(SModelOperations.hasLanguage(targetModel, moduleReference))) {
            additionalLanguages.add(moduleReference);
          }
        }
        necessaryLanguages.retainAll(additionalLanguages);
      }
    });
    if (necessaryImports.isEmpty() && necessaryLanguages.isEmpty()) {
      return null;
    }

    AddRequiredImportsDialog dialog = new AddRequiredImportsDialog(ProjectHelper.toIdeaProject(context.getProject()), necessaryImports.toArray(new SModelReference[necessaryImports.size()]), necessaryLanguages.toArray(new ModuleReference[necessaryLanguages.size()]));
    dialog.show();
    if (dialog.isOK()) {
      return addImports(context.getProject(), targetModel, dialog.getSelectedLanguages(), dialog.getSelectedImports());
    } else {
      return null;
    }
  }

  @Nullable
  public static Runnable addImportsWithDialog(PasteNodeData pasteNodeData, SModel targetModel, IOperationContext context) {
    return CopyPasteUtil.addImportsWithDialog(pasteNodeData.getSourceModule(), targetModel, pasteNodeData.getNecessaryLanguages(), pasteNodeData.getNecessaryModels(), context);
  }

  private static Runnable addImports(Project p, final SModel targetModel, @NotNull final ModuleReference[] requiredLanguages, @NotNull final SModelReference[] requiredImports) {
    if (requiredLanguages.length == 0 && requiredImports.length == 0) {
      return null;
    }

    return new Runnable() {
      @Override
      public void run() {
        //  model properties 
        for (SModelReference imported : requiredImports) {
          targetModel.addModelImport(imported, false);
        }
        for (ModuleReference language : requiredLanguages) {
          targetModel.addLanguage(language);
        }
        //  model's module properties 
        IModule targetModule = targetModel.getModelDescriptor().getModule();
        if (targetModule == null) {
          return;
        }

        for (ModuleReference language : requiredLanguages) {
          targetModule.addUsedLanguage(language);
        }

        for (SModelReference model : requiredImports) {
          SModelDescriptor modelDescriptor = SModelRepository.getInstance().getModelDescriptor(model);
          if (modelDescriptor == null) {
            continue;
          }
          IModule module = modelDescriptor.getModule();
          if (module == null || module == targetModule) {
            continue;
          }

          targetModule.addDependency(module.getModuleReference(), false);
        }
      }
    };
  }

  public static boolean doesClipboardContainNode() {
    Transferable content = null;
    for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
      if (trf != null && trf.isDataFlavorSupported(SModelDataFlavor.sNode)) {
        return true;
      }
      break;
    }
    return false;
  }

  public static synchronized void setDataConverter(CopyPasteUtil.IDataConverter dataConverter) {
    myDataConverter = dataConverter;
  }

  public static synchronized boolean isConversionAvailable(SModel model, SNode anchor) {
    return myDataConverter != null && myDataConverter.canPasteAsNodes(model, anchor);
  }

  public static synchronized PasteNodeData getConvertedFromClipboard(SModel model, Project project) {
    return (myDataConverter == null ?
      null :
      myDataConverter.getPasteNodeData(model, project)
    );
  }

  public static boolean canPasteNodes(SModel model, SNode anchor) {
    List<SNode> nodes = getNodesFromClipboard(model);
    return ListSequence.fromList(nodes).isNotEmpty() || isConversionAvailable(model, anchor);
  }

  public static synchronized void pasteNodes(SModel model, SNode anchor, Project project) {
    if (myDataConverter != null) {
      myDataConverter.pasteAsNodes(model, anchor, project);
    }
  }

  public static interface IDataConverter {
    public boolean canPasteAsNodes(SModel model, SNode anchor);
    public void pasteAsNodes(SModel model, SNode anchor, Project project);
    public PasteNodeData getPasteNodeData(SModel model, Project project);
  }

  private static Logger LOG = Logger.getLogger(CopyPasteUtil.class);
}
