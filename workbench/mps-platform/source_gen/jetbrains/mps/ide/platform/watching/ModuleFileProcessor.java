package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.project.IModule;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.smodel.MPSModuleRepository;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.fileTypes.MPSFileTypesManager;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.smodel.ModelAccess;
import java.util.Collections;

/*package*/ class ModuleFileProcessor extends EventProcessor {
  private final Set<IModule> myChangedModules = SetSequence.fromSet(new HashSet<IModule>());
  private final Set<IModule> myDeletedModules = SetSequence.fromSet(new HashSet<IModule>());
  private final Set<IModule> myProcessedModules = SetSequence.fromSet(new HashSet<IModule>());
  private boolean myNeedReload = false;

  public ModuleFileProcessor() {
  }

  protected boolean isEmpty() {
    return SetSequence.fromSet(myChangedModules).isEmpty() && SetSequence.fromSet(myDeletedModules).isEmpty() && !(myNeedReload);
  }

  public void update(ProgressIndicator indicator) {
    indicator.setText("Reloading updated modules... Please wait.");
    for (final IModule module : myChangedModules) {
      String text = "Reloading " + module.getModuleFqName();
      indicator.setText2(text);
      module.reloadFromDisk(false);
      SetSequence.fromSet(myProcessedModules).addElement(module);
    }
    for (final IModule module : myDeletedModules) {
      indicator.setText2("Unloading removed module " + module.getModuleFqName());
      module.dispose();
      MPSModuleRepository.getInstance().removeModule(module);
      SetSequence.fromSet(myProcessedModules).addElement(module);
    }
    if (myNeedReload) {
      // update lib modules 
      // update project modules 
    }
  }

  public Set<IModule> getProcessedModules() {
    return myProcessedModules;
  }

  public boolean needsReload() {
    return !(SetSequence.fromSet(myProcessedModules).isEmpty());
  }

  protected boolean accepts(VirtualFile file) {
    return file.isDirectory() || MPSFileTypesManager.instance().isModuleFile(file);
  }

  @Override
  protected void processDelete(VirtualFile file) {
    SetSequence.fromSet(myDeletedModules).addSequence(Sequence.fromIterable(replaceGenerators(getModulesByFile(file))));
  }

  @Override
  protected void processCreate(VirtualFile file) {
    if (file.isDirectory() || MPSFileTypesManager.instance().isModuleFile(file)) {
      myNeedReload = true;
    }
  }

  @Override
  protected void processContentChanged(VirtualFile file) {
    if (file.isDirectory()) {
      return;
    }
    List<IModule> modules = ModuleFileProcessor.getModulesByFile(file);
    SetSequence.fromSet(myChangedModules).addSequence(Sequence.fromIterable(replaceGenerators(modules)).where(new IWhereFilter<IModule>() {
      public boolean accept(IModule it) {
        return it.needReloading();
      }
    }));
  }

  private Iterable<IModule> replaceGenerators(Iterable<IModule> modules) {
    return Sequence.fromIterable(modules).select(new ISelector<IModule, IModule>() {
      public IModule select(IModule it) {
        return (it instanceof Generator ?
          ((Generator) it).getSourceLanguage() :
          it
        );
      }
    });
  }

  private static List<IModule> getModulesByFile(final VirtualFile file) {
    final Wrappers._T<List<IModule>> res = new Wrappers._T<List<IModule>>(ListSequence.fromList(new ArrayList<IModule>()));
    final MPSModuleRepository repo = MPSModuleRepository.getInstance();
    final IFile mpsFile = FileSystem.getInstance().getFileByPath(file.getPath());

    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        res.value = (file.isDirectory() ?
          repo.findModulesUnderDir(mpsFile) :
          Collections.singletonList(repo.getModuleByFile(mpsFile))
        );
      }
    });
    return res.value;
  }
}
