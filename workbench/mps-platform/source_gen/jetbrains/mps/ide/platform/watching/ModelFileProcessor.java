package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.smodel.descriptor.source.FileBasedModelDataSource;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.descriptor.source.ReloadableSources;
import jetbrains.mps.progress.ProgressMonitor;
import jetbrains.mps.project.IModule;
import jetbrains.mps.progress.SubProgressKind;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.Language;
import java.util.ArrayList;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.project.SModelRoot;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Map;
import java.util.Collection;
import jetbrains.mps.smodel.descriptor.source.changes.ModelFileWatcher;

/*package*/ class ModelFileProcessor extends EventProcessor {
  private final Set<FileBasedModelDataSource> myInvalidatedSources = SetSequence.fromSet(new HashSet<FileBasedModelDataSource>());
  private final Set<SModule> myModulesWithChangedModelSets = SetSequence.fromSet(new HashSet<SModule>());

  public ModelFileProcessor() {
  }

  public void validateModules(Iterable<SModule> modules) {
    SetSequence.fromSet(myModulesWithChangedModelSets).removeSequence(Sequence.fromIterable(modules));
  }

  protected boolean isEmpty() {
    return !(ReloadableSources.getInstance().needsReloading()) && SetSequence.fromSet(myInvalidatedSources).isEmpty() && SetSequence.fromSet(myModulesWithChangedModelSets).isEmpty();
  }

  public void update(ProgressMonitor monitor) {
    monitor.start("Reloading updated models... Please wait.", SetSequence.fromSet(myModulesWithChangedModelSets).count() + 10);
    try {
      for (SModule module : SetSequence.fromSet(myModulesWithChangedModelSets)) {
        monitor.step("reloading all models in module " + module.getModuleName());
        ((IModule) module).reloadFromDisk(false);
        monitor.advance(1);
      }
      for (FileBasedModelDataSource source : SetSequence.fromSet(myInvalidatedSources)) {
        source.invalidate();
      }
      ReloadableSources.getInstance().reload(monitor.subTask(10, SubProgressKind.AS_COMMENT));
    } finally {
      monitor.done();
    }
  }

  protected boolean accepts(VirtualFile file) {
    return ListSequence.fromList(findModelRootIntersection(file, true)).isNotEmpty() || ListSequence.fromList(findSourceIntersection(file, true)).isNotEmpty();
  }

  @Override
  protected void processDelete(VirtualFile file) {
    invalidateModelsAndRoots(file);
  }

  @Override
  protected void processCreate(VirtualFile file) {
    invalidateModelsAndRoots(file);
  }

  private void invalidateModelsAndRoots(VirtualFile file) {
    List<FileBasedModelDataSource> sources = findSourceIntersection(file, false);
    SetSequence.fromSet(myInvalidatedSources).addSequence(ListSequence.fromList(sources));

    List<SModule> modules = findModelRootIntersection(file, false);

    SetSequence.fromSet(myModulesWithChangedModelSets).addSequence(ListSequence.fromList(modules));
    // todo remove when generators are disconnected from languages 
    SetSequence.fromSet(myModulesWithChangedModelSets).addSequence(ListSequence.fromList(modules).where(new IWhereFilter<SModule>() {
      public boolean accept(SModule it) {
        return it instanceof Generator;
      }
    }).select(new ISelector<SModule, Language>() {
      public Language select(SModule it) {
        return ((Generator) it).getSourceLanguage();
      }
    }));
  }

  protected void processContentChanged(VirtualFile file) {
    SetSequence.fromSet(myInvalidatedSources).addSequence(ListSequence.fromList(findSourceIntersection(file, false)));
  }

  private List<SModule> findModelRootIntersection(VirtualFile file, boolean onlyFirst) {
    List<SModule> res = ListSequence.fromList(new ArrayList<SModule>());
    String path = file.getPath();

    Iterable<IModule> modules = MPSModuleRepository.getInstance().getAllModules();
    for (IModule module : Sequence.fromIterable(modules)) {
      for (SModelRoot smr : CollectionSequence.fromCollection(module.getSModelRoots())) {
        if (!(intersects(path, smr.getPath()))) {
          continue;
        }
        ListSequence.fromList(res).addElement(module);
        if (onlyFirst) {
          return res;
        } else {
          break;
        }
      }
    }
    return res;
  }

  private List<FileBasedModelDataSource> findSourceIntersection(VirtualFile file, boolean onlyFirst) {
    List<FileBasedModelDataSource> res = ListSequence.fromList(new ArrayList<FileBasedModelDataSource>());
    Map<FileBasedModelDataSource, Collection<String>> s2f = ModelFileWatcher.getInstance().getSources2Files();
    String path = file.getPath();

    for (Map.Entry<FileBasedModelDataSource, Collection<String>> entry : SetSequence.fromSet(s2f.entrySet())) {
      for (String p : CollectionSequence.fromCollection(entry.getValue())) {
        if (!(intersects(path, p))) {
          continue;
        }
        ListSequence.fromList(res).addElement(entry.getKey());
        if (onlyFirst) {
          return res;
        } else {
          break;
        }
      }
    }
    return res;
  }

  private boolean intersects(String vf1, String vf2) {
    if (vf1 == null || vf2 == null) {
      return false;
    }
    return vf1.startsWith(vf2) || vf2.startsWith(vf1);
  }
}
