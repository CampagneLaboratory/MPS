package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.smodel.descriptor.source.FileBasedModelDataSource;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.project.IModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.descriptor.source.ReloadableSources;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.project.SModelRoot;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Map;
import java.util.Collection;
import jetbrains.mps.smodel.descriptor.source.changes.ModelFileWatcher;

/*package*/ class ModelFileProcessor extends EventProcessor {
  private final Set<FileBasedModelDataSource> myInvalidatedSources = SetSequence.fromSet(new HashSet<FileBasedModelDataSource>());
  private final Set<IModule> myModulesWithChangedModelSets = SetSequence.fromSet(new HashSet<IModule>());

  public ModelFileProcessor() {
  }

  public void validateModules(Iterable<IModule> modules) {
    SetSequence.fromSet(myModulesWithChangedModelSets).removeSequence(Sequence.fromIterable(modules));
  }

  protected boolean isEmpty() {
    return !(ReloadableSources.getInstance().needsReloading()) && SetSequence.fromSet(myInvalidatedSources).isEmpty() && SetSequence.fromSet(myModulesWithChangedModelSets).isEmpty();
  }

  public void update(ProgressIndicator indicator) {
    indicator.setText("Reloading updated models... Please wait.");
    for (IModule module : SetSequence.fromSet(myModulesWithChangedModelSets)) {
      indicator.setText2("reloading all models in module " + module.getModuleFqName());
      module.reloadFromDisk(false);
    }
    for (FileBasedModelDataSource source : SetSequence.fromSet(myInvalidatedSources)) {
      source.invalidate();
    }
    ReloadableSources.getInstance().reload(new ProgressMonitorAdapter(indicator));
  }

  protected boolean accepts(VirtualFile file) {
    return ListSequence.fromList(findModelRootIntersection(file, true)).isNotEmpty() || ListSequence.fromList(findSourceIntersection(file, true)).isNotEmpty();
  }

  @Override
  protected void processDelete(VirtualFile file) {
    invalidateModelsAndRoots(file);
  }

  @Override
  protected void processCreate(VirtualFile file) {
    invalidateModelsAndRoots(file);
  }

  private void invalidateModelsAndRoots(VirtualFile file) {
    List<FileBasedModelDataSource> sources = findSourceIntersection(file, false);
    SetSequence.fromSet(myInvalidatedSources).addSequence(ListSequence.fromList(sources));

    List<IModule> modules = findModelRootIntersection(file, false);
    SetSequence.fromSet(myModulesWithChangedModelSets).addSequence(ListSequence.fromList(modules));
  }

  protected void processContentChanged(VirtualFile file) {
    SetSequence.fromSet(myInvalidatedSources).addSequence(ListSequence.fromList(findSourceIntersection(file, false)));
  }

  private List<IModule> findModelRootIntersection(VirtualFile file, boolean onlyFirst) {
    List<IModule> res = ListSequence.fromList(new ArrayList<IModule>());
    String path = file.getPath();

    Set<IModule> modules = MPSModuleRepository.getInstance().getAllModules();
    for (IModule module : SetSequence.fromSet(modules)) {
      for (SModelRoot smr : CollectionSequence.fromCollection(module.getSModelRoots())) {
        if (!(intersects(path, smr.getPath()))) {
          continue;
        }
        ListSequence.fromList(res).addElement(module);
        if (onlyFirst) {
          return res;
        } else {
          break;
        }
      }
    }
    return res;
  }

  private List<FileBasedModelDataSource> findSourceIntersection(VirtualFile file, boolean onlyFirst) {
    List<FileBasedModelDataSource> res = ListSequence.fromList(new ArrayList<FileBasedModelDataSource>());
    Map<FileBasedModelDataSource, Collection<String>> s2f = ModelFileWatcher.getInstance().getSources2Files();
    String path = file.getPath();

    for (Map.Entry<FileBasedModelDataSource, Collection<String>> entry : SetSequence.fromSet(s2f.entrySet())) {
      for (String p : CollectionSequence.fromCollection(entry.getValue())) {
        if (!(intersects(path, p))) {
          continue;
        }
        ListSequence.fromList(res).addElement(entry.getKey());
        if (onlyFirst) {
          return res;
        } else {
          break;
        }
      }
    }
    return res;
  }

  private boolean intersects(String vf1, String vf2) {
    if (vf1 == null || vf2 == null) {
      return false;
    }
    return vf1.startsWith(vf2) || vf2.startsWith(vf1);
  }
}
