package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.project.IModule;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.smodel.descriptor.source.ReloadableSources;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import com.intellij.openapi.vfs.VirtualFile;
import java.util.Collection;
import jetbrains.mps.smodel.descriptor.source.FileBasedModelDataSource;
import jetbrains.mps.smodel.descriptor.source.changes.ModelFileWatcher;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;

/*package*/ class ModelFileProcessor extends EventProcessor {
  private final Set<SModelDescriptor> myDeletedModels = SetSequence.fromSet(new HashSet<SModelDescriptor>());
  private final Set<IModule> myModulesWithNewModels = SetSequence.fromSet(new HashSet<IModule>());

  public ModelFileProcessor() {
  }

  public void validateModules(Iterable<IModule> modules) {
  }

  protected boolean isEmpty() {
    return false;
  }

  public void update(ProgressIndicator indicator) {
    indicator.setText("Reloading updated models... Please wait.");
    ReloadableSources.getInstance().reload(new ProgressMonitorAdapter(indicator));
  }

  protected boolean accepts(VirtualFile file) {
    return true;
  }

  @Override
  protected void processDelete(VirtualFile file) {
  }

  @Override
  protected void processCreate(VirtualFile file) {
  }

  protected void processContentChanged(VirtualFile file) {
    while (file != null) {
      Collection<FileBasedModelDataSource> sources = ModelFileWatcher.getInstance().getSourcesForFile(file.getPath());
      for (FileBasedModelDataSource source : CollectionSequence.fromCollection(sources)) {
        source.invalidate();
      }
      file = file.getParent();
    }
  }
}
