package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.vfs.FileSystemListener;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.ide.vfs.IdeaFileSystemProvider;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.progress.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.progress.SubProgressKind;
import jetbrains.mps.smodel.descriptor.source.ReloadableSources;
import java.util.Set;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Collection;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.HashSet;

public class FileProcessor extends EventProcessor {
  private FileSystemListenersContainer listenersContainer;
  private Map<FileSystemListener, FileProcessor.ListenerData> dataMap = MapSequence.fromMap(new HashMap<FileSystemListener, FileProcessor.ListenerData>());

  public FileProcessor() {
    this.listenersContainer = ((IdeaFileSystemProvider) FileSystem.getInstance().getFileSystemProvider()).getListenersContainer();
  }

  public void update(ProgressMonitor monitor) {
    monitor.start("Reloading files... Please wait.", MapSequence.fromMap(dataMap).count() * 2);
    try {
      for (FileSystemListener listener : Sequence.fromIterable(sortedListeners())) {
        FileProcessor.ListenerData data = MapSequence.fromMap(dataMap).get(listener);
        if (!(listenersContainer.contains(listener))) {
          continue;
        }

        if (data.changed.isEmpty()) {
          monitor.advance(1);
        } else {
          filesChanged(monitor.subTask(1, SubProgressKind.AS_COMMENT), listener, data.changed);
        }

        if (data.added.isEmpty() && data.removed.isEmpty()) {
          monitor.advance(1);
        } else {
          listener.folderChanged(monitor.subTask(1, SubProgressKind.AS_COMMENT), data.added, data.removed);
        }
      }
      ReloadableSources.getInstance().reload(monitor.subTask(10, SubProgressKind.AS_COMMENT));
    } finally {
      monitor.done();
    }
  }

  private Iterable<FileSystemListener> sortedListeners() {
    Set<FileSystemListener> result = new LinkedHashSet<FileSystemListener>(MapSequence.fromMap(dataMap).count());
    for (FileSystemListener l : SetSequence.fromSet(MapSequence.fromMap(dataMap).keySet())) {
      visit(l, result);
    }
    return result;
  }

  private void visit(FileSystemListener listener, Set<FileSystemListener> result) {
    if (result.contains(listener)) {
      return;
    }
    result.add(listener);
    Iterable<FileSystemListener> dependencies = listener.getDependencies();
    if (dependencies == null) {
      return;
    }

    boolean readd = false;
    for (FileSystemListener dep : dependencies) {
      if (MapSequence.fromMap(dataMap).containsKey(dep) && !(result.contains(dep))) {
        visit(dep, result);
        readd = true;
      }
    }
    if (readd) {
      result.remove(listener);
      result.add(listener);
    }
  }

  private void filesChanged(ProgressMonitor monitor, FileSystemListener listener, Collection<IFile> files) {
    monitor.start("", CollectionSequence.fromCollection(files).count());
    try {
      for (IFile file : CollectionSequence.fromCollection(files)) {
        listener.fileChanged(monitor.subTask(1), file);
      }
    } finally {
      monitor.done();
    }

  }

  protected boolean accepts(VirtualFile file) {
    return true;
  }

  protected void processDelete(VirtualFile file) {
    String path = file.getPath();
    final IFile ifile = FileSystem.getInstance().getFileByPath(path);
    Sequence.fromIterable(get(path)).visitAll(new IVisitor<FileProcessor.ListenerData>() {
      public void visit(FileProcessor.ListenerData it) {
        it.removed.add(ifile);
      }
    });
  }

  protected void processCreate(VirtualFile file) {
    String path = file.getPath();
    final IFile ifile = FileSystem.getInstance().getFileByPath(path);
    Sequence.fromIterable(get(path)).visitAll(new IVisitor<FileProcessor.ListenerData>() {
      public void visit(FileProcessor.ListenerData it) {
        it.added.add(ifile);
      }
    });
  }

  protected void processContentChanged(VirtualFile file) {
    String path = file.getPath();
    final IFile ifile = FileSystem.getInstance().getFileByPath(path);
    Sequence.fromIterable(get(path)).visitAll(new IVisitor<FileProcessor.ListenerData>() {
      public void visit(FileProcessor.ListenerData it) {
        it.changed.add(ifile);
      }
    });
  }

  protected boolean isEmpty() {
    return MapSequence.fromMap(dataMap).isEmpty();
  }

  public Iterable<FileProcessor.ListenerData> get(String path) {
    return Sequence.fromIterable(listenersContainer.listeners(path)).select(new ISelector<FileSystemListener, FileProcessor.ListenerData>() {
      public FileProcessor.ListenerData select(FileSystemListener it) {
        FileProcessor.ListenerData data = MapSequence.fromMap(dataMap).get(it);
        if (data == null) {
          data = new FileProcessor.ListenerData();
          MapSequence.fromMap(dataMap).put(it, data);
        }
        return data;
      }
    });
  }

  private class ListenerData {
    private Set<IFile> added = new HashSet<IFile>();
    private Set<IFile> removed = new HashSet<IFile>();
    private Set<IFile> changed = new HashSet<IFile>();

    private ListenerData() {
    }
  }
}
