package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.concurrent.ConcurrentMap;
import jetbrains.mps.vfs.FileSystemListener;
import java.util.concurrent.ConcurrentHashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.util.containers.ConcurrentHashSet;
import com.intellij.openapi.vfs.LocalFileSystem;
import java.util.Map;
import jetbrains.mps.vfs.IFile;

public class FileSystemListenersContainer {
  private Object LOCK = new Object();
  private FileSystemListenersContainer.Node root = new FileSystemListenersContainer.Node(null, null);
  private ConcurrentMap<FileSystemListener, String> myListeners = new ConcurrentHashMap<FileSystemListener, String>();

  public FileSystemListenersContainer() {
  }

  public void addListener(FileSystemListener listener) {
    if (myListeners.containsKey(listener)) {
      return;
    }
    String path = listener.getFileToListen().getPath();
    if (myListeners.putIfAbsent(listener, path) != null) {
      return;
    }

    String normalized = path.replace('\\', '/');
    FileSystemListenersContainer.Node curr = root;
    synchronized (LOCK) {
      for (String s : normalized.split("\\/")) {
        if ((s == null || s.length() == 0)) {
          continue;
        }
        curr = curr.child(s, true);
      }
      curr.listeners.add(listener);
      curr.watchIt(listener.getFileToListen());
    }
  }

  public void removeListener(FileSystemListener listener) {
    String path = myListeners.get(listener);
    if (path == null) {
      return;
    }

    String normalized = path.replace('\\', '/');
    FileSystemListenersContainer.Node curr = root;
    synchronized (LOCK) {
      for (String s : normalized.split("\\/")) {
        if ((s == null || s.length() == 0)) {
          continue;
        }
        curr = curr.child(s, false);
        if (curr == null) {
          return;
        }
      }
      curr.listeners.remove(listener);
      curr.deleteIfEmpty();
    }
    myListeners.remove(listener);
  }

  public Iterable<FileSystemListener> listeners(String path) {
    String normalized = path.replace('\\', '/');
    FileSystemListenersContainer.Node curr = root;
    List<FileSystemListener> result = new ArrayList<FileSystemListener>();
    root.storeListeners(result);
    for (String s : normalized.split("\\/")) {
      if ((s == null || s.length() == 0)) {
        continue;
      }
      curr = curr.child(s, false);
      if (curr == null) {
        return result;
      }
      curr.storeListeners(result);
    }
    return result;
  }

  public boolean contains(FileSystemListener listener) {
    return myListeners.containsKey(listener);
  }

  private class Node {
    private final Set<FileSystemListener> listeners = new ConcurrentHashSet<FileSystemListener>();
    private LocalFileSystem.WatchRequest watchRequest = null;
    private final String pathPart;
    private final Map<String, FileSystemListenersContainer.Node> children = new ConcurrentHashMap<String, FileSystemListenersContainer.Node>();
    private final FileSystemListenersContainer.Node parent;

    private Node(String pathPart, FileSystemListenersContainer.Node parent) {
      this.parent = parent;
      this.pathPart = pathPart;
    }

    private FileSystemListenersContainer.Node child(String part, boolean create) {
      FileSystemListenersContainer.Node child = children.get(part);
      if (child == null && create) {
        child = new FileSystemListenersContainer.Node(part, this);
        children.put(part, child);
      }
      return child;
    }

    private void watchIt(IFile fullPath) {
      watchRequest = LocalFileSystem.getInstance().addRootToWatch(fullPath.getPath(), true);
      if (parent != null && parent.watchRequest == null && fullPath.getParent() != null) {
        parent.watchRequest = LocalFileSystem.getInstance().addRootToWatch(fullPath.getParent().getPath(), false);
      }
    }

    private void deleteIfEmpty() {
      if (parent == null || !(listeners.isEmpty()) || !(children.isEmpty())) {
        return;
      }

      parent.children.remove(pathPart);
      LocalFileSystem.getInstance().removeWatchedRoot(watchRequest);
      parent.deleteIfEmpty();
    }

    private void storeListeners(List<FileSystemListener> result) {
      result.addAll(listeners);
    }
  }
}
