package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.concurrent.ConcurrentMap;
import jetbrains.mps.vfs.FileSystemListener;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

public class FileSystemListenersContainer {
  private final ReadWriteLock myLock = new ReentrantReadWriteLock();
  private final FileSystemListenersContainer.Node root = new FileSystemListenersContainer.Node(null, null);
  private final ConcurrentMap<FileSystemListener, String> myListeners = new ConcurrentHashMap<FileSystemListener, String>();
  private final Pattern myPathSplitPattern;
  public FileSystemListenersContainer() {
    myPathSplitPattern = Pattern.compile("/");
  }
  public void addListener(FileSystemListener listener) {
    if (myListeners.containsKey(listener)) {
      return;
    }
    String path = listener.getFileToListen().getPath();
    if (myListeners.putIfAbsent(listener, path) != null) {
      return;
    }

    FileSystemListenersContainer.Node curr = root;

    myLock.writeLock().lock();
    try {
      for (String s : normalizeAndSplit(path)) {
        if ((s == null || s.length() == 0)) {
          continue;
        }
        curr = curr.child(s, true);
      }
      curr.addListener(listener);
    } finally {
      myLock.writeLock().unlock();
    }
  }
  public void removeListener(FileSystemListener listener) {
    String path = myListeners.get(listener);
    if (path == null) {
      return;
    }

    FileSystemListenersContainer.Node curr = root;
    myLock.writeLock().lock();
    try {
      for (String s : normalizeAndSplit(path)) {
        if ((s == null || s.length() == 0)) {
          continue;
        }
        curr = curr.child(s, false);
        if (curr == null) {
          return;
        }
      }
      curr.removeListener(listener);
    } finally {
      myLock.writeLock().unlock();
    }
    myListeners.remove(listener);
  }
  public Iterable<FileSystemListener> listeners(String path) {
    FileSystemListenersContainer.Node curr = root;
    List<FileSystemListener> result = new ArrayList<FileSystemListener>();
    myLock.readLock().lock();
    try {
      root.storeListeners(result);
      for (String s : normalizeAndSplit(path)) {
        if ((s == null || s.length() == 0)) {
          continue;
        }
        curr = curr.child(s, false);
        if (curr == null) {
          return result;
        }
        curr.storeListeners(result);
      }
    } finally {
      myLock.readLock().unlock();
    }
    return result;
  }
  private String[] normalizeAndSplit(String path) {
    String normalized = path.replace('\\', '/');
    return myPathSplitPattern.split(normalized, 0);
  }
  public boolean contains(FileSystemListener listener) {
    return myListeners.containsKey(listener);
  }
  private static class Node {
    private List<FileSystemListener> listeners;
    private final String pathPart;
    private final Map<String, FileSystemListenersContainer.Node> children = new HashMap<String, FileSystemListenersContainer.Node>(8);
    private final FileSystemListenersContainer.Node parent;
    /*package*/ Node(String pathPart, FileSystemListenersContainer.Node parent) {
      this.parent = parent;
      this.pathPart = pathPart;
    }
    /*package*/ FileSystemListenersContainer.Node child(String part, boolean create) {
      FileSystemListenersContainer.Node child = children.get(part);
      if (child == null && create) {
        child = new FileSystemListenersContainer.Node(part, this);
        children.put(part, child);
      }
      return child;
    }
    private void deleteIfEmpty() {
      if (parent == null || !(children.isEmpty())) {
        return;
      }
      if (listeners != null && !(listeners.isEmpty())) {
        return;
      }

      listeners = null;
      parent.children.remove(pathPart);
      parent.deleteIfEmpty();
    }
    /*package*/ void storeListeners(List<FileSystemListener> result) {
      if (listeners != null) {
        result.addAll(listeners);
      }
    }
    /*package*/ void addListener(FileSystemListener l) {
      if (listeners == null) {
        listeners = new ArrayList<FileSystemListener>(5);
      }
      listeners.add(l);
    }
    /*package*/ void removeListener(FileSystemListener l) {
      if (listeners != null && listeners.remove(l)) {
        deleteIfEmpty();
      }
    }
  }
}
