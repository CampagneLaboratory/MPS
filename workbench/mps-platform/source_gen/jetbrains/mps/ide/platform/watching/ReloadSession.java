package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.concurrent.atomic.AtomicInteger;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.progress.ProgressMonitor;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.progress.SubProgressKind;
import jetbrains.mps.classloading.MPSClassesReloadManager;
import jetbrains.mps.progress.EmptyProgressMonitor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class ReloadSession {
  private List<ReloadListener> myListeners = ListSequence.fromList(new ArrayList<ReloadListener>());
  private boolean myReloaded = false;
  private Map<Class, ReloadParticipant> myParticipants = MapSequence.fromMap(new HashMap<Class, ReloadParticipant>());
  private boolean myEmpty = true;
  private AtomicInteger myEmployCount = new AtomicInteger(0);


  public ReloadSession(Iterable<ReloadListener> listeners) {
    ListSequence.fromList(myListeners).addSequence(Sequence.fromIterable(listeners));
  }



  /*package*/ boolean isBeingEmployed() {
    return myEmployCount.get() > 0;
  }



  /*package*/ void incEmployCount() {
    int count = myEmployCount.incrementAndGet();
    assert count >= 0;
  }



  /*package*/ void decEmployCount() {
    int count = myEmployCount.decrementAndGet();
    assert count >= 0;
  }



  /*package*/ boolean isEmpty() {
    return myEmpty;
  }



  /*package*/ void updateStatus() {
    this.myEmpty = Sequence.fromIterable(getParticipants()).all(new IWhereFilter<ReloadParticipant>() {
      public boolean accept(ReloadParticipant it) {
        return it.isEmpty();
      }
    });
  }



  /*package*/ void doReload(final ProgressMonitor monitor) {
    assert !(myReloaded) : "Contract: do not call doReload twice on one reload session";
    myReloaded = true;

    monitor.start("Reloading ...", 2);
    fireReloadStarted();
    try {
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          int work = 1;
          for (ReloadParticipant rp : getParticipants()) {
            rp.update(monitor.subTask(work++, SubProgressKind.REPLACING));
          }

          if (MPSClassesReloadManager.getInstance().isReloadRequested()) {
            monitor.subTask(1, SubProgressKind.REPLACING).start("Reloading classes... Please wait.", 1);
            MPSClassesReloadManager.getInstance().reloadMPSClasses(new EmptyProgressMonitor());
          }
        }
      });
    } finally {
      if (LOG.isInfoEnabled()) {
        LOG.info("Reload finished.");
      }
      monitor.done();
      fireReloadFinished();
    }
  }



  /*package*/ void clear() {
    ListSequence.fromList(myListeners).clear();
    MapSequence.fromMap(myParticipants).clear();
  }



  /*package*/ <T extends ReloadParticipant> T getParticipant(Class<T> participantClass) {
    ReloadParticipant p = MapSequence.fromMap(myParticipants).get(participantClass);
    if (p == null) {
      try {
        p = participantClass.newInstance();
        MapSequence.fromMap(myParticipants).put(participantClass, p);
      } catch (IllegalAccessException e) {
      } catch (InstantiationException e) {
      }
    }
    return (T) p;
  }



  private Iterable<ReloadParticipant> getParticipants() {
    return MapSequence.fromMap(myParticipants).values();
  }

  private void fireReloadStarted() {
    for (ReloadListener rl : myListeners) {
      rl.reloadStarted();
    }
  }

  private void fireReloadFinished() {
    for (ReloadListener rl : myListeners) {
      rl.reloadFinished();
    }
  }

  protected static Logger LOG = LogManager.getLogger(ReloadSession.class);
}
