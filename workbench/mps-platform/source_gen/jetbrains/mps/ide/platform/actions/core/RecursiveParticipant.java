package jetbrains.mps.ide.platform.actions.core;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public interface RecursiveParticipant<InitialDataObject, FinalDataObject> extends RefactoringParticipant<InitialDataObject, FinalDataObject> {

  public List<RefactoringParticipant.Change<InitialDataObject, FinalDataObject>> getChanges(InitialDataObject initialState, SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, Iterable<RefactoringParticipant.ParticipantState> parents);

  public static class RecursiveParticipantState<I, F> extends MoveNodeRefactoringParticipant.MoveNodeParticipantState<I, F> {
    private Iterable<RefactoringParticipant.ParticipantState> myParents;
    public static <I, F> RecursiveParticipant.RecursiveParticipantState<I, F> create(MoveNodeRefactoringParticipant<I, F> participant, SNode oldNode, Iterable<RefactoringParticipant.ParticipantState> parents) {
      return new RecursiveParticipant.RecursiveParticipantState<I, F>(participant, oldNode, parents);
    }
    private RecursiveParticipantState(MoveNodeRefactoringParticipant<I, F> participant, SNode oldNode, Iterable<RefactoringParticipant.ParticipantState> parents) {
      super(participant, oldNode);
      myParents = parents;
    }
    @Override
    protected List<RefactoringParticipant.Change<I, F>> initChanges(SRepository repository, List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope) {
      if (getParticipant() instanceof RecursiveParticipant) {
        if (Sequence.fromIterable(myParents).any(new IWhereFilter<RefactoringParticipant.ParticipantState>() {
          public boolean accept(RefactoringParticipant.ParticipantState parent) {
            return eq_7nv468_a0a0a0a0a0a0a0a3d_0(parent.getParticipant(), RecursiveParticipantState.this.getParticipant()) && eq_7nv468_a0a0a0a0a0a0a0a3d(parent.getInitialState(), RecursiveParticipantState.this.getInitialState());
          }
        })) {
          // todo: checked exception 
          throw new IllegalStateException("infinite recursion detected");
        } else {
          return ((RecursiveParticipant<I, F>) getParticipant()).getChanges(getInitialState(), repository, selectedOptions, searchScope, Sequence.fromIterable(myParents).concat(Sequence.fromIterable(Sequence.<RefactoringParticipant.ParticipantState>singleton(this))));
        }
      } else {
        return super.initChanges(repository, selectedOptions, searchScope);
      }
    }
    private static boolean eq_7nv468_a0a0a0a0a0a0a0a3d(Object a, Object b) {
      return (a != null ? a.equals(b) : a == b);
    }
    private static boolean eq_7nv468_a0a0a0a0a0a0a0a3d_0(Object a, Object b) {
      return (a != null ? a.equals(b) : a == b);
    }
  }
}
