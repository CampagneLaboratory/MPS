package jetbrains.mps.ide.platform.actions.core;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import jetbrains.mps.ide.platform.refactoring.MoveNodesDialog;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.project.Project;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.platform.refactoring.RefactoringAccessEx;
import jetbrains.mps.ide.platform.refactoring.RefactoringViewAction;
import jetbrains.mps.ide.platform.refactoring.RefactoringViewItem;
import jetbrains.mps.smodel.CopyUtil;

public class MoveNodesDefault implements MoveNodesRefactoring {


  public String getName() {
    return "Move Nodes";
  }

  public static void moveNodes(List<SNode> nodes, MPSProject mpsProject) {
    MoveNodesDefault moveNodesDefault = new MoveNodesDefault();
    if (moveNodesDefault.isApplicable(mpsProject, nodes)) {
      moveNodesDefault.apply(mpsProject, nodes);
    }
  }

  public boolean isApplicable(MPSProject project, List<SNode> nodesToMove) {
    return canBeMoved(nodesToMove, project.getRepository());
  }

  public static boolean canBeMoved(final List<SNode> nodesToMove, SRepository repository) {
    if (ListSequence.fromList(nodesToMove).isEmpty()) {
      return false;
    }
    final Wrappers._boolean result = new Wrappers._boolean();
    repository.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        SNode firstNode = ListSequence.fromList(nodesToMove).first();
        final SContainmentLink containmentLink = firstNode.getContainmentLink();
        final SNode parent = firstNode.getParent();
        final SModel model = firstNode.getModel();
        result.value = ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return eq_92fyi8_a0a0a0a0a0a0a4a0a0a0a2a8(it.getContainmentLink(), containmentLink) && it.getParent() == parent && it.getModel() == model;
          }
        });
      }
    });
    return result.value;
  }

  public void apply(final MPSProject project, final List<SNode> nodesToMove) {

    final Wrappers._T<SModel> currentModel = new Wrappers._T<SModel>();
    final Wrappers._T<SContainmentLink> role = new Wrappers._T<SContainmentLink>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        currentModel.value = SNodeOperations.getModel(ListSequence.fromList(nodesToMove).first());
        role.value = ListSequence.fromList(nodesToMove).first().getContainmentLink();
      }
    });
    final NodeLocation newLocation = MoveNodesDialog.getSelectedObject(project.getProject(), currentModel.value, new MoveNodesDialog.ModelFilter("Choose Node or Model") {
      @Override
      public boolean check(NodeLocation selectedObject, SModel model) {
        return true;
      }
    });
    if (newLocation instanceof NodeLocation.NodeLocationChild) {
      ((NodeLocation.NodeLocationChild) newLocation).setRole(role.value);
    }
    if (newLocation == null) {
      return;
    }
    Map<SNodeReference, NodeLocation> moveMap = MapSequence.fromMap(new HashMap<SNodeReference, NodeLocation>());
    for (SNode node : ListSequence.fromList(nodesToMove)) {
      MapSequence.fromMap(moveMap).put(node.getReference(), newLocation);
    }
    doMove(project, moveMap, null);
  }

  public static class ToMoveItem extends MultiTuple._2<List<SNode>, NodeLocation> {
    public ToMoveItem() {
      super();
    }
    public ToMoveItem(List<SNode> nodes, NodeLocation newLocation) {
      super(nodes, newLocation);
    }
    public List<SNode> nodes(List<SNode> value) {
      return super._0(value);
    }
    public NodeLocation newLocation(NodeLocation value) {
      return super._1(value);
    }
    public List<SNode> nodes() {
      return super._0();
    }
    public NodeLocation newLocation() {
      return super._1();
    }
  }

  public static <I, F> List<MoveNodesDefault.ChangeWrapper<I, F>> getChangesFromModel(final MoveNodeRefactoringParticipant<I, F> participant, SNode nodeToMove, Project project) {
    I initialDataObject = participant.getDataCollector().beforeMove(nodeToMove);
    return ListSequence.fromList(participant.getChanges(initialDataObject, project.getRepository(), project.getScope())).select(new ISelector<RefactoringParticipant.Change<F>, MoveNodesDefault.ChangeWrapper<I, F>>() {
      public MoveNodesDefault.ChangeWrapper<I, F> select(RefactoringParticipant.Change<F> change) {
        MoveNodesDefault.ChangeWrapper<I, F> wrapper = new MoveNodesDefault.ChangeWrapper<I, F>();
        wrapper.myChange = change;
        wrapper.myParticipant = participant;
        return wrapper;
      }
    }).toListSequence();
  }

  public static <I, F> void confirmChangeFromModel(MoveNodesDefault.ChangeWrapper<I, F> changeWrapper, SNode movedNode, Project project, RefactoringSession refactoringSession) {
    F finalDataObject = changeWrapper.myParticipant.getDataCollector().afterMove(movedNode);
    changeWrapper.myChange.confirm(finalDataObject, project.getRepository(), refactoringSession);
  }

  @NotNull
  public static SNode resolveNode(SNodeReference nodeReference, Project project) {
    SNode node = nodeReference.resolve(project.getRepository());
    if (node == null) {
      throw new IllegalArgumentException("Node " + nodeReference + " doesn't exist in current project.");
    }
    return node;
  }

  public static class ChangeWrapper<I, F> {
    public RefactoringParticipant.Change<F> myChange;
    public MoveNodeRefactoringParticipant<I, F> myParticipant;
  }

  public static void doMove(final MPSProject project, final Map<SNodeReference, NodeLocation> moveMap, final Runnable callBack) {

    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (IMapping<SNodeReference, NodeLocation> moving : MapSequence.fromMap(moveMap)) {
          SNode node = resolveNode(moving.key(), project);
          if (!(moving.value().canInsert(project.getRepository(), node))) {
            throw new IllegalArgumentException();
          }
        }
      }
    });

    Map<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> changes = MapSequence.fromMap(new HashMap<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>>());
    for (MoveNodeRefactoringParticipant<?, ?> participant : Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.ide.platform.MoveNodeParticipantEP").getObjects()).toListSequence()) {
      Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>> participantChanges = MapSequence.fromMap(new HashMap<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>());
      MapSequence.fromMap(changes).put(participant, participantChanges);
      for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {
        MapSequence.fromMap(participantChanges).put(nodeRef, getChangesFromModel(participant, resolveNode(nodeRef, project), project));
      }
    }

    List<IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>>> changesAsList = MapSequence.fromMap(changes).where(new IWhereFilter<IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>>>() {
      public boolean accept(IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> it) {
        return MapSequence.fromMap(it.value()).isNotEmpty();
      }
    }).toListSequence();
    List<Integer> selectedOptions = SelectOptionsDialog.selectOptions(ProjectHelper.toIdeaProject(project), ListSequence.fromList(changesAsList).select(new ISelector<IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>>, String>() {
      public String select(IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> it) {
        return it.key().getDescription();
      }
    }).toListSequence(), "Select Participants");

    final Map<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> selectedChanges = MapSequence.fromMap(new HashMap<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>>());
    for (int i : selectedOptions) {
      IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> mapping = ListSequence.fromList(changesAsList).getElement(i);
      MapSequence.fromMap(selectedChanges).put(mapping.key(), mapping.value());
    }

    SearchResults searchResults = new SearchResults();
    final Map<SNodeReference, Boolean> shouldKeep = MapSequence.fromMap(new HashMap<SNodeReference, Boolean>());

    for (IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> participantChanges : MapSequence.fromMap(selectedChanges)) {
      for (IMapping<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>> nodeChanges : MapSequence.fromMap(participantChanges.value())) {
        MapSequence.fromMap(shouldKeep).put(nodeChanges.key(), false);
        for (MoveNodesDefault.ChangeWrapper<?, ?> change : ListSequence.fromList(nodeChanges.value())) {
          MapSequence.fromMap(shouldKeep).putValue(nodeChanges.key(), MapSequence.fromMap(shouldKeep).get(nodeChanges.key()) || (change.myChange.needsToPreserveOldNode()));
          searchResults.add(change.myChange.getSearchResult());
        }
      }
    }

    RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(), new RefactoringViewAction() {
      public void performAction(RefactoringViewItem refactoringViewItem) {
        if (callBack != null) {
          callBack.run();
        }

        Map<SNode, SNode> copyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
        Map<SNodeReference, SNode> nodesToMove = MapSequence.fromMap(new HashMap<SNodeReference, SNode>());
        for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {
          MapSequence.fromMap(nodesToMove).put(nodeRef, resolveNode(nodeRef, project));
        }
        CopyUtil.copyAndPreserveId(Sequence.fromIterable(MapSequence.fromMap(nodesToMove).values()).toListSequence(), copyMap);

        for (IMapping<SNodeReference, SNode> oldNode : MapSequence.fromMap(nodesToMove)) {
          if (!(MapSequence.fromMap(shouldKeep).get(oldNode.key()))) {
            SNodeOperations.detachNode(oldNode.value());
          }
        }

        RefactoringSessionImpl refactoringSession = new RefactoringSessionImpl();

        for (IMapping<MoveNodeRefactoringParticipant, Map<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>>> participantChanges : MapSequence.fromMap(selectedChanges)) {
          for (IMapping<SNodeReference, List<? extends MoveNodesDefault.ChangeWrapper<?, ?>>> nodeChanges : MapSequence.fromMap(participantChanges.value())) {
            for (MoveNodesDefault.ChangeWrapper<?, ?> change : ListSequence.fromList(nodeChanges.value())) {
              confirmChangeFromModel(change, MapSequence.fromMap(nodesToMove).get(nodeChanges.key()), project, refactoringSession);
            }
          }
        }
        refactoringSession.commit();
        refactoringViewItem.close();
      }
    }, searchResults, false, "Move nodes");
  }

  private static boolean eq_92fyi8_a0a0a0a0a0a0a4a0a0a0a2a8(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
