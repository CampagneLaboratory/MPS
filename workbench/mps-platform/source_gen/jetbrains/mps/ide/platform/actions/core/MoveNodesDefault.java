package jetbrains.mps.ide.platform.actions.core;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import jetbrains.mps.ide.platform.refactoring.MoveNodesDialog;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.CopyUtil;
import java.util.Iterator;
import jetbrains.mps.ide.platform.refactoring.RefactoringAccessEx;
import jetbrains.mps.ide.platform.refactoring.RefactoringViewAction;
import jetbrains.mps.ide.platform.refactoring.RefactoringViewItem;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.progress.EmptyProgressMonitor;
import java.util.Collection;
import jetbrains.mps.ide.findusages.model.SearchResult;

public class MoveNodesDefault implements MoveNodesRefactoring {


  public String getName() {
    return "Move Nodes";
  }

  public static void moveNodes(List<SNode> nodes, MPSProject mpsProject) {
    MoveNodesDefault moveNodesDefault = new MoveNodesDefault();
    if (moveNodesDefault.isApplicable(mpsProject, nodes)) {
      moveNodesDefault.apply(mpsProject, nodes);
    }
  }

  public boolean isApplicable(MPSProject project, List<SNode> nodesToMove) {
    return canBeMoved(nodesToMove, project.getRepository());
  }

  public static boolean canBeMoved(final List<SNode> nodesToMove, SRepository repository) {
    if (ListSequence.fromList(nodesToMove).isEmpty()) {
      return false;
    }
    final Wrappers._boolean result = new Wrappers._boolean();
    repository.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        SNode firstNode = ListSequence.fromList(nodesToMove).first();
        final SContainmentLink containmentLink = firstNode.getContainmentLink();
        final SNode parent = firstNode.getParent();
        final SModel model = firstNode.getModel();
        result.value = ListSequence.fromList(nodesToMove).all(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return eq_92fyi8_a0a0a0a0a0a0a4a0a0a0a2a8(it.getContainmentLink(), containmentLink) && it.getParent() == parent && it.getModel() == model;
          }
        });
      }
    });
    return result.value;
  }

  public void apply(final MPSProject project, final List<SNode> nodesToMove) {

    final Wrappers._T<SModel> currentModel = new Wrappers._T<SModel>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        currentModel.value = SNodeOperations.getModel(ListSequence.fromList(nodesToMove).first());
      }
    });
    final NodeLocation newLocation = MoveNodesDialog.getSelectedObject(project.getProject(), currentModel.value, new MoveNodesDialog.ModelFilter("Choose Node or Model") {
      @Override
      public boolean check(NodeLocation selectedObject, SModel model) {
        return true;
      }
    });
    if (newLocation == null) {
      return;
    }
    doMove(project, ListSequence.fromListAndArray(new ArrayList<ToMoveItem>(), new ToMoveItem(nodesToMove, newLocation)), null);
  }

  public static class ToMoveItem extends MultiTuple._2<List<SNode>, NodeLocation> {
    public ToMoveItem() {
      super();
    }
    public ToMoveItem(List<SNode> nodes, NodeLocation newLocation) {
      super(nodes, newLocation);
    }
    public List<SNode> nodes(List<SNode> value) {
      return super._0(value);
    }
    public NodeLocation newLocation(NodeLocation value) {
      return super._1(value);
    }
    public List<SNode> nodes() {
      return super._0();
    }
    public NodeLocation newLocation() {
      return super._1();
    }
  }

  public static void doMove(final MPSProject project, final List<ToMoveItem> toMove, final Runnable callBack) {

    final List<SContainmentLink> roles = ListSequence.fromList(new ArrayList<SContainmentLink>(ListSequence.fromList(toMove).count()));

    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        for (ToMoveItem nodesToMove : ListSequence.fromList(toMove)) {
          for (SNode node : ListSequence.fromList(nodesToMove.nodes())) {
            if (!(SNodeUtil.isAccessible(node, project.getRepository()))) {
              throw new IllegalArgumentException();
            }
          }
          final SContainmentLink role = ListSequence.fromList(nodesToMove.nodes()).first().getContainmentLink();
          if (!(ListSequence.fromList(nodesToMove.nodes()).all(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return eq_92fyi8_a0a0a0a0a0a2a0a0a0a0a3a41(it.getContainmentLink(), role);
            }
          }))) {
            throw new IllegalArgumentException();
          }
          ListSequence.fromList(roles).addElement(role);
          if (!(nodesToMove.newLocation().isValid(project.getRepository(), nodesToMove.nodes(), role))) {
            throw new IllegalArgumentException();
          }
        }
      }
    });

    final List<MoveRefactoringContributor> selectedBuilders = SelectContributorsDialog.selectContributors(ProjectHelper.toIdeaProject(project), Sequence.fromIterable(new ExtensionPoint<MoveRefactoringContributor.MoveNodesBuilderFactory>("jetbrains.mps.ide.platform.MoveNodesBuilderEP").getObjects()).select(new ISelector<MoveRefactoringContributor.MoveNodesBuilderFactory, MoveRefactoringContributor>() {
      public MoveRefactoringContributor select(MoveRefactoringContributor.MoveNodesBuilderFactory it) {
        return it.createContributor(new MoveContextImpl(project.getScope()));
      }
    }).where(new IWhereFilter<MoveRefactoringContributor>() {
      public boolean accept(MoveRefactoringContributor it) {
        return it != null;
      }
    }).toListSequence());

    final Wrappers._T<List<SNode>> nodesToMoveWithDescendants = new Wrappers._T<List<SNode>>();
    final Wrappers._T<SearchResults<SNode>> searchResults = new Wrappers._T<SearchResults<SNode>>();

    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        nodesToMoveWithDescendants.value = ListSequence.fromList(toMove).translate(new ITranslator2<ToMoveItem, SNode>() {
          public Iterable<SNode> translate(ToMoveItem it) {
            return it.nodes();
          }
        }).translate(new ITranslator2<SNode, SNode>() {
          public Iterable<SNode> translate(SNode it) {
            return SNodeOperations.getNodeDescendants(it, null, true, new SAbstractConcept[]{});
          }
        }).toListSequence();
        for (MoveRefactoringContributor builder : ListSequence.fromList(selectedBuilders)) {
          builder.willBeMoved(nodesToMoveWithDescendants.value);
        }
        searchResults.value = new SearchResults<SNode>();
        for (MoveRefactoringContributor builder : ListSequence.fromList(selectedBuilders)) {
          searchResults.value.addAll(builder.getAffectedNodes());
        }
      }
    });

    final Runnable refactorAction = new Runnable() {
      public void run() {
        project.getRepository().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            List<Boolean> shouldKeepOldNodes = ListSequence.fromList(new ArrayList<Boolean>(ListSequence.fromList(nodesToMoveWithDescendants.value).count()));
            for (MoveRefactoringContributor builder : ListSequence.fromList(selectedBuilders)) {
              List<Boolean> builderRequires = builder.shouldKeepOldNodes(ListSequence.fromList(nodesToMoveWithDescendants.value).select(new ISelector<SNode, Boolean>() {
                public Boolean select(SNode it) {
                  return ListSequence.fromList(toMove).translate(new ITranslator2<ToMoveItem, SNode>() {
                    public Iterable<SNode> translate(ToMoveItem it) {
                      return it.nodes();
                    }
                  }).contains(it);
                }
              }).toListSequence());
              for (int i = 0; i < ListSequence.fromList(shouldKeepOldNodes).count(); i++) {
                ListSequence.fromList(shouldKeepOldNodes).setElement(i, ListSequence.fromList(shouldKeepOldNodes).getElement(i) || (ListSequence.fromList(builderRequires).getElement(i)));
              }
            }

            final Map<SNode, SNode> copyMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
            List<List<SNode>> copied = ListSequence.fromList(new ArrayList<List<SNode>>(ListSequence.fromList(toMove).count()));
            for (ToMoveItem nodesToMove : ListSequence.fromList(toMove)) {
              ListSequence.fromList(copied).addElement(CopyUtil.copyAndPreserveId(nodesToMove.nodes(), copyMap));
            }

            {
              Iterator<SNode> oldNode_it = ListSequence.fromList(toMove).translate(new ITranslator2<ToMoveItem, SNode>() {
                public Iterable<SNode> translate(ToMoveItem it) {
                  return it.nodes();
                }
              }).iterator();
              Iterator<Boolean> shoudKeep_it = ListSequence.fromList(shouldKeepOldNodes).iterator();
              SNode oldNode_var;
              boolean shoudKeep_var;
              while (oldNode_it.hasNext() && shoudKeep_it.hasNext()) {
                oldNode_var = oldNode_it.next();
                shoudKeep_var = shoudKeep_it.next();
                if (!(shoudKeep_var)) {
                  SNodeOperations.detachNode(oldNode_var);
                }
              }
            }
            {
              Iterator<ToMoveItem> nodesToMove_it = ListSequence.fromList(toMove).iterator();
              Iterator<SContainmentLink> role_it = ListSequence.fromList(roles).iterator();
              Iterator<List<SNode>> copiedGroup_it = ListSequence.fromList(copied).iterator();
              ToMoveItem nodesToMove_var;
              SContainmentLink role_var;
              List<SNode> copiedGroup_var;
              while (nodesToMove_it.hasNext() && role_it.hasNext() && copiedGroup_it.hasNext()) {
                nodesToMove_var = nodesToMove_it.next();
                role_var = role_it.next();
                copiedGroup_var = copiedGroup_it.next();
                nodesToMove_var.newLocation().insertNodes(copiedGroup_var, role_var);
              }
            }
            for (MoveRefactoringContributor builder : ListSequence.fromList(selectedBuilders)) {
              builder.isMoved(ListSequence.fromList(nodesToMoveWithDescendants.value).select(new ISelector<SNode, SNode>() {
                public SNode select(SNode it) {
                  return MapSequence.fromMap(copyMap).get(it);
                }
              }).toListSequence());
            }
            for (MoveRefactoringContributor builder : ListSequence.fromList(selectedBuilders)) {
              builder.commit();
            }
            if (callBack != null) {
              callBack.run();
            }
          }
        });
      }
    };

    if (searchResults.value.getSearchResults().isEmpty()) {
      refactorAction.run();
    } else {
      RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(), new RefactoringViewAction() {
        public void performAction(RefactoringViewItem refactoringViewItem) {
          refactorAction.run();
          refactoringViewItem.close();
        }
      }, searchResults.value, false, "Move nodes");
    }
  }

  @Deprecated
  public Set<SReference> findUsages(MPSProject project, Iterable<SNode> nodes) {
    return FindUsagesFacade.getInstance().findUsages(project.getScope(), SetSequence.fromSetWithValues(new HashSet<SNode>(), Sequence.fromIterable(nodes).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return SNodeOperations.getNodeDescendants(it, null, true, new SAbstractConcept[]{});
      }
    })), new EmptyProgressMonitor());
  }

  @Deprecated
  public Map<SReference, SNode> classifyUsages(Iterable<SReference> usages) {
    Map<SReference, SNode> result = MapSequence.fromMap(new HashMap<SReference, SNode>());
    for (SReference ref : Sequence.fromIterable(usages)) {
      MapSequence.fromMap(result).put(ref, ref.getTargetNode());
    }
    return result;
  }

  @Deprecated
  public SearchResults<SNode> nodesToRefactoringResult(Collection<SNode> searchedNodes, Iterable<SNode> usages, final String category) {
    SearchResults<SNode> searchResults = new SearchResults<SNode>();
    searchResults.getSearchedNodes().addAll(searchedNodes);
    searchResults.getSearchResults().addAll(Sequence.fromIterable(usages).select(new ISelector<SNode, SearchResult<SNode>>() {
      public SearchResult<SNode> select(SNode it) {
        return new SearchResult<SNode>(it, category);
      }
    }).toListSequence());
    return searchResults;
  }


  @Deprecated
  public void updateUsage(SReference usage, SNode newTarget) {
    usage.getSourceNode().setReferenceTarget(usage.getLink(), newTarget);
  }

  private static boolean eq_92fyi8_a0a0a0a0a0a0a4a0a0a0a2a8(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
  private static boolean eq_92fyi8_a0a0a0a0a0a2a0a0a0a0a3a41(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}
