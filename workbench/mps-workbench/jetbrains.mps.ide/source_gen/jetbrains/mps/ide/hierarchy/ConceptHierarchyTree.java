package jetbrains.mps.ide.hierarchy;

/*Generated by MPS */

import jetbrains.mps.smodel.LanguageHierarchyCache;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.util.NameUtil;
import java.util.HashSet;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;

public class ConceptHierarchyTree extends AbstractHierarchyTree {
  private LanguageHierarchyCache myCache;
  public ConceptHierarchyTree(LanguageHierarchyCache cache, AbstractHierarchyView abstractHierarchyView, boolean isParentHierarchy) {
    super(abstractHierarchyView, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", isParentHierarchy);
    myCache = cache;
  }
  @Override
  protected Set<SNode> getParents(SNode node, Set<SNode> visited) throws CircularHierarchyException {
    if (visited.contains(node)) {
      throw new CircularHierarchyException(node, "circular concept hierarchy");
    }
    List<String> parents = LanguageHierarchyCache.getParentsNames(NameUtil.nodeFQName(node));
    Set<SNode> result = new HashSet<SNode>();
    for (String s : parents) {
      SNode conceptDeclaration = SModelUtil.findConceptDeclaration(s);
      result.add(conceptDeclaration);
    }
    return result;
  }
  @Override
  protected SNode getParent(SNode node) {
    if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration"))) {
      SNode concept = SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration"));
      SNode extendsConcept = SLinkOperations.getTarget(concept, MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xf979be93cfL, "extends"));
      if (extendsConcept == null && concept != MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept").getDeclarationNode()) {
        extendsConcept = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept").getDeclarationNode();
      }
      return extendsConcept;
    } else {
      return null;
    }
  }
  @Override
  protected Set<SNode> getDescendants(SNode conceptDeclaration, Set<SNode> visited) throws CircularHierarchyException {
    if (visited.contains(conceptDeclaration)) {
      throw new CircularHierarchyException(conceptDeclaration, "circular concept hierarchy");
    }
    Set<SNode> result = new HashSet<SNode>();
    for (String s : myCache.getDescendantsOfConcept(NameUtil.nodeFQName(conceptDeclaration))) {
      SNode abstractConceptDeclaration = SModelUtil.findConceptDeclaration(s);
      result.add(abstractConceptDeclaration);
    }
    return result;
  }
  @Override
  protected String noNodeString() {
    return "(no concept)";
  }
}
