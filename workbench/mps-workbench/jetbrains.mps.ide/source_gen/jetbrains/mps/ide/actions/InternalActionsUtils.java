package jetbrains.mps.ide.actions;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.ide.findusages.view.FindUtils;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.ide.findusages.model.SearchResult;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.apache.log4j.Level;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.references.UnregisteredNodes;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.ide.findusages.model.IResultProvider;
import jetbrains.mps.ide.findusages.findalgorithm.finders.IFinder;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchQuery;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.findusages.view.UsagesViewTool;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class InternalActionsUtils {
  public InternalActionsUtils() {
  }
  public static List<SNodeReference> getAllConcepts() {
    final List<SNodeReference> concepts = ListSequence.fromList(new ArrayList<SNodeReference>());
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        for (Object concept : FindUtils.getSearchResults(new EmptyProgressMonitor(), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration").getDeclarationNode(), GlobalScope.getInstance(), "jetbrains.mps.lang.structure.findUsages.ConceptInstances_Finder").getSearchResults()) {
          ListSequence.fromList(concepts).addElement(new SNodePointer(((SearchResult<SNode>) concept).getObject()));
        }
      }
    });
    return concepts;
  }
  public static void executeActionOnAllNodes(String actionName, ProgressMonitor monitor, final _FunctionTypes._void_P1_E0<? super SNode> nodeCallback) {
    final Wrappers._T<Iterable<SModelReference>> modelReferences = new Wrappers._T<Iterable<SModelReference>>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MPSModuleRepository.getInstance().getModules();
        if (LOG.isEnabledFor(Level.WARN)) {
          LOG.warn("Modules: " + Sequence.fromIterable(modules).count());
        }
        modelReferences.value = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {
          public Iterable<SModel> translate(SModule it) {
            return it.getModels();
          }
        }).select(new ISelector<SModel, SModelReference>() {
          public SModelReference select(SModel it) {
            return it.getReference();
          }
        });
        if (LOG.isEnabledFor(Level.WARN)) {
          LOG.warn("Models: " + Sequence.fromIterable(modelReferences.value).count());
        }
      }
    });

    monitor.start(actionName, Sequence.fromIterable(modelReferences.value).count());
    try {
      final Wrappers._int num = new Wrappers._int(0);

      for (final SModelReference modelRef : modelReferences.value) {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            // hack for conf stubs 
            UnregisteredNodes.instance().clear();
            if (num.value++ % 100 == 0) {
              if (LOG.isEnabledFor(Level.WARN)) {
                LOG.warn("Model num: " + num.value + ", name: " + SModelStereotype.withoutStereotype(modelRef.getModelName()));
              }
            }
            SModel model = SModelRepository.getInstance().getModelDescriptor(modelRef);
            if (model != null) {
              for (SNode node : SNodeUtil.getDescendants(model)) {
                try {
                  nodeCallback.invoke(node);
                } catch (Throwable t) {
                  if (LOG.isEnabledFor(Level.ERROR)) {
                    LOG.error("Exception in callback for node " + node, t);
                  }
                }
              }
            }
          }
        });
        monitor.advance(1);
        if (monitor.isCanceled()) {
          break;
        }
      }
    } finally {
      monitor.done();
    }
  }
  public static void executeActionOnAllNodesInModal(final String actionName, Project project, final _FunctionTypes._void_P1_E0<? super SNode> nodeCallback) {
    if (ModelAccess.instance().canWrite()) {
      throw new IllegalStateException("Must be executed outside of write action");
    }
    ProgressManager.getInstance().run(new Task.Modal(project, actionName, true) {
      @Override
      public void run(@NotNull ProgressIndicator indicator) {
        InternalActionsUtils.executeActionOnAllNodes(actionName, new ProgressMonitorAdapter(indicator), nodeCallback);
      }
    });
  }
  public static void showUsagesViewForNodes(Project project, final List<SNodeReference> nodes) {
    IResultProvider provider = FindUtils.makeProvider(new IFinder() {
      @Override
      public SearchResults find(SearchQuery query, ProgressMonitor progress) {
        SearchResults<SNode> results = new SearchResults<SNode>();
        for (SNode node : ListSequence.fromList(nodes).select(new ISelector<SNodeReference, SNode>() {
          public SNode select(SNodeReference it) {
            return ((SNodePointer) it).resolve(MPSModuleRepository.getInstance());
          }
        }).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return it != null;
          }
        })) {
          results.getSearchResults().add(new SearchResult<SNode>(node, "Uncategorized"));
        }
        return results;
      }
    });

    project.getComponent(UsagesViewTool.class).findUsages(provider, new SearchQuery(GlobalScope.getInstance()), false, true, false, "Nothing");
  }
  protected static Logger LOG = LogManager.getLogger(InternalActionsUtils.class);
}
