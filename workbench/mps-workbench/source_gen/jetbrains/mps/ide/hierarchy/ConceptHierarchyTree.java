package jetbrains.mps.ide.hierarchy;

/*Generated by MPS */

import jetbrains.mps.smodel.LanguageHierarchyCache;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.util.NameUtil;
import java.util.HashSet;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;

public class ConceptHierarchyTree extends AbstractHierarchyTree {
  private LanguageHierarchyCache myCache;

  public ConceptHierarchyTree(LanguageHierarchyCache cache, AbstractHierarchyView abstractHierarchyView, boolean isParentHierarchy) {
    super(abstractHierarchyView, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", isParentHierarchy);
    myCache = cache;
  }

  @Override
  protected Set<SNode> getParents(SNode node, Set<SNode> visited) throws CircularHierarchyException {
    if (visited.contains(node)) {
      throw new CircularHierarchyException(node, "circular concept hierarchy");
    }
    List<String> parents = LanguageHierarchyCache.getParentsNames(NameUtil.nodeFQName(node));
    Set<SNode> result = new HashSet<SNode>();
    for (String s : parents) {
      SNode conceptDeclaration = SModelUtil.findConceptDeclaration(s);
      result.add(conceptDeclaration);
    }
    return result;
  }

  @Override
  protected SNode getParent(SNode node) {
    if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.lang.structure.structure.ConceptDeclaration")) {
      SNode concept = SNodeOperations.cast(node, "jetbrains.mps.lang.structure.structure.ConceptDeclaration");
      SNode extendsConcept = SLinkOperations.getTarget(concept, "extends", false);
      if (extendsConcept == null && concept != SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.core.structure.BaseConcept")) {
        extendsConcept = SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.core.structure.BaseConcept");
      }
      return extendsConcept;
    } else {
      return null;
    }
  }

  @Override
  protected Set<SNode> getDescendants(SNode conceptDeclaration, Set<SNode> visited) throws CircularHierarchyException {
    if (visited.contains(conceptDeclaration)) {
      throw new CircularHierarchyException(conceptDeclaration, "circular concept hierarchy");
    }
    Set<SNode> result = new HashSet<SNode>();
    for (String s : myCache.getDescendantsOfConcept(NameUtil.nodeFQName(conceptDeclaration))) {
      SNode abstractConceptDeclaration = SModelUtil.findConceptDeclaration(s);
      result.add(abstractConceptDeclaration);
    }
    return result;
  }

  @Override
  protected String noNodeString() {
    return "(no concept)";
  }
}
