package jetbrains.mps.ide.findusages.caches;

/*Generated by MPS */

import jetbrains.mps.reloading.ClassBytesProvider;
import jetbrains.mps.reloading.AbstractClassPathItem;
import org.objectweb.asm.ClassReader;
import jetbrains.mps.baseLanguage.javastub.asm.ASMClass;
import jetbrains.mps.stubs.javastub.classpath.ClassifierKind;
import org.objectweb.asm.tree.InnerClassNode;
import org.objectweb.asm.Opcodes;

public class CacheClassifierLoader {
  private ClassBytesProvider myCpItem;
  private CacheClassifierUpdater myUpdater;

  public CacheClassifierLoader(ClassBytesProvider cpItem, CacheClassifierUpdater updater) {
    myCpItem = cpItem;
    myUpdater = updater;
  }

  public void getClassifier(String pack, String name) {
    if (AbstractClassPathItem.isAnonymous(name)) {
      return;
    }

    String cp = ((pack.length() == 0) ?
      "" :
      pack + "."
    );
    byte[] code = myCpItem.getClass(cp + name);
    if (code == null) {
      return;
    }
    ClassReader reader = new ClassReader(code);
    ASMClass ac = new ASMClass(reader);
    myUpdater.updateClassifier(ClassifierKind.getClassifierKind(reader), ac);
    updateInnerClassifiers(pack, ac);
  }

  private void updateInnerClassifiers(String pack, ASMClass ac) {
    for (InnerClassNode cn : ac.getInnerClasses()) {
      if ((cn.access & Opcodes.ACC_SYNTHETIC) != 0) {
        continue;
      }

      boolean isPrivate = (cn.access & Opcodes.ACC_PRIVATE) != 0;
      if (isPrivate && myUpdater.isSkipPrivate()) {
        continue;
      }

      String name = cn.name;
      if (name == null) {
        continue;
      }
      if (!(name.startsWith(ac.getName() + "$"))) {
        continue;
      }

      int index = name.lastIndexOf("/");
      if (index != -1) {
        name = name.substring(index + 1);
      }

      getClassifier(pack, name);
    }
  }
}
