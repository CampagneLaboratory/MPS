package jetbrains.mps.ide.findusages.caches;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import jetbrains.mps.baseLanguage.javastub.SReferenceHandler;
import jetbrains.mps.stubs.javastub.classpath.ClassifierKind;
import jetbrains.mps.baseLanguage.javastub.asm.ASMClass;
import jetbrains.mps.baseLanguage.javastub.asm.ASMTypeVariable;
import jetbrains.mps.baseLanguage.javastub.asm.ASMFormalTypeParameter;
import jetbrains.mps.baseLanguage.javastub.asm.ASMType;
import jetbrains.mps.baseLanguage.javastub.asm.ASMMethod;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.javastub.asm.ASMAnnotation;
import jetbrains.mps.baseLanguage.javastub.asm.ASMField;
import java.util.List;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.javastub.asm.ASMClassType;
import jetbrains.mps.baseLanguage.javastub.asm.ASMPrimitiveType;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.baseLanguage.javastub.asm.ASMEnumValue;
import jetbrains.mps.baseLanguage.javastub.asm.ASMArrayType;
import jetbrains.mps.baseLanguage.javastub.asm.ASMVarArgType;
import jetbrains.mps.baseLanguage.javastub.asm.ASMParameterizedType;
import jetbrains.mps.baseLanguage.javastub.asm.ASMExtendsType;
import jetbrains.mps.baseLanguage.javastub.asm.ASMSuperType;
import jetbrains.mps.util.NodeNameUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.baseLanguage.javastub.ASMNodeId;
import jetbrains.mps.smodel.SReference;

public class CacheClassifierUpdater {
  protected static Log log = LogFactory.getLog(CacheClassifierUpdater.class);

  private final boolean mySkipPrivate;
  private SReferenceHandler myHandler;

  public CacheClassifierUpdater(boolean skipPrivate, SReferenceHandler handler) {
    mySkipPrivate = skipPrivate;
    this.myHandler = handler;
  }

  public void updateClassifier(ClassifierKind clsfr, ASMClass ac) {
    if (clsfr == ClassifierKind.ANNOTATIONS) {
      updateAnnotationMethods(ac);
      updateAnnotations(ac);
    } else if (clsfr == ClassifierKind.CLASS) {
      updateAnnotations(ac);
      updateTypeVariables(ac);
      updateExtendsAndImplements(ac);
      updateInstanceFields(ac);
      updateStaticFields(ac);
      updateConstructors(ac);
      updateInstanceMethods(ac);
      updateStaticMethods(ac);
    } else if (clsfr == ClassifierKind.INTERFACE) {
      updateAnnotations(ac);
      updateTypeVariables(ac);
      updateExtendsForInterface(ac);
      updateStaticFields(ac);
      updateInstanceMethods(ac);
    } else {
      return;
    }
  }

  private void updateTypeVariables(ASMClass cls) {
    for (ASMTypeVariable tv : cls.getTypeParameters()) {
      if (tv instanceof ASMFormalTypeParameter) {
        ASMFormalTypeParameter tp = (ASMFormalTypeParameter) tv;
        if (tp.getClassBound() != null) {
          getTypeByASMType(tp.getClassBound());
        }
        for (ASMType act : tp.getInterfaceBounds()) {
          getTypeByASMType(act);
        }
      }
    }
  }

  private void updateTypeVariables(ASMMethod method) {
    Map<ASMTypeVariable, SNode> typeVars = MapSequence.fromMap(new HashMap<ASMTypeVariable, SNode>());
    for (ASMTypeVariable tv : method.getTypeParameters()) {
      SNode tvd = MapSequence.fromMap(typeVars).get(tv);
      if (tv instanceof ASMFormalTypeParameter) {
        ASMFormalTypeParameter tp = (ASMFormalTypeParameter) tv;
        if (tp.getClassBound() != null) {
          getTypeByASMType(tp.getClassBound());
        }
        for (ASMType act : tp.getInterfaceBounds()) {
          getTypeByASMType(act);
        }
      }
    }
  }

  private void updateAnnotations(ASMClass ac) {
    for (ASMAnnotation annotation : ac.getAnnotations()) {
      createAnnotation(annotation);
    }
  }

  private void updateExtendsForInterface(ASMClass ac) {
    for (ASMType type : ac.getGenericInterfaces()) {
      getTypeByASMType(type);
    }
  }

  private void updateExtendsAndImplements(ASMClass ac) {
    ASMType refSuperclass = ac.getGenericSuperclass();
    if (refSuperclass != null) {
      getTypeByASMType(refSuperclass);
    }
    for (ASMType type : ac.getGenericInterfaces()) {
      getTypeByASMType(type);
    }
  }

  private void updateInstanceFields(ASMClass refCls) {
    for (ASMField field : refCls.getDeclaredFields()) {
      if (field.isPrivate() && mySkipPrivate) {
        continue;
      }
      if (field.isStatic()) {
        continue;
      }
      if (field.isCompilerGenerated()) {
        continue;
      }
      getTypeByASMType(field.getGenericType());
      for (ASMAnnotation annotation : field.getAnnotations()) {
        createAnnotation(annotation);
      }
    }
  }

  private void updateStaticFields(ASMClass ac) {
    for (ASMField field : ac.getDeclaredFields()) {
      if (field.isPrivate() && mySkipPrivate) {
        continue;
      }
      if (!(field.isStatic())) {
        continue;
      }
      if (field.isCompilerGenerated()) {
        continue;
      }
      if (field.isEnumConstant()) {
        continue;
      } else {
        getTypeByASMType(field.getGenericType());
        for (ASMAnnotation annotation : field.getAnnotations()) {
          createAnnotation(annotation);
        }
      }
    }
  }

  private void updateAnnotationMethods(ASMClass refCls) {
    for (ASMMethod m : refCls.getDeclaredMethods()) {
      getTypeByASMType(m.getGenericReturnType());
      if (m.getAnnotationDefault() != null) {
        getAnnotationValue(m.getAnnotationDefault());
      }
    }
  }

  private void updateConstructors(ASMClass ac) {
    for (ASMMethod c : ac.getDeclaredConstructors()) {
      if (c.isSynthetic()) {
        continue;
      }
      if (c.isPrivate() && mySkipPrivate) {
        continue;
      }

      {
        ASMType pt;
        String pn;
        List<ASMAnnotation> pa;
        Iterator<ASMType> pt_iterator = ListSequence.fromList(c.getGenericParameterTypes()).iterator();
        Iterator<String> pn_iterator = ListSequence.fromList(c.getParameterNames()).iterator();
        Iterator<List<ASMAnnotation>> pa_iterator = ListSequence.fromList(c.getParameterAnnotations()).iterator();
        while (true) {
          if (!(pt_iterator.hasNext())) {
            break;
          }
          if (!(pn_iterator.hasNext())) {
            break;
          }
          if (!(pa_iterator.hasNext())) {
            break;
          }
          pt = pt_iterator.next();
          pn = pn_iterator.next();
          pa = pa_iterator.next();
          getTypeByASMType(pt);
        }
      }
      for (ASMAnnotation annotation : c.getAnnotations()) {
        createAnnotation(annotation);
      }
      for (ASMType exception : c.getExceptionTypes()) {
        getTypeByASMType(exception);
      }
    }
  }

  private void updateInstanceMethods(ASMClass ac) {
    for (ASMMethod m : ac.getDeclaredMethods()) {
      if (m.isPrivate() && mySkipPrivate) {
        continue;
      }
      if (m.isStatic()) {
        continue;
      }
      if (m.isBridge()) {
        continue;
      }
      if (m.isCompilerGenerated()) {
        continue;
      }

      this.updateBaseMethod(m);
    }
  }

  private void updateStaticMethods(ASMClass ac) {
    for (ASMMethod m : ac.getDeclaredMethods()) {
      if (m.isPrivate() && mySkipPrivate) {
        continue;
      }
      if (!(m.isStatic())) {
        continue;
      }
      if (m.isCompilerGenerated()) {
        continue;
      }

      updateBaseMethod(m);
    }
  }

  private void updateBaseMethod(ASMMethod m) {
    updateTypeVariables(m);
    getTypeByASMType(m.getGenericReturnType());
    {
      ASMType pt;
      String pn;
      List<ASMAnnotation> pa;
      Iterator<ASMType> pt_iterator = ListSequence.fromList(m.getGenericParameterTypes()).iterator();
      Iterator<String> pn_iterator = ListSequence.fromList(m.getParameterNames()).iterator();
      Iterator<List<ASMAnnotation>> pa_iterator = ListSequence.fromList(m.getParameterAnnotations()).iterator();
      while (true) {
        if (!(pt_iterator.hasNext())) {
          break;
        }
        if (!(pn_iterator.hasNext())) {
          break;
        }
        if (!(pa_iterator.hasNext())) {
          break;
        }
        pt = pt_iterator.next();
        pn = pn_iterator.next();
        pa = pa_iterator.next();
        getTypeByASMType(pt);
      }
    }
    for (ASMType exception : m.getExceptionTypes()) {
      getTypeByASMType(exception);
    }
    for (ASMAnnotation annotation : m.getAnnotations()) {
      createAnnotation(annotation);
    }
  }

  private void createAnnotation(ASMAnnotation annotation) {
    ASMClassType c = (ASMClassType) annotation.getType();
    addClassifierReference(c);
    Map<String, Object> values = ((Map<String, Object>) annotation.getValues());
    for (String key : MapSequence.fromMap(values).keySet()) {
      getAnnotationValue(MapSequence.fromMap(values).get(key));
      addAnnotationMethodReference(c, key);
    }
  }

  private void getAnnotationValue(Object value) {
    if (value instanceof ASMAnnotation) {
      createAnnotation((ASMAnnotation) value);
      return;
    }
    if (value instanceof ASMPrimitiveType) {
      getTypeByASMType((ASMPrimitiveType) value);
      return;
    }
    if (value instanceof List) {
      List<Object> list = (List<Object>) value;
      ListSequence.fromList(list).visitAll(new IVisitor<Object>() {
        public void visit(Object it) {
          getAnnotationValue(it);
        }
      });
      return;
    }
    if (value instanceof ASMEnumValue) {
      ASMEnumValue enumValue = (ASMEnumValue) value;
      ASMClassType c = (ASMClassType) enumValue.getType();
      addClassifierReference(c);
      addEnumConstReference(enumValue);
      return;
    }
    if (value instanceof ASMClassType) {
      addClassifierReference((ASMClassType) value);
      return;
    }
    if (log.isErrorEnabled()) {
      log.error("couldn't create annotation value from " + ((value == null ?
        "" :
        value.getClass().getName()
      )) + " : " + value);
    }
  }

  private void getTypeByASMType(ASMType type) {
    if (type instanceof ASMArrayType) {
      getTypeByASMType(((ASMArrayType) type).getElementType());
    }
    if (type instanceof ASMVarArgType) {
      getTypeByASMType(((ASMVarArgType) type).getElementType());
    }
    if (type instanceof ASMTypeVariable) {
      getTypeByASMType(ASMClassType.OBJECT);
    }
    if (type instanceof ASMClassType) {
      ASMClassType c = (ASMClassType) type;
      addClassifierReference(c);
    }
    if (type instanceof ASMParameterizedType) {
      ASMParameterizedType pt = (ASMParameterizedType) type;
      getTypeByASMType(pt.getRawType());
      addTypeParameters(pt.getActualTypeArguments());
    }
    if (type instanceof ASMExtendsType) {
      ASMExtendsType e = (ASMExtendsType) type;
      if (e.getBase() instanceof ASMClassType) {
        ASMClassType ct = (ASMClassType) e.getBase();
      }
      getTypeByASMType(e.getBase());
    }
    if (type instanceof ASMSuperType) {
      ASMSuperType e = (ASMSuperType) type;
      getTypeByASMType(e.getBase());
    }
  }

  private void addTypeParameters(List<? extends ASMType> typeParameters) {
    for (ASMType tv : typeParameters) {
      getTypeByASMType(tv);

    }
  }

  private void addClassifierReference(ASMClassType clsType) {
    String pack = NodeNameUtil.getNamespace(clsType.getName());
    String resolve = NameUtil.shortNameFromLongName(clsType.getName());
    resolve = resolve.replaceAll("\\$", ".");
    SNodeId nodeId = ASMNodeId.createId(clsType.getName());
    SReference ref = myHandler.createSReference(null, pack, nodeId, null, resolve, "abc");
  }

  private void addAnnotationMethodReference(ASMClassType annotationType, String method) {
    String pack = NodeNameUtil.getNamespace(annotationType.getName());
    SNodeId nodeId = ASMNodeId.createAnnotationMethodId(annotationType.getName(), method);
    String resolve = NameUtil.shortNameFromLongName(annotationType.getName());
    resolve = resolve.replaceAll("\\$", ".");
    SReference ref = myHandler.createSReference(null, pack, nodeId, null, resolve, "abc");
  }

  private void addEnumConstReference(ASMEnumValue enumValue) {
    ASMClassType classType = (ASMClassType) enumValue.getType();
    String pack = NodeNameUtil.getNamespace(classType.getName());
    String resolve = NameUtil.shortNameFromLongName(classType.getName());
    resolve = resolve.replaceAll("\\$", ".");
    SNodeId nodeId = ASMNodeId.createFieldId(classType.getName(), enumValue.getConstant());
    SReference ref = myHandler.createSReference(null, pack, nodeId, null, resolve, "abc");
  }

  public boolean isSkipPrivate() {
    return mySkipPrivate;
  }
}
