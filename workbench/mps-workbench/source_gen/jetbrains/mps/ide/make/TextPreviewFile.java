package jetbrains.mps.ide.make;

/*Generated by MPS */

import com.intellij.openapi.vfs.newvfs.impl.StubVirtualFile;
import java.util.Map;
import java.util.Arrays;
import org.jetbrains.annotations.NotNull;
import java.io.IOException;
import java.nio.charset.Charset;
import jetbrains.mps.util.FileUtil;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vfs.VirtualFileSystem;
import com.intellij.openapi.vfs.newvfs.NewVirtualFileSystem;
import com.intellij.openapi.util.io.FileAttributes;
import java.io.OutputStream;
import java.io.InputStream;
import com.intellij.util.ArrayUtil;

public class TextPreviewFile extends StubVirtualFile {
  private static TextPreviewFile.TextPreviewVirtualFileSystem FS = new TextPreviewFile.TextPreviewVirtualFileSystem();
  public static final String COMPLEX_CONTENT = "<complex content>";
  private String[] forkNames;
  private Map<String, Object> forks;
  private String name;
  private String path;

  public TextPreviewFile(String name, String path, Map<String, Object> forks) {
    this.name = name;
    this.path = path;
    this.forks = forks;
    this.forkNames = forks.keySet().toArray(new String[forks.size()]);
    Arrays.sort(forkNames);
  }

  public String[] forkNames() {
    return forkNames.clone();
  }

  public CharSequence fork(String name) {
    Object contents = forks.get(name);
    return ((contents instanceof String) ?
      (String) contents :
      "<binary content>"
    );
  }

  @NotNull
  @Override
  public byte[] contentsToByteArray() throws IOException {
    if (forks.size() == 1) {
      final Object next = forks.values().iterator().next();
      if (next instanceof String) {
        return ((String) next).getBytes(getCharset());
      }
    }
    return COMPLEX_CONTENT.getBytes(getCharset());
  }

  @Override
  public Charset getCharset() {
    return FileUtil.DEFAULT_CHARSET;
  }

  @NotNull
  @NonNls
  @Override
  public String getName() {
    return name;
  }

  @Override
  public long getTimeStamp() {
    return 0L;
  }

  @Override
  public long getModificationStamp() {
    return 0L;
  }

  @Override
  public String getPath() {
    return path;
  }

  @Nullable
  @Override
  public VirtualFile getParent() {
    return null;
  }

  @NotNull
  @Override
  public String getUrl() {
    return TextPreviewFile.TextPreviewVirtualFileSystem.PROTOCOL + getPath();
  }

  @NotNull
  @Override
  public VirtualFileSystem getFileSystem() {
    return FS;
  }

  @Override
  public boolean isDirectory() {
    return false;
  }

  @Override
  public boolean isValid() {
    return true;
  }

  @Override
  public boolean isWritable() {
    return false;
  }

  @Override
  public long getLength() {
    // TODO: override getFileType() to get right text highlighting 
    return 0;
  }

  private static class TextPreviewVirtualFileSystem extends NewVirtualFileSystem {
    private static String PROTOCOL = "preview";

    public TextPreviewVirtualFileSystem() {
    }

    @Override
    public String getCanonicallyCasedName(VirtualFile file) {
      return file.getName();
    }

    @Nullable
    public FileAttributes getAttributes(@NotNull VirtualFile file) {
      if (file instanceof TextPreviewFile) {
        TextPreviewFile previewFile = (TextPreviewFile) file;
        long length = COMPLEX_CONTENT.length();
        if (previewFile.forks.size() == 1) {
          Object next = previewFile.forks.values().iterator().next();
          if (next instanceof String) {
            length = ((String) next).length();
          }
        }
        return new FileAttributes(false, false, false, false, length, previewFile.getModificationStamp(), false);
      }
      return null;
    }

    @Override
    public boolean markNewFilesAsDirty() {
      return false;
    }

    @Override
    public boolean isReadOnly() {
      return true;
    }

    @Override
    public void refresh(boolean b) {
    }

    @Override
    public void refreshWithoutFileWatcher(boolean b) {
    }

    @Nullable
    @Override
    protected String normalize(String string) {
      return string;
    }

    @Nullable
    @Override
    public VirtualFile refreshAndFindFileByPath(@NotNull String string) {
      return null;
    }

    @Nullable
    @Override
    public VirtualFile findFileByPathIfCached(@NotNull @NonNls String string) {
      return null;
    }

    @Nullable
    @Override
    public VirtualFile findFileByPath(@NotNull @NonNls String string) {
      return null;
    }

    @Override
    @NotNull
    public String extractPresentableUrl(@NotNull String string) {
      return string;
    }

    public void renameFile(Object object, @NotNull VirtualFile file, @NotNull String string) throws IOException {
    }

    public void moveFile(Object object, @NotNull VirtualFile file, @NotNull VirtualFile file1) throws IOException {
    }

    public void deleteFile(Object object, @NotNull VirtualFile file) throws IOException {
    }

    public VirtualFile createChildFile(Object object, @NotNull VirtualFile file, @NotNull String string) throws IOException {
      return null;
    }

    @NotNull
    public VirtualFile createChildDirectory(Object object, @NotNull VirtualFile file, @NotNull String string) throws IOException {
      return null;
    }

    public VirtualFile copyFile(Object object, @NotNull VirtualFile file, @NotNull VirtualFile file1, @NotNull String string) throws IOException {
      return null;
    }

    public int getRank() {
      return 0;
    }

    protected String extractRootPath(@NotNull String string) {
      return "/";
    }

    public boolean isCaseSensitive() {
      return false;
    }

    public long getLength(VirtualFile file) {
      return 0L;
    }

    @NotNull
    public OutputStream getOutputStream(VirtualFile file, Object object, long l, long l1) throws IOException {
      return null;
    }

    @NotNull
    public InputStream getInputStream(VirtualFile file) throws IOException {
      return null;
    }

    @NotNull
    public byte[] contentsToByteArray(VirtualFile file) throws IOException {
      return null;
    }

    public void setWritable(VirtualFile file, boolean b) throws IOException {
    }

    public boolean isWritable(VirtualFile file) {
      return false;
    }

    public void setTimeStamp(VirtualFile file, long l) throws IOException {
    }

    public long getTimeStamp(VirtualFile file) {
      return 0L;
    }

    public boolean isDirectory(VirtualFile file) {
      return false;
    }

    @NotNull
    public String[] list(VirtualFile file) {
      return ArrayUtil.EMPTY_STRING_ARRAY;
    }

    @NonNls
    @NotNull
    public String getProtocol() {
      return PROTOCOL;
    }

    public boolean exists(VirtualFile file) {
      return false;
    }
  }
}
