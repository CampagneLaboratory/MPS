package jetbrains.mps.ide.typesystem.trace;

/*Generated by MPS */

import jetbrains.mps.ide.ui.MPSTree;
import com.intellij.openapi.actionSystem.DataProvider;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.newTypesystem.operation.AbstractOperation;
import jetbrains.mps.newTypesystem.TypeCheckingContextNew;
import jetbrains.mps.smodel.SNode;
import java.util.Set;
import jetbrains.mps.newTypesystem.state.State;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.List;
import jetbrains.mps.nodeEditor.NodeHighlightManager;
import jetbrains.mps.nodeEditor.EditorMessageOwner;
import java.util.LinkedList;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import javax.swing.tree.TreeSelectionModel;
import jetbrains.mps.typesystem.inference.TypeContextManager;
import jetbrains.mps.ide.ui.MPSTreeNode;
import jetbrains.mps.ide.ui.TextTreeNode;
import java.util.ArrayList;
import jetbrains.mps.newTypesystem.operation.AddErrorOperation;
import jetbrains.mps.newTypesystem.operation.TraceWarningOperation;
import jetbrains.mps.newTypesystem.operation.equation.AddEquationOperation;
import jetbrains.mps.newTypesystem.operation.block.AbstractBlockOperation;
import jetbrains.mps.newTypesystem.state.blocks.Block;
import jetbrains.mps.newTypesystem.operation.ExpandTypeOperation;
import jetbrains.mps.newTypesystem.operation.ApplyRuleOperation;
import jetbrains.mps.newTypesystem.operation.block.AddDependencyOperation;
import jetbrains.mps.newTypesystem.operation.block.RemoveDependencyOperation;
import javax.swing.tree.TreePath;
import jetbrains.mps.newTypesystem.TypesUtil;
import jetbrains.mps.newTypesystem.operation.AssignTypeOperation;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.util.Pair;
import jetbrains.mps.ide.actions.MPSCommonDataKeys;
import jetbrains.mps.workbench.MPSDataKeys;
import javax.swing.JPopupMenu;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import jetbrains.mps.workbench.action.ActionUtils;
import jetbrains.mps.workbench.action.BaseAction;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import jetbrains.mps.smodel.ModelAccess;
import java.util.Collection;
import javax.swing.event.TreeSelectionListener;
import javax.swing.event.TreeSelectionEvent;
import jetbrains.mps.nodeEditor.DefaultEditorMessage;
import java.awt.Color;
import jetbrains.mps.nodeEditor.EditorMessage;
import java.awt.Graphics;
import jetbrains.mps.ide.util.ColorAndGraphicsUtil;
import java.util.Collections;

public class TypeSystemTraceTree extends MPSTree implements DataProvider {
  private final IOperationContext myOperationContext;
  private AbstractOperation myOperation;
  private final TypeCheckingContextNew myTypeCheckingContextNew;
  private TypeCheckingContextNew myCurrentContext;
  private final SNode mySelectedNode;
  private final Set<SNode> myNodes;
  private boolean generationMode = false;
  private TypeSystemTracePanel myParent;
  private State myStateCopy;
  private State myCurrentState;
  private AbstractOperation myOldOperation;
  private EditorComponent myEditorComponent;
  private List<TypeSystemTraceTreeNode> myErrorNodes;
  private TypeSystemTraceTree.DetailsTree myDetailsTree;
  private NodeHighlightManager myHighlightManager;
  private EditorMessageOwner myMessageOwner;

  public TypeSystemTraceTree(IOperationContext operationContext, TypeCheckingContextNew tcc, SNode node, TypeSystemTracePanel parent, EditorComponent editorComponent) {
    myOperationContext = operationContext;
    myTypeCheckingContextNew = tcc;
    myOperation = tcc.getOperation();
    myErrorNodes = new LinkedList<TypeSystemTraceTreeNode>();
    mySelectedNode = node;
    myNodes = new HashSet<SNode>();
    myNodes.addAll(SNodeOperations.getDescendants(((SNode) node), null, false, new String[]{}));
    myNodes.add(node);
    myCurrentContext = tcc;
    myParent = parent;
    myStateCopy = new State(tcc, tcc.getState().getOperation());
    myCurrentState = myStateCopy;
    setGenerationMode(TraceSettings.isGenerationMode());
    myEditorComponent = editorComponent;
    this.myHighlightManager = editorComponent.getHighlightManager();
    this.myMessageOwner = new EditorMessageOwner() {};
    EditorCell nodeCell = myEditorComponent.findNodeCell(mySelectedNode);
    if (nodeCell != null) {
      myHighlightManager.mark(new TypeSystemTraceTree.SelectedNodeEditorMessage(nodeCell, ""));
    }

    this.rebuildNow();
    expandAll();
    this.myDetailsTree = new TypeSystemTraceTree.DetailsTree(null);
    addTreeSelectionListener(new TypeSystemTraceTree.ShowDetailsUpdater());
    getSelectionModel().setSelectionMode(TreeSelectionModel.CONTIGUOUS_TREE_SELECTION);
  }

  /*package*/ MPSTree getDetailsTree() {
    return myDetailsTree;
  }

  public void rebuildTrace() {
    myTypeCheckingContextNew.checkRootInTraceMode(true);
    this.rebuildNow();
    this.expandAll();
  }

  public void setGenerationMode(boolean generationMode) {
    if (generationMode == this.generationMode) {
      return;
    }
    this.generationMode = generationMode;
    myOldOperation = null;
    if (this.generationMode) {
      TypeCheckingContextNew context = (TypeCheckingContextNew) TypeContextManager.getInstance().createTypeCheckingContext(mySelectedNode);
      context.getTypeInGenerationMode(mySelectedNode);
      myOperation = context.getOperation();
      myCurrentContext = context;
      myCurrentState = context.getState();
    } else {
      myOperation = myTypeCheckingContextNew.getOperation();
      myCurrentContext = myTypeCheckingContextNew;
      myCurrentState = myStateCopy;
    }
  }

  public State getState() {
    return myStateCopy;
  }

  @Override
  protected MPSTreeNode rebuild() {
    setRootVisible(false);
    setGenerationMode(TraceSettings.isGenerationMode());
    if (TraceSettings.isTraceForSelectedNode() && mySelectedNode != null) {
      getSliceVars(myOperation);
    }
    MPSTreeNode result = create(myOperation, false, true);
    if (result == null) {
      result = new TextTreeNode("Empty type system trace");
    }
    setRootVisible(true);
    return result;
  }

  public TypeSystemTraceTreeNode create(AbstractOperation operation, boolean showParent, boolean withChildren) {
    boolean showNode = showNode(operation);
    List<TypeSystemTraceTreeNode> children = new ArrayList<TypeSystemTraceTreeNode>();
    if (withChildren) {
      for (AbstractOperation consequence : operation.getConsequences()) {
        TypeSystemTraceTreeNode node = create(consequence, showNode || showParent, false);
        if (node != null) {
          children.add(node);
        }
      }
    }
    if (!(filterNodeType(operation))) {
      return null;
    }
    if (!(showParent)) {
      if (!(showNode) && children.isEmpty()) {
        return null;
      }
    }
    TypeSystemTraceTreeNode result = new TypeSystemTraceTreeNode(operation, myOperationContext, myCurrentContext.getState(), myEditorComponent);
    for (TypeSystemTraceTreeNode node : children) {
      result.add(node);
    }
    if (operation instanceof AddErrorOperation || operation instanceof TraceWarningOperation) {
      myErrorNodes.add(result);
    }
    return result;
  }

  @Override
  public void dispose() {
    myHighlightManager.clearForOwner(myMessageOwner);
    super.dispose();
  }

  private boolean showNode(AbstractOperation diff) {
    if (!(TraceSettings.isTraceForSelectedNode())) {
      return true;
    }
    if (mySelectedNode == null) {
      return true;
    }
    if (myNodes.contains(diff.getSource())) {
      return true;
    }
    if (diff instanceof AddEquationOperation) {
      AddEquationOperation eq = (AddEquationOperation) diff;
      if (myNodes.contains(eq.getChild()) || myNodes.contains(eq.getParent())) {
        return true;
      }
    }
    if (diff instanceof AbstractBlockOperation) {
      Block block = ((AbstractBlockOperation) diff).getBlock();
      for (SNode node : block.getInputs()) {
        if (myNodes.contains(node)) {
          return true;
        }
      }
    }
    return false;
  }

  private boolean filterNodeType(AbstractOperation operation) {
    if (!(TraceSettings.isShowTypesExpansion()) && operation instanceof ExpandTypeOperation) {
      return false;
    }
    if (!(TraceSettings.isShowApplyRuleOperations()) && operation instanceof ApplyRuleOperation) {
      return false;
    }
    if (!(TraceSettings.isShowBlockDependencies()) && (operation instanceof AddDependencyOperation || operation instanceof RemoveDependencyOperation)) {
      return false;
    }
    return true;
  }

  public void goToNextError() {
    int currentRow = -1;
    MPSTreeNode currentNode = this.getCurrentNode();
    if (null != currentNode) {
      currentRow = this.getRowForPath(new TreePath(currentNode.getPath()));
    }
    MPSTreeNode errorNode = getNextErrorNode(currentRow);
    if (null != errorNode) {
      this.scrollPathToVisible(new TreePath(errorNode.getPath()));
      this.selectNode(errorNode);
    }
  }

  private MPSTreeNode getNextErrorNode(int row) {
    TreePath errorPath;
    int errorRow;
    for (TypeSystemTraceTreeNode errorNode : myErrorNodes) {
      errorPath = new TreePath(errorNode.getPath());
      errorRow = this.getRowForPath(errorPath);
      if (errorRow > row) {
        return errorNode;
      }
    }
    if (!(myErrorNodes.isEmpty())) {
      return myErrorNodes.get(0);
    }
    return null;
  }

  private void getSliceVars(AbstractOperation diff) {
    if (diff == null) {
      return;
    }
    if (diff instanceof AddEquationOperation) {
      AddEquationOperation eq = (AddEquationOperation) diff;
      SNode child = eq.getChild();
      SNode parent = eq.getParent();
      if (myNodes.contains(child)) {
        myNodes.addAll(TypesUtil.getVariables(parent, myStateCopy));
      }
      if (myNodes.contains(parent)) {
        myNodes.addAll(TypesUtil.getVariables(child, myStateCopy));
      }
    }
    if (diff instanceof AssignTypeOperation) {
      AssignTypeOperation typeDifference = (AssignTypeOperation) diff;
      if (myNodes.contains(typeDifference.getNode()) && TypesUtil.isVariable(typeDifference.getType())) {
        myNodes.add(typeDifference.getType());
      }
    }
    for (AbstractOperation childDiff : diff.getConsequences()) {
      getSliceVars(childDiff);
    }
  }

  @Nullable
  public Object getData(@NonNls String id) {
    MPSTreeNode currentNode = this.getCurrentNode();
    AbstractOperation operation = (AbstractOperation) check_kyyn1p_a0a1a21(currentNode);
    if (operation == null) {
      return null;
    }
    final Pair<String, String> rule = operation.getRule();
    final SNode source = operation.getSource();
    if (id.equals(MPSCommonDataKeys.OPERATION_CONTEXT.getName())) {
      return myOperationContext;
    }
    if (id.equals(MPSDataKeys.RULE_MODEL_AND_ID.getName())) {
      return rule;
    }
    if (source != null && jetbrains.mps.util.SNodeOperations.isRegistered(source)) {
      if (id.equals(MPSDataKeys.SOURCE_NODE.getName())) {
        return source;
      }
    }
    return null;
  }

  @Override
  protected JPopupMenu createPopupMenu(final MPSTreeNode treeNode) {
    DefaultActionGroup group = ActionUtils.groupFromActions(((BaseAction) ActionManager.getInstance().getAction("jetbrains.mps.ide.actions.GoToNode_Action")), ((BaseAction) ActionManager.getInstance().getAction("jetbrains.mps.ide.actions.GoToRule_Action")));
    return ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group).getComponent();
  }

  private void showState(final TypeSystemTraceTreeNode newNode) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        AbstractOperation rootDifference = myCurrentContext.getOperation();
        Object difference = newNode.getUserObject();
        if (myOldOperation == null) {
          myCurrentState.clear(false);
          myCurrentState.executeOperationsBeforeAnchor(rootDifference, difference);
        } else {
          myCurrentState.updateState(myOldOperation, (AbstractOperation) difference);
        }
        myParent.resetState(myCurrentState);

        AbstractOperation nextDiff = findUltimateConsequence((AbstractOperation) difference);
        if (nextDiff != null && nextDiff != difference) {
          myCurrentState.updateState((AbstractOperation) difference, (AbstractOperation) nextDiff);
          myParent.updateState(myCurrentState);
          myOldOperation = (AbstractOperation) nextDiff;
        } else {
          myOldOperation = (AbstractOperation) difference;
        }
      }
    });
  }

  private void showState(final MPSTreeNode fromNode, final MPSTreeNode toNode) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        AbstractOperation rootDiff = myCurrentContext.getOperation();
        Object fromDiff = fromNode.getUserObject();
        Object toDiff = toNode.getUserObject();

        if (myOldOperation == null) {
          myCurrentState.clear(false);
          myCurrentState.executeOperationsBeforeAnchor(rootDiff, fromDiff);
        } else {
          myCurrentState.updateState(myOldOperation, (AbstractOperation) fromDiff);
        }
        myParent.resetState(myCurrentState);

        myCurrentState.updateState((AbstractOperation) fromDiff, (AbstractOperation) toDiff);
        myParent.updateState(myCurrentState);

        myOldOperation = (AbstractOperation) toDiff;
      }
    });
  }

  private AbstractOperation findUltimateConsequence(AbstractOperation op) {
    if (op == null) {
      return null;
    }
    AbstractOperation result = op;
    List<AbstractOperation> consequences = result.getConsequences();
    while (consequences != null && consequences.size() > 0) {
      result = consequences.get(consequences.size() - 1);
      consequences = result.getConsequences();
    }
    return result;
  }

  private void showDetails(MPSTreeNode treeNode) {
    AbstractOperation operation = (AbstractOperation) check_kyyn1p_a0a0a71(treeNode);
    myDetailsTree.setOperation(operation);
  }

  private void showDetails(Collection<? extends MPSTreeNode> treeNodes) {
    List<AbstractOperation> operations = new ArrayList<AbstractOperation>();
    for (MPSTreeNode treeNode : treeNodes) {
      AbstractOperation operation = (AbstractOperation) check_kyyn1p_a0a0a1a81(treeNode);
      operations.add(operation);
    }
    myDetailsTree.setOperations(operations);
  }

  private static Object check_kyyn1p_a0a0a1a3c(MPSTreeNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getUserObject();
    }
    return null;
  }

  private static Object check_kyyn1p_a0a1a21(MPSTreeNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getUserObject();
    }
    return null;
  }

  private static Object check_kyyn1p_a0a0a71(MPSTreeNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getUserObject();
    }
    return null;
  }

  private static Object check_kyyn1p_a0a0a1a81(MPSTreeNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getUserObject();
    }
    return null;
  }

  private class ShowDetailsUpdater implements TreeSelectionListener {
    private ShowDetailsUpdater() {
    }

    @Override
    public void valueChanged(TreeSelectionEvent e) {
      TreePath[] selectionPaths = getSelectionPaths();
      if (selectionPaths != null && selectionPaths.length >= 1) {
        if (selectionPaths.length == 1) {
          TreePath path = selectionPaths[0];
          if (path == null) {
            return;
          }
          MPSTreeNode treeNode = (MPSTreeNode) path.getLastPathComponent();
          showState((TypeSystemTraceTreeNode) treeNode);
          showDetails(treeNode);
        } else {
          TreePath fromPath = selectionPaths[0];
          TreePath toPath = selectionPaths[selectionPaths.length - 1];
          showState((MPSTreeNode) fromPath.getLastPathComponent(), (MPSTreeNode) toPath.getLastPathComponent());
          List<MPSTreeNode> selectedNodes = new ArrayList<MPSTreeNode>();
          for (int idx = 0; idx < selectionPaths.length; idx++) {
            selectedNodes.add((MPSTreeNode) selectionPaths[idx].getLastPathComponent());
          }
          showDetails(selectedNodes);
        }
      }
    }
  }

  private class SelectedNodeEditorMessage extends DefaultEditorMessage {
    private EditorCell myCell;

    public SelectedNodeEditorMessage(EditorCell cell, String message) {
      super(cell.getSNode(), new Color(192, 255, 255), message, myMessageOwner);
      this.myCell = cell;
    }

    @Override
    public EditorCell getCell(EditorComponent component) {
      return myCell;
    }

    @Override
    public boolean acceptCell(EditorCell cell, EditorComponent component) {
      return myCell == cell;
    }

    @Override
    public boolean sameAs(EditorMessage that) {
      return super.sameAs(that) && this.equals(that);
    }

    @Override
    protected void paintWithColor(Graphics graphics, EditorCell cell, Color color) {
      int x = cell.getX() + cell.getLeftInset();
      int y = cell.getY() + cell.getTopInset();
      int width = cell.getWidth() - cell.getLeftInset() - cell.getRightInset() - 1;
      int height = cell.getHeight() - cell.getTopInset() - cell.getBottomInset() - 1;

      graphics.setColor(color);
      ColorAndGraphicsUtil.fillStripes(graphics, x, y, width, height);
    }

    @Override
    public boolean isBackground() {
      return true;
    }

    @Override
    public boolean equals(Object that) {
      if (that == null) {
        return false;
      }
      if (this == that) {
        return true;
      }
      if (that.getClass() != TypeSystemTraceTree.SelectedNodeEditorMessage.class) {
        return false;
      }
      return this.myCell.equals(((TypeSystemTraceTree.SelectedNodeEditorMessage) that).myCell);
    }

    @Override
    public int hashCode() {
      return myCell.hashCode() * 37;
    }
  }

  public class DetailsTree extends MPSTree implements DataProvider {
    private List<AbstractOperation> myOperations;

    public DetailsTree(AbstractOperation operation) {
      this.myOperations = Collections.singletonList(operation);
      rebuildNow();
      expandAll();
      addTreeSelectionListener(new TypeSystemTraceTree.DetailsTree.ShowStateUpdater());
    }

    public void setOperation(AbstractOperation operation) {
      this.myOperations = Collections.singletonList(operation);
      rebuildNow();
      expandAll();
    }

    public void setOperations(Collection<? extends AbstractOperation> operation) {
      this.myOperations = new ArrayList<AbstractOperation>(operation);
      rebuildNow();
      expandAll();
    }

    public Collection<MPSTreeNode> create(Collection<? extends AbstractOperation> operations, boolean showParent) {
      if (operations == null || operations.size() == 0 || operations.iterator().next() == null) {
        return null;
      }
      List<MPSTreeNode> result = new ArrayList<MPSTreeNode>();
      for (AbstractOperation operation : operations) {
        boolean showNode = showNode(operation);
        List<MPSTreeNode> children = new ArrayList<MPSTreeNode>();
        for (AbstractOperation consequence : operation.getConsequences()) {
          Collection<MPSTreeNode> nodes = create(Collections.singletonList(consequence), showNode || showParent);
          if (nodes != null) {
            children.addAll(nodes);
          }
        }
        if (!(filterNodeType(operation))) {
          continue;
        }
        if (!(showParent)) {
          if (!(showNode) && children.isEmpty()) {
            continue;
          }
        }
        if (showParent) {
          TypeSystemTraceTreeNode treeNode = new TypeSystemTraceTreeNode(operation, myOperationContext, myCurrentContext.getState(), myEditorComponent);
          for (MPSTreeNode node : children) {
            treeNode.add(node);
          }
          result.add(treeNode);
        } else {
          result.addAll(children);
        }
        // <node> 
      }
      return result;
    }

    @Nullable
    public Object getData(@NonNls String id) {
      MPSTreeNode currentNode = this.getCurrentNode();
      if (currentNode instanceof TypeSystemTraceTreeNode) {
        AbstractOperation operation = (AbstractOperation) check_kyyn1p_a0a0a1a3c(currentNode);
        if (operation == null) {
          return null;
        }
        final Pair<String, String> rule = operation.getRule();
        final SNode source = operation.getSource();
        if (id.equals(MPSCommonDataKeys.OPERATION_CONTEXT.getName())) {
          return myOperationContext;
        }
        if (id.equals(MPSDataKeys.RULE_MODEL_AND_ID.getName())) {
          return rule;
        }
        if (source != null && source.isRegistered()) {
          if (id.equals(MPSDataKeys.SOURCE_NODE.getName())) {
            return source;
          }
        }
      }
      return null;
    }

    @Override
    protected JPopupMenu createPopupMenu(MPSTreeNode node) {
      return TypeSystemTraceTree.this.createPopupMenu(node);
    }

    protected MPSTreeNode rebuild() {
      setRootVisible(false);
      MPSTreeNode result;
      Collection<MPSTreeNode> nodes = create(myOperations, false);
      if (nodes == null) {
        result = new TextTreeNode("Empty type system trace");
        setRootVisible(true);
      } else {
        result = new TextTreeNode("Details");
        for (MPSTreeNode node : nodes) {
          result.add(node);
        }
      }
      return result;
    }

    private class ShowStateUpdater implements TreeSelectionListener {
      private ShowStateUpdater() {
      }

      @Override
      public void valueChanged(TreeSelectionEvent e) {
        TreePath path = e.getNewLeadSelectionPath();
        if (path == null) {
          return;
        }
        Object treeNode = path.getLastPathComponent();
        if (treeNode instanceof TypeSystemTraceTreeNode) {
          showState((TypeSystemTraceTreeNode) treeNode);
        }
      }
    }
  }
}
