package jetbrains.mps.ide.depanalyzer;

/*Generated by MPS */

import jetbrains.mps.ide.ui.MPSTreeNode;
import jetbrains.mps.ide.ui.treeMessages.TreeMessage;
import java.awt.Color;
import java.util.List;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.ide.icons.IconManager;
import jetbrains.mps.ide.moduleDependencies.icons.Icons;
import javax.swing.tree.TreeNode;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.ide.ui.TextMPSTreeNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.ide.projectPane.ProjectPane;
import com.intellij.openapi.project.Project;

public class ModuleDependencyNode extends MPSTreeNode {
  private static final TreeMessage HAS_CYCLE = new TreeMessage(Color.RED, "cycle", null);
  private static final TreeMessage BOOTSTRAP_DEPENDENCY = new TreeMessage(Color.RED, "bootstrap dependecy", null);

  private List<IModule> myModules;
  private boolean myInitialized;
  private boolean myCyclic;

  public ModuleDependencyNode(IModule module, IOperationContext context) {
    this(ListSequence.fromListAndArray(new ArrayList<IModule>(), module), context);
  }

  public ModuleDependencyNode(List<IModule> modules, IOperationContext context) {
    super(context);
    myModules = modules;
    if ((int) ListSequence.fromList(modules).count() == 1) {
      setIcon(IconManager.getIconFor(ListSequence.fromList(modules).first()));
    }
    String text = ListSequence.fromList(modules).first().getModuleFqName();
    if (ListSequence.fromList(modules).count() > 1) {
      text += ", " + ListSequence.fromList(modules).getElement(1).getModuleFqName();
      if (ListSequence.fromList(modules).count() > 2) {
        text += ", ... (" + ListSequence.fromList(modules).count() + " modules)";
      }
      setIcon(Icons.MODULES_GROUP_ICON);
    }
    setNodeIdentifier(text);
  }

  public List<IModule> getModules() {
    return myModules;
  }

  public boolean isUsedLanguage() {
    return false;
  }

  public void setCyclic() {
    myCyclic = true;
  }

  public boolean isCyclic() {
    return myCyclic;
  }

  public ModuleDependencyNode getFromNode() {
    TreeNode node = getParent();
    if (node != null && isUsedLanguage()) {
      node = node.getParent();
    }
    if (node != null && node instanceof ModuleDependencyNode) {
      return (ModuleDependencyNode) node;
    }
    return null;
  }

  protected void doInit() {
    Set<IModule> reqModules = SetSequence.fromSet(new HashSet<IModule>());
    Set<IModule> rtModules = SetSequence.fromSet(new HashSet<IModule>());
    Set<IModule> usedLanguages = SetSequence.fromSet(new HashSet<IModule>());

    DependencyTree tree = (DependencyTree) getTree();

    for (IModule module : ListSequence.fromList(myModules)) {
      GlobalModuleDependenciesManager depManager = new GlobalModuleDependenciesManager(module);
      SetSequence.fromSet(reqModules).addSequence(CollectionSequence.fromCollection(depManager.getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE)));
      SetSequence.fromSet(rtModules).addSequence(CollectionSequence.fromCollection(depManager.getModules(GlobalModuleDependenciesManager.Deptype.EXECUTE)));
      SetSequence.fromSet(usedLanguages).addSequence(CollectionSequence.fromCollection(depManager.getUsedLanguages()));
    }

    Set<IModule> allModules = (tree.isShowRuntime() ?
      rtModules :
      reqModules
    );
    Set<IModule> depLoops = tree.getLoops();
    // Dependency manager doesn't add module itself to its dependencies, fixing this here 
    SetSequence.fromSet(allModules).addSequence(SetSequence.fromSet(depLoops).intersect(ListSequence.fromList(myModules)));

    if (tree.isHideSourceModules()) {
      SetSequence.fromSet(allModules).removeSequence(ListSequence.fromList(tree.getModules()));
      SetSequence.fromSet(usedLanguages).removeSequence(ListSequence.fromList(tree.getModules()));
    }

    for (IModule m : SetSequence.fromSet(allModules).sort(new ISelector<IModule, Comparable<?>>() {
      public Comparable<?> select(IModule it) {
        return it.getModuleFqName();
      }
    }, true)) {
      add(new ModuleDependencyNode.DepDependencyNode(m, !(SetSequence.fromSet(reqModules).contains(m)), SetSequence.fromSet(depLoops).contains(m), getOperationContext()));
    }

    if (tree.isShowUsedLanguage()) {
      MPSTreeNode usedlanguages = new TextMPSTreeNode("Used Languages", getOperationContext());
      boolean hasBootstrapDep = false;
      for (IModule l : SetSequence.fromSet(usedLanguages).sort(new ISelector<IModule, Comparable<?>>() {
        public Comparable<?> select(IModule it) {
          return it.getModuleFqName();
        }
      }, true)) {
        Iterable<IModule> langModules = new GlobalModuleDependenciesManager(l).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE);
        boolean isBootstrapDep = Sequence.fromIterable(langModules).intersect(ListSequence.fromList(myModules)).isNotEmpty();
        hasBootstrapDep |= isBootstrapDep;
        usedlanguages.add(new ModuleDependencyNode.ULangDependencyNode(l, isBootstrapDep, getOperationContext()));
      }
      if (hasBootstrapDep) {
        usedlanguages.addTreeMessage(new TreeMessage(Color.RED, "bootstrap dependencies", null));
      }
      add(usedlanguages);
    }
    myInitialized = true;
  }

  public boolean isInitialized() {
    return myInitialized;
  }

  public void doubleClick() {
    if ((int) ListSequence.fromList(myModules).count() == 1) {
      ProjectPane.getInstance(check_lba8jw_a0a0a0a7(((DependencyTree) getTree()), this)).selectModule(ListSequence.fromList(myModules).first(), false);
    }
  }

  private static Project check_lba8jw_a0a0a0a7(DependencyTree checkedDotOperand, ModuleDependencyNode checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getProject();
    }
    return null;
  }

  public static class DepDependencyNode extends ModuleDependencyNode {
    public DepDependencyNode(IModule module, boolean isRuntime, boolean isCyclic, IOperationContext context) {
      super(module, context);
      if (isRuntime) {
        setNodeIdentifier(getNodeIdentifier() + " (runtime)");
      }
      if (isCyclic) {
        setCyclic();
        addTreeMessage(HAS_CYCLE);
      }
    }

    public boolean isUsedLanguage() {
      return false;
    }
  }

  public static class ULangDependencyNode extends ModuleDependencyNode {
    public ULangDependencyNode(IModule module, boolean isBootstrap, IOperationContext context) {
      super(module, context);
      if (isBootstrap) {
        setCyclic();
        addTreeMessage(BOOTSTRAP_DEPENDENCY);
      }
    }

    public boolean isUsedLanguage() {
      return true;
    }
  }
}
