package jetbrains.mps.ide.editor.actions;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.selection.Selection;
import jetbrains.mps.nodeEditor.selection.SingularSelection;
import java.util.Iterator;
import jetbrains.mps.nodeEditor.cells.EditorCell_Component;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.ActionHandler;
import jetbrains.mps.nodeEditor.cells.APICellAdapter;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import jetbrains.mps.nodeEditor.ChildrenCollectionFinder;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.CellAction;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.SNodeOperations;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;

public class EditorActionUtils {
  public EditorActionUtils() {
  }

  /*package*/ static boolean isReadonlyActionEnabled(EditorComponent editorComponent) {
    return editorComponent.isFocusOwner() && !(editorComponent.getNodeSubstituteChooser().isVisible()) && editorComponent.getSelectionManager().getSelection() != null;
  }

  /*package*/ static boolean isWriteActionEnabled(EditorComponent editorComponent) {
    return isReadonlyActionEnabled(editorComponent) && !(editorComponent.isReadOnly());
  }

  /*package*/ static EditorCell getEditorCellToInsert(EditorComponent editorComponent) {
    Selection selection = editorComponent.getSelectionManager().getSelection();
    // TODO: remove this limitation 
    if (!(selection instanceof SingularSelection)) {
      return null;
    }
    Iterator<EditorCell> iterator = (Iterator<EditorCell>) ((Iterator) selection.getSelectedCells().iterator());
    if (!(iterator.hasNext())) {
      return null;
    }
    EditorCell editorCell = iterator.next();
    return (editorCell instanceof EditorCell_Component ?
      null :
      editorCell
    );
  }

  /**
   * Should be executed inside read action
   */
  public static void callInsertAction(@NotNull EditorCell cell) {
    ActionHandler actionHandler = cell.getEditorComponent().getActionHandler();
    if (cell.isErrorState() && APICellAdapter.validate(cell, false, true)) {
      return;
    }

    if (cell instanceof EditorCell_Label && !(isLinkCollection(cell))) {
      // Looking for the next child collection to the right from this cell 
      EditorCell cellWithRole = new ChildrenCollectionFinder(cell, true, false).find();

      if (cellWithRole == null) {
        // Looking for the next child collection in parents 
        cellWithRole = getSiblingCollectionForInsert(cell, true);
      }

      if (cellWithRole != null && actionHandler.executeAction(cellWithRole, CellActionType.INSERT)) {
        return;
      }
    }
    actionHandler.executeAction(cell, CellActionType.INSERT);
  }

  public static EditorCell getSiblingCollectionForInsert(@NotNull EditorCell cell, boolean forward) {
    // TODO FIXME rewrite without hasSingleRolesAtLeftBoundary, cleanup ChildrenCollectionFinder 
    EditorCell nextLeaf = (forward ?
      APICellAdapter.getNextLeaf(cell) :
      APICellAdapter.getPrevLeaf(cell)
    );

    if ((APICellAdapter.isBigCell(cell) || APICellAdapter.isLastPositionInBigCell(cell)) && ((forward ?
      hasSingleRolesAtRightBoundary(cell) :
      hasSingleRolesAtLeftBoundary(cell)
    )) && nextLeaf != null) {
      // Looking for the next child collection in parents 
      return new ChildrenCollectionFinder(nextLeaf, cell, forward, true).find();
    }
    return null;
  }

  /**
   * Should be executed inside read action
   */
  public static void callInsertBeforeAction(@NotNull EditorCell cell) {
    ActionHandler actionHandler = cell.getEditorComponent().getActionHandler();
    if (cell.isErrorState() && APICellAdapter.validate(cell, true, true)) {
      return;
    }

    if (cell instanceof EditorCell_Label && !(isLinkCollection(cell))) {
      // Looking for the prev. child collection (to the left from this cell) 
      EditorCell cellWithRole = new ChildrenCollectionFinder(cell, false, false).find();

      if (cellWithRole == null) {
        // Looking for the next child collection in parents 
        cellWithRole = getSiblingCollectionForInsert(cell, false);
      }

      if (cellWithRole != null && actionHandler.executeAction(cellWithRole, CellActionType.INSERT_BEFORE)) {
        return;
      }
    }

    actionHandler.executeAction(cell, CellActionType.INSERT_BEFORE);
  }

  /*package*/ static void runEditorComponentAction(EditorComponent editorComponent, CellActionType actionType) {
    CellAction action = editorComponent.getComponentAction(CellActionType.UP);
    EditorContext editorContext = editorComponent.getEditorContext();
    if (action != null && action.canExecute(editorContext)) {
      action.execute(editorContext);
    }
  }

  /**
   * We can use this method to determine if we should redispatch insert event to the corresponding
   * child collection below the cell returned from cell.getNextLeaf() or we should go on and insert
   * next child into a collection containing cell itself.
   * 
   * @return true if we should redispatch insert event to the next leaft cell
   */
  private static boolean hasSingleRolesAtRightBoundary(EditorCell cell) {
    if (!(hasSingleRole(cell))) {
      return false;
    }

    if (isOnRightBoundary(cell)) {
      final EditorCell_Collection parentCell = cell.getParent();
      if (parentCell != null) {
        final EditorCell nextLeaf = APICellAdapter.getNextLeaf(cell);
        if (nextLeaf != null) {
          final Wrappers._boolean ancestor = new Wrappers._boolean(false);
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              ancestor.value = SNodeOperations.isAncestor(parentCell.getSNode(), nextLeaf.getSNode());
            }
          });
          if (ancestor.value) {
            return true;
          }
        }
        return hasSingleRolesAtRightBoundary(parentCell);
      }
    }
    return true;
  }

  /**
   * We can use this method to determine if we should redispatch insert event to the corresponding
   * child collection below the cell returned from cell.getPrevLeaf() or we should go on and insert
   * prev. child into a collection containing cell itself
   * 
   * @return true if we should redispatch insert event to the prev. leaft cell
   */
  private static boolean hasSingleRolesAtLeftBoundary(EditorCell cell) {
    if (!(hasSingleRole(cell))) {
      return false;
    }

    if (isOnLeftBoundary(cell)) {
      final EditorCell_Collection parentCell = cell.getParent();
      if (parentCell != null) {
        final EditorCell prevLeaf = APICellAdapter.getPrevLeaf(cell);
        if (prevLeaf != null) {
          final Wrappers._boolean ancestor = new Wrappers._boolean(false);
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              ancestor.value = SNodeOperations.isAncestor(parentCell.getSNode(), prevLeaf.getSNode());
            }
          });
          if (ancestor.value) {
            return true;
          }
        }
        return hasSingleRolesAtLeftBoundary((EditorCell) parentCell);
      }
    }
    return true;
  }

  public static boolean isOnLeftBoundary(EditorCell cell) {
    EditorCell prevLeaf = APICellAdapter.getPrevLeaf(cell);
    return prevLeaf == null || prevLeaf.getSNode() != cell.getSNode();
  }

  public static boolean isOnRightBoundary(EditorCell cell) {
    EditorCell nextLeaf = APICellAdapter.getNextLeaf(cell);
    return nextLeaf == null || nextLeaf.getSNode() != cell.getSNode();
  }

  private static boolean hasSingleRole(final EditorCell cell) {
    final boolean[] result = new boolean[1];
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        SNode linkDeclaration = jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.getContainingLinkDeclaration(((SNode) cell.getSNode()));
        result[0] = linkDeclaration != null && BehaviorReflection.invokeNonVirtual(Boolean.TYPE, linkDeclaration, "jetbrains.mps.lang.structure.structure.LinkDeclaration", "call_isSingular_1213877254557", new Object[]{});
      }
    });
    return result[0];
  }

  private static boolean isLinkCollection(EditorCell cell) {
    return cell.getRole() != null;
  }
}
