package jetbrains.mps.ide.editor.util;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;

public class CommentUtil {

  /**
   * 
   * 
   * @param node node to comment. This node must have parent
   * @throws IllegalStateException if node has no parent
   */
  public static void commentOut(@NotNull SNode node) {
    SNode parent = SNodeOperations.getParent(node);
    if (parent == null) {
      throw new IllegalStateException("Node to comment has no parent. Node: " + BehaviorReflection.invokeVirtual(String.class, node, "virtual_getPresentation_1213877396640", new Object[]{}) + " Node id: " + node.getNodeId());
    }
    SContainmentLink containmentLink = node.getContainmentLink();
    assert containmentLink != null;
    SNode newComment = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute")));
    BehaviorReflection.invokeNonVirtual(Void.class, newComment, "jetbrains.mps.lang.core.structure.ChildAttribute", "call_setLink_709746936026609906", new Object[]{containmentLink});
    SNode prev = CommentUtil.getPrevious(parent, node, containmentLink);
    SNode next = CommentUtil.getNext(parent, node, containmentLink);
    parent.removeChild(node);
    SLinkOperations.setTarget(newComment, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, 0x2ab99f0d2248e89dL, "commentedNode"), node);
    if (prev != null) {
      parent.insertChildAfter(MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute"), newComment, prev);
    } else if (next != null) {
      parent.insertChildBefore(MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute"), newComment, next);
    } else {
      parent.addChild(MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute"), newComment);
    }
  }

  /**
   * 
   * 
   * @param attribute attribute containing commented node. This node must have parent
   * @throws IllegalStateException if attribute has no parent   
   */
  public static void uncomment(@NotNull SNode attribute) {
    SNode parent = SNodeOperations.getParent(attribute);
    if (parent == null) {
      throw new IllegalStateException("Node to comment has no parent. Node: " + BehaviorReflection.invokeVirtual(String.class, attribute, "virtual_getPresentation_1213877396640", new Object[]{}) + " Node id: " + attribute.getNodeId());
    }
    SContainmentLink containmentLink = BehaviorReflection.invokeNonVirtual(SContainmentLink.class, attribute, "jetbrains.mps.lang.core.structure.ChildAttribute", "call_getLink_709746936026609871", new Object[]{});
    SNode commentedNode = SLinkOperations.getTarget(attribute, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, 0x2ab99f0d2248e89dL, "commentedNode"));
    if (containmentLink != null) {
      attribute.removeChild(commentedNode);
      if (!(containmentLink.isMultiple())) {
        SNode currentChild = ListSequence.fromList(SNodeOperations.getChildren(parent, containmentLink)).first();
        if ((currentChild != null)) {
          CommentUtil.commentOut(currentChild);
        }
      }

      SNode prev = CommentUtil.getPrevious(parent, attribute, containmentLink);
      SNode next = CommentUtil.getNext(parent, attribute, containmentLink);
      parent.removeChild(attribute);
      if (prev != null) {
        parent.insertChildAfter(containmentLink, commentedNode, prev);
      } else if (next != null) {
        parent.insertChildBefore(containmentLink, commentedNode, next);
      } else {
        parent.addChild(containmentLink, commentedNode);
      }
    }
    SNodeOperations.deleteNode(attribute);
  }
  private static SNode getPrevious(SNode parent, SNode anchor, SContainmentLink containmentLink) {
    Iterator<SNode> iterator = Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(parent, containmentLink)).iterator();
    SNode prev = null;
    while (iterator.hasNext()) {
      SNode next = iterator.next();
      if (next == anchor) {
        return prev;
      }
    }
    return null;
  }
  private static SNode getNext(SNode parent, SNode anchor, SContainmentLink containmentLink) {
    Iterator<SNode> iterator = Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(parent, containmentLink)).iterator();
    while (iterator.hasNext()) {
      SNode next = iterator.next();
      if (next == anchor) {
        if (iterator.hasNext()) {
          return iterator.next();
        }
      }
    }
    return null;
  }
}
