package jetbrains.mps.execution.api.commands;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.NotNull;
import com.intellij.execution.process.ProcessHandler;
import com.intellij.execution.ExecutionException;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import java.io.IOException;
import com.intellij.execution.process.ProcessNotCreatedException;
import com.intellij.execution.configurations.GeneralCommandLine;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class ProcessHandlerBuilder {
  private final List<String> myCommandLine = ListSequence.fromList(new ArrayList<String>());

  public ProcessHandlerBuilder() {
  }

  public ProcessHandlerBuilder append(@Nullable String command) {
    if (!(StringUtils.isEmpty(command))) {
      ListSequence.fromList(myCommandLine).addSequence(Sequence.fromIterable(splitCommandInParts(command)));
    }
    return this;
  }

  public ProcessHandlerBuilder append(String... command) {
    for (String commandPart : Sequence.fromIterable(Sequence.fromArray(command))) {
      append(commandPart);
    }
    return this;
  }

  public ProcessHandlerBuilder append(@NotNull List<String> command) {
    for (String commandPart : ListSequence.fromList(command)) {
      append(commandPart);
    }
    return this;
  }

  public ProcessHandlerBuilder appendKey(@Nullable String key, @Nullable String parameter) {
    if (StringUtils.isNotEmpty(key) && StringUtils.isNotEmpty(parameter)) {
      return append("-" + key).append(parameter);
    }
    return this;
  }

  public ProcessHandlerBuilder appendKey(@Nullable String key, String... parameter) {
    if (StringUtils.isNotEmpty(key) && parameter.length > 0) {
      return append("-" + key).append(parameter);
    }
    return this;
  }

  public ProcessHandlerBuilder appendKey(@Nullable String key, @NotNull List<String> parameters) {
    if (StringUtils.isNotEmpty(key) && ListSequence.fromList(parameters).isNotEmpty()) {
      return append("-" + key).append(parameters);
    }
    return this;
  }

  public ProcessHandler build() throws ExecutionException {
    return build(new File(System.getProperty("user.dir")));
  }

  public ProcessHandler build(@NotNull File workingDirectory) throws ExecutionException {
    if (!(workingDirectory.exists())) {
      throw new ExecutionException("Working directory " + workingDirectory + " does not exist.");
    }
    ProcessBuilder builder = new ProcessBuilder(ListSequence.fromList(myCommandLine).toGenericArray(String.class));
    builder.directory(workingDirectory);
    try {
      Process process = builder.start();
      DefaultProcessHandler processHandler = new DefaultProcessHandler(process, ListSequence.fromList(myCommandLine).foldLeft("", new ILeftCombinator<String, String>() {
        public String combine(String s, String it) {
          return (StringUtils.isEmpty(s) ?
            it :
            s + " " + it
          );
        }
      }));
      return processHandler;
    } catch (IOException e) {
      throw new ProcessNotCreatedException("Start process failed", e, getCommandLine(workingDirectory.getAbsolutePath()));
    } catch (NullPointerException e) {
      throw new ProcessNotCreatedException("Start process failed: one of the command line arguments is null", e, getCommandLine(workingDirectory.getAbsolutePath()));
    } catch (Throwable t) {
      throw new ProcessNotCreatedException("Start process failed", t, getCommandLine(workingDirectory.getAbsolutePath()));
    }
  }

  private GeneralCommandLine getCommandLine(String workingDirectory) {
    GeneralCommandLine commandLine = new GeneralCommandLine();
    commandLine.setExePath(ListSequence.fromList(myCommandLine).getElement(0));
    commandLine.setWorkDirectory(workingDirectory);
    commandLine.addParameters(ListSequence.fromList(myCommandLine).tailListSequence(1));
    return commandLine;
  }

  public static Iterable<String> splitCommandInParts(@NotNull String command) {
    // this mega-regexp finds a space outside of " 
    // those spaces a to be replaces with ^ 
    // I figured, you do not expect this character in command lines, better solutions are welcomed 
    // we need all this for MPS-12488 
    String charToReplace = "^";
    String regex = "^([^\"]*(\"[^\"]*\")*[^\"]*)(\\s)";
    while (command.matches(regex + ".*")) {
      command = command.replaceAll(regex, "$1\\" + charToReplace);
    }
    return Sequence.fromIterable(Sequence.fromArray(command.split("\\" + charToReplace))).where(new IWhereFilter<String>() {
      public boolean accept(String it) {
        return StringUtils.isNotEmpty(it);
      }
    }).<String>select(new ISelector<String, String>() {
      public String select(String it) {
        return it.replace("\"", "");
      }
    });
  }
}
