package jetbrains.mps.baseLanguage.util.plugin.run;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import jetbrains.mps.generator.ModelGenerationStatusManager;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.make.script.IResult;
import java.util.concurrent.Future;
import jetbrains.mps.workbench.make.WorkbenchMakeService;
import jetbrains.mps.smodel.resources.ModelsToResources;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

@Deprecated
public class RunUtil {
  @Deprecated
  public RunUtil() {
  }

  public static boolean makeBeforeRun(Project project, SNode... nodes) {
    return makeBeforeRun(project, Sequence.fromIterable(Sequence.fromArray(nodes)).toListSequence());
  }

  public static boolean makeBeforeRun(final Project project, List<SNode> nodes) {
    if (ThreadUtils.isEventDispatchThread()) {
      throw new RuntimeException("Can't run make from the event dispatch thread");
    }
    final List<SModelDescriptor> models = ListSequence.fromList(new ArrayList<SModelDescriptor>());
    for (final SNode node : nodes) {
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          SModelDescriptor md = SNodeOperations.getModel(node).getModelDescriptor();
          if (md instanceof EditableSModelDescriptor) {
            if (!(ListSequence.fromList(models).contains((EditableSModelDescriptor) md)) && ModelGenerationStatusManager.getInstance().generationRequired(md, ProjectOperationContext.get(project))) {
              ListSequence.fromList(models).addElement((EditableSModelDescriptor) md);
            }

          }
        }
      });
    }
    if (ListSequence.fromList(models).isNotEmpty()) {
      final ProjectOperationContext context = ProjectOperationContext.get(project);
      IResult result = null;
      Future<IResult> future = new WorkbenchMakeService(context, true).make(new ModelsToResources(context, models).resources(false));
      try {
        result = future.get();
      } catch (CancellationException ignore) {
      } catch (InterruptedException ignore) {
      } catch (ExecutionException ignore) {
      }
      return result != null && result.isSucessful();
      // <node> 
    }
    return true;
  }
}
