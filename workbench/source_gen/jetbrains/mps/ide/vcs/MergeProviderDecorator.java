package jetbrains.mps.ide.vcs;

/*Generated by MPS */

import com.intellij.openapi.vcs.merge.MergeProvider;
import jetbrains.mps.logging.Logger;
import java.io.File;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.vcs.merge.MergeData;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vcs.VcsException;
import jetbrains.mps.fileTypes.MPSFileTypeFactory;
import com.intellij.openapi.diff.DiffRequestFactory;
import com.intellij.openapi.diff.MergeRequest;
import com.intellij.openapi.diff.ActionButtonPresentation;
import java.io.IOException;
import jetbrains.mps.util.FileUtil;
import com.intellij.util.io.ZipUtil;
import com.intellij.openapi.application.PathManager;
import java.io.FilenameFilter;

/*package*/ class MergeProviderDecorator implements MergeProvider {
  private static final Logger LOG = Logger.getLogger(MergeProviderDecorator.class);

  private File myBackup;
  private final MergeProvider myProvider;
  private Project myProject;

  public MergeProviderDecorator(Project project, MergeProvider provider) {
    myProject = project;
    myProvider = provider;
    myBackup = null;
  }

  @NotNull
  public MergeData loadRevisions(VirtualFile file) throws VcsException, VcsException {
    MergeData mergeData = myProvider.loadRevisions(file);
    if (file.getFileType().equals(MPSFileTypeFactory.MODEL_FILE_TYPE)) {
      String leftText = VcsHelperUtil.decodeContent(file, mergeData.CURRENT);
      String rightText = VcsHelperUtil.decodeContent(file, mergeData.LAST);
      String originalText = VcsHelperUtil.decodeContent(file, mergeData.ORIGINAL);
      DiffRequestFactory diffRequestFactory = DiffRequestFactory.getInstance();
      MergeRequest request = diffRequestFactory.createMergeRequest(leftText, rightText, originalText, file, myProject, ActionButtonPresentation.APPLY, ActionButtonPresentation.CANCEL_WITH_PROMPT);
      try {
        myBackup = VcsHelperUtil.zipModel(mergeData, request.getContents(), file);
      } catch (IOException e) {
        LOG.error(e);
      }
    }
    return mergeData;
  }

  public void conflictResolvedForFile(VirtualFile file) {
    myProvider.conflictResolvedForFile(file);
    if (myBackup != null && myBackup.exists()) {
      try {
        File tmp = FileUtil.createTmpDir();
        ZipUtil.extract(myBackup, tmp, null);
        //  copy merge result 
        FileUtil.copyFile(new File(file.getPath()), new File(tmp + File.separator + file.getName() + ".result"));
        //  copy logfiles 
        File logsDir = new File(PathManager.getLogPath());
        File[] logfiles = logsDir.listFiles(new FilenameFilter() {
          public boolean accept(File dir, String name) {
            return name.matches("mpsvcs\\.log(\\.1)*") || name.matches("idea\\.log(\\.1)*");
          }
        });
        File tmpLogDir = new File(tmp + File.separator + "logs");
        tmpLogDir.mkdir();
        for (File logfile : logfiles) {
          FileUtil.copyFile(logfile, new File(tmpLogDir + File.separator + logfile.getName()));
        }
        FileUtil.zip(tmp, myBackup);
        FileUtil.delete(tmp);
      } catch (IOException e) {
        LOG.error(e);
      }
    }
  }

  public boolean isBinary(VirtualFile file) {
    return myProvider.isBinary(file);
  }
}
