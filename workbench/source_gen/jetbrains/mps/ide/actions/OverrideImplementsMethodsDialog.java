package jetbrains.mps.ide.actions;

/*Generated by MPS */

import jetbrains.mps.ide.util.GroupedNodesChooser;
import javax.swing.JCheckBox;
import jetbrains.mps.smodel.SNodePointer;
import com.intellij.openapi.project.Project;
import jetbrains.mps.plugins.projectplugins.ProjectPluginManager;
import com.intellij.ui.NonFocusableCheckBox;
import jetbrains.mps.smodel.SNode;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.smodel.behaviour.BehaviorManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Comparator;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class OverrideImplementsMethodsDialog extends GroupedNodesChooser {
  private JCheckBox myRemoveAttributes;
  private JCheckBox myInsertOverride;
  private JCheckBox myAddReturn;
  private PersistentOptions_PreferencesComponent myOptions;

  public OverrideImplementsMethodsDialog(SNodePointer[] methods, Project project) {
    super(methods, false, true, project);
  }

  @Override
  protected void initOptions() {
    try {
      myOptions = myProject.getComponent(ProjectPluginManager.class).getPrefsComponent(PersistentOptions_PreferencesComponent.class);
    } catch (Exception e) {
      myOptions = null;
    }

    myAddReturn = new NonFocusableCheckBox("Add return keyword");
    myAddReturn.setMnemonic('r');
    myRemoveAttributes = new NonFocusableCheckBox("Remove Attributes");
    myRemoveAttributes.setMnemonic('t');
    myInsertOverride = (showInsertOverride() ?
      new NonFocusableCheckBox("Insert @Override") :
      null
    );
    myOptionControls = (showInsertOverride() ?
      new JCheckBox[]{myAddReturn, myRemoveAttributes, myInsertOverride} :
      new JCheckBox[]{myAddReturn, myRemoveAttributes}
    );
    if (myInsertOverride != null) {
      myInsertOverride.setMnemonic('O');
    }
  }

  protected boolean showInsertOverride() {
    return true;
  }

  @Override
  protected void customizeOptionsPanel() {
    myAddReturn.setSelected((myOptions != null ?
      myOptions.getStateObject().addReturnsOnImplement :
      false
    ));
    myRemoveAttributes.setSelected((myOptions != null ?
      myOptions.getStateObject().removeAttributes :
      true
    ));
    if (myInsertOverride != null) {
      myInsertOverride.setSelected((myOptions != null ?
        myOptions.getStateObject().addOverrideAnnotation :
        true
      ));
    }
  }

  public boolean isInsertOverrideAnnotation() {
    return (myInsertOverride != null ?
      myInsertOverride.isSelected() :
      false
    );
  }

  public boolean isAddReturn() {
    return myAddReturn.isSelected();
  }

  public boolean isRemoveAttributes() {
    return myRemoveAttributes.isSelected();
  }

  @Override
  public void dispose() {
    if (myOptions != null) {
      if (myInsertOverride != null) {
        myOptions.getStateObject().addOverrideAnnotation = myInsertOverride.isSelected();
      }
      myOptions.getStateObject().addReturnsOnImplement = myAddReturn.isSelected();
      myOptions.getStateObject().removeAttributes = myRemoveAttributes.isSelected();
    }
    super.dispose();
  }

  public static Iterable<SNode> sortMethods(SNode baseClass, Iterable<SNode> methods) {
    final Map<SNode, Integer> containerIndex = MapSequence.fromMap(new HashMap<SNode, Integer>());
    int i = 1;
    for (SNode c : ((List<SNode>) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(baseClass, "jetbrains.mps.baseLanguage.structure.ClassConcept"), "call_getAllSuperClassifiers_4892662966716545618", new Class[]{SNode.class}))) {
      MapSequence.fromMap(containerIndex).put(c, i++);
    }
    return Sequence.fromIterable(methods).sort(new Comparator<SNode>() {
      public int compare(SNode a, SNode b) {
        SNode parentA = SNodeOperations.getParent(a);
        SNode parentB = SNodeOperations.getParent(b);
        if (parentA == parentB) {
          return new Integer(parentA.getIndexOfChild(a)).compareTo(parentB.getIndexOfChild(b));
        }
        int iA = (parentA != null && MapSequence.fromMap(containerIndex).containsKey(parentA) ?
          MapSequence.fromMap(containerIndex).get(parentA) :
          0
        );
        int iB = (parentB != null && MapSequence.fromMap(containerIndex).containsKey(parentB) ?
          MapSequence.fromMap(containerIndex).get(parentB) :
          0
        );
        return new Integer(iA).compareTo(iB);
      }
    }, true);
  }

  public static SNodePointer[] toNodePointers(Iterable<SNode> methods) {
    return Sequence.fromIterable(methods).select(new ISelector<SNode, SNodePointer>() {
      public SNodePointer select(SNode it) {
        return new SNodePointer(it);
      }
    }).toGenericArray(SNodePointer.class);
  }
}
