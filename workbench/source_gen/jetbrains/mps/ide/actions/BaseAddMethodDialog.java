package jetbrains.mps.ide.actions;

/*Generated by MPS */

import jetbrains.mps.ide.dialogs.BaseDialog;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.ide.ui.MPSTree;
import jetbrains.mps.ide.ui.MPSTreeNode;
import java.awt.Frame;
import java.awt.HeadlessException;
import javax.swing.InputMap;
import javax.swing.KeyStroke;
import java.awt.event.KeyEvent;
import javax.swing.AbstractAction;
import java.awt.event.ActionEvent;
import javax.swing.JComponent;
import java.util.List;
import com.intellij.openapi.actionSystem.AnAction;
import java.util.ArrayList;
import com.intellij.ui.treeStructure.actions.CollapseAllAction;
import com.intellij.ui.treeStructure.actions.ExpandAllAction;
import jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration;
import jetbrains.mps.smodel.INodeAdapter;
import java.util.Map;
import java.util.LinkedHashMap;
import jetbrains.mps.lang.core.behavior.BaseConcept_Behavior;
import com.intellij.util.containers.MultiMap;
import java.util.Collections;
import java.util.Comparator;
import jetbrains.mps.ide.ui.TextTreeNode;
import jetbrains.mps.ide.dialogs.DialogDimensionsSettings;
import javax.swing.JScrollPane;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import jetbrains.mps.smodel.ModelAccess;
import javax.swing.tree.TreePath;
import java.util.Arrays;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.icons.IconManager;

public abstract class BaseAddMethodDialog extends BaseDialog {
  private EditorContext myContext;
  private MPSTree myTree = new MPSTree() {
    protected MPSTreeNode rebuild() {
      return rebuildOurTree();
    }
  };

  public BaseAddMethodDialog(EditorContext context, Frame mainFrame, String title) throws HeadlessException {
    super(mainFrame, title);
    myContext = context;
    InputMap inputMap = myTree.getInputMap();
    for (KeyStroke ks : inputMap.allKeys()) {
      if (ks.getKeyCode() == KeyEvent.VK_ENTER) {
        inputMap.put(ks, new Object());
      }
    }
    myTree.registerKeyboardAction(new AbstractAction() {
      public void actionPerformed(ActionEvent e) {
        onOk();
      }
    }, KeyStroke.getKeyStroke("ENTER"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  }

  protected List<AnAction> getToolbarActions() {
    List<AnAction> result = new ArrayList<AnAction>();
    result.add(new CollapseAllAction(myTree));
    result.add(new ExpandAllAction(myTree));
    return result;
  }

  protected void refreshTree() {
    myTree.rebuildLater();
  }

  protected abstract List<BaseMethodDeclaration> collectImplementableMethods();

  protected abstract int compareMethods(BaseMethodDeclaration m1, BaseMethodDeclaration m2);

  protected abstract List<BaseMethodDeclaration> doAddMethods(List<BaseAddMethodDialog.MethodTreeNode> paths);

  protected abstract INodeAdapter getContainer(BaseMethodDeclaration bm);

  protected abstract int compareContainers(INodeAdapter c1, INodeAdapter c2);

  protected abstract JComponent createAdditionalOptionsComponent();

  private MPSTreeNode rebuildOurTree() {
    Map<String, BaseMethodDeclaration> possibleMethods = new LinkedHashMap<String, BaseMethodDeclaration>();
    for (BaseMethodDeclaration method : collectImplementableMethods()) {
      String signature = BaseConcept_Behavior.call_getPresentation_1213877396640(method.getNode());
      if (possibleMethods.containsKey(signature)) {
        possibleMethods.put(signature, method);
      } else {
        possibleMethods.put(signature, method);
      }
    }
    MultiMap<INodeAdapter, BaseMethodDeclaration> methodsByContainer = new MultiMap<INodeAdapter, BaseMethodDeclaration>();
    for (BaseMethodDeclaration method : possibleMethods.values()) {
      methodsByContainer.putValue(getContainer(method), method);
    }
    List<INodeAdapter> containers = new ArrayList<INodeAdapter>(methodsByContainer.keySet());
    Collections.sort(containers, new Comparator<INodeAdapter>() {
      public int compare(INodeAdapter o1, INodeAdapter o2) {
        return compareContainers(o1, o2);
      }
    });
    TextTreeNode root = new TextTreeNode("Methods");
    for (INodeAdapter container : containers) {
      BaseAddMethodDialog.NodeTreeNode node = new BaseAddMethodDialog.NodeTreeNode(container);
      List<BaseMethodDeclaration> methods = new ArrayList<BaseMethodDeclaration>(methodsByContainer.get(container));
      Collections.sort(methods, new Comparator<BaseMethodDeclaration>() {
        public int compare(BaseMethodDeclaration m1, BaseMethodDeclaration m2) {
          return compareMethods(m1, m2);
        }
      });
      for (BaseMethodDeclaration method : methods) {
        node.add(new BaseAddMethodDialog.MethodTreeNode(method));
      }
      root.add(node);
    }
    return root;
  }

  public DialogDimensionsSettings.DialogDimensions getDefaultDimensionSettings() {
    return new DialogDimensionsSettings.DialogDimensions(200, 200, 400, 300);
  }

  protected JComponent getMainComponent() {
    myTree.rebuildNow();
    myTree.expandAll();
    myTree.selectFirstLeaf();
    JScrollPane scrollPane = new JScrollPane(myTree);
    JComponent optionsComponent = createAdditionalOptionsComponent();
    if (optionsComponent == null) {
      return scrollPane;
    }
    List<AnAction> actions = getToolbarActions();
    DefaultActionGroup group = new DefaultActionGroup(actions.toArray(new AnAction[actions.size()]));
    JComponent toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true).getComponent();
    JPanel mainPanel = new JPanel(new BorderLayout());
    mainPanel.add(toolbar, BorderLayout.NORTH);
    mainPanel.add(scrollPane, BorderLayout.CENTER);
    mainPanel.add(optionsComponent, BorderLayout.SOUTH);
    return mainPanel;
  }

  @BaseDialog.Button(position = 0, name = "OK", mnemonic = 'O', defaultButton = true)
  public void onOk() {
    dispose();
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        List<TreePath> paths = new ArrayList<TreePath>(Arrays.asList(myTree.getSelectionPaths()));
        List<BaseAddMethodDialog.MethodTreeNode> methodNodes = ListSequence.fromList(new ArrayList<BaseAddMethodDialog.MethodTreeNode>());
        for (TreePath path : paths) {
          if (path.getLastPathComponent() instanceof BaseAddMethodDialog.MethodTreeNode) {
            methodNodes.add((BaseAddMethodDialog.MethodTreeNode) path.getLastPathComponent());
          }
        }
        Collections.sort(methodNodes, new Comparator<BaseAddMethodDialog.MethodTreeNode>() {
          public int compare(BaseAddMethodDialog.MethodTreeNode m1, BaseAddMethodDialog.MethodTreeNode m2) {
            return compareMethods(m1.getMethod(), m2.getMethod());
          }
        });
        List<BaseMethodDeclaration> methods = doAddMethods(ListSequence.fromList(methodNodes).reversedList());
        if (methods.isEmpty()) {
          return;
        }
        if (methods.size() == 1) {
          SNode node = methods.get(0).getNode();
          myContext.selectAfter(node);
        } else {
          SNode first = methods.get(methods.size() - 1).getNode();
          SNode last = methods.get(0).getNode();
          myContext.select(first);
          myContext.selectRange(first, last);
        }
      }
    });
  }

  @BaseDialog.Button(position = 1, name = "Cancel", mnemonic = 'C')
  public void onCancel() {
    dispose();
  }

  private static class NodeTreeNode extends MPSTreeNode {
    private INodeAdapter myNodeAdapter;

    public NodeTreeNode(INodeAdapter nodeAdapter) {
      super(null);
      myNodeAdapter = nodeAdapter;
      setIcon(IconManager.getIconFor(myNodeAdapter.getNode()));
      setNodeIdentifier(myNodeAdapter.getNode().getName());
    }
  }

  public static class MethodTreeNode extends MPSTreeNode {
    private BaseMethodDeclaration myMethod;

    public MethodTreeNode(BaseMethodDeclaration method) {
      super(null);
      myMethod = method;
      setIcon(IconManager.getIconFor(myMethod.getNode()));
      setNodeIdentifier(BaseConcept_Behavior.call_getPresentation_1213877396640(myMethod.getNode()));
    }

    public BaseMethodDeclaration getMethod() {
      return myMethod;
    }
  }
}
