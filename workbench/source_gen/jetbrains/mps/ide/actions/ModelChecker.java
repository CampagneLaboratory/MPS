package jetbrains.mps.ide.actions;

/*Generated by MPS */

import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.SModelDescriptor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.findusages.model.SearchResult;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.util.TimePresentationUtil;

public class ModelChecker {
  public static final String CATEGORY_ERROR = "Errors";
  public static final String CATEGORY_WARNING = "Warnings";
  public static final String CATEGORY_INFO = "Infos";

  private SearchResults<ModelCheckerIssue> myResults = new SearchResults<ModelCheckerIssue>();
  private boolean myCancelled = false;
  private IOperationContext myOperationContext;
  private ProgressContext myProgressContext;

  public ModelChecker(IOperationContext myOperationContext, ProgressContext myProgressContext) {
    this.myOperationContext = myOperationContext;
    this.myProgressContext = myProgressContext;
  }

  public void checkModel(final SModelDescriptor modelDescriptor) {
    ModelCheckerSettings settings = ModelCheckerSettings.getInstance();
    final List<SpecificChecker> specificCheckers = ListSequence.fromList(new ArrayList<SpecificChecker>());

    ListSequence.fromList(specificCheckers).addElement(new UnavailableConceptsChecker(this));
    if (settings.isCheckUnresolvedReferences()) {
      ListSequence.fromList(specificCheckers).addElement(new UnresolvedReferencesChecker(this));
    }
    if (settings.isCheckConstraints()) {
      ListSequence.fromList(specificCheckers).addElement(new ConstraintsChecker(this));
    }
    if (settings.isCheckScopes()) {
      ListSequence.fromList(specificCheckers).addElement(new ScopesChecker(this));
    }
    if (settings.isCheckTypesystem()) {
      ListSequence.fromList(specificCheckers).addElement(new TypesystemChecker(this));
    }

    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        SModel model = modelDescriptor.getSModel();
        for (SpecificChecker specificChecker : ListSequence.fromList(specificCheckers)) {
          specificChecker.checkModel(model);
          if (ModelChecker.this.myProgressContext.getProgressIndicator().isCanceled()) {
            break;
          }
        }
      }
    });
    this.myCancelled = !(this.myProgressContext.getProgressIndicator().isCanceled());
  }

  public SearchResults<ModelCheckerIssue> getSearchResults() {
    return this.myResults;
  }

  public boolean isCancelled() {
    return this.myCancelled;
  }

  public IOperationContext getOperationContext() {
    return this.myOperationContext;
  }

  public void addIssue(SNode node, String message, String category, ModelCheckerFix fix) {
    ModelCheckerIssue issue = new ModelCheckerIssue(node, message, fix);
    this.myResults.getSearchResults().add(new SearchResult(issue, node, category));
  }

  public void addIssue(SNode node, String message) {
    addIssue(node, message, CATEGORY_ERROR, null);
  }

  public boolean checkAndUpdateIndicator(String text) {
    ProgressIndicator indicator = this.myProgressContext.getProgressIndicator();
    long estimatedTime = this.myProgressContext.getEstimatedTime();
    // Return false if operation was cancelled 
    if (indicator.isCanceled()) {
      return false;
    }

    long elapsedTime = System.currentTimeMillis() - this.myProgressContext.getStartTime();
    String estimatedTimeString = TimePresentationUtil.timeIntervalStringPresentation(estimatedTime);
    String elapsedTimeString = TimePresentationUtil.timeIntervalStringPresentation(elapsedTime);
    indicator.setText(text);
    indicator.setText2("Estimated time: " + estimatedTimeString + ", elapsed time: " + elapsedTimeString);
    if (elapsedTime < estimatedTime) {
      indicator.setIndeterminate(false);
      indicator.setFraction(elapsedTime * 1.0 / estimatedTime);
    } else {
      indicator.setIndeterminate(true);
    }
    return true;
  }
}
